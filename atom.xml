<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JayMo个人网站</title>
  
  <subtitle>打造属于自己的超能力</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jaymo666.github.io/"/>
  <updated>2018-05-21T12:38:57.051Z</updated>
  <id>http://jaymo666.github.io/</id>
  
  <author>
    <name>莫爵贵(JayMo)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP协议缓存机制详解</title>
    <link href="http://jaymo666.github.io/2018/05/21/HTTP%E5%8D%8F%E8%AE%AE%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://jaymo666.github.io/2018/05/21/HTTP协议缓存机制详解/</id>
    <published>2018-05-21T12:07:40.000Z</published>
    <updated>2018-05-21T12:38:57.051Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器 HTTP 协议缓存机制详解 ，包括缓存分类，HTTP协议定义的缓存机制<a id="more"></a></p><h2 id="浏览器-HTTP-协议缓存机制详解"><a href="#浏览器-HTTP-协议缓存机制详解" class="headerlink" title="浏览器 HTTP 协议缓存机制详解"></a>浏览器 HTTP 协议缓存机制详解</h2><p>缓存分为服务端侧（server side，比如 Nginx、Apache）和客户端侧（client side，比如 web browser)</p><p>服务端缓存又分为 代理服务器缓存 和 反向代理服务器缓存（也叫网关缓存，比如 Nginx反向代理、Squid等），其实广泛使用的 CDN 也是一种服务端缓存，目的都是让用户的请求走”捷径“，并且都是缓存图片、文件等静态资源。</p><blockquote><p>客户端侧缓存一般指的是浏览器缓存，目的就是加速各种静态资源的访问，想想现在的大型网站，随便一个页面都是一两百个请求，每天 pv 都是亿级别，如果没有缓存，用户体验会急剧下降、同时服务器压力和网络带宽都面临严重的考验。</p></blockquote><h2 id="浏览器缓存机制详解"><a href="#浏览器缓存机制详解" class="headerlink" title="浏览器缓存机制详解"></a>浏览器缓存机制详解</h2><p>浏览器缓存机制，其实主要就是HTTP协议定义的缓存机制（如： Expires； Cache-control等）。但是也有非HTTP协议定义的缓存机制，如使用HTML Meta 标签，Web开发者可以在HTML页面的<head>节点中加入<meta>标签，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;META HTTP-EQUIV=&quot;Pragma&quot; CONTENT=&quot;no-cache&quot;&gt;</span><br></pre></td></tr></table></figure></head></p><p>上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。使用上很简单，但只有部分浏览器可以支持，而且所有缓存代理服务器都不支持，因为代理不解析HTML内容本身。而广泛应用的还是 HTTP头信息 来控制缓存，下面我主要介绍HTTP协议定义的缓存机制。</p><h2 id="HTTP头信息控制缓存"><a href="#HTTP头信息控制缓存" class="headerlink" title="HTTP头信息控制缓存"></a>HTTP头信息控制缓存</h2><h3 id="浏览器请求流程"><a href="#浏览器请求流程" class="headerlink" title="浏览器请求流程"></a>浏览器请求流程</h3><p>浏览器第一次请求流程图：<br><img src="https://static.oschina.net/uploads/space/2015/0119/015343_psx2_568818.png" alt=""></p><p>浏览器再次请求时：<br><img src="https://static.oschina.net/uploads/space/2015/0119/015353_P04w_568818.png" alt=""></p><h3 id="几个重要概念解释"><a href="#几个重要概念解释" class="headerlink" title="几个重要概念解释"></a>几个重要概念解释</h3><ul><li><p>Expires策略：Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大（比如时钟不同步，或者跨时区），那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。</p><ul><li>Cache-control策略（重点关注）：Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。</li></ul></li></ul><hr><p>值可以是public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age<br>各个消息中的指令含义如下：</p><ul><li>Public指示响应可被任何缓存区缓存。</li><li>Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允 许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。</li><li>no-cache指示请求或响应消息不能缓存，该选项并不是说可以设置”不缓存“，容易望文生义~</li><li>no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存，完全不存下來。</li><li>max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。</li><li>min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。</li><li>max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</li></ul><hr><ul><li>Last-Modified/If-Modified-Since：Last-Modified/If-Modified-Since要配合Cache-Control使用。</li></ul><p>Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。</p><p>If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。</p><hr><ul><li>Etag/If-None-Match：Etag/If-None-Match也要配合Cache-Control使用。</li></ul><p>Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。<br>If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。</p><hr><ul><li>既生Last-Modified何生Etag？你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</li></ul><p>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间<br>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存<br>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</p><p>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag一起使用时，服务器会优先验证ETag。</p><hr><p>yahoo的Yslow法则中则提示谨慎设置Etag：需要注意的是分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败，Yahoo建议分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样，因为除了 last-modified、inode 也很难保持一致)。</p><p>Pragma行是为了兼容HTTP1.0，作用与Cache-Control: no-cache是一样的。</p><p>最后总结下几种状态码的区别：<br><img src="https://static.oschina.net/uploads/space/2015/0119/021903_6FjX_568818.jpg" alt=""></p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2018/05/21/HTTP协议缓存机制详解/">http://jaymo666.github.io/2018/05/21/HTTP协议缓存机制详解/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器 HTTP 协议缓存机制详解 ，包括缓存分类，HTTP协议定义的缓存机制&lt;/p&gt;
    
    </summary>
    
      <category term="浏览器" scheme="http://jaymo666.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://jaymo666.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="缓存" scheme="http://jaymo666.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript数组方法对比</title>
    <link href="http://jaymo666.github.io/2018/04/23/JavaScript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94/"/>
    <id>http://jaymo666.github.io/2018/04/23/JavaScript数组方法对比/</id>
    <published>2018-04-23T14:06:36.000Z</published>
    <updated>2018-04-23T14:07:28.221Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 提供了多种新增，移除，替换数组元素的方法，但是有些会影响原来的数组；有些则不会，它是新建了一个数组。<a id="more"></a></p><h1 id="JavaScript数组方法对比"><a href="#JavaScript数组方法对比" class="headerlink" title="JavaScript数组方法对比"></a>JavaScript数组方法对比</h1><blockquote><p>JavaScript 提供了多种新增，移除，替换数组元素的方法，但是有些会影响原来的数组；有些则不会，它是新建了一个数组。</p></blockquote><h3 id="新增：影响原数组"><a href="#新增：影响原数组" class="headerlink" title="新增：影响原数组"></a>新增：影响原数组</h3><p>使用 array.push() 和 array.ushift() 新增元素会影响原来的数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let mutatingAdd = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];</span><br><span class="line"></span><br><span class="line">mutatingAdd.push(&apos;f&apos;); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;]</span><br><span class="line"></span><br><span class="line">mutatingAdd.unshift(&apos;z&apos;); // [&apos;z&apos;, &apos;a&apos;,&apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; &apos;f&apos;]</span><br></pre></td></tr></table></figure></p><h3 id="新增：不影响原数组"><a href="#新增：不影响原数组" class="headerlink" title="新增：不影响原数组"></a>新增：不影响原数组</h3><p>两种方式新增元素不会影响原数组，第一种是 array.concat() 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];</span><br><span class="line"></span><br><span class="line">const arr2 = arr1.concat(&apos;f&apos;); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;]  </span><br><span class="line"></span><br><span class="line">console.log(arr1); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br></pre></td></tr></table></figure></p><p>第二种方法是使用 JavaScript 的展开（spread）操作符，展开操作符是三个点（…）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];</span><br><span class="line"></span><br><span class="line">const arr2 = [...arr1, &apos;f&apos;]; // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;]  </span><br><span class="line"></span><br><span class="line">const arr3 = [&apos;z&apos;, ...arr1]; // [&apos;z&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br></pre></td></tr></table></figure></p><p>展开操作符会复制原来的数组，从原数组取出所有元素，然后存入新的环境。</p><h3 id="移除：影响原数组"><a href="#移除：影响原数组" class="headerlink" title="移除：影响原数组"></a>移除：影响原数组</h3><p>使用 array.pop() 和 array.shift() 移除数组元素时，会影响原来的数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let mutatingRemove = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];  </span><br><span class="line"></span><br><span class="line">mutatingRemove.pop(); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]  </span><br><span class="line"></span><br><span class="line">mutatingRemove.shift(); // [&apos;b&apos;, &apos;c&apos;, &apos;d&apos;]</span><br></pre></td></tr></table></figure></p><p>array.splice() 也可以删除数组的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let mutatingRemove = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];  </span><br><span class="line"></span><br><span class="line">mutatingRemove.splice(0, 2); // [&apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br></pre></td></tr></table></figure></p><blockquote><p>splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。</p></blockquote><p><code>arrayObject.splice(index,howmany,item1,.....,itemX)</code><br>参数| 描述<br>—|—<br>index   |必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。<br>howmany|    必需。要删除的项目数量。如果设置为 0，则不会删除项目。<br>item1, …, itemX   |可选。向数组添加的新项目。</p><h3 id="移除：不影响原数组"><a href="#移除：不影响原数组" class="headerlink" title="移除：不影响原数组"></a>移除：不影响原数组</h3><p>JavaScript 的 array.filter() 方法基于原数组创建一个新数组，新数组仅包含匹配特定条件的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];</span><br><span class="line"></span><br><span class="line">const arr2 = arr1.filter(a =&gt; a !== &apos;e&apos;); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]</span><br><span class="line">// 或者</span><br><span class="line"></span><br><span class="line">const arr2 = arr1.filter(a =&gt; &#123;  </span><br><span class="line"></span><br><span class="line">  return a !== &apos;e&apos;;</span><br><span class="line"></span><br><span class="line">&#125;); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]</span><br></pre></td></tr></table></figure></p><p>以上代码的条件是“不等于 ‘e’ ”，因此新数组（arr2）里面没有包含 ‘e’。</p><p>另一种不影响原数组的方式是 array.slice()（不要与 array.splice() 混淆）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];  </span><br><span class="line"></span><br><span class="line">const arr2 = arr1.slice(1, 5) // [&apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]  </span><br><span class="line"></span><br><span class="line">const arr3 = arr1.slice(2) // [&apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br></pre></td></tr></table></figure><blockquote><p>slice() 方法可从已有的数组中返回选定的元素。</p></blockquote><p>语法<br><code>arrayObject.slice(start,end)</code><br>参数| 描述<br>—|—<br>start|  必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。<br>end|    可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</p><blockquote><p>如果 end 未被规定，那么 slice() 方法会选取从 start 到数组结尾的所有元素。</p></blockquote><h3 id="替换：影响原数组"><a href="#替换：影响原数组" class="headerlink" title="替换：影响原数组"></a>替换：影响原数组</h3><p>可以使用 array.map() 创建一个新数组，并且可以检查每一个元素，根据特定的条件替换它们。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]  </span><br><span class="line"></span><br><span class="line">const arr2 = arr1.map(item =&gt; &#123;  </span><br><span class="line"></span><br><span class="line">  if(item === &apos;c&apos;) &#123;</span><br><span class="line">    item = &apos;CAT&apos;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return item;</span><br><span class="line"></span><br><span class="line">&#125;); // [&apos;a&apos;, &apos;b&apos;, &apos;CAT&apos;, &apos;d&apos;, &apos;e&apos;]</span><br></pre></td></tr></table></figure><h4 id="使用-array-map-转换数据"><a href="#使用-array-map-转换数据" class="headerlink" title="使用 array.map() 转换数据"></a>使用 array.map() 转换数据</h4><p>array.map() 是个强力方法，可以用于转换数据，而不污染原先的数据源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const origArr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];  </span><br><span class="line"></span><br><span class="line">const transformedArr = origArr.map(n =&gt; n + &apos;Hi!&apos;); // [&apos;aHi!&apos;, &apos;bHi!&apos;, &apos;cHi!&apos;, &apos;dHi!&apos;, &apos;eHi!&apos;]  </span><br><span class="line"></span><br><span class="line">console.log(origArr); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]; // 原数组毫发无损</span><br></pre></td></tr></table></figure></p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2018/04/23/JavaScript数组方法对比/">http://jaymo666.github.io/2018/04/23/JavaScript数组方法对比/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 提供了多种新增，移除，替换数组元素的方法，但是有些会影响原来的数组；有些则不会，它是新建了一个数组。&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://jaymo666.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://jaymo666.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>经典前端题1</title>
    <link href="http://jaymo666.github.io/2018/04/16/%E7%BB%8F%E5%85%B8%E5%89%8D%E7%AB%AF%E9%A2%981/"/>
    <id>http://jaymo666.github.io/2018/04/16/经典前端题1/</id>
    <published>2018-04-16T05:49:41.000Z</published>
    <updated>2018-04-16T05:50:25.794Z</updated>
    
    <content type="html"><![CDATA[<p> 经典前端题(1)<a id="more"></a></p><h2 id="经典前端题-1"><a href="#经典前端题-1" class="headerlink" title="经典前端题(1)"></a>经典前端题(1)</h2><h3 id="用typeof来判断对象的潜在陷阱"><a href="#用typeof来判断对象的潜在陷阱" class="headerlink" title="用typeof来判断对象的潜在陷阱"></a>用typeof来判断对象的潜在陷阱</h3><p><strong>问：使用 typeof bar === “object” 来确定 bar 是否是对象的潜在陷阱是什么？如何避免这个陷阱？</strong></p><p>尽管 typeof bar === “object” 是检查 bar 是否对象的可靠方法，令人惊讶的是在JavaScript中 null 也被认为是对象！</p><p>因此，令大多数开发人员惊讶的是，下面的代码将输出 true 控制台：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var bar = null;</span><br><span class="line">console.log(typeof bar === &quot;object&quot;);  </span><br><span class="line">//  true!</span><br></pre></td></tr></table></figure></p><p>只要清楚这一点，同时检查 bar 是否为 null，就可以很容易地避免问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  (bar !== null) </span><br><span class="line">  &amp;&amp; </span><br><span class="line">  (typeof bar === &quot;object&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h3 id="下面的代码将输出什么到控制台-是否加var"><a href="#下面的代码将输出什么到控制台-是否加var" class="headerlink" title="下面的代码将输出什么到控制台(是否加var)"></a>下面的代码将输出什么到控制台(是否加var)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;  </span><br><span class="line">    var a = b = 3;</span><br><span class="line">&#125;)();</span><br><span class="line">    </span><br><span class="line">console.log(typeof a == &apos;undefined&apos;);</span><br><span class="line">console.log(typeof b == &apos;undefined&apos;);</span><br></pre></td></tr></table></figure><p>部分开发者就会认为，变量a和b都是声明定义在匿名函数内部的，属于函数内的局部变量，如果要在函数外部进行打印调用，a和b则为undefined。所以最后两行代码打印的结果都是true。</p><p>然而结果并非如此，之所以这么理解的原因是，他们把<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = b = 3;</span><br></pre></td></tr></table></figure></p><p>这句代码错误地理解为等同于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var b = 3;</span><br><span class="line">var a = b;</span><br></pre></td></tr></table></figure></p><p>而事实上，它等同于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = 3;</span><br><span class="line">var a = b;</span><br></pre></td></tr></table></figure></p><p>这个时候的变量b声明是不加关键字var的，也就是说变量b是全局变量（隐式全局变量）。</p><p>所以最后我们得到的结果分别是：true和false。</p><h4 id="在严格模式下（使用-use-strict），又会是什么结果？"><a href="#在严格模式下（使用-use-strict），又会是什么结果？" class="headerlink" title="在严格模式下（使用 use strict），又会是什么结果？"></a>在严格模式下（使用 use strict），又会是什么结果？</h4><p>这里就要注意一点了，在严格模式下我们运行后得到的结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">报错:b is not undefined</span><br></pre></td></tr></table></figure></p><p>这也正是因为严格模式的这个特点，可以避免很多不必要的bug（全局变量污染）。</p><h3 id="关于this指向的常见面试题"><a href="#关于this指向的常见面试题" class="headerlink" title="关于this指向的常见面试题"></a>关于this指向的常见面试题</h3><p>看下面的代码，你觉得输出的结果是什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">    foo: &quot;bar&quot;,</span><br><span class="line">    func: function() &#123;        </span><br><span class="line">        var self = this;        </span><br><span class="line">        console.log(this.foo);        </span><br><span class="line">        console.log(self.foo);</span><br><span class="line">        (function() &#123;            </span><br><span class="line">            console.log(this.foo);            </span><br><span class="line">            console.log(self.foo);</span><br><span class="line">        &#125;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myObject.func();</span><br></pre></td></tr></table></figure></p><p>在外部函数中，  this 和 self 两者都指向了 myObject  ，因此两者都可以正确地引用和访问 foo 。 </p><p>在内部函数中, this不再指向myObject.其结果可以console.log(this)打印出来，发现是：Windows对象。（在ECMA 5之前，在内部函数中的this 将指向全局的<code>window</code>对象；反之，因为作为ECMA 5，内部函数中的功能this 是未定义的。）</p><p>上面的代码将输出以下内容到控制台：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bar</span><br><span class="line">bar</span><br><span class="line">undefined</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><h3 id="use-strict-有什么意义和好处？"><a href="#use-strict-有什么意义和好处？" class="headerlink" title="use strict 有什么意义和好处？"></a>use strict 有什么意义和好处？</h3><blockquote><p>use strict 是一种在JavaScript代码运行时自动实行更严格解析和错误处理的方法。<br> 严格模式是ES5引入的，更好的将错误检测引入代码的方法.包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。</p></blockquote><p>设立”严格模式”的目的，主要有以下几个：</p><ul><li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的Javascript做好铺垫。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">变量必须先声明，再使用</span><br><span class="line">function test()&#123;</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  foo = &apos;bar&apos;;  // Error</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">不能对变量执行delete操作</span><br><span class="line">var foo = &quot;test&quot;;</span><br><span class="line">function test()&#123;&#125;</span><br><span class="line"> </span><br><span class="line">delete foo; // Error</span><br><span class="line">delete test; // Error</span><br><span class="line"> </span><br><span class="line">function test2(arg) &#123;</span><br><span class="line">    delete arg; // Error</span><br><span class="line">&#125;</span><br><span class="line">对象的属性名不能重复</span><br><span class="line">&#123; foo: true, foo: false &#125; // Error</span><br><span class="line"> </span><br><span class="line">禁用eval()</span><br><span class="line"> </span><br><span class="line">函数的arguments参数</span><br><span class="line">setTimeout(function later()&#123;</span><br><span class="line">  // do stuff...</span><br><span class="line">  setTimeout( later, 1000 );</span><br><span class="line">&#125;, 1000 );</span><br><span class="line"> </span><br><span class="line">禁用with()&#123;&#125;</span><br><span class="line"> </span><br><span class="line">不能修改arguments</span><br><span class="line">不能在函数内定义arguments变量</span><br><span class="line">不能使用arugment.caller和argument.callee。因此如果你要引用匿名函数，需要对匿名函数命名。</span><br></pre></td></tr></table></figure><h4 id="进入标志"><a href="#进入标志" class="headerlink" title="进入标志"></a>进入标志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br></pre></td></tr></table></figure><p>老版本的浏览器会把它当作一行普通字符串，加以忽略。</p><h4 id="如何调用"><a href="#如何调用" class="headerlink" title="如何调用"></a>如何调用</h4><h5 id="针对整个脚本文件"><a href="#针对整个脚本文件" class="headerlink" title="针对整个脚本文件"></a>针对整个脚本文件</h5><p>将”use strict”放在脚本文件的第一行，则整个脚本都将以”严格模式”运行。如果这行语句不在第一行，则无效，整个脚本以”正常模式”运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。</p><p>(严格地说，只要前面不是产生实际运行结果的语句，”use strict”可以不在第一行，比如直接跟在一个空的分号后面。)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">　　&quot;use strict&quot;;</span><br><span class="line">　　console.log(&quot;这是严格模式。&quot;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">　  console.log(&quot;这是正常模式。&quot;);kly, it&apos;s almost 2 years ago now. I can admit it now - I run it on my school&apos;s network that has about 50 computers.</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>上面的代码表示，一个网页中依次有两段Javascript代码。前一个script标签是严格模式，后一个不是。</p><h5 id="针对单个函数"><a href="#针对单个函数" class="headerlink" title="针对单个函数"></a>针对单个函数</h5><p>将”use strict”放在函数体的第一行，则整个函数以”严格模式”运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function strict()&#123;</span><br><span class="line">　　&quot;use strict&quot;;</span><br><span class="line">　　return &quot;这是严格模式。&quot;;</span><br><span class="line">&#125;</span><br><span class="line">function notStrict() &#123;</span><br><span class="line">　　return &quot;这是正常模式。&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="脚本文件的变通写法"><a href="#脚本文件的变通写法" class="headerlink" title="脚本文件的变通写法"></a>脚本文件的变通写法</h5><p>因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function ()&#123;</span><br><span class="line"> </span><br><span class="line">　　&quot;use strict&quot;;</span><br><span class="line">　　// some code here</span><br><span class="line"> </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><h3 id="小心javascript自动插入分号机制"><a href="#小心javascript自动插入分号机制" class="headerlink" title="小心javascript自动插入分号机制"></a>小心javascript自动插入分号机制</h3><p>在《JavaScript语言精粹》这本书里，这个“自动插入分号”机制被划入到了JavaScript的毒瘤里面，与之并列的前面的全局变量。 </p><p>有些时候，不合时宜地插入分号，会导致严重的后果。 比如一个return语句要正确返回一个值，<strong>这个值的表达式的开始部分必须和return位于同一行</strong>。</p><p>今天，我们就来聊聊这个知识点，看下面的代码函数，它们会返回什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function foo1()&#123;  </span><br><span class="line">    return &#123;</span><br><span class="line">      bar: &quot;hello&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">function foo2()&#123;  </span><br><span class="line">    return</span><br><span class="line">      &#123;</span><br><span class="line">          bar: &quot;hello&quot;</span><br><span class="line">      &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&quot;foo1 returns:&quot;);</span><br><span class="line">console.log(foo1());</span><br><span class="line">console.log(&quot;foo2 returns:&quot;);</span><br><span class="line">console.log(foo2());</span><br></pre></td></tr></table></figure></p><p>将产生：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo1 returns:</span><br><span class="line">Object &#123;bar: &quot;hello&quot;&#125;</span><br><span class="line">foo2 returns:</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure></p><p>这不仅是令人惊讶，而且特别让人困惑的是， foo2()返回的是undefined，也没有任何错误抛出。<br>原因是这样的，当碰到 foo2()中包含return语句的代码行（代码行上没有其他任何代码），分号会立即自动插入到返回语句之后。请仔细留意上面两个函数中return的不同之处，foo2函数的return是单独一行的。</p><p>也不会抛出错误，因为代码的其余部分是完全有效的，即使它没有得到调用或做任何事情（相当于它就是是一个未使用的代码块，定义了等同于字符串 “hello”的属性 bar）。</p><p>所以，在使用return语句的时候，要留意javascript的这个特点，尽可能不要将return关键字写在独立的一行，避免不必造成不必要的错误。</p><h3 id="NaN-是什么？如何测试一个值是否等于-NaN-？"><a href="#NaN-是什么？如何测试一个值是否等于-NaN-？" class="headerlink" title="NaN 是什么？如何测试一个值是否等于 NaN ？"></a>NaN 是什么？如何测试一个值是否等于 NaN ？</h3><p>NaN 属性代表一个“不是数字”的值。这个特殊的值是因为运算不能执行而导致的，不能执行的原因要么是因为其中的运算对象之一非数字。例如： “abc” / 4。<br>首先，虽然 NaN 意味着“不是数字”，但是它的类型，不管你信不信，是 Number：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof NaN === &quot;number&quot;);  </span><br><span class="line">// logs &quot;true&quot;</span><br></pre></td></tr></table></figure></p><p>此外， NaN 和任何东西比较，甚至是它自己本身，结果是false：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(NaN === NaN);  </span><br><span class="line">// logs &quot;false&quot;</span><br></pre></td></tr></table></figure></p><p>一种半可靠的方法来测试一个数字是否等于 NaN，是使用内置函数 isNaN()，但即使使用 isNaN() 依然并非是一个完美的解决方案。 </p><p>一个更好的解决办法是使用 value !== value，如果值等于NaN，只会产生true。因为只有NaN 这货，才会自己不等于自己。</p><p>另外，ES6提供了一个新的<code>Number.isNaN()</code> 函数，这是一个不同的函数，并且比老的全局 isNaN() 函数更可靠。</p><p><code>Number.isNaN()</code>和全局函数<code>isNaN()</code> 相比，该方法不会强制将参数转换成数字，只有在参数是真正的数字类型，且值为 NaN 的时候才会返回 true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Number.isNaN(NaN);        // true</span><br><span class="line">Number.isNaN(Number.NaN); // true</span><br><span class="line">Number.isNaN(0 / 0)       // true</span><br><span class="line"></span><br><span class="line">// 下面这几个如果使用全局的 isNaN() 时，会返回 true。</span><br><span class="line">Number.isNaN(&quot;NaN&quot;);      // false，字符串 &quot;NaN&quot; 不会被隐式转换成数字 NaN。</span><br><span class="line">Number.isNaN(undefined);  // false</span><br><span class="line">Number.isNaN(&#123;&#125;);         // false</span><br><span class="line">Number.isNaN(&quot;blabla&quot;);   // false</span><br><span class="line"></span><br><span class="line">// 下面的都返回 false</span><br><span class="line">Number.isNaN(true);</span><br><span class="line">Number.isNaN(null);</span><br><span class="line">Number.isNaN(37);</span><br><span class="line">Number.isNaN(&quot;37&quot;);</span><br><span class="line">Number.isNaN(&quot;37.37&quot;);</span><br><span class="line">Number.isNaN(&quot;&quot;);</span><br><span class="line">Number.isNaN(&quot; &quot;);</span><br></pre></td></tr></table></figure><h3 id="下面的代码运行结果是什么？-自动类型转换"><a href="#下面的代码运行结果是什么？-自动类型转换" class="headerlink" title="下面的代码运行结果是什么？(自动类型转换)"></a>下面的代码运行结果是什么？(自动类型转换)</h3><p>JavaScript（ECMAScript）是一种弱类型语言，它可对值进行自动类型转换，以适应正在执行的操作。</p><p>让我们通过下面的6个例子来说明一下。<br>例子1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(1 +  &quot;2&quot; + &quot;2&quot;);</span><br></pre></td></tr></table></figure></p><p>得到的结果是：<br><code>&quot;122&quot;</code><br>解析： 1 + “2” + “2”  输出： “122” 。  1 + “2” 是执行的第一个操作。由于其中一个运算对象 “2” 是字符串，JavaScript会假设它需要执行字符串连接，因此，会将  1 的类转换为 “1”  ，  1+”2” 结果就是 “12” 。然后， “12”+”2” 就是 “122” 。</p><p>例子2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(1 +  +&quot;2&quot; + &quot;2&quot;);</span><br></pre></td></tr></table></figure></p><p>得到的结果是：<br><code>&quot;32&quot;</code><br>解析： 1 + +”2” + “2” 输出： “32” 说明：根据运算的顺序，要执行的第一个运算是 +”2” （第一个 “2” 前面的额外 + 被视为一元运算符）。</p><p>因此，JavaScript将 “2” 的类型转换为数字，然后应用一元 + 号（即将其视为一个正数）。其结果就是得到一个数字 2 ，接下来的运算就是 1 + 2 ，这当然是 3 。</p><p>然后我们需要在一个数字和一个字符串之间进行运算（即， 3 和 “2”），同样的，JavaScript会将数值类型转换为字符串，并执行字符串的连接，产生 “32” 。</p><p>例子3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(1 +  -&quot;1&quot; + &quot;2&quot;);</span><br></pre></td></tr></table></figure></p><p>得到的结果是：<br><code>&quot;02&quot;</code><br>解析：  1 + -“1” + “2”  输出： “02” 。这里的解释和前一个例子相同，不同的地方是此处的一元运算符是 - 而不是 + 。</p><p>先是 “1” 变为 1 ，然后当应用 - 时又变为了 -1 ，然后将其与 1 相加，结果为 0 ，再将其转换为字符串，连接最后的  “2”  运算对象，得到 “02” 。</p><p>例子4：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(+&quot;1&quot; +  &quot;1&quot; + &quot;2&quot;);</span><br></pre></td></tr></table></figure></p><p>得到的结果是：<br><code>&quot;112&quot;</code><br>解析： +”1” + “1” + “2”  输出：  “112” 。虽然第一个运算对象  “1” 因为前缀的一元 + 运算符类型转换为数值，但当连接到第二个运算对象 “1” 的时候，又立即转换回字符串，然后又和最后的运算对象 “2”  连接，产生了字符串  “112” 。</p><p>例子5：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log( &quot;A&quot; - &quot;B&quot; + &quot;2&quot;);</span><br></pre></td></tr></table></figure></p><p>得到的结果是：<br><code>&quot;NaN2&quot;</code><br>解析： “A” - “B” + “2” 输出： “NaN2” 。由于运算符 - 不能被应用于字符串，并且 “A” 和 “B” 都不能转换成数值，因此， “A” - “B” 的结果是 NaN  ，然后再和字符串 “2”  连接，得到 “NaN2”  。</p><p>例子6：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log( &quot;A&quot; - &quot;B&quot; + 2);</span><br></pre></td></tr></table></figure></p><p>得到的结果是：<br><code>NaN</code><br>解析： “A” - “B” + 2 输出： NaN 。参见前一个例子， “A” - “B” 结果为 NaN 。但是，应用任何运算符到 NaN 与其他任何的数字运算对象，结果仍然是 NaN 。</p><h3 id="关于逻辑运算符，下面代码运行的结果是什么？"><a href="#关于逻辑运算符，下面代码运行的结果是什么？" class="headerlink" title="关于逻辑运算符，下面代码运行的结果是什么？"></a>关于逻辑运算符，下面代码运行的结果是什么？</h3><p>逻辑运算符用于测定变量或值之间的逻辑。在我们实际开发过程中十分常用，所以面试官会把逻辑运算符的知识点当作考察应聘者的内容之一。</p><p>在JavaScript中，  ||  和  &amp;&amp;  都是逻辑运算符，用于在从左至右计算时，返回第一个可完全确定的“逻辑值”。</p><p>或 || 运算符。在 X||Y 的表达式中，首先计算 X 并将其解释执行为一个布尔值。</p><p>如果这个布尔值true，那么返回true（1），不再计算 Y ，因为“或”的条件已经满足。</p><p>如果这个布尔值为false，那么我们仍然不能知道 X||Y 是真是假，直到我们计算 Y ，并且也把它解释执行为一个布尔值。</p><p>因此， 0||1 的计算结果为true（1），同理计算 1||2 。 </p><p>与 &amp;&amp; 运算符。在 X&amp;&amp;Y 的表达式中，首先计算 X  并将其解释执行为一个布尔值。</p><p>如果这个布尔值为 false，那么返回 false（0），不再计算 Y ，因为“与”的条件已经失败。</p><p>如果这个布尔值为true，但是，我们仍然不知道 X&amp;&amp;Y 是真是假，直到我们去计算 Y ，并且也把它解释执行为一个布尔值。 .</p><p>不过，<strong>关于 &amp;&amp; 运算符有趣的地方在于，当一个表达式计算为“true”的时候，那么就返回表达式本身。</strong></p><p><strong>这很好，虽然它在逻辑表达式方面计算为“真”，但如果你希望的话也可用于返回该值。这就解释了为什么，有些令人奇怪的是， 1 &amp;&amp; 2返回 2，而不是你以为的可能返回 true 或 1。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log( 0 || 1 );</span><br><span class="line">console.log( 1 || 2 );</span><br><span class="line">console.log( 0 &amp;&amp; 1 );</span><br><span class="line">console.log( 1 &amp;&amp; 2 );</span><br></pre></td></tr></table></figure><p>答案：<br>···<br>1<br>1<br>0<br>2<br>···</p><h3 id="以下代码将输出什么？-设置对象的属性"><a href="#以下代码将输出什么？-设置对象的属性" class="headerlink" title="以下代码将输出什么？(设置对象的属性)"></a>以下代码将输出什么？(设置对象的属性)</h3><p>看下面的代码，输出的结果是什么？并解释你的答案。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a=&#123;&#125;,</span><br><span class="line">    b=&#123;key:&apos;b&apos;&#125;,   </span><br><span class="line">    c=&#123;key:&apos;c&apos;&#125;;</span><br><span class="line"></span><br><span class="line">a[b]=123;</span><br><span class="line">a[c]=456;</span><br><span class="line"></span><br><span class="line">console.log(a[b]);</span><br></pre></td></tr></table></figure></p><p>不少人可能会以为答案是<code>123</code> ，但结果是  <code>456</code> ，为什么会是这样子的呢。</p><p>原因是我们忽略了一个知识点：<strong>JavaScript在设置对象的属性的时候，会暗中字符串化参数值</strong>。</p><p>在这里例子中，由于 b 和 c都是对象，把它们设置为对象a的参数，它们都将被转换为<code>&quot;[object Object]&quot;</code>  。</p><p>结果就是， a[b] 和 a[c] 都相当 “[object Object]”  ，而后者会将前者的值覆盖。</p><p>因此，设置或引用 a[c] 和设置或引用 a[b] 完全相同。所以得到的答案是  456  。<br>把对象b作为a的属性的时候，会先调用对象b的toString()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var b=&#123;key:&apos;b&apos;&#125;;</span><br><span class="line"> console.log(b.toString());</span><br><span class="line"> //[object Object]</span><br></pre></td></tr></table></figure></p><p> c也类似，因为转换后得自符串是一样的，所以后面的会覆盖前面的</p><h3 id="关于this指向，以下代码将输出什么"><a href="#关于this指向，以下代码将输出什么" class="headerlink" title="关于this指向，以下代码将输出什么"></a>关于this指向，以下代码将输出什么</h3><p>看下面的代码，输出的结果是什么？并解释你的答案。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    _name: &apos;I am John&apos;,</span><br><span class="line">    sayHello: function ()&#123;        </span><br><span class="line">        return this._name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">     </span><br><span class="line">var sayHello = person.sayHello;</span><br><span class="line"></span><br><span class="line">console.log(sayHello());</span><br><span class="line">console.log(person.sayHello());</span><br></pre></td></tr></table></figure><p>代码运行的结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undefined</span><br><span class="line">I am　John</span><br></pre></td></tr></table></figure></p><p>第二个打印 <code>person.sayHello()</code>的结果是： <code>I am John</code>这个好理解。</p><p>为什么第一次打印出来的结果是 undefined 呢？明明是直接赋值过去的呀。这里涉及到的知识点就是：this的指向。</p><p>在执行<code>sayHello()</code>的时候，当访问到 this._name 时，此时的this已经不再是 person  对象，而是全局窗口对象，也就是 widnow 对象。</p><h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><ul><li><a href="http://www.xuanfengge.com/4637.html" target="_blank" rel="noopener">Javascript 严格模式use strict详解</a></li><li>微信公众号：web前端教程</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN" target="_blank" rel="noopener">MDN web docs</a> </li></ul><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2018/04/16/经典前端题1/">http://jaymo666.github.io/2018/04/16/经典前端题1/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 经典前端题(1)&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://jaymo666.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="js" scheme="http://jaymo666.github.io/tags/js/"/>
    
      <category term="面试题" scheme="http://jaymo666.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>设计模式详解</title>
    <link href="http://jaymo666.github.io/2018/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://jaymo666.github.io/2018/04/16/设计模式详解/</id>
    <published>2018-04-16T04:19:07.000Z</published>
    <updated>2018-04-21T14:29:05.787Z</updated>
    
    <content type="html"><![CDATA[<p>用php实例代码解释软件设计模式<a id="more"></a></p><h2 id="16-个-PHP-设计模式详解-1"><a href="#16-个-PHP-设计模式详解-1" class="headerlink" title="16 个 PHP 设计模式详解(1)"></a>16 个 PHP 设计模式详解(1)</h2><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。</p></blockquote><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>设计模式主要分为三大类，各自还有许多子类</p><ul><li>创建型模式</li><li>结构型模式</li><li>行为型模式</li></ul><p>1.创建型模式<br>模式名|描述<br>—|—<br>抽象工厂模式| 为一个产品族提供了统一的创建接口。当需要这个产品族的某一系列的时候，可以从抽象工厂中选出相应的系列创建一个具体的工厂类<br>工厂方法模式| 定义一个接口用于创建对象，但是让子类决定初始化哪个类。工厂方法把一个类的初始化下放到子类。<br>生成器模式|将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br>惰性初始模式| 推迟对象的创建、数据的计算等需要耗费较多资源的操作，只有在第一次访问的时候才执行。<br>对象池模式|  通过回收利用对象避免获取和释放资源所需的昂贵成本。<br>原型模式|   用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br>单例模式    |确保一个类只有一个实例，并提供对该实例的全局访问</p><p>2.结构性模式</p><table><thead><tr><th>模式名</th><th>描述</th></tr></thead><tbody><tr><td>适配器模式</td><td>将某个类的接口转换成客户端期望的另一个接口表示。适配器模式可以消除由于接口不匹配所造成的类兼容性问题。</td></tr><tr><td>桥接模式</td><td>将一个抽象与实现解耦，以便两者可以独立的变化。</td></tr><tr><td>组合模式</td><td>把多个对象组成树状结构来表示局部与整体，这样用户可以一样的对待单个对象和对象的组合。</td></tr><tr><td>修饰模式</td><td>向某个对象动态地添加更多的功能。修饰模式是除类继承外另一种扩展功能的方法。</td></tr><tr><td>外观模式</td><td>为子系统中的一组接口提供一个一致的界面， 外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</td></tr><tr><td>享元</td><td>通过共享以便有效的支持大量小颗粒对象。</td></tr><tr><td>代理</td><td>为其他对象提供一个代理以控制对这个对象的访问。</td></tr></tbody></table><p>3.行为型模式</p><table><thead><tr><th>模式名</th><th>描述</th></tr></thead><tbody><tr><td>黑板</td><td>广义的观察者在系统范围内交流信息，允许多位读者和写者。</td></tr><tr><td>责任链</td><td>为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。</td></tr><tr><td>命令</td><td>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。</td></tr><tr><td>解释器</td><td>给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。</td></tr><tr><td>迭代器</td><td>提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。</td></tr><tr><td>中介者</td><td>包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用，从而使它们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用，保证这些作用可以彼此独立的变化。</td></tr><tr><td>备忘录</td><td>备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。</td></tr><tr><td>空对象</td><td>通过提供默认对象来避免空引用。</td></tr><tr><td>观察者模式</td><td>在对象间定义一个一对多的联系性，由此当一个对象改变了状态，所有其他相关的对象会被通知并且自动刷新。</td></tr><tr><td>规格</td><td>以布尔形式表示的可重绑定的商业逻辑。</td></tr><tr><td>状态</td><td>让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能获取的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。</td></tr><tr><td>策略</td><td>定义一个算法的系列，将其各个分装，并且使他们有交互性。策略模式使得算法在用户使用的时候能独立的改变。</td></tr><tr><td>模板方法</td><td>模板方法模式准备一个抽象类，将部分逻辑以具体方法及具体构造子类的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先构建一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。</td></tr><tr><td>访问者</td><td>封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。</td></tr></tbody></table><p>从三类设计模式挑选16个常用的设计模式来讲解.</p><p>在说模式之前先讲一下UML类图和时序图</p><h2 id="UML类图和时序图"><a href="#UML类图和时序图" class="headerlink" title="UML类图和时序图"></a>UML类图和时序图</h2><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_class_struct.jpg" alt=""></p><blockquote><ul><li>车的类图结构为&lt;&gt;，表示车是一个抽象类；</li><li>它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；</li><li>小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；</li><li>小汽车与发动机之间是组合关系，使用带实心菱形的实线表示；</li><li>学生与班级之间是聚合关系，使用带空心菱形的实线表示；</li><li>学生与身份证之间为关联关系，使用一根实线表示；</li><li>学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；</li></ul></blockquote><p>类的关系：</p><ul><li>泛化Generalization</li><li>实现Realization</li><li>依赖Dependency</li><li>关联Association</li></ul><p>关联关系又分为：</p><ul><li>一般关联关系</li><li>聚合关系Aggregation</li><li>合成关系Composition</li></ul><p>类的继承包括：泛化和实现</p><h3 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h3><p>泛化关系用一条带空心箭头的直接表示；如下图表示（A继承自B）<br><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalization.jpg" alt=""><br>例：汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系；<br><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalize.jpg" alt=""><br>注：最终代码中，泛化关系表现为继承非抽象类；</p><h3 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h3><p>实现关系用一条带空心箭头的虚线表示；<br>eg：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才 可以用来定义对象。<br><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_realize.jpg" alt=""><br>注：最终代码中，实现关系表现为继承抽象类；</p><h3 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h3><p>聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；<br>！<a href="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_aggregation.jpg" target="_blank" rel="noopener"></a><br>聚合关系用于表示<strong>实体对象之间</strong>的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成；</p><p>与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在；</p><h3 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h3><p>组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成；<br><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_composition.jpg" alt=""><br>与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成；</p><p>但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了；</p><h3 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h3><p>关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系；</p><p>比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系；</p><p>关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A；<br><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_association.jpg" alt="Alt text"><br>注：在最终代码中，关联对象通常是以成员变量的形式实现的；</p><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系；<br><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_dependency.jpg" alt=""><br>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化；</p><p>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生；</p><p>注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；</p><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><blockquote><p>时序图（Sequence DIagram）是显示对象之间交互的图，这些对象是按时间顺序排列的。时序图中显示的是参与交互的对象及其对象之间消息交互的顺序。<br>时序图包括的建模元素主要有：</p><ul><li>对象（Actor）</li><li>生命线（Lifeline）</li><li>控制焦点（Focus of control）</li><li>消息（Message）<br>等等</li></ul></blockquote><p>关于时序图，以下这篇文章将概念介绍的比较详细；更多实例应用，参见后续章节模式中的时序图；</p><p><a href="http://smartlife.blog.51cto.com/1146871/284874" target="_blank" rel="noopener">http://smartlife.blog.51cto.com/1146871/284874</a></p><h2 id="设计模式详解"><a href="#设计模式详解" class="headerlink" title="设计模式详解"></a>设计模式详解</h2><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><blockquote><p>创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。<br>工厂模式 分为三类</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul></blockquote><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><blockquote><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，<strong>可以根据参数的不同返回不同类的实例</strong>。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p></blockquote><h5 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h5><p>角色：</p><ul><li>Factory：<code>工厂角色</code>：工厂角色负责实现创建所有实例的内部逻辑</li><li>Product： <code>抽象产品角色</code>:抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口</li><li>ConcreteProduct:<code>具体产品角色</code>:具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。实现Product父类的接口功能，也可添加自定义的功能</li></ul><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/SimpleFactory.jpg" alt=""><br>代码实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">//简单工厂模式</span><br><span class="line">class Cat</span><br><span class="line">&#123;</span><br><span class="line">    function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;I am Cat class &lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog</span><br><span class="line">&#123;</span><br><span class="line">    function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;I am Dog class &lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Factory</span><br><span class="line">&#123;</span><br><span class="line">    public static function CreateAnimal($name)&#123;</span><br><span class="line">        if ($name == &apos;cat&apos;) &#123;</span><br><span class="line">            return new Cat();</span><br><span class="line">        &#125; elseif ($name == &apos;dog&apos;) &#123;</span><br><span class="line">            return new Dog();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$cat = Factory::CreateAnimal(&apos;cat&apos;);</span><br><span class="line">$dog = Factory::CreateAnimal(&apos;dog&apos;);</span><br></pre></td></tr></table></figure></p><p>Factory是工厂角色，里面有CreateAnimal这个抽象产品角色（其实可以有多个抽象产品角色）。</p><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。<br>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</p><h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><blockquote><p>此模式中，通过定义一个抽象的核心工厂类，并定义创建产品对象的接口，创建具体产品实例的工作延迟到其工厂子类去完成。这样做的好处是核心类只关注工厂类的接口定义，而具体的产品实例交给具体的工厂子类去创建。当系统需要新增一个产品，无需修改现有系统代码，只需要添加一个具体产品类和其对应的工厂子类，是系统的扩展性变得很好，符合面向对象编程的开闭原则</p></blockquote><h5 id="模式结构-1"><a href="#模式结构-1" class="headerlink" title="模式结构"></a>模式结构</h5><p>角色：</p><ul><li>Product：抽象产品：</li><li>ConcreteProduct：具体产品</li><li>Factory：抽象工厂</li><li>ConcreteFactory：具体工厂<br><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/FactoryMethod.jpg" alt=""><br>代码实例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">//抽象产品</span><br><span class="line">interface Animal&#123;</span><br><span class="line">    public function run();</span><br><span class="line">    public function say();</span><br><span class="line">&#125;</span><br><span class="line">//具体产品</span><br><span class="line">class Cat implements Animal</span><br><span class="line">&#123;</span><br><span class="line">    public function run()&#123;</span><br><span class="line">        echo &quot;I ran slowly &lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public function say()&#123;</span><br><span class="line">        echo &quot;I am Cat class &lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//具体产品</span><br><span class="line">class Dog implements Animal</span><br><span class="line">&#123;</span><br><span class="line">    public function run()&#123;</span><br><span class="line">        echo &quot;I&apos;m running fast &lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public function say()&#123;</span><br><span class="line">        echo &quot;I am Dog class &lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 抽象工厂</span><br><span class="line">abstract class Factory&#123;</span><br><span class="line">    abstract static function createAnimal();</span><br><span class="line">&#125;</span><br><span class="line">//具体工厂</span><br><span class="line">class CatFactory extends Factory</span><br><span class="line">&#123;</span><br><span class="line">    public static function createAnimal()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Cat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//具体工厂</span><br><span class="line">class DogFactory extends Factory</span><br><span class="line">&#123;</span><br><span class="line">    public static function createAnimal()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Dog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$cat = CatFactory::createAnimal();</span><br><span class="line">$cat-&gt;say();</span><br><span class="line">$cat-&gt;run();</span><br><span class="line"></span><br><span class="line">$dog = DogFactory::createAnimal();</span><br><span class="line">$dog-&gt;say();</span><br><span class="line">$dog-&gt;run();</span><br></pre></td></tr></table></figure></li></ul><h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><p>工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</p><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><blockquote><p>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p></blockquote><p>此模式是对工厂方法模式的进一步扩展。在工厂方法模式中，一个具体的工厂负责生产一类具体的产品，即一对一的关系，但是，如果需要一个具体的工厂生产多种产品对象，那么就需要用到抽象工厂模式了。</p><p>为了更清晰地理解工厂方法模式，需要先引入两个概念：</p><ul><li>产品等级结构 ：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</li><li>产品族 ：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。</li></ul><h5 id="模式结构-2"><a href="#模式结构-2" class="headerlink" title="模式结构"></a>模式结构</h5><p>角色：</p><ul><li><p>抽象工厂（AbstractFactory）：担任这个角色的是抽象工厂模式的核心，是与应用系统的商业逻辑无关的。</p></li><li><p>具体工厂（Factory）：这个角色直接在客户端的调用下创建产品的实例，这个角色含有选择合适的产品对象的逻辑，而这个逻辑是与应用系统商业逻辑紧密相关的。</p></li><li><p>抽象产品（AbstractProduct）：担任这个角色的类是抽象工厂模式所创建的对象的父类，或它们共同拥有的接口</p></li><li><p>具体产品（Product）：抽象工厂模式所创建的任何产品对象都是一个具体的产品类的实例。<br><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/AbatractFactory.jpg" alt=""><br>代码实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">// 抽象产品，定义产品有哪些功能</span><br><span class="line">interface TV&#123;</span><br><span class="line">    public function open();</span><br><span class="line">    public function watch();</span><br><span class="line">&#125;</span><br><span class="line">// 抽象产品，定义产品有哪些功能</span><br><span class="line">class HaierTv implements TV</span><br><span class="line">&#123;</span><br><span class="line">    public function open()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;Open Haier TV &lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function watch()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;I&apos;m watching TV &lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 抽象产品，定义产品有哪些功能</span><br><span class="line">interface PC&#123;</span><br><span class="line">    public function work();</span><br><span class="line">    public function play();</span><br><span class="line">&#125;</span><br><span class="line">// 具体产品，实现抽象产品定义的功能</span><br><span class="line">class LenovoPc implements PC</span><br><span class="line">&#123;</span><br><span class="line">    public function work()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;I&apos;m working on a Lenovo computer &lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public function play()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;Lenovo computers can be used to play games &lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 抽象工厂，定义创建哪些抽象产品</span><br><span class="line">abstract class Factory&#123;</span><br><span class="line">    abstract public static function createPc();</span><br><span class="line">    abstract public static function createTv();</span><br><span class="line">&#125;</span><br><span class="line">// 具体工厂，实例化抽象产品</span><br><span class="line">class ProductFactory extends Factory</span><br><span class="line">&#123;</span><br><span class="line">    public static function createTV()</span><br><span class="line">    &#123;</span><br><span class="line">        return new HaierTv();</span><br><span class="line">    &#125;</span><br><span class="line">    public static function createPc()</span><br><span class="line">    &#123;</span><br><span class="line">        return new LenovoPc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$newTv = ProductFactory::createTV();</span><br><span class="line">$newTv-&gt;open();</span><br><span class="line">$newTv-&gt;watch();</span><br><span class="line"></span><br><span class="line">$newPc = ProductFactory::createPc();</span><br><span class="line">$newPc-&gt;work();</span><br><span class="line">$newPc-&gt;play();</span><br></pre></td></tr></table></figure></li></ul><h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><blockquote><p>又名：生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</p></blockquote><p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。例如，一辆汽车由轮子，发动机以及其他零件组成，对于普通人而言，我们使用的只是一辆完整的车，这时，我们需要加入一个构造者，让他帮我们把这些组件按序组装成为一辆完整的车。</p><h5 id="模式结构-3"><a href="#模式结构-3" class="headerlink" title="模式结构"></a>模式结构</h5><p>角色：</p><ul><li><p>Builder: 抽象构造者类，为创建一个Product对象的各个部件指定抽象接口。</p></li><li><p>ConcreteBuilder：具体构造者类，实现Builder的接口以构造和装配该产品的各个部件。定义并明确它所创建的表示。提供一个检索产品的接口</p></li><li><p>Director：指挥者，构造一个使用Builder接口的对象。</p></li><li><p>Product：表示被构造的复杂对象。ConcreateBuilder创建该产品的内部表示并定义它的装配过程。</p></li></ul><p>包含定义组成部件的类，包括将这些部件装配成最终产品的接口。</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Builder.jpg" alt=""><br>代码实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">abstract class Builder</span><br><span class="line">&#123;</span><br><span class="line">    protected $car;</span><br><span class="line">    abstract public function buildPartA();</span><br><span class="line">    abstract public function buildPartB();</span><br><span class="line">    abstract public function buildPartC();</span><br><span class="line">    abstract public function getResult();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CarBuilder extends Builder</span><br><span class="line">&#123;</span><br><span class="line">    function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;car = new Car();</span><br><span class="line">    &#125;</span><br><span class="line">    public function buildPartA()&#123;</span><br><span class="line">        $this-&gt;car-&gt;setPartA(&apos;发动机&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function buildPartB()&#123;</span><br><span class="line">        $this-&gt;car-&gt;setPartB(&apos;轮子&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function buildPartC()&#123;</span><br><span class="line">        $this-&gt;car-&gt;setPartC(&apos;其他零件&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getResult()&#123;</span><br><span class="line">        return $this-&gt;car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car</span><br><span class="line">&#123;</span><br><span class="line">    protected $partA;</span><br><span class="line">    protected $partB;</span><br><span class="line">    protected $partC;</span><br><span class="line"></span><br><span class="line">    public function setPartA($str)&#123;</span><br><span class="line">        $this-&gt;partA = $str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function setPartB($str)&#123;</span><br><span class="line">        $this-&gt;partB = $str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function setPartC($str)&#123;</span><br><span class="line">        $this-&gt;partC = $str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function show()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;这辆车由：&quot;.$this-&gt;partA.&apos;,&apos;.$this-&gt;partB.&apos;,和&apos;.$this-&gt;partC.&apos;组成&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Director</span><br><span class="line">&#123;</span><br><span class="line">    public $myBuilder;</span><br><span class="line"></span><br><span class="line">    public function startBuild()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;myBuilder-&gt;buildPartA();</span><br><span class="line">        $this-&gt;myBuilder-&gt;buildPartB();</span><br><span class="line">        $this-&gt;myBuilder-&gt;buildPartC();</span><br><span class="line">        return $this-&gt;myBuilder-&gt;getResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function setBuilder(Builder $builder)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;myBuilder = $builder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$carBuilder = new CarBuilder();</span><br><span class="line">$director = new Director();</span><br><span class="line">$director-&gt;setBuilder($carBuilder);</span><br><span class="line">$newCar = $director-&gt;startBuild();</span><br><span class="line">$newCar-&gt;show();</span><br></pre></td></tr></table></figure></p><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><blockquote><p>单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。</p></blockquote><blockquote><p>实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</p></blockquote><p>单例模式的要点有：某个类只能有一个实例；它必须自行创建本身的实例；它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。<br>角色：</p><ul><li>Singleton：单例类<br><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Singleton.jpg" alt=""></li></ul><p>代码实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Singleton</span><br><span class="line">&#123;</span><br><span class="line">    private static $instance;</span><br><span class="line">    //私有构造方法，禁止使用new创建对象</span><br><span class="line">    private function __construct()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static function getInstance()&#123;</span><br><span class="line">        if (!isset(self::$instance)) &#123;</span><br><span class="line">            self::$instance = new self;</span><br><span class="line">        &#125;</span><br><span class="line">        return self::$instance;</span><br><span class="line">    &#125;</span><br><span class="line">    //将克隆方法设为私有，禁止克隆对象</span><br><span class="line">    private function __clone()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public function say()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;这是用单例模式创建对象实例 &lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public function operation()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;这里可以添加其他方法和操作 &lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// $shiyanlou = new Singleton();</span><br><span class="line">$shiyanlou = Singleton::getInstance();</span><br><span class="line">$shiyanlou-&gt;say();</span><br><span class="line">$shiyanlou-&gt;operation();</span><br><span class="line"></span><br><span class="line">$newShiyanlou = Singleton::getInstance();</span><br><span class="line">var_dump($shiyanlou === $newShiyanlou);</span><br></pre></td></tr></table></figure></p><p>上述的五个模式均属于创建型模式，接下来将要介绍的六个模式属于结构型模式。</p><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><blockquote><p>结构型模式(Structural Pattern)描述如何将<code>类</code>或者<code>对 象</code>结合在一起形成更大的结构，就像搭积木，可以通过 简单积木的组合形成复杂的、功能更为强大的结构。</p></blockquote><p>结构型模式可以分为<code>类结构型模式</code>和<code>对象结构型模式</code>：</p><ul><li>类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。</li><li>对象结构型模式关心<code>类与对象的组合</code>，通过<code>关联关系</code>使得在一 个类中定义另一个类的实例对象，然后通过该对象调用其方法。 根据“合成复用原则”，在系统中尽量使用关联关系来替代继 承关系，因此<code>大部分结构型模式都是对象结构型模式</code>。<h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><blockquote><p>在设计模式)中，适配器模式（英语：adapter pattern）有时候也称包装样式或者包装(wrapper)。将一个类)的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。</p></blockquote></li></ul><p>角色：</p><ul><li><p>Target：目标抽象类</p></li><li><p>Adapter：适配器类</p></li><li><p>Adaptee：适配者类</p></li><li><p>Client：客户类</p></li></ul><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Adapter.jpg" alt=""></p><p>实例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Adaptee</span><br><span class="line">&#123;</span><br><span class="line">    public function realRequest()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;这是被适配者真正的调用方法&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Target&#123;</span><br><span class="line">    public function request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Adapter implements Target</span><br><span class="line">&#123;</span><br><span class="line">    protected $adaptee;</span><br><span class="line">    function __construct(Adaptee $adaptee)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;adaptee = $adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function request()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;适配器转换：&quot;;</span><br><span class="line">        $this-&gt;adaptee-&gt;realRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$adaptee = new Adaptee();</span><br><span class="line">$target = new Adapter($adaptee);</span><br><span class="line">$target-&gt;request();</span><br></pre></td></tr></table></figure></p><p>优点：将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。</p><h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><blockquote><p>桥接模式是软件设计模式中最复杂的模式之一，它把<code>事物对象</code>和<code>其具体行为</code>、<code>具体特征</code>分离开来，使它们可以各自独立的变化。事物对象仅是一个抽象的概念。如“圆形”、“三角形”归于抽象的“<code>形状</code>”之下，而“画圆”、“画三角”归于实现行为的“<code>画图</code>”类之下，然后由“形状”调用“画图”。</p></blockquote><p>理解桥接模式，重点需要理解如何将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化。桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</p><p>角色：</p><ul><li><p>Abstraction：定义抽象的接口，该接口包含实现具体行为、具体特征的Implementor接口</p></li><li><p>Refined Abstraction：抽象接口Abstraction的子类，依旧是一个抽象的事物名</p></li><li><p>Implementor：定义具体行为、具体特征的应用接口</p></li><li><p>ConcreteImplementor：实现Implementor接口</p></li></ul><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Bridge.jpg" alt=""><br>实例代码;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">interface DrawingAPI&#123;</span><br><span class="line">    public function drawCircle($x,$y,$radius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* drawAPI1</span><br><span class="line">*/</span><br><span class="line">class DrawingAPI1 implements DrawingAPI</span><br><span class="line">&#123;</span><br><span class="line">    public function drawCircle($x,$y,$radius)</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;API1.circle at (&quot;.$x.&apos;,&apos;.$y.&apos;) radius &apos;.$radius.&apos;&lt;br&gt;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* drawAPI2</span><br><span class="line">*/</span><br><span class="line">class DrawingAPI2 implements DrawingAPI</span><br><span class="line">&#123;</span><br><span class="line">    public function drawCircle($x,$y,$radius)</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;API2.circle at (&quot;.$x.&apos;,&apos;.$y.&apos;) radius &apos;.$radius.&apos;&lt;br&gt;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">*shape接口</span><br><span class="line">*/</span><br><span class="line">interface Shape&#123;</span><br><span class="line">    public function draw();</span><br><span class="line">    public function resize($radius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CircleShape implements Shape</span><br><span class="line">&#123;</span><br><span class="line">    private $x;</span><br><span class="line">    private $y;</span><br><span class="line">    private $radius;</span><br><span class="line">    private $drawingAPI;</span><br><span class="line">    function __construct($x,$y,$radius,DrawingAPI $drawingAPI)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;x = $x;</span><br><span class="line">        $this-&gt;y = $y;</span><br><span class="line">        $this-&gt;radius = $radius;</span><br><span class="line">        $this-&gt;drawingAPI = $drawingAPI;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function draw()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;drawingAPI-&gt;drawCircle($this-&gt;x,$this-&gt;y,$this-&gt;radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function resize($radius)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;radius = $radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$shape1 = new CircleShape(1,2,4,new DrawingAPI1());</span><br><span class="line">$shape2 = new CircleShape(1,2,4,new DrawingAPI2());</span><br><span class="line">$shape1-&gt;draw();</span><br><span class="line">$shape2-&gt;draw();</span><br><span class="line">$shape1-&gt;resize(10);</span><br><span class="line">$shape1-&gt;draw();</span><br></pre></td></tr></table></figure></p><h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><blockquote><p>修饰模式，是面向对象编程领域中，一种动态地往一个类中添加<code>新的行为</code>的设计模式。就功能而言，修饰模式相比生成子类更为灵活，<code>这样可以给某个对象而不是整个类添加一些功能</code>。</p></blockquote><p>一般来说，给一个对象或者类增加行为的方式可以有两种：</p><ul><li>继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。</li><li>关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)<br><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Decorator.jpg" alt=""></li></ul><p>通过使用修饰模式，可以在运行时扩充一个类的功能。原理是：增加一个修饰类包裹原来的类，包裹的方式一般是通过在将原来的对象作为修饰类的构造函数的参数。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用原来的类中的方法。修饰类必须和原来的类有相同的接口。</p><p>修饰模式是类继承的另外一种选择。类继承在编译时候增加行为，而装饰模式是在运行时增加行为。</p><p>角色</p><ul><li><p>Component: 抽象构件</p></li><li><p>ConcreteComponent: 具体构件</p></li><li><p>Decorator: 抽象装饰类</p></li><li><p>ConcreteDecorator: 具体装饰类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?php </span><br><span class="line">abstract class Component &#123;</span><br><span class="line">    abstract public function operation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyComponent extends Component</span><br><span class="line">&#123;</span><br><span class="line">    public function operation()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;这是正常的组件方法 &lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Decorator extends Component &#123;</span><br><span class="line">    protected $component;</span><br><span class="line">    function __construct(Component $component)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;component = $component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function operation()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;component-&gt;operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyDecorator extends Decorator</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    function __construct(Component $component)</span><br><span class="line">    &#123;</span><br><span class="line">        parent::__construct($component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function addMethod()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;这是装饰器添加的方法 &lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function operation()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;addMethod();</span><br><span class="line">        parent::operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$component = new MyComponent();</span><br><span class="line">$da = new MyDecorator($component);</span><br><span class="line">$da-&gt;operation();</span><br></pre></td></tr></table></figure></li></ul><h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><blockquote><p>外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式</p></blockquote><p>举一个简单的例子，相信大家都使用过 C++ 语言，他是一门编译型语言，写完代码之后，我们需要经过编译之后才能运行，在IDE中，会有一个 Build 的按钮，点击它即可完成编译过程，但是这一个简单的动作背后，却是一系列复杂操作的协调配合，至少包括词法分析，语法分析，生成中间代码，生成汇编代码以及链接等操作，作为普通开发人员，我们不必在意这些过程是如何完成的，只需要点击Build按钮，IDE就会自动帮我们完成背后的工作。那么这个Build按钮就是IDE为我们提供的高级接口，通过他来完成各种子系统的协调工作。</p><p>角色：</p><ul><li>Facade：外观角色，提供高级接口</li><li>SubSystem：子系统角色，负责各自的功能实现</li></ul><p>实例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line"></span><br><span class="line">class SystemA</span><br><span class="line">&#123;</span><br><span class="line">    public function operationA()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;operationA &lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SystemB</span><br><span class="line">&#123;</span><br><span class="line">    public function operationB()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;operationB &lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SystemC</span><br><span class="line">&#123;</span><br><span class="line">    public function operationC()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;operationC &lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Facade</span><br><span class="line">&#123;</span><br><span class="line">    protected $systemA;</span><br><span class="line">    protected $systemB;</span><br><span class="line">    protected $systemC;</span><br><span class="line"></span><br><span class="line">    function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;systemA = new SystemA();</span><br><span class="line">        $this-&gt;systemB = new SystemB();</span><br><span class="line">        $this-&gt;systemC = new SystemC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function myOperation()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;systemA-&gt;operationA();</span><br><span class="line">        $this-&gt;systemB-&gt;operationB();</span><br><span class="line">        $this-&gt;systemC-&gt;operationC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$facade = new Facade();</span><br><span class="line">$facade-&gt;myOperation();</span><br></pre></td></tr></table></figure></p><p>优缺点：<br>使用外观模式最大的优点就是子系统与客户端之间是松耦合的关系，客户端不必知道具体有哪些子系统，也无需知道他们是如何工作的，通过引入一个外观类，提供一个客户端间接访问子系统的高级接口。子系统和外观类可以独立运作，修改某一个子系统的内容，不会影响到其他子系统，也不会影响到外观对象。不过它的缺点就是它不够灵活，当需要增加一个子系统的时候，需要修改外观类。</p><h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><blockquote><p>享元模式（英语：Flyweight Pattern）是一种软件设计模式)。它使用共享物件，用来尽可能减少内存使用量以及分享资讯给尽可能多的相似物件；它适合用于当大量物件只是重复因而导致无法令人接受的使用大量内存。通常物件中的部分状态是可以分享。常见做法是把它们放在外部数据结构，当需要使用时再将它们传递给享元。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。</p></blockquote><p>要理解享元模式，先要理解两个重要的概念：内部状态和外部状态。</p><p>内部状态存储于flyweight中，它包含了独立于flyweight场景的信息，这些信息使得flyweight可以被共享。而外部状态取决于flyweight场景，并根据场景而变化，因此不可共享。用户对象负责在必要的时候将外部状态传递给flyweight。</p><p>角色</p><ul><li>Flyweight： 抽象享元类</li><li>ConcreteFlyweight： 具体享元类</li><li>UnsharedConcreteFlyweight： 非共享具体享元类</li><li>FlyweightFactory： 享元工厂类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">interface Flyweight&#123;</span><br><span class="line">    public function operation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyFlyweight implements Flyweight</span><br><span class="line">&#123;</span><br><span class="line">    protected $intrinsicState;</span><br><span class="line">    function __construct($str)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;intrinsicState = $str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function operation()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &apos;MyFlyweight[&apos;.$this-&gt;intrinsicState.&apos;] do operation. &lt;br&gt;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FlyweightFactory</span><br><span class="line">&#123;</span><br><span class="line">    protected static $flyweightPool;</span><br><span class="line">    function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        if (!isset(self::$flyweightPool)) &#123;</span><br><span class="line">            self::$flyweightPool = [];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public function getFlyweight($str)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (!array_key_exists($str,self::$flyweightPool)) &#123;</span><br><span class="line">            $fw = new MyFlyweight($str);</span><br><span class="line">            self::$flyweightPool[$str] = $fw;</span><br><span class="line">            return $fw;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            echo &quot;aready in the pool,use the exist one: &lt;br&gt;&quot;;</span><br><span class="line">            return self::$flyweightPool[$str];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$factory = new FlyweightFactory();</span><br><span class="line">$fw = $factory-&gt;getFlyweight(&apos;one&apos;);</span><br><span class="line">$fw-&gt;operation();</span><br><span class="line"></span><br><span class="line">$fw1 = $factory-&gt;getFlyweight(&apos;two&apos;);</span><br><span class="line">$fw1-&gt;operation();</span><br><span class="line"></span><br><span class="line">$fw2 = $factory-&gt;getFlyweight(&apos;one&apos;);</span><br><span class="line">$fw2-&gt;operation();</span><br></pre></td></tr></table></figure></li></ul><p>享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。</p><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>所谓的代理者是指一个类别可以作为其它东西的接口。代理者可以作任何东西的接口：网络连接、内存中的大对象、文件或其它昂贵或无法复制的资源。</p><p>代理对象可以在客户端和目标对象之间起到 中介的作用，并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。</p><p>可能大家听得最多且最常用的就是VPN网络代理，或者代理服务器等。</p><p>角色<br>-Subject: 抽象主题角色</p><ul><li>Proxy: 代理主题角色</li><li>RealSubject: 真实主题角色<br>实例代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">interface Subject&#123;</span><br><span class="line">    public function request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RealSubject implements Subject</span><br><span class="line">&#123;</span><br><span class="line">    public function request()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;RealSubject::request &lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Proxy implements Subject</span><br><span class="line">&#123;</span><br><span class="line">    protected $realSubject;</span><br><span class="line">    function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;realSubject = new RealSubject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function beforeRequest()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;Proxy::beforeRequest &lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function request()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;beforeRequest();</span><br><span class="line">        $this-&gt;realSubject-&gt;request();</span><br><span class="line">        $this-&gt;afterRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function afterRequest()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;Proxy::afterRequest &lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$proxy = new Proxy();</span><br><span class="line">$proxy-&gt;request();</span><br></pre></td></tr></table></figure></li></ul><p>下面将会介绍五种行为型模式。</p><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><blockquote><p>行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。</p></blockquote><p>行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。</p><p>通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象 之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。</p><p>行为型模式分为类行为型模式和对象行为型模式两种：</p><ul><li>类行为型模式：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。</li><li>对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式</li></ul><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><blockquote><p>在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。</p></blockquote><p>主要特点就是<code>将一个请求封装为一个对象</code>，从而使我们可用不同的请求对客户进行<code>参数化</code>；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为<code>动作(Action)模式`</code>或事务(Transaction)模式`</p><p>角色</p><ul><li>Command: 抽象命令类</li><li>ConcreteCommand: 具体命令类</li><li>Invoker: 调用者</li><li>Receiver: 接收者</li><li>Client:客户类</li></ul><p>示例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">class Receiver</span><br><span class="line">&#123;</span><br><span class="line">    public function Action()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;Receiver-&gt;Action&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Command&#123;</span><br><span class="line">    protected $receiver;</span><br><span class="line">    function __construct(Receiver $receiver)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;receiver = $receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    abstract public function Execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyCommand extends Command</span><br><span class="line">&#123;</span><br><span class="line">    function __construct(Receiver $receiver)</span><br><span class="line">    &#123;</span><br><span class="line">        parent::__construct($receiver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function Execute()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;receiver-&gt;Action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Invoker</span><br><span class="line">&#123;</span><br><span class="line">    protected $command;</span><br><span class="line">    function __construct(Command $command)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;command = $command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function Invoke()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;command-&gt;Execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$receiver = new Receiver();</span><br><span class="line">$command = new MyCommand($receiver);</span><br><span class="line">$invoker = new Invoker($command);</span><br><span class="line">$invoker-&gt;Invoke();</span><br></pre></td></tr></table></figure></p><h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><blockquote><p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p></blockquote><p>举个简单的例子，就比如大家平时喜欢用微信聊天，你发送的聊天内容需要通过微信服务器进行中间处理，然后下发给你的好友，微信服务器就是一个中介者。</p><p>角色</p><ul><li>Mediator: 抽象中介者</li><li>ConcreteMediator: 具体中介者</li><li>Colleague: 抽象同事类</li><li>ConcreteColleague: 具体同事类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line"></span><br><span class="line">abstract class Colleague&#123;</span><br><span class="line">    protected $mediator;</span><br><span class="line">    abstract public function sendMsg($who,$msg);</span><br><span class="line">    abstract public function receiveMsg($msg);</span><br><span class="line">    public function setMediator(Mediator $mediator)&#123;</span><br><span class="line">        $this-&gt;mediator = $mediator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ColleagueA extends Colleague</span><br><span class="line">&#123;</span><br><span class="line">    public function sendMsg($toWho,$msg)</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;Send Msg From ColleagueA To: &quot;.$toWho . &apos;&lt;br&gt;&apos;;</span><br><span class="line">        $this-&gt;mediator-&gt;opreation($toWho,$msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function receiveMsg($msg)</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;ColleagueA Receive Msg: &quot;.$msg . &apos;&lt;br&gt;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ColleagueB extends Colleague</span><br><span class="line">&#123;</span><br><span class="line">    public function sendMsg($toWho,$msg)</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;Send Msg From ColleagueB To: &quot;.$toWho . &apos;&lt;br&gt;&apos;;</span><br><span class="line">        $this-&gt;mediator-&gt;opreation($toWho,$msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function receiveMsg($msg)</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;ColleagueB Receive Msg: &quot;.$msg . &apos;&lt;br&gt;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Mediator&#123;</span><br><span class="line">    abstract public function opreation($id,$message);</span><br><span class="line">    abstract public function register($id,Colleague $colleague);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyMediator extends Mediator</span><br><span class="line">&#123;</span><br><span class="line">    protected static $colleagues;</span><br><span class="line">    function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        if (!isset(self::$colleagues)) &#123;</span><br><span class="line">            self::$colleagues = [];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function opreation($id,$message)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!array_key_exists($id,self::$colleagues)) &#123;</span><br><span class="line">            echo &quot;colleague not found&quot;;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        $colleague = self::$colleagues[$id];</span><br><span class="line">        $colleague-&gt;receiveMsg($message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function register($id,Colleague $colleague)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!in_array($colleague, self::$colleagues)) &#123;</span><br><span class="line">            self::$colleagues[$id] = $colleague;</span><br><span class="line">        &#125;</span><br><span class="line">        $colleague-&gt;setMediator($this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$colleagueA = new ColleagueA();</span><br><span class="line">$colleagueB = new ColleagueB();</span><br><span class="line">$mediator = new MyMediator();</span><br><span class="line">$mediator-&gt;register(1,$colleagueA);</span><br><span class="line">$mediator-&gt;register(2,$colleagueB);</span><br><span class="line">$colleagueA-&gt;sendMsg(2,&apos;hello admin&apos;);</span><br><span class="line">$colleagueB-&gt;sendMsg(1,&apos;shiyanlou&apos;);</span><br></pre></td></tr></table></figure><p>中介者模式的两个主要作用：中转作用（结构性）：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，通过中介者即可。该中转作用属于中介者在结构上的支持。</p><p>协调作用（行为性）：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。</p><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><blockquote><p> 在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来<code>实时事件处理系统</code>。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。</p></blockquote><p>角色</p><ul><li><p>Subject: 抽象目标类，一般至少提供三个接口：</p><ul><li>添附(Attach)：新增观察者到串炼内，以追踪目标对象的变化。</li><li>解附(Detach)：将已经存在的观察者从串炼中移除。</li><li>通知(Notify)：利用观察者所提供的更新函式来通知此目标已经产生变化。</li></ul></li><li><p>ConcreteSubject: 具体目标，提供了观察者欲追踪的状态，也可设置目标状态</p></li><li><p>Observer: 抽象观察者，定义观察者的更新操作接口</p></li><li><p>ConcreteObserver: 具体观察者，实现抽象观察者的接口，做出自己的更新操作</p></li></ul><p>生活实例：<br>举一个生活中的例子：比如用户（观察者）从报社订阅报纸，报社和用户之间是一对多依赖，用户可以在报社订阅（register）报纸，报社可以把最新的报纸发给用户（notify），用户自动收到更新。在用户不需要的时候还可以取消注册（remove）。<br>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line"></span><br><span class="line">abstract class Obeserver&#123;</span><br><span class="line">    abstract function update(Subject $sub);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Subject&#123;</span><br><span class="line">    protected static $obeservers;</span><br><span class="line">    function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        if (!isset(self::$obeservers)) &#123;</span><br><span class="line">            self::$obeservers = [];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public function attach(Obeserver $obeserver)&#123;</span><br><span class="line">        if (!in_array($obeserver, self::$obeservers)) &#123;</span><br><span class="line">            self::$obeservers[] = $obeserver;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public function deattach(Obeserver $obeserver)&#123;</span><br><span class="line">        if (in_array($obeserver, self::$obeservers)) &#123;</span><br><span class="line">            $key = array_search($obeserver,self::$obeservers);</span><br><span class="line">            unset(self::$obeservers[$key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    abstract public function setState($state);</span><br><span class="line">    abstract public function getState();</span><br><span class="line">    public function notify()</span><br><span class="line">    &#123;</span><br><span class="line">        foreach (self::$obeservers as $key =&gt; $value) &#123;</span><br><span class="line">            $value-&gt;update($this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MySubject extends Subject</span><br><span class="line">&#123;</span><br><span class="line">    protected $state;</span><br><span class="line">    public function setState($state)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;state = $state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getState()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyObeserver extends Obeserver</span><br><span class="line">&#123;</span><br><span class="line">    protected $obeserverName;</span><br><span class="line">    function __construct($name)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;obeserverName = $name;</span><br><span class="line">    &#125;</span><br><span class="line">    public function update(Subject $sub)</span><br><span class="line">    &#123;</span><br><span class="line">        $state = $sub-&gt;getState();</span><br><span class="line">        echo &quot;Update Obeserver[&quot;.$this-&gt;obeserverName.&apos;] State: &apos;.$state . &apos;&lt;br&gt;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$subject = new MySubject();</span><br><span class="line">$one = new MyObeserver(&apos;one&apos;);</span><br><span class="line">$two = new MyObeserver(&apos;two&apos;);</span><br><span class="line"></span><br><span class="line">$subject-&gt;attach($one);</span><br><span class="line">$subject-&gt;attach($two);</span><br><span class="line">$subject-&gt;setState(1);</span><br><span class="line">$subject-&gt;notify();</span><br><span class="line">echo &quot;--------------------- &lt;br&gt;&quot;;</span><br><span class="line">$subject-&gt;setState(2);</span><br><span class="line">$subject-&gt;deattach($two);</span><br><span class="line">$subject-&gt;notify();</span><br></pre></td></tr></table></figure><h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><blockquote><p>状态模式：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。</p></blockquote><p>有时，一个对象的行为受其一个或多个具体的属性变化而变化，这样的属性也叫作状态，这样的的对象也叫作有状态的对象。</p><p>角色</p><ul><li><p>Context: 环境类，维护一个ConcreteState子类的实例，这个实例定义当前状态；</p></li><li><p>State: 抽象状态类，定义一个接口以封装与Context的一个特定状态相关的行为；</p></li><li><p>ConcreteState: 具体状态类，每一个子类实现一个与Context的一个状态相关的行为。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line"></span><br><span class="line">class Context&#123;</span><br><span class="line">    protected $state;</span><br><span class="line">    function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;state = StateA::getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    public function changeState(State $state)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;state = $state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function request()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;state-&gt;handle($this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class State&#123;</span><br><span class="line">    abstract function handle(Context $context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class StateA extends State</span><br><span class="line">&#123;</span><br><span class="line">    private static $instance;</span><br><span class="line">    private function __construct()&#123;&#125;</span><br><span class="line">    private function __clone()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static function getInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        if (!isset(self::$instance)) &#123;</span><br><span class="line">            self::$instance = new self;</span><br><span class="line">        &#125;</span><br><span class="line">        return self::$instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function handle(Context $context)</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;doing something in State A.\n done,change state to B &lt;br&gt;&quot;;</span><br><span class="line">        $context-&gt;changeState(StateB::getInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class StateB extends State</span><br><span class="line">&#123;</span><br><span class="line">    private static $instance;</span><br><span class="line">    private function __construct()&#123;&#125;</span><br><span class="line">    private function __clone()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static function getInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        if (!isset(self::$instance)) &#123;</span><br><span class="line">            self::$instance = new self;</span><br><span class="line">        &#125;</span><br><span class="line">        return self::$instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function handle(Context $context)</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;doing something in State B.\n done,change state to A &lt;br&gt;&quot;;</span><br><span class="line">        $context-&gt;changeState(StateA::getInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$context = new Context();</span><br><span class="line">$context-&gt;request();</span><br><span class="line">$context-&gt;request();</span><br><span class="line">$context-&gt;request();</span><br><span class="line">$context-&gt;request();</span><br></pre></td></tr></table></figure><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><blockquote><p>策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。</p></blockquote><p>常见示例：常见的排序算法有快速排序，冒泡排序，归并排序，选择排序等，如果我们需要在一个算法类中提供这些算法，一个常见的解决方法就是在类中定义多个方法，每个方法定义一种具体的排序算法，然后使用 if…else…去判断到底是哪种算法，或者直接调用某个具体方法。这种方法是将算法的实现硬编码到类中，这样做最大的弊端就是算法类类非常臃肿，而且当需要增加或者更换一种新的排序方法时候，需要修改算法类的代码，同时也需要修改客户端调用处的代码。策略模式就是为了解决这列问题而设计的。</p><p>角色</p><ul><li><p>Context: 环境类，使用一个ConcreteStrategy对象来配置；维护一个对Stategy对象的引用，同时，可以定义一个接口来让Stategy访问它的数据。</p></li><li><p>Strategy: 抽象策略类，定义所有支持的算法的公共接口。Context使用这个接口来调用某ConcreteStrategy定义的算法；</p></li><li><p>ConcreteStrategy: 具体策略类，实现 Strategy 接口的具体算法；</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">abstract class Strategy&#123;</span><br><span class="line">    abstract function use();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class StrategyA extends Strategy</span><br><span class="line">&#123;</span><br><span class="line">    public function use()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;这是使用策略A的方法 &lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class StrategyB extends Strategy</span><br><span class="line">&#123;</span><br><span class="line">    public function use()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;这是使用策略B的方法 &lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Context</span><br><span class="line">&#123;</span><br><span class="line">    protected $startegy;</span><br><span class="line">    public function setStrategy(Strategy $startegy)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;startegy = $startegy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function use()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;startegy-&gt;use();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$context = new Context();</span><br><span class="line">$startegyA = new StrategyA();</span><br><span class="line">$startegyB = new StrategyB();</span><br><span class="line">$context-&gt;setStrategy($startegyA);</span><br><span class="line">$context-&gt;use();</span><br><span class="line"></span><br><span class="line">$context-&gt;setStrategy($startegyB);</span><br><span class="line">$context-&gt;use();</span><br></pre></td></tr></table></figure><h3 id="【参考来源】"><a href="#【参考来源】" class="headerlink" title="【参考来源】"></a>【参考来源】</h3><ul><li><a href="https://design-patterns.readthedocs.io" target="_blank" rel="noopener">https://design-patterns.readthedocs.io</a></li><li><a href="https://www.shiyanlou.com/courses/699" target="_blank" rel="noopener">https://www.shiyanlou.com/courses/699</a></li></ul><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2018/04/16/设计模式详解/">http://jaymo666.github.io/2018/04/16/设计模式详解/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用php实例代码解释软件设计模式&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://jaymo666.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="php" scheme="http://jaymo666.github.io/tags/php/"/>
    
      <category term="设计模式" scheme="http://jaymo666.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="实例" scheme="http://jaymo666.github.io/tags/%E5%AE%9E%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>js十大排序算法详解</title>
    <link href="http://jaymo666.github.io/2018/04/03/js%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://jaymo666.github.io/2018/04/03/js十大排序算法详解/</id>
    <published>2018-04-03T07:20:16.000Z</published>
    <updated>2018-04-03T07:26:53.047Z</updated>
    
    <content type="html"><![CDATA[<p>用js实现的十大经典算法，有简单的例子+原理图+动图<a id="more"></a></p><h2 id="十大经典算法导图"><a href="#十大经典算法导图" class="headerlink" title="十大经典算法导图"></a>十大经典算法导图</h2><p><img src="http://ww1.sinaimg.cn/large/006ij6n6gy1fpzdft7jc8j30qu0gc42s.jpg" alt=""></p><p>图片名词解释：</p><ul><li>n: 数据规模</li><li>k:“桶”的个数</li><li>In-place: 占用常数内存，不占用额外内存</li><li>Out-place: 占用额外内存</li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="原始人冒泡排序"><a href="#原始人冒泡排序" class="headerlink" title="原始人冒泡排序"></a>原始人冒泡排序</h3><p>原理图：<br><img src="http://ww1.sinaimg.cn/large/006ij6n6gy1fpzcm4hx1lj30c3086my6.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//从小到大,先排好最大的（最后面的）</span><br><span class="line">        function bubbleSort(arr) &#123;</span><br><span class="line">            var len = arr.length;</span><br><span class="line">            for (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">                for (var j = 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">                    if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                        var temp = arr[j + 1];</span><br><span class="line">                        arr[j + 1] = arr[j];</span><br><span class="line">                        arr[j] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            return arr;</span><br><span class="line">        &#125;</span><br><span class="line">        var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];</span><br><span class="line">        console.log(bubbleSort(arr))</span><br></pre></td></tr></table></figure><h3 id="进化版冒泡排序"><a href="#进化版冒泡排序" class="headerlink" title="进化版冒泡排序"></a>进化版冒泡排序</h3><blockquote><p>对上述冒泡排序的一种优化， 优化思路：当一次遍历前后数组不产生变化时，说明该数组已经有序，结束排序。</p></blockquote><p>原理图：<br><img src="http://ww1.sinaimg.cn/large/006ij6n6gy1fpzcnft0mcj30c3086410.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 如果在某次的排序中没有出现交换的情况，</span><br><span class="line">        // 那么说明在无序的元素现在已经是有序了，就可以直接返回了。</span><br><span class="line">        function bubbleSort2(array) &#123;</span><br><span class="line">            console.time(&apos;2.改进后冒泡排序耗时&apos;);</span><br><span class="line">            var len = array.length,</span><br><span class="line">                i, j, tmp, exchange;</span><br><span class="line"></span><br><span class="line">            for (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">                exchange = 0;</span><br><span class="line">                for (var j = 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">                    if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                        var temp = arr[j + 1];</span><br><span class="line">                        arr[j + 1] = arr[j];</span><br><span class="line">                        arr[j] = temp;</span><br><span class="line">                        exchange = 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!exchange) return arr;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            console.timeEnd(&apos;2.改进后冒泡排序耗时&apos;);</span><br><span class="line">            return arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];</span><br><span class="line">        console.log(bubbleSort2(arr));</span><br></pre></td></tr></table></figure><p>冒泡动图：<br><img src="https://images2015.cnblogs.com/blog/1093977/201707/1093977-20170718164306583-1106893271.gif" alt=""></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote><p>实现思路跟冒泡排序差不多， 可以说是冒泡排序的衍生版本；</p></blockquote><p>原理图：</p><p><img src="http://ww1.sinaimg.cn/large/006ij6n6gy1fpzco4jxq5j30af07gdgc.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function selectionSort(arr) &#123;</span><br><span class="line">　　var len = arr.length;</span><br><span class="line">　　var minIndex, temp;</span><br><span class="line">　　console.time(&apos;选择排序耗时&apos;);</span><br><span class="line">　　for (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">　　　　minIndex = i;</span><br><span class="line">　　　　for (var j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">　　　　　　if (arr[j] &lt; arr[minIndex]) &#123; //寻找最小的数</span><br><span class="line">　　　　　　　　minIndex = j; //将最小数的索引保存</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　temp = arr[i];</span><br><span class="line">　　　　arr[i] = arr[minIndex];</span><br><span class="line">　　　　arr[minIndex] = temp;</span><br><span class="line">　　&#125;</span><br><span class="line">　　console.timeEnd(&apos;选择排序耗时&apos;);</span><br><span class="line">　　return arr;</span><br><span class="line">&#125;</span><br><span class="line">var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];</span><br><span class="line">console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]；</span><br></pre></td></tr></table></figure><p>选择排序动图：</p><p><img src="https://images2015.cnblogs.com/blog/1093977/201707/1093977-20170718165159083-345710938.gif" alt=""></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote><p>最普通的排序算法， 从数组下标1开始每增1项排序一次，越往后遍历次数越多；</p></blockquote><blockquote><p>打个比方就类比水浒传一百单八将的排名吧，每个好汉来了不知道自己排老几，怎么办，那就和已经排过级别的人比较，然后找到其对应的位置，单八将宋万、杜迁先上的梁山，先默认杜迁第一来的也是单八将最厉害的，然后宋万来了，一比较宋万厉害，那宋万排第一，杜迁排第二，接下来朱贵来了，朱贵没他们两个厉害，那就排第三，再后来林冲来了，林冲比他们三个都厉害，那林冲排第一，宋万第二，杜迁第三，朱贵第四，依次类推。梁山排名其实就是典型的插入排序。</p></blockquote><p>原理图：</p><p><img src="https://images0.cnblogs.com/blog2015/687225/201508/231533515818732.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function insertionSort(array) &#123;</span><br><span class="line">　　console.time(&apos;插入排序耗时：&apos;);</span><br><span class="line">　　for (var i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">　　　　var key = array[i];//key是要插入的元素</span><br><span class="line">　　　　var j = i - 1;</span><br><span class="line">　　　　while ( array[j] &gt; key) &#123;</span><br><span class="line">　　　　　　array[j + 1] = array[j];</span><br><span class="line">　　　　　    j--;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　array[j + 1] = key;</span><br><span class="line">　　&#125;</span><br><span class="line">　　console.timeEnd(&apos;插入排序耗时：&apos;);</span><br><span class="line">　　return array;</span><br><span class="line">&#125;</span><br><span class="line">var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];</span><br><span class="line">console.log(insertionSort(arr));</span><br></pre></td></tr></table></figure><h2 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h2><blockquote><p>插入排序的一种优化实现， 通过二分法减少遍历时间。</p></blockquote><p>原理图：<br><img src="https://images0.cnblogs.com/blog2015/687225/201508/231534358169080.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function binaryInsertionSort(array) &#123;</span><br><span class="line">　　console.time(&apos;二分插入排序耗时：&apos;);</span><br><span class="line">　　for (var i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">　　　　var key = array[i], left = 0, right = i - 1;</span><br><span class="line">　　　　while (left &lt;= right) &#123;</span><br><span class="line">　　　　　　var middle = parseInt((left + right) / 2);</span><br><span class="line">　　　　　　if (key &lt; array[middle]) &#123;</span><br><span class="line">　　　　　　　　right = middle - 1;</span><br><span class="line">　　　　　　&#125; else &#123;</span><br><span class="line">　　　　　　　　left = middle + 1;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　for (var j = i - 1; j &gt;= left; j--) &#123;</span><br><span class="line">　　　　　　array[j + 1] = array[j];</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　array[left] = key;</span><br><span class="line">　　&#125;</span><br><span class="line">　　console.timeEnd(&apos;二分插入排序耗时：&apos;);</span><br><span class="line">　　return array;</span><br><span class="line">&#125;</span><br><span class="line">var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];</span><br><span class="line">console.log(binaryInsertionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50];</span><br></pre></td></tr></table></figure><p>代码解释：<br>首先外层循环没什么疑问，就是简单的遍历一遍数组，那么先看while循环，left和right两个变量可以简单的类比上面插入排序中的已排序的首末两个位置，然后选取未排序的第一个值和已排序的中间位置的值进行比较，这样的话也就是在最坏的情况下每层循环也只是计算了已排序的序列长度的一半的次数，简而言之就是在无限逼近left和right值，找到未排序第一个值应该在的位置。</p><p>还是以梁山排名为例子，在宋江没有到梁上之前，每个上梁上的人跟已经排过名的从大往小进行比较，然后找到自己的位置，在老大宋江来之后，后续人慢慢多了，然后宋老大就订了条规矩，就是每个新来的人和已排过名次的位于中间名次的好汉进行比较，胜了往前一位比较，败了往后一位比较，然后找到自己的位置。好了，while循环解释完毕，那么下面又多了一条for循环，这又是什么鬼？</p><p>不要着急，待小编与你慢慢道来，看不懂没关系，先看循环体，循环体的意思就是把前一个值给后一个，然后看循环条件是从i-1的位置从后往前依次将前一个元素的值给后一个，先不要管i-1是谁，先问 i 是谁，i 不就是未排序的第一个元素么，不就是我们拿来对已进行排序的元素么，简而言之不就是新上梁山的好汉么，那么从left值开始到 i-1 的位置依次将前一个元素的值给后一个无非就是空出 left 的位置，left 的位置不就是新上梁上好汉的位置！</p><p>二分插入排序动图：<br><img src="https://images2015.cnblogs.com/blog/1093977/201707/1093977-20170718195933005-962384786.gif" alt=""></p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一</p><p>原理：</p><blockquote><p>先将整个待排序记录序列分割成若干个子序列，在序列内分别进行直接插入排序，待整个序列基本有序时，再对全体记录进行一次直接插入排序;<br>像比赛一样，1-6一组，2-7一组，每差5为一组进行比较，之后再每差2为一组进行比较，最后就是两两比较</p></blockquote><p>原理图：<br><img src="http://ww1.sinaimg.cn/large/006ij6n6gy1fpzdqkzq4sj30dc0d1n06.jpg" alt="希尔排序"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function shellSort(arr) &#123;</span><br><span class="line">　　var len = arr.length,</span><br><span class="line">　　temp,</span><br><span class="line">　　gap = 1;</span><br><span class="line">　　console.time(&apos;希尔排序耗时:&apos;);</span><br><span class="line">　　while(gap &lt; len/5) &#123; //动态定义间隔序列</span><br><span class="line">　　　　gap =gap*5+1;</span><br><span class="line">　　&#125;</span><br><span class="line">　　for (gap; gap &gt; 0; gap = Math.floor(gap/5)) &#123;</span><br><span class="line">　　　　for (var i = gap; i &lt; len; i++) &#123;</span><br><span class="line">　　　　　　temp = arr[i];</span><br><span class="line">　　　　　　for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123;</span><br><span class="line">　　　　　　　　arr[j+gap] = arr[j];</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　　　arr[j+gap] = temp;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　console.timeEnd(&apos;希尔排序耗时:&apos;);</span><br><span class="line">　　return arr;</span><br><span class="line">&#125;</span><br><span class="line">var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];</span><br><span class="line">console.log(shellSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]；</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">       function shellSort2(a) &#123;</span><br><span class="line">    　　var n = a.length;</span><br><span class="line">        var i, j, gap;</span><br><span class="line"></span><br><span class="line">    for (gap = n / 2; gap &gt; 0; gap /= 2) //步长 </span><br><span class="line">    &#123;</span><br><span class="line">        for (i = 0; i &lt; gap; i++)        //循环每一组，直接插入排序 </span><br><span class="line">        &#123;</span><br><span class="line">            for (j = i + gap; j &lt; n; j += gap) //组内排序  </span><br><span class="line">                if (a[j] &lt; a[j - gap])  //a[j]与a[j-gap]将交换</span><br><span class="line">                &#123;</span><br><span class="line">                    var temp = a[j];</span><br><span class="line">                    var k = j - gap;</span><br><span class="line">                    while (k &gt;= 0 &amp;&amp; a[k] &gt; temp)  //</span><br><span class="line">                    &#123;</span><br><span class="line">                        a[k + gap] = a[k];  //a[j]=a[j-gap]</span><br><span class="line">                        k -= gap;  //</span><br><span class="line">                    &#125;</span><br><span class="line">                    a[k + gap] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>原理图：<br><img src="https://images0.cnblogs.com/blog2015/687225/201508/231540595036165.jpg" alt=""></p><blockquote><p>比如现在有个十万人的司令部，习大大是首长，习大大跟司令说了，把所有的人按年龄排序，司令想了，让我一个人也忙活不过来啊，这怎么办，然后就把任务下达给军长，军长下达给师长，依次类推，排长再把一个排分成两个小队，小队再分成两个小组，最后分成两个人一组或一人一组，接下来就是组员之间进行比较，完了小队与小队比较，排与排之间比较，依次类推，最后军团和军团比较，形成最后的序列。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function mergeSort(arr) &#123; //采用自上而下的递归方法</span><br><span class="line">　　var len = arr.length;</span><br><span class="line">　　if(len &lt; 2) &#123;</span><br><span class="line">　　　　return arr;</span><br><span class="line">　　&#125;</span><br><span class="line">　　var middle = Math.floor(len / 2),</span><br><span class="line">　　left = arr.slice(0, middle),</span><br><span class="line">　　right = arr.slice(middle);</span><br><span class="line">　　return merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function merge(left, right)&#123;</span><br><span class="line">　　var result = [];</span><br><span class="line">　　console.time(&apos;归并排序耗时&apos;);</span><br><span class="line">　　while (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">　　　　if (left[0] &lt;= right[0]) &#123;</span><br><span class="line">　　　　　　result.push(left.shift());</span><br><span class="line">　　　　&#125; else &#123;</span><br><span class="line">　　　　　　result.push(right.shift());</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line"> </span><br><span class="line">　　while (left.length)&#123;</span><br><span class="line">　　　　result.push(left.shift());</span><br><span class="line">　　&#125;</span><br><span class="line">　　while (right.length)&#123;</span><br><span class="line">　　　　result.push(right.shift());</span><br><span class="line">　　&#125;</span><br><span class="line">　　console.timeEnd(&apos;归并排序耗时&apos;);</span><br><span class="line">　　return result;</span><br><span class="line">&#125;</span><br><span class="line">var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];</span><br><span class="line">console.log(mergeSort(arr));</span><br></pre></td></tr></table></figure><p>并归排序动图：<br><img src="https://images2015.cnblogs.com/blog/1093977/201707/1093977-20170719101142724-1183690310.gif" alt="image"></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序在诸多算法排序中可能不是最好的， 但在JS语言实现中差不多是最快的！<br>阮一峰老师研究JS实现排序时曾只针对该种排序进行讲解：<a href="http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html" target="_blank" rel="noopener">javascript的快速排序实现</a>。</p><p>步骤：</p><ol><li>在数据集之中，选择一个元素作为”基准”（pivot）。</li><li>所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。</li><li>对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</li></ol><p>原理图：</p><p><img src="https://images0.cnblogs.com/blog2015/687225/201508/231537564105629.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var quickSort2 = function(arr) &#123;</span><br><span class="line">　　console.time(&apos;2.快速排序耗时&apos;);</span><br><span class="line">　　if (arr.length &lt;= 1) &#123; return arr; &#125;</span><br><span class="line">　　var pivotIndex = Math.floor(arr.length / 2);</span><br><span class="line">　　var pivot = arr.splice(pivotIndex, 1)[0];</span><br><span class="line">　　console.log(pivot)</span><br><span class="line">　　var left = [];</span><br><span class="line">　　var right = [];</span><br><span class="line">　　for (var i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">　　　　if (arr[i] &lt; pivot) &#123;</span><br><span class="line">　　　　　　left.push(arr[i]);</span><br><span class="line">　　　　&#125; else &#123;</span><br><span class="line">　　　　　　right.push(arr[i]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　console.timeEnd(&apos;2.快速排序耗时&apos;);</span><br><span class="line">　　return quickSort2(left).concat([pivot], quickSort2(right));</span><br><span class="line">&#125;;</span><br><span class="line">var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];</span><br><span class="line">console.log(quickSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]；</span><br></pre></td></tr></table></figure><p>快速排序动图<br><img src="https://images2015.cnblogs.com/blog/1093977/201707/1093977-20170720144911458-343191376.gif" alt="image"></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><blockquote><p>因为js模拟二叉树比较麻烦，所以堆排序的优势用js语言无法体现， 相对而言C语言的链表在实现上更能表现堆排序，堆排序或许更适合指针类的计算机语言。</p></blockquote><p>原理图：</p><p>1.调整二叉树，形成大根堆(子节点都比父节点小)。<br><img src="https://images0.cnblogs.com/blog2015/687225/201508/231539382698148.png" alt="image"><br>2.交换堆第一元素跟最后元素位置，最后元素弹出堆。然后继续回到1，调整堆。<br><img src="https://images0.cnblogs.com/blog2015/687225/201508/231539568002875.png" alt="image"><br>3.重复2， 当所有节点弹出堆后；弹出的节点值就是有序的了。<br><img src="https://images0.cnblogs.com/blog2015/687225/201508/231540164726220.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function heapSort(array) &#123;</span><br><span class="line">　　console.time(&apos;堆排序耗时&apos;);</span><br><span class="line">　　//建堆</span><br><span class="line">　　var heapSize = array.length, temp;</span><br><span class="line">　　for (var i = Math.floor(heapSize / 2) - 1; i &gt;= 0; i--) &#123;　　</span><br><span class="line">　　　　heapify(array, i, heapSize);</span><br><span class="line">　　&#125;</span><br><span class="line">　　//堆排序</span><br><span class="line">　　for (var j = heapSize - 1; j &gt;= 1; j--) &#123;</span><br><span class="line">　　　　temp = array[0];</span><br><span class="line">　　　　array[0] = array[j];</span><br><span class="line">　　　　array[j] = temp;</span><br><span class="line">　　　　console.log(array)</span><br><span class="line">　　　　heapify(array, 0, --heapSize);</span><br><span class="line">　　&#125;</span><br><span class="line">　　console.timeEnd(&apos;堆排序耗时&apos;);</span><br><span class="line">　　return array;</span><br><span class="line">&#125;</span><br><span class="line">function heapify(arr, x, len) &#123;</span><br><span class="line">　　var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;</span><br><span class="line">　　if (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class="line">　　　　largest = l;</span><br><span class="line">　　&#125;</span><br><span class="line">　　if (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class="line">　　　　largest = r;</span><br><span class="line">　　&#125;</span><br><span class="line">　　if (largest != x) &#123;</span><br><span class="line">　　　　temp = arr[x];</span><br><span class="line">　　　　arr[x] = arr[largest];</span><br><span class="line">　　　　arr[largest] = temp;</span><br><span class="line">　　　　console.log(arr)</span><br><span class="line">　　　　heapify(arr, largest, len);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line">var arr=[91,60,96,13,35,65,46,65,10,30,20,31,77,81,22];</span><br><span class="line">console.log(heapSort(arr));//[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96]；</span><br></pre></td></tr></table></figure><p>这种算法有两个难点，一是建堆，而是堆排序。首先明白什么是堆，堆其实可以这么理解，类似金字塔，一层有一个元素，两层有两个元素，三层有四个元素，每层从数组中取元素，从左到右的顺序放到堆相应的位置上，也就是说每一层元素个数为2n-1 ；（n 代表行数），这就完成了建堆。</p><p>那么想，堆排序中最后一位不就是2n-m（n代表总行数，m代表差多少位不到完成堆的位数），那该元素的父级是谁，2n-1-m/2，2n-1-m/2是谁？拿总位数除以2就知道了，没错就是数组的中间值，这也是编者为什么从中间值入手的原因了。</p><p>而对于 l = 2<em>x +1 与 r = 2</em>x+2 ，不正是每个父级元素对应的子堆么，每一层的堆排序都能够把本层的最大值剔除出来，这样当所有 层循环结束之后，序列也就完成了。</p><p>这一点小编觉得和归并排序有点类似，都是细分到最小单元，从最小单元比较，但是同归并排序有两大点不同，一是堆排序并不像归并那么无序，只是一味的平分数组，而堆排序则是按原始序列排出金字塔式的结构，把最大值一层层往上冒，冒到金字塔最顶端的时候把它踢出来，这样达到排序的效果。<br>堆排序动图：<img src="https://images2015.cnblogs.com/blog/1093977/201707/1093977-20170720162940240-260464315.gif" alt="image"></p><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function countingSort(array) &#123;</span><br><span class="line">　　var len = array.length,</span><br><span class="line">　　B = [],</span><br><span class="line">　　C = [],</span><br><span class="line">　　min = max = array[0];</span><br><span class="line">　　console.time(&apos;计数排序耗时&apos;);</span><br><span class="line">　　for (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">　　　　min = min &lt;= array[i] ? min : array[i];</span><br><span class="line">　　　　max = max &gt;= array[i] ? max : array[i];</span><br><span class="line">　　　　C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1;</span><br><span class="line">　　&#125;</span><br><span class="line">　　for (var k = 0; k &lt;len; k++) &#123;</span><br><span class="line">　　　　var length = C[k]；</span><br><span class="line">　　　　for(var m = 0 ;m &lt;length ; m++)&#123;</span><br><span class="line">　　　　　　B.push(k);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　console.timeEnd(&apos;计数排序耗时&apos;);</span><br><span class="line">　　return B;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2];</span><br><span class="line">console.log(countingSort(arr)); //[1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9]；</span><br></pre></td></tr></table></figure><p>C数组的下标对应的数值就是该下标出现的次数<br>动图：<br><img src="https://images2015.cnblogs.com/blog/1093977/201707/1093977-20170720184113068-1226664727.gif" alt="image"></p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><blockquote><p>一看到这个名字就会觉得奇特，几个意思，我排序还要再准备几个桶不成？还真别说，想用桶排序还得真准备几个桶，但是此桶非彼桶，这个桶是用来装数据用的。其实桶排序和计数排序还有点类似，计数排序是找一个空数组把值作为下标找到其位置，再把出现的次数给存起来，这似乎看似很完美，但也有局限性，不用小编说相信读者也能明白，既然计数是把原数组的值当做下标来看待，那么该值必然是整数，那假如出现小数怎么办？这时候就出现了一种通用版的计数排序——桶排序。</p></blockquote><p>简单例子：</p><blockquote><p>期末考试完了老师要将同学们的分数按照从高到低排序。小哼的班上只有5个同学，这5个同学分别考了5分、3分、5分、2分和8分，哎，考得真是惨不忍睹（满分是10分）。接下来将分数进行从大到小排序，排序后是8 5 5 3 2。</p></blockquote><p>首先我们需要申请一个大小为11的数组int a[11]。OK，现在你已经有了11个变量，编号从a[0]~a[10]。刚开始的时候，我们将a[0]~a[10]都初始化为0，表示这些分数还都没有人得过。例如a[0]等于0就表示目前还没有人得过0分，同理a[1]等于0就表示目前还没有人得过1分……a[10]等于0就表示目前还没有人得过10分。</p><p>下面开始处理每一个人的分数，第一个人的分数是5分，我们就将相对应的a[5]的值在原来的基础增加1，即将a[5]的值从0改为1，表示5分出现过了一次。</p><p>第二个人的分数是3分，我们就把相对应的a[3]的值在原来的基础上增加1，即将a[3]的值从0改为1，表示3分出现过了一次。</p><p>注意啦！第三个人的分数也是5分，所以a[5]的值需要在此基础上再增加1，即将a[5]的值从1改为2，表示5分出现过了两次。</p><p>按照刚才的方法处理第四个和第五个人的分数。最终结果就出来了</p><p>你发现没有，a[0]~a[10]中的数值其实就是0分到10分每个分数出现的次数。接下来，我们只需要将出现过的分数打印出来就可以了，出现几次就打印几次，具体如下。</p><blockquote><p>桶排序与计数排序很相似，不过现在的桶不单计数，是实实在在地放入元素。举个例子，学校要对所有老师按年龄进行排序，这么多老师很难操作，那么先让他们按年龄段进行分组，20－30岁的一组，30－40岁一组，50－60岁一组，然后组内再排序。这样效率就大大提高了。桶排序也是于这种思想。</p></blockquote><p>操作步骤：</p><ol><li>确认范围，亦即求取原数组的最大值与最小值。</li><li>确认需要多少个桶（这个通常作为参数传入，不能大于原数组长度），然后最大值减最小值，除以桶的数量，但得每个桶最多能放多个元素，我们称这个数为桶的最大容量。</li><li>遍历原数组的所有元素，除以这个最大容量，就能得到它要放入的桶的编号了。在放入时可以使用插入排序，也可以在合并时才使用快速排序。</li><li>对所有桶进行遍历，如果桶内的元素已经排好序，直接一个个取出来，放到结果数组就行了。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">var arr = [2,5,3,0,2,8,0,3,4,3]</span><br><span class="line">   function bucketSort(array, num)&#123;</span><br><span class="line">    if(array.length &lt;= 1)&#123;</span><br><span class="line">      return array</span><br><span class="line">    &#125;</span><br><span class="line">    var n = array.length;</span><br><span class="line">    var min = Math.min.apply(0, array)</span><br><span class="line">    var max = Math.max.apply(0, array)</span><br><span class="line">    if(max === min)&#123;</span><br><span class="line">       return array</span><br><span class="line">    &#125;</span><br><span class="line">    var capacity = (max - min + 1) /num;</span><br><span class="line">    var buckets = new Array(max - min + 1)</span><br><span class="line">    for(var i = 0; i &lt; n; i++)&#123;</span><br><span class="line">      var el = array[i];//el可能是负数</span><br><span class="line">      var index = Math.floor((el - min) / capacity)</span><br><span class="line">      var bucket = buckets[index]</span><br><span class="line">      if(bucket)&#123;</span><br><span class="line">         var jn = bucket.length;</span><br><span class="line">         if(el &gt;= bucket[jn-1])&#123;</span><br><span class="line">            bucket[jn] = el</span><br><span class="line">         &#125;else&#123;</span><br><span class="line">            insertSort: </span><br><span class="line">            for(var j = 0; j &lt; jn; j++)&#123;</span><br><span class="line">                if(bucket[j] &gt; el)&#123;</span><br><span class="line">                    while(jn &gt; j)&#123; //全部向后挪一位</span><br><span class="line">                        bucket[jn] = bucket[jn-1]</span><br><span class="line">                        jn--</span><br><span class="line">                    &#125;</span><br><span class="line">                    bucket[j] = el //让el占据bucket[j]的位置</span><br><span class="line">                    break insertSort;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">         buckets[index] = [el]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var index = 0</span><br><span class="line">    for(var i = 0; i &lt; num; i++)&#123;</span><br><span class="line">        var bucket = buckets[i]</span><br><span class="line">        for(var k = 0, kn = bucket.length; k &lt; kn; k++)&#123;</span><br><span class="line">            array[index++] = bucket[k]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line"> &#125;</span><br><span class="line"> console.log(  bucketSort(arr,4) )</span><br><span class="line"> //[ 0, 0, 2, 2, 3, 3, 3, 4, 5, 8 ]</span><br></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><blockquote><p>基数排序按照对位数分组的顺序的不同，可以分为LSD（Least significant digit）基数排序和MSD（Most significant digit）基数排序。</p></blockquote><h3 id="LSD基数排序"><a href="#LSD基数排序" class="headerlink" title="LSD基数排序"></a>LSD基数排序</h3><p>LSD基数排序，是按照从低位到高位的顺序进行分组排序。MSD基数排序，是按照从高位到低位的顺序进行分组排序<br>对于序列中的每个整数的每一位都可以看成是一个桶，而该位上的数字就可以认为是这个桶的键值。比如下面数组</p><p>[170, 45, 75, 90, 802, 2, 24, 66]</p><p>首先我们要确认最大值，一个for循环得最大数，因为最大数的位数最长。</p><p>然后，建立10个桶，亦即10个数组。</p><p>然后再遍历所有元素，取其个位数，个位数是什么就放进对应编号的数组，1放进1号桶。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0号桶： 170，90</span><br><span class="line">1号桶： 无</span><br><span class="line">2号桶： 802，2</span><br><span class="line">3号桶： 无</span><br><span class="line">4号桶： 24</span><br><span class="line">5号桶： 45， 75</span><br><span class="line">6号桶： 66</span><br><span class="line">7－9号桶： 无</span><br></pre></td></tr></table></figure></p><p> 然后再依次将元素从桶里最出来，覆盖原数组，或放到一个新数组，我们把这个经过第一次排序的数组叫sorted。</p><p>sorted = [170,90,802,2,24,45,75,66]</p><p>然后我们再一次遍历sorted数组的元素，这次取十位的值。这时要注意，2不存在十位，那么默认为0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0号桶： 2，802</span><br><span class="line"> 1号桶： 无</span><br><span class="line"> 2号桶： 24</span><br><span class="line"> 3号桶： 无</span><br><span class="line"> 4号桶： 45</span><br><span class="line"> 5号桶： 无</span><br><span class="line"> 6号桶： 66</span><br><span class="line"> 7号桶： 170， 75</span><br><span class="line"> 8号桶： 无</span><br><span class="line"> 9号桶： 90</span><br></pre></td></tr></table></figure><p> 再全部取出来</p><p>sorted = [2，802,24，45，66，170，75，90]</p><p>开始百位上的入桶操作，没有百位就默认为0：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0号桶： 2，24，45，66，75，90</span><br><span class="line">1号桶： 170</span><br><span class="line">2－7号桶：无</span><br><span class="line">8号桶： 802</span><br><span class="line">9号桶： 无</span><br></pre></td></tr></table></figure></p><p>再全部取出来</p><p>sorted = [2，24，45，66，75，90，170，802]</p><p>没有千位数，那么循环结束，返回结果桶sorted</p><p>从程序描述如下：<br><img src="http://ww1.sinaimg.cn/large/006ij6n6gy1fpzhmh1ggaj30df0aead6.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">function radixSort(array) &#123;</span><br><span class="line">    var max = Math.max.apply(0, array);</span><br><span class="line">    var times = getLoopTimes(max),</span><br><span class="line">        len = array.length;</span><br><span class="line">    var buckets = [];</span><br><span class="line">    for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        buckets[i] = []; //初始化10个桶</span><br><span class="line">    &#125;</span><br><span class="line">    for (var radix = 1; radix &lt;= times; radix++) &#123;</span><br><span class="line">        //个位，十位，百位，千位这样循环</span><br><span class="line">        lsdRadixSort(array, buckets, len, radix);</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line">// 根据数字某个位数上的值得到桶的编号</span><br><span class="line">function getBucketNumer(num, d) &#123;</span><br><span class="line">    return (num + &quot;&quot;).reverse()[d];</span><br><span class="line">&#125;</span><br><span class="line">//或者这个</span><br><span class="line">function getBucketNumer(num, i) &#123;</span><br><span class="line">    return Math.floor((num / Math.pow(10, i)) % 10);</span><br><span class="line">&#125;</span><br><span class="line">//获取数字的位数</span><br><span class="line">function getLoopTimes(num) &#123;</span><br><span class="line">    var digits = 0;</span><br><span class="line">    do &#123;</span><br><span class="line">        if (num &gt; 1) &#123;</span><br><span class="line">            digits++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while ((num = num / 10));</span><br><span class="line">    return digits;</span><br><span class="line">&#125;</span><br><span class="line">function lsdRadixSort(array, buckets, len, radix) &#123;</span><br><span class="line">    //入桶</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        let el = array[i];</span><br><span class="line">        let index = getBucketNumer(el, radix);</span><br><span class="line">        buckets[index].push(el);</span><br><span class="line">    &#125;</span><br><span class="line">    var k = 0;</span><br><span class="line">    //重写原桶</span><br><span class="line">    for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        let bucket = buckets[i];</span><br><span class="line">        for (let j = 0; j &lt; bucket.length; j++) &#123;</span><br><span class="line">            array[k++] = bucket[j];</span><br><span class="line">        &#125;</span><br><span class="line">        bucket.length = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// test</span><br><span class="line">var arr = [278, 109, 63, 930, 589, 184, 505, 269, 8, 83];</span><br><span class="line">console.log(radixSort(arr));</span><br></pre></td></tr></table></figure><h3 id="字符串使用基数排序实现字典排序"><a href="#字符串使用基数排序实现字典排序" class="headerlink" title="字符串使用基数排序实现字典排序"></a>字符串使用基数排序实现字典排序</h3><blockquote><p>此外，基数排序不局限于数字，可以稍作变换，就能应用于字符串的字典排序中。我们先来一个简单的例子，只对都是小写字母的字符串数组进行排序。</p></blockquote><p>小写字母一共26个，考虑到长度不一样的情况，我们需要对够短的字符串进行补充，这时补上什么好呢？我们不能直接上0，而是补空白。然后根据字母与数字的对应关系，弄27个桶，空字符串对应0，a对应1，b对应2…. 字典排序是从左边开始比较， 因此我们需要用到MST基数排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">var character = &#123;&#125;;</span><br><span class="line">&quot;abcdefghijklmnopqrstuvwxyz&quot;.split(&quot;&quot;).forEach(function(el, i) &#123;</span><br><span class="line">    character[el] = i + 1;</span><br><span class="line">&#125;);</span><br><span class="line">function toNum(c, length) &#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    arr.c = c;</span><br><span class="line">    for (var i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        arr[i] = character[c[i]] || 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">function getBucketNumer(arr, i) &#123;</span><br><span class="line">    return arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function radixSort(array) &#123;</span><br><span class="line">    var len = array.length;</span><br><span class="line">    var loopTimes = 0;</span><br><span class="line"></span><br><span class="line">    //求出最长的字符串，并得它的长度，那也是最高位</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        let el = array[i];</span><br><span class="line">        var charLen = el.length;</span><br><span class="line">        if (charLen &gt; loopTimes) &#123;</span><br><span class="line">            loopTimes = charLen;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将字符串转换为数字数组</span><br><span class="line">    var nums = [];</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        nums.push(toNum(array[i], loopTimes));</span><br><span class="line">    &#125;</span><br><span class="line">    //开始多关键字排序</span><br><span class="line">    msdRadixSort(nums, len, 0, loopTimes);</span><br><span class="line">    //变回字符串</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        array[i] = nums[i].c;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function msdRadixSort(array, len, radix, radixs) &#123;</span><br><span class="line">    var buckets = [];</span><br><span class="line">    for (var i = 0; i &lt;= 26; i++) &#123;</span><br><span class="line">        buckets[i] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    //入桶</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        let el = array[i];</span><br><span class="line">        let index = getBucketNumer(el, radix);</span><br><span class="line">        buckets[index].push(el);</span><br><span class="line">    &#125;</span><br><span class="line">    //递归子桶</span><br><span class="line">    for (let i = 0; i &lt;= 26; i++) &#123;</span><br><span class="line">        let el = buckets[i];</span><br><span class="line">        //el.c是用来识别是桶还是我们临时创建的数字字符串</span><br><span class="line">        if (el.length &gt; 1 &amp;&amp; !el.c &amp;&amp; radix &lt; radixs) &#123;</span><br><span class="line">            msdRadixSort(el, el.length, radix + 1, radixs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var k = 0;</span><br><span class="line">    //重写原桶</span><br><span class="line">    for (let i = 0; i &lt;= 26; i++) &#123;</span><br><span class="line">        let bucket = buckets[i];</span><br><span class="line">        for (let j = 0; j &lt; bucket.length; j++) &#123;</span><br><span class="line">            array[k++] = bucket[j];</span><br><span class="line">        &#125;</span><br><span class="line">        bucket.length = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var array = [&quot;ac&quot;, &quot;ee&quot;, &quot;ef&quot;, &quot;b&quot;, &quot;z&quot;, &quot;f&quot;, &quot;ep&quot;, &quot;gaaa&quot;, &quot;azh&quot;, &quot;az&quot;, &quot;r&quot;];</span><br><span class="line"></span><br><span class="line">var a = radixSort(array);</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure></p><p>基数排序动图</p><p><img src="https://images2015.cnblogs.com/blog/1093977/201707/1093977-20170720230230990-296833526.gif" alt="image"></p><h3 id="基数排序-vs-计数排序-vs-桶排序"><a href="#基数排序-vs-计数排序-vs-桶排序" class="headerlink" title="基数排序 vs 计数排序 vs 桶排序"></a>基数排序 vs 计数排序 vs 桶排序</h3><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ul><h2 id="参考来源："><a href="#参考来源：" class="headerlink" title="参考来源："></a>参考来源：</h2><ul><li><a href="https://www.cnblogs.com/liyongshuai/p/7197962.html" target="_blank" rel="noopener">https://www.cnblogs.com/liyongshuai/p/7197962.html</a></li><li><a href="https://www.cnblogs.com/wteam-xq/p/4752610.html" target="_blank" rel="noopener">https://www.cnblogs.com/wteam-xq/p/4752610.html</a></li><li><a href="https://segmentfault.com/a/1190000012923917#articleHeader2" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012923917#articleHeader2</a></li></ul><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2018/04/03/js十大排序算法详解/">http://jaymo666.github.io/2018/04/03/js十大排序算法详解/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用js实现的十大经典算法，有简单的例子+原理图+动图&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://jaymo666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="js" scheme="http://jaymo666.github.io/tags/js/"/>
    
      <category term="算法" scheme="http://jaymo666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>用mock实现前端所需数据</title>
    <link href="http://jaymo666.github.io/2018/04/01/%E7%94%A8mock%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E6%89%80%E9%9C%80%E6%95%B0%E6%8D%AE/"/>
    <id>http://jaymo666.github.io/2018/04/01/用mock实现前端所需数据/</id>
    <published>2018-04-01T12:36:39.000Z</published>
    <updated>2018-04-01T13:09:27.535Z</updated>
    
    <content type="html"><![CDATA[<p>mock.js的小demo及mock语法简述及JSON.stringify用法<a id="more"></a></p><p>[TOC]</p><h2 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h2><ul><li>mock.js 官网:<a href="http://mockjs.com/" target="_blank" rel="noopener">http://mockjs.com/</a></li><li>（进阶的有eolinker，是基于mock.js的可视化模拟数据API接口）:<a href="https://www.eolinker.com/" target="_blank" rel="noopener">https://www.eolinker.com/</a></li></ul><h2 id="Mock概述："><a href="#Mock概述：" class="headerlink" title="Mock概述："></a>Mock概述：</h2><p>Mock.js实现的功能</p><ul><li>基于 数据模板 生成数据</li><li>基于 HTML模板 生成数据</li><li>拦截并模拟 Ajax请求</li></ul><h2 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h2><h3 id="浏览器："><a href="#浏览器：" class="headerlink" title="浏览器："></a>浏览器：</h3><blockquote><p>index.html:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;http://mockjs.com/dist/mock.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var data = Mock.mock(&#123;</span><br><span class="line">            &apos;list|1-10&apos;: [&#123;</span><br><span class="line">                &apos;id|+1&apos;: 1</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;);</span><br><span class="line">        $(&apos;&lt;pre&gt;&apos;).text(JSON.stringify(data, null, 4))</span><br><span class="line">            .appendTo(&apos;body&apos;);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        //JQuery</span><br><span class="line">        //配置模拟数据</span><br><span class="line">        Mock.mock(&apos;http://g.cn&apos;,&#123;</span><br><span class="line">            &apos;name&apos;:&apos;@name&apos;,</span><br><span class="line">            &apos;age|1-100&apos;:100,</span><br><span class="line">            &apos;color&apos;:&apos;@color&apos;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        //发送Ajax请求</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url:&apos;http://g.cn&apos;,</span><br><span class="line">            dataType:&apos;json&apos;</span><br><span class="line">        &#125;).done(function(data,status,xhr)&#123;</span><br><span class="line">            console.log(</span><br><span class="line">                JSON.stringify(data,null,4)</span><br><span class="line">            )</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>页面返回值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;list&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;id&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;id&quot;: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;id&quot;: 3</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>浏览器控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">index.html:33 &#123;</span><br><span class="line">    &quot;name&quot;: &quot;Deborah Williams&quot;,</span><br><span class="line">    &quot;age&quot;: 2,</span><br><span class="line">    &quot;color&quot;: &quot;#ecf279&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>Mock.js 的语法规范包括两部分：</p><ul><li>数据模板定义（Data Temaplte Definition，DTD）</li><li>数据占位符定义（Data Placeholder Definition，DPD）</li></ul><h3 id="数据模板定义-DTD"><a href="#数据模板定义-DTD" class="headerlink" title="数据模板定义 DTD"></a>数据模板定义 DTD</h3><p>数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 属性名   name</span><br><span class="line">// 生成规则 rule</span><br><span class="line">// 属性值   value</span><br><span class="line">&apos;name|rule&apos;: value</span><br></pre></td></tr></table></figure></p><p>注意：</p><ul><li>属性名 和 生成规则 之间用 | 分隔。</li><li>生成规则 是可选的。</li><li>生成规则 有 7 种格式：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&apos;name|min-max&apos;: value</span><br><span class="line">&apos;name|count&apos;: value</span><br><span class="line">&apos;name|min-max.dmin-dmax&apos;: value</span><br><span class="line">&apos;name|min-max.dcount&apos;: value</span><br><span class="line">&apos;name|count.dmin-dmax&apos;: value</span><br><span class="line">&apos;name|count.dcount&apos;: value</span><br><span class="line">&apos;name|+step&apos;: value</span><br></pre></td></tr></table></figure><p>生成规则 的 含义 需要依赖 属性值 才能确定。</p><p>属性值 中可以含有 @占位符。<br>属性值 还指定了最终值的初始值和类型。</p><h3 id="数据占位符定义-DPD"><a href="#数据占位符定义-DPD" class="headerlink" title="数据占位符定义 DPD"></a>数据占位符定义 DPD</h3><blockquote><p>占位符 只是在属性值字符串中占个位置，并不出现在最终的属性值中。占位符 的格式为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@占位符</span><br><span class="line">@占位符(参数 [, 参数])</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>用 @ 来标识其后的字符串是 占位符。</li><li>占位符 引用的是 Mock.Random 中的方法。</li><li>通过 Mock.Random.extend() 来扩展自定义占位符。</li><li>占位符 也可以引用 数据模板 中的属性。</li><li>占位符 会优先引用 数据模板 中的属性</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> name: &#123;</span><br><span class="line"> first: &apos;@FIRST&apos;,</span><br><span class="line"> middle: &apos;@FIRST&apos;,</span><br><span class="line"> last: &apos;@LAST&apos;,</span><br><span class="line"> full: &apos;@first @middle @last&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// =&gt;</span><br><span class="line">&#123;</span><br><span class="line"> &quot;name&quot;: &#123;</span><br><span class="line"> &quot;first&quot;: &quot;Charles&quot;,</span><br><span class="line"> &quot;middle&quot;: &quot;Brenda&quot;,</span><br><span class="line"> &quot;last&quot;: &quot;Lopez&quot;,</span><br><span class="line"> &quot;full&quot;: &quot;Charles Brenda Lopez&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="Mock-mock-rurl-rtype-template-function-options"><a href="#Mock-mock-rurl-rtype-template-function-options" class="headerlink" title="Mock.mock( rurl?, rtype?, template|function(options) )"></a>Mock.mock( rurl?, rtype?, template|function(options) )</h3><p>根据数据模板生成模拟数据。<br>参数的含义和默认值如下所示：</p><ul><li>参数 rurl：可选。表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。例如 /\/domain\/list.json/、’/domian/list.json’。</li><li>参数 rtype：可选。表示需要拦截的 Ajax 请求类型。例如 GET、POST、PUT、DELETE 等。</li><li>参数 template：可选。表示数据模板，可以是对象或字符串。例如 { ‘data|1-10’:[{}] }、‘@EMAIL’。</li><li>参数 function(options)：可选。表示用于生成响应数据的函数。</li><li>参数 options：指向本次请求的 Ajax 选项集。</li></ul><h3 id="Mock-mockjax-library"><a href="#Mock-mockjax-library" class="headerlink" title="Mock.mockjax(library)"></a>Mock.mockjax(library)</h3><p>覆盖（拦截） Ajax 请求，目前内置支持 jQuery、Zepto、KISSY。</p><h3 id="Mock-Random"><a href="#Mock-Random" class="headerlink" title="Mock.Random"></a>Mock.Random</h3><p>Mock.Random 是一个工具类，用于生成各种随机数据。Mock.Random 的方法在数据模板中称为“占位符”，引用格式为 @占位符(参数 [, 参数]) 。</p><h3 id="Mock-tpl-input-options-helpers-partials"><a href="#Mock-tpl-input-options-helpers-partials" class="headerlink" title="Mock.tpl(input,options,helpers,partials)"></a>Mock.tpl(input,options,helpers,partials)</h3><p>基于 Handlebars、Mustache 的 HTML 模板生成模拟数据。</p><p>方法使用详情请参考<a href="http://mockjs.com/#mock" target="_blank" rel="noopener">mock.js文档</a></p><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="JSON-stringify-方法"><a href="#JSON-stringify-方法" class="headerlink" title="JSON.stringify 方法"></a>JSON.stringify 方法</h3><blockquote><p>把一个对象通过 stringify 之后提交给后台或者存储在 Storage 里是很常用的手段。</p></blockquote><blockquote><p>demo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var data = [</span><br><span class="line">    &#123;name: &quot;王尼玛&quot;, sex:1, age: 30&#125;,</span><br><span class="line">    &#123;name: &quot;王尼美&quot;, sex:0, age: 20&#125;,</span><br><span class="line">    &#123;name: &quot;王大锤&quot;, sex:1, age: 30&#125;</span><br><span class="line">];</span><br><span class="line">var str_json = JSON.stringify(data);</span><br><span class="line">console.log(str_json);</span><br></pre></td></tr></table></figure></p></blockquote><p>这个是我们日常用法，非常简单，对吧。</p><p>比如说，我们的数据非常复杂，还有类似头像，昵称，个人签名之类的信息。<br>可是我保存在本地，只需要用户名，和性别，肿么破呢？<br>也许你会说 so easy, 遍历数据重新提取下即可。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var data = [</span><br><span class="line">    &#123;name: &quot;王尼玛&quot;, sex:1, age: 30&#125;,</span><br><span class="line">    &#123;name: &quot;王尼美&quot;, sex:0, age: 20&#125;,</span><br><span class="line">    &#123;name: &quot;王大锤&quot;, sex:1, age: 30&#125;</span><br><span class="line">];</span><br><span class="line">for (var i=0, new_data=[]; i&lt;data.length; i++) &#123;</span><br><span class="line">    new_data.push(&#123;</span><br><span class="line">        name: data[i].name,</span><br><span class="line">        sex:  data[i].sex</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">var str_json = JSON.stringify(new_data);</span><br><span class="line">console.log(str_json);</span><br></pre></td></tr></table></figure></p><p>确实分分钟搞定。</p><p>其实我们只需要用 stringify 第二个参数即可简单处理这种问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var data = [</span><br><span class="line">    &#123;name: &quot;王尼玛&quot;, sex:1, age: 30&#125;,</span><br><span class="line">    &#123;name: &quot;王尼美&quot;, sex:0, age: 20&#125;,</span><br><span class="line">    &#123;name: &quot;王大锤&quot;, sex:1, age: 30&#125;</span><br><span class="line">];</span><br><span class="line">var str_json = JSON.stringify(data, [&quot;name&quot;, &quot;sex&quot;]);</span><br><span class="line">console.log(str_json);</span><br></pre></td></tr></table></figure></p><p>第二个参数如此强悍，为我们省去了不少麻烦。</p><p>还有第三个参数，用于格式化字符串用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var data = [</span><br><span class="line">    &#123;name: &quot;王尼玛&quot;, sex:1, age: 30&#125;,</span><br><span class="line">    &#123;name: &quot;王尼美&quot;, sex:0, age: 20&#125;,</span><br><span class="line">    &#123;name: &quot;王大锤&quot;, sex:1, age: 30&#125;</span><br><span class="line">];</span><br><span class="line">var str_json = JSON.stringify(data, null, &quot;\t&quot;);</span><br><span class="line">console.log(str_json);</span><br><span class="line">str_json = JSON.stringify(data, [&quot;name&quot;, &quot;sex&quot;], &quot;\t&quot;);</span><br><span class="line">console.log(str_json);</span><br></pre></td></tr></table></figure><p>不想要的 key 返回 undefined 即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var data = [</span><br><span class="line">    &#123;name: &quot;王尼玛&quot;, sex:1, age: 30&#125;,</span><br><span class="line">    &#123;name: &quot;王尼美&quot;, sex:0, age: 20&#125;,</span><br><span class="line">    &#123;name: &quot;王大锤&quot;, sex:1, age: 30&#125;</span><br><span class="line">];</span><br><span class="line">var str_json = JSON.stringify(data, function (k, v) &#123;</span><br><span class="line">    if (k === &quot;sex&quot;) &#123;</span><br><span class="line">        return [&quot;女&quot;, &quot;男&quot;][v];</span><br><span class="line">    &#125; else if (k === &quot;age&quot; ) &#123;</span><br><span class="line">        return undefined;</span><br><span class="line">    &#125;</span><br><span class="line">    return v;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(str_json);</span><br></pre></td></tr></table></figure></p><p>JSON.stringify(str, null, 4) //表示使用四个空格缩进</p><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><ul><li><a href="https://segmentfault.com/a/1190000003087224" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003087224</a></li><li><a href="https://www.cnblogs.com/52cik/p/js-json-stringify.html" target="_blank" rel="noopener">https://www.cnblogs.com/52cik/p/js-json-stringify.html</a></li></ul><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2018/04/01/用mock实现前端所需数据/">http://jaymo666.github.io/2018/04/01/用mock实现前端所需数据/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mock.js的小demo及mock语法简述及JSON.stringify用法&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Ajax概念-简单例子复习/Ajax概念+简单例子复习</title>
    <link href="http://jaymo666.github.io/2018/03/28/Ajax%E6%A6%82%E5%BF%B5-%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90%E5%A4%8D%E4%B9%A0/"/>
    <id>http://jaymo666.github.io/2018/03/28/Ajax概念-简单例子复习/</id>
    <published>2018-03-28T02:58:55.000Z</published>
    <updated>2018-03-28T13:05:37.003Z</updated>
    
    <content type="html"><![CDATA[<p>Ajax概念-简单例子复习/Ajax概念+简单例子复习<a id="more"></a></p><h1 id="Ajax概念-简单例子复习-Ajax概念-简单例子复习"><a href="#Ajax概念-简单例子复习-Ajax概念-简单例子复习" class="headerlink" title="Ajax概念-简单例子复习/Ajax概念+简单例子复习"></a>Ajax概念-简单例子复习/Ajax概念+简单例子复习</h1><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><blockquote><p>同步：页面请求实时传给服务器，导致必填数据没有填的时候，要回到页面上重新从头填写，耗时长、客户体验差。</p></blockquote><blockquote><p>异步：在页面必填项写上必填选项，不用通过传给服务器判断必填内容是否已经填写完整，耗时短、用户体验强。</p></blockquote><h2 id="异步："><a href="#异步：" class="headerlink" title="异步："></a>异步：</h2><blockquote><p>XMLHttpRequest： XMLHttpRequest对象的出现分割了同步和异步。XMLHttpRequest出现之前是同步的，出现之后是异步的。</p></blockquote><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><ol><li>利用html+css来实现页面，表达信息；</li><li>用XMLHttpRequest和web服务器进行数据的异步交换</li><li>运用js操作DOM，实现动态局部刷新；</li></ol><h2 id="创建XMLhttpRequest对象"><a href="#创建XMLhttpRequest对象" class="headerlink" title="创建XMLhttpRequest对象"></a>创建XMLhttpRequest对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var request;</span><br><span class="line">if(window.XMLHttpRequest)&#123;</span><br><span class="line">    request = new XMLHtpRequest();</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    request = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//IE5,IE6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ajax-HTTP请求"><a href="#Ajax-HTTP请求" class="headerlink" title="Ajax+HTTP请求"></a>Ajax+HTTP请求</h2><h4 id="HTTP请求，简洁版"><a href="#HTTP请求，简洁版" class="headerlink" title="HTTP请求，简洁版"></a>HTTP请求，简洁版</h4><ul><li>建立TCP连接</li><li>Web浏览器向Web服务器发送请求命令</li><li>Web服务器发送请求头</li><li>Web服务器应答</li><li>Web服务器向浏览器发送数据</li><li>Web服务器关闭TCP连接</li></ul><h4 id="http-状态码"><a href="#http-状态码" class="headerlink" title="http 状态码"></a>http 状态码</h4><ul><li>1XX 信息类 表示收到web浏览器请求</li><li>2xx 成功 200</li><li>3xx 重定向，表示请求没有成功，</li><li>4xx 表示客户端错误</li><li>5xx 服务器错误，表示服务器不能完成对请求的处理</li></ul><h4 id="XMLHttpRequest发送方法"><a href="#XMLHttpRequest发送方法" class="headerlink" title="XMLHttpRequest发送方法"></a>XMLHttpRequest发送方法</h4><ul><li>open（method,url,async）//async:同步false；异步：true（默认）</li><li>send(string)</li></ul><p><strong>例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">request.open(&quot;GET&quot;,  &quot;get.php&quot;,true);</span><br><span class="line">request.send();</span><br><span class="line"></span><br><span class="line">request.open(&quot;POST&quot;, &quot;post.php&quot;,true)；</span><br><span class="line">request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);//写在中间，引用表单时，告诉服务器是什么格式，Content-type&quot;告诉服务器是表单格式，页面表单数据向服务端传输时的编码方式application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">request.send(&quot;name=jaymo&amp;sex=男&quot;);</span><br></pre></td></tr></table></figure><h4 id="XMLHttpRequest取得相应"><a href="#XMLHttpRequest取得相应" class="headerlink" title="XMLHttpRequest取得相应"></a>XMLHttpRequest取得相应</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var request=new XMLHttpRequest();</span><br><span class="line">    request.open(&quot;GET&quot;,&quot;get.php&quot;,true);</span><br><span class="line">    request.send();</span><br><span class="line">    request.onreadyStatechange=function()&#123;</span><br><span class="line">    if（request.readyState===4&amp;&amp;request.status===200）&#123;</span><br><span class="line">    //做一些事</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h4 id="例子简介："><a href="#例子简介：" class="headerlink" title="例子简介："></a>例子简介：</h4><ul><li>html：用来查询员工查询和新建</li><li>php：用来查询和新建的后台接口</li><li>XAMPP </li></ul><h5 id="启动xampp"><a href="#启动xampp" class="headerlink" title="启动xampp"></a>启动xampp</h5><p>修改端口，改为8088；<br>在浏览器输入：<a href="http://localhost:8088/" target="_blank" rel="noopener">http://localhost:8088/</a><br></p><h4 id="建立php文件："><a href="#建立php文件：" class="headerlink" title="建立php文件："></a>建立php文件：</h4><p>test.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;测试页面&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">echo &quot; Hello World! 这是测试页面。&quot;;</span><br><span class="line">?&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h5 id="真正例子"><a href="#真正例子" class="headerlink" title="真正例子"></a>真正例子</h5><h2 id="json解析"><a href="#json解析" class="headerlink" title="json解析"></a>json解析</h2><p>第一种方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var jsondata=&apos;&#123;&quot;staff&quot;:[&#123;&quot;name&quot;:&quot;红旗&quot;,&quot;age&quot;:18&#125;,&#123;&quot;name&quot;:&quot;郭靖&quot;,&quot;age&quot;:16&#125;]&#125;&apos;;</span><br><span class="line">var jsonobj=eval(&apos;(&apos;+jsondata+&apos;)&apos;);</span><br><span class="line">alert(jsonobj.staff[0].name);</span><br></pre></td></tr></table></figure></p><p>第二种方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var jsondata=&apos;&#123;&quot;staff&quot;:[&#123;&quot;name&quot;:&quot;红旗&quot;,&quot;age&quot;:18&#125;,&#123;&quot;name&quot;:&quot;郭靖&quot;,&quot;age&quot;:16&#125;]&#125;&apos;;</span><br><span class="line">var jsonobj=JSON.parse(jsondata);</span><br><span class="line">alert(jsonobj.staff[0].name);</span><br></pre></td></tr></table></figure></p><blockquote><p>在JavaScript中有eval和JSON.parse两种方式，推荐后者，因为前者是不安全的，它不能验证json格式的合法性，不能避免在json中直接执行JavaScript代码，从而造成潜在威胁的存在。推荐用JSONlint进行json在线验证</p></blockquote><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2018/03/28/Ajax概念-简单例子复习/">http://jaymo666.github.io/2018/03/28/Ajax概念-简单例子复习/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ajax概念-简单例子复习/Ajax概念+简单例子复习&lt;/p&gt;
    
    </summary>
    
      <category term="Ajax" scheme="http://jaymo666.github.io/categories/Ajax/"/>
    
    
      <category term="Ajax" scheme="http://jaymo666.github.io/tags/Ajax/"/>
    
      <category term="json" scheme="http://jaymo666.github.io/tags/json/"/>
    
      <category term="jQuery" scheme="http://jaymo666.github.io/tags/jQuery/"/>
    
      <category term="js" scheme="http://jaymo666.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JSON的使用</title>
    <link href="http://jaymo666.github.io/2018/03/28/JSON%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://jaymo666.github.io/2018/03/28/JSON的使用/</id>
    <published>2018-03-28T02:35:19.000Z</published>
    <updated>2018-03-28T02:55:46.363Z</updated>
    
    <content type="html"><![CDATA[<p>Json复习<a id="more"></a></p><h1 id="JSON的使用"><a href="#JSON的使用" class="headerlink" title="JSON的使用"></a>JSON的使用</h1><h2 id="JSON的两种格式"><a href="#JSON的两种格式" class="headerlink" title="JSON的两种格式"></a>JSON的两种格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;JSON&quot;,&quot;address&quot;:&quot;北京市西城区&quot;,&quot;age&quot;:25&#125;//JSON的对象格式的字符串</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;&quot;name&quot;:&quot;JSON&quot;,&quot;address&quot;:&quot;北京市西城区&quot;,&quot;age&quot;:25&#125;]//数组对象格式</span><br></pre></td></tr></table></figure><p>区别与联系：</p><blockquote><p>对象格式和数组对象格式唯一的不同则是在对象格式的基础上加上了[]，再来看具体的结构，可以看出都是以键值对的形式出现的，中间以英文状态下的逗号（,）分隔。</p></blockquote><h2 id="两个重要函数"><a href="#两个重要函数" class="headerlink" title="两个重要函数"></a>两个重要函数</h2><h4 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h4><h4 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h4><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>JSON字符串:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var str1 = &apos;&#123; &quot;name&quot;: &quot;cxh&quot;, &quot;sex&quot;: &quot;man&quot; &#125;&apos;;</span><br></pre></td></tr></table></figure></p><p>JSON对象:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj1= &#123; &quot;name&quot;: &quot;cxh&quot;, &quot;sex&quot;: &quot;man&quot; &#125;;</span><br></pre></td></tr></table></figure></p><h4 id="JSON字符串转换为JSON对象"><a href="#JSON字符串转换为JSON对象" class="headerlink" title="JSON字符串转换为JSON对象"></a>JSON字符串转换为JSON对象</h4><p>要使用上面的str1，必须使用下面的方法先转化为JSON对象：</p><p>由JSON字符串转换为JSON对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = eval(&apos;(&apos; + str1+ &apos;)&apos;);</span><br><span class="line">console.log(obj);</span><br><span class="line">//或者</span><br><span class="line">var obj = JSON.parse(str1); </span><br><span class="line">console.log(obj);</span><br></pre></td></tr></table></figure></p><p>一般，从后台传入到前台的是json字符串，不是真正的json对象，因此需要使用eval函数转换。 将字符串转换为json对象使用函数eval，或JSON.parse(str)。其中：eval(“(“ + str+ “)”)；</p><h4 id="SON对象转化为JSON字符串"><a href="#SON对象转化为JSON字符串" class="headerlink" title="SON对象转化为JSON字符串"></a>SON对象转化为JSON字符串</h4><p>使用toJSONString()或者全局方法JSON.stringify()将JSON对象转化为JSON字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var last=JSON.stringify(obj1); //将JSON对象转化为JSON字符</span><br><span class="line">console.log(last);</span><br><span class="line">typeof last;</span><br></pre></td></tr></table></figure><h2 id="Js-中对-Json-数组的常用操作"><a href="#Js-中对-Json-数组的常用操作" class="headerlink" title="Js 中对 Json 数组的常用操作"></a>Js 中对 Json 数组的常用操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var persons = [</span><br><span class="line">    &#123;name: &quot;tina&quot;, age: 14&#125;,</span><br><span class="line">    &#123;name: &quot;timo&quot;, age: 15&#125;,</span><br><span class="line">    &#123;name: &quot;lily&quot;, age: 16&#125;,</span><br><span class="line">    &#123;name: &quot;lucy&quot;, age: 16&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="根据对象属性值得到相应对象"><a href="#根据对象属性值得到相应对象" class="headerlink" title="根据对象属性值得到相应对象"></a>根据对象属性值得到相应对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//1. 获取 name 等于 lily 的对象</span><br><span class="line">var lily=persons.filter((p)=&gt;&#123;</span><br><span class="line">    return p.name==&quot;lily&quot;;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(lily);</span><br><span class="line"></span><br><span class="line">//注：filter()方法返回的是一个数组</span><br><span class="line">var twins = persons.filter((p) =&gt; &#123;</span><br><span class="line">    return p.age == 16;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(twins); </span><br><span class="line">// 打印结果 [&#123;name: &quot;lily&quot;, age: 16&#125;,&#123;name: &quot;lucy&quot;, age: 16&#125;]</span><br></pre></td></tr></table></figure><h4 id="删除其中一个对象"><a href="#删除其中一个对象" class="headerlink" title="删除其中一个对象"></a>删除其中一个对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 删除 name 等于 tina 的对象，利用splice()方法</span><br><span class="line"></span><br><span class="line">// 1. 首先我们要得到这个对象</span><br><span class="line">var tina = persons.filter((p) =&gt; &#123;</span><br><span class="line">    return p.name == &quot;tina&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//2. 其次得到这个对象在数组中对应的索引</span><br><span class="line">var index = persons.indexOf(tina[0]);</span><br><span class="line"></span><br><span class="line">//3. 如果存在则将其删除，index &gt; -1 代表存在</span><br><span class="line">index &gt; -1 &amp;&amp; persons.splice(index, 1);</span><br><span class="line"></span><br><span class="line">console.log(persons);</span><br></pre></td></tr></table></figure><h4 id="修改其中一个对象的属性值"><a href="#修改其中一个对象的属性值" class="headerlink" title="修改其中一个对象的属性值"></a>修改其中一个对象的属性值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//将 name 等于 timo 的 age 修改为 20</span><br><span class="line"></span><br><span class="line">//1. 得到 timo 对象</span><br><span class="line">var timo = persons.filter((p) =&gt; &#123;</span><br><span class="line">    return p.name == &quot;timo&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//2. 修改age</span><br><span class="line">timo[0].age = 20;</span><br></pre></td></tr></table></figure><h4 id="往数组中添加一个对象"><a href="#往数组中添加一个对象" class="headerlink" title="往数组中添加一个对象"></a>往数组中添加一个对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">persons.push(&#123;name: &quot;similar&quot;, age: 18&#125;);</span><br></pre></td></tr></table></figure><h2 id="js-数组转json，json转数组"><a href="#js-数组转json，json转数组" class="headerlink" title="js 数组转json，json转数组"></a>js 数组转json，json转数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//数组转json串</span><br><span class="line">var arr = [1,2,3, &#123; a : 1 &#125; ];</span><br><span class="line">JSON.stringify( arr );</span><br><span class="line"></span><br><span class="line">//json字符串转数组</span><br><span class="line">var jsonStr = &apos;[1,2,3,&#123;&quot;a&quot;:1&#125;]&apos;;</span><br><span class="line">JSON.parse( jsonStr );</span><br></pre></td></tr></table></figure><h2 id="js解析json数组"><a href="#js解析json数组" class="headerlink" title="js解析json数组"></a>js解析json数组</h2><blockquote><p>解析json数组即对JSONArray的遍历</p></blockquote><h4 id="对于标准的json数组如"><a href="#对于标准的json数组如" class="headerlink" title="对于标准的json数组如"></a>对于标准的json数组如</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var result=[&#123;&quot;flag&quot;:1,&quot;macId&quot;:&quot;2&quot;,&quot;mbId&quot;:0,&quot;userName&quot;:&quot;XXX&quot;&#125;,&#123;&quot;flag&quot;:1,&quot;macId&quot;:&quot;1&quot;,&quot;mbId&quot;:1,&quot;userName&quot;:&quot;YYY&quot;&#125;]</span><br></pre></td></tr></table></figure><p>进行遍历的时候，可以直接通过for循环遍历这个数组，有两种方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//1</span><br><span class="line">for (var i = 0; i &lt; result.length; i++) &#123;</span><br><span class="line">        //result[i]表示获得第i个json对象即JSONObject</span><br><span class="line">        //result[i]通过.字段名称即可获得指定字段的值</span><br><span class="line">       console.log(result[i].userName);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> //2</span><br><span class="line"> for(var i in result)&#123;</span><br><span class="line">        //表示遍历数组，而i表示的是数组的下标值，</span><br><span class="line">        //result[i]表示获得第i个json对象即JSONObject</span><br><span class="line">        //result[i]通过.字段名称即可获得指定字段的值</span><br><span class="line">        result[i].userName;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="对于不标准的json数组如"><a href="#对于不标准的json数组如" class="headerlink" title="对于不标准的json数组如"></a>对于不标准的json数组如</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var result2=&#123;&quot;datas&quot;:[&#123;&quot;flag&quot;:1,&quot;macId&quot;:&quot;2&quot;,&quot;mbId&quot;:0,&quot;userName&quot;:&quot;XXX&quot;&#125;,&#123;&quot;flag&quot;:1,&quot;macId&quot;:&quot;1&quot;,&quot;mbId&quot;:1,&quot;userName&quot;:&quot;YYY&quot;&#125;]&#125;;</span><br></pre></td></tr></table></figure><p>进行遍历之前得先解析出标准的json数组格式即[{},{}]</p><blockquote><p>var data= result2.datas;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//1.  for (var i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">        //data[i]表示获得第i个json对象即JSONObject</span><br><span class="line">        //data[i]通过.字段名称即可获得指定字段的值</span><br><span class="line">        data[i].userName;</span><br><span class="line">    &#125;</span><br><span class="line">//2.</span><br><span class="line">  for(var i in data)&#123;</span><br><span class="line">        //表示遍历数组，而i表示的是数组的下标值，</span><br><span class="line">        //data[i]表示获得第i个json对象即JSONObject</span><br><span class="line">        //data[i]通过.字段名称即可获得指定字段的值</span><br><span class="line">        data[i].userName;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2018/03/28/JSON的使用/">http://jaymo666.github.io/2018/03/28/JSON的使用/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Json复习&lt;/p&gt;
    
    </summary>
    
      <category term="json" scheme="http://jaymo666.github.io/categories/json/"/>
    
    
      <category term="json" scheme="http://jaymo666.github.io/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>在npm发布第一个包</title>
    <link href="http://jaymo666.github.io/2018/03/14/%E5%9C%A8npm%E5%8F%91%E5%B8%83%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%85/"/>
    <id>http://jaymo666.github.io/2018/03/14/在npm发布第一个包/</id>
    <published>2018-03-14T12:39:50.000Z</published>
    <updated>2018-03-14T13:59:26.157Z</updated>
    
    <content type="html"><![CDATA[<p>第一个npm包:web-plus<a id="more"></a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=447960871&auto=0&height=66"></iframe><h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><ul><li>安装node.js</li><li>注册一个github账户用于托管代码</li><li>注册一个npm账户</li><li>开发你的module，更新至github</li><li>发布module至npm<h2 id="github创建项目"><a href="#github创建项目" class="headerlink" title="github创建项目"></a>github创建项目</h2></li></ul><p>终端进入到项目文件夹，执行npm init命令，构建模块的描述文件，系统会提示你输入所需的信息，不想输入就直接Enter跳过。这里主要的几个配置如下:</p><ul><li>name就是你要发布的module名</li><li>version版本信息（每发布一次版本号都必须大于上一次发布的版本号）；</li><li>entry入口文件</li></ul><h2 id="开发："><a href="#开发：" class="headerlink" title="开发："></a>开发：</h2><blockquote><p>npm init</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">$ npm init</span><br><span class="line">This utility will walk you through creating a package.json file.</span><br><span class="line">It only covers the most common items, and tries to guess sensible defaults.</span><br><span class="line"></span><br><span class="line">See `npm help json` for definitive documentation on these fields</span><br><span class="line">and exactly what they do.</span><br><span class="line"></span><br><span class="line">Use `npm install &lt;pkg&gt;` afterwards to install a package and</span><br><span class="line">save it as a dependency in the package.json file.</span><br><span class="line"></span><br><span class="line">Press ^C at any time to quit.</span><br><span class="line">package name: (npm-module) web-plus</span><br><span class="line">version: (1.0.0)</span><br><span class="line">description: 前端常用代码片段</span><br><span class="line">entry point: (index.js)</span><br><span class="line">test command:</span><br><span class="line">git repository: git@github.com:JayMo666/webplus.git</span><br><span class="line">keywords: web</span><br><span class="line">author: JayMo</span><br><span class="line">license: (ISC) MIT</span><br><span class="line">About to write to F:\npm\npm-module\package.json:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;web-plus&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;前端常用代码片段&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;repository&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;git&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;git+ssh://git@github.com/JayMo666/webplus.git&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;web&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;author&quot;: &quot;JayMo&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">  &quot;bugs&quot;: &#123;</span><br><span class="line">    &quot;url&quot;: &quot;https://github.com/JayMo666/webplus/issues&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;homepage&quot;: &quot;https://github.com/JayMo666/webplus#readme&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Is this ok? (yes)</span><br></pre></td></tr></table></figure><h3 id="npm注册"><a href="#npm注册" class="headerlink" title="npm注册"></a>npm注册</h3><h3 id="npm-命令"><a href="#npm-命令" class="headerlink" title="npm 命令"></a>npm 命令</h3><p>1.首先增加用户</p><blockquote><p>npm adduser<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm adduser</span><br><span class="line">Username: jaymo666</span><br><span class="line">Password: *******</span><br><span class="line">Email: (this IS public) 1294****8@qq.com</span><br><span class="line">Logged in as jaymo666 on https://registry.npmjs.org/.</span><br></pre></td></tr></table></figure></p></blockquote><p>2.查看当前登录用户</p><blockquote><p>npm whoami</p></blockquote><p>3.登录命令（这里已经登录，不用执行此命令）</p><blockquote><p>npm login</p></blockquote><h2 id="开发包-编程"><a href="#开发包-编程" class="headerlink" title="开发包-编程"></a>开发包-编程</h2><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><ul><li>a.js</li><li>index.js （这个是入口文件，要和package.json 文件中的  “main”的值一样）</li><li>package.json (npm init 生成的）</li></ul><h4 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h4><p>index.js:就开发一个简单地hello程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function hello(name)&#123;</span><br><span class="line">  console.log(&quot;hello &quot;+ name);</span><br><span class="line">&#125;</span><br><span class="line">exports.hello=hello;</span><br></pre></td></tr></table></figure><p>b.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var h=require(&apos;./index&apos;);</span><br><span class="line">h.hello(&apos;jaymo&apos;);</span><br></pre></td></tr></table></figure><p>##5.发布npm包</p><blockquote><p>npm publish<br>进入npm个人中心，可以看到自己的npm包已经发布在上面了</p></blockquote><p>##6.获取npm包</p><blockquote><p>npm install package-name<br>此处package-name使用web-plus即可<br>可以看到，多了一个node_modules目录，里面多了一个web-plus文件夹，里面放的就是我们刚才创建的npm包，包含a.js、index.js、package.json三个文件</p></blockquote><p>##7.使用npm包<br>跟使用普通的npm包一样，问了测试简单，创建一个index.js，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = require(&apos;web-plus&apos;)</span><br><span class="line">a.hello(&apos;jaymo&apos;)</span><br></pre></td></tr></table></figure></p><p>执行<code>node index</code>即可看见输出了hello jaymo</p><p>##8.更新npm包<br>更新npm包也是使用<code>npm publish</code>命令发布，不过必须更改npm包的版本号，即package.json的version字段，否则会报错<br>1.查看版本</p><blockquote><p>npm version<br>2.修改版本<br>npm version 版本<br>3.然后发布<br>npm publish</p></blockquote><p>##9.易出现的错误：</p><ul><li>如果在发布的文件下运行a.js文件测试：</li></ul><p><code>node a</code><br>如果出现：Cannot find module ‘web-plus’错误，可能是在a文件中require(‘./文件名’);引入出错</p><ul><li>如果是使用npm包出现Cannot find module ‘web-plus’错误，可能是：发布的包中package.json文件中main（入口文件）的值不是主文件名（在这里为index.js)</li></ul><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2018/03/14/在npm发布第一个包/">http://jaymo666.github.io/2018/03/14/在npm发布第一个包/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一个npm包:web-plus&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>迁移hexo到新电脑</title>
    <link href="http://jaymo666.github.io/2018/03/08/%E8%BF%81%E7%A7%BBhexo%E5%88%B0%E6%96%B0%E7%94%B5%E8%84%91/"/>
    <id>http://jaymo666.github.io/2018/03/08/迁移hexo到新电脑/</id>
    <published>2018-03-08T04:09:30.000Z</published>
    <updated>2018-03-08T04:39:53.924Z</updated>
    
    <content type="html"><![CDATA[<p>在更换新电脑的情况下恢复博客，保留了源码…<a id="more"></a></p><p>1、从官网Git下载git，在新电脑上安装，因为https速度慢，而且每次都要输入口令，常用的是使用ssh。使用下面方法创建：<br>（1）打开git bash，在用户主目录下运行：ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com" target="_blank" rel="noopener">youremail@example.com</a>“ 把其中的邮件地址换成自己的邮件地址，然后一路回车<br>（2）最后完成后，会在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，千万不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。<br>（3）登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」，你就应该看到已经添加的Key。<br>注意：不要在git版本库中运行ssh，然后又将它提交，这样就把密码泄露出去了。<br>（3）<a href="https://coding.net" target="_blank" rel="noopener">https://coding.net</a> 中的ssh与github的共用</p><p>2、下载Node.js，并安装</p><p>3、打开git bash客户端，输入 npm install hexo-cli -g，开始安装hexo</p><p>4、下面就将原来的文件拷贝到新电脑中，但是要注意哪些文件是必须的，哪些文件是可以删除的。<br>（1）讨论下哪些文件是必须拷贝的：首先是之前自己修改的文件，像站点配置_config.yml，theme文件夹里面的主题，以及source里面自己写的博客文件，这些肯定要拷贝的。除此之外，还有三个文件需要有，就是scaffolds文件夹（文章的模板）、package.json（说明使用哪些包）和.gitignore（限定在提交的时候哪些文件可以忽略）。其实，这三个文件不是我们修改的，所以即使丢失了，也没有关系，我们可以建立一个新的文件夹，然后在里面执行hexo init，就会生成这三个文件，我们只需要将它们拷贝过来使用即可。总结：_config.yml，theme/，source/，scaffolds/，package.json，.gitignore，是需要拷贝的。<br>（2）再讨论下哪些文件是不必拷贝的，或者说可以删除的：首先是.git文件，无论是在站点根目录下，还是主题目录下的.git文件，都可以删掉。然后是文件夹node_modules（在用npm install会重新生成），public（这个在用hexo g时会重新生成），.deploy_git文件夹（在使用hexo d时也会重新生成），db.json文件。其实上面这些文件也就是.gitignore文件里面记载的可以忽略的内容。总结：.git/，public/，.deploy_git/，db.json文件需要删除。</p><p>5、在git bash中切换目录到新拷贝的文件夹里，使用 npm install 命令，进行模块安装。很明显我们这里没用hexo init初始化，因为有的文件我们已经拷贝生成过来了，所以不必用hexo init去整体初始化，如果不慎在此时用了hexo init，则站点的配置文件_config.yml里面内容会被清空使用默认值，所以这一步一定要慎重，不要用hexo init。</p><p>6、安装其他的一些必要组件，如果在node_modules里面有的，就不要重复安装了：<br>（1）为了使用hexo d来部署到git上，需要安装<br>npm install hexo-deployer-git –save<br>（2）为了建立RSS订阅，需要安装<br>npm install hexo-generator-feed –save<br>（3）为了建立站点地图，需要安装<br>npm install hexo-generator-sitemap –save<br>插件安装后，有的需要对配置文件_config.yml进行配置，具体怎么配置，可以参考上面插件在github主页上的具体说明</p><p>7、使用hexo g，然后使用hexo d进行部署，如果都没有出错，就转移成功了！</p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2018/03/08/迁移hexo到新电脑/">http://jaymo666.github.io/2018/03/08/迁移hexo到新电脑/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在更换新电脑的情况下恢复博客，保留了源码…&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://jaymo666.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://jaymo666.github.io/tags/hexo/"/>
    
      <category term="github" scheme="http://jaymo666.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客再配置</title>
    <link href="http://jaymo666.github.io/2018/03/08/%E2%80%9Chexo%E5%8D%9A%E5%AE%A2%E5%86%8D%E9%85%8D%E7%BD%AE%E2%80%9D/"/>
    <id>http://jaymo666.github.io/2018/03/08/“hexo博客再配置”/</id>
    <published>2018-03-08T04:09:30.000Z</published>
    <updated>2018-03-08T07:00:49.228Z</updated>
    
    <content type="html"><![CDATA[<p>记录更换电脑后开启的新功能<a id="more"></a></p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=447960871&auto=0&height=66"></iframe></p><h1 id="1-已结开启的功能"><a href="#1-已结开启的功能" class="headerlink" title="1.已结开启的功能"></a>1.已结开启的功能</h1><h2 id="1-1设置-RSS"><a href="#1-1设置-RSS" class="headerlink" title="1.1设置 RSS"></a>1.1设置 RSS</h2><h2 id="1-2侧边栏社交链接"><a href="#1-2侧边栏社交链接" class="headerlink" title="1.2侧边栏社交链接"></a>1.2侧边栏社交链接</h2><h2 id="1-3设置「动画效果」"><a href="#1-3设置「动画效果」" class="headerlink" title="1.3设置「动画效果」"></a>1.3设置「动画效果」</h2><h2 id="1-4设置「背景动画」"><a href="#1-4设置「背景动画」" class="headerlink" title="1.4设置「背景动画」"></a>1.4设置「背景动画」</h2><h1 id="2-待开启"><a href="#2-待开启" class="headerlink" title="2.待开启"></a>2.待开启</h1><h2 id="2-1设置字体"><a href="#2-1设置字体" class="headerlink" title="2.1设置字体"></a>2.1设置字体</h2><h2 id="2-2开启打赏功能"><a href="#2-2开启打赏功能" class="headerlink" title="2.2开启打赏功能"></a>2.2开启打赏功能</h2><h2 id="2-3订阅微信公众号"><a href="#2-3订阅微信公众号" class="headerlink" title="2.3订阅微信公众号"></a>2.3订阅微信公众号</h2><h1 id="3-hexo-官方插件地址："><a href="#3-hexo-官方插件地址：" class="headerlink" title="3.hexo 官方插件地址："></a>3.hexo 官方插件地址：</h1><p><a href="https://hexo.io/plugins/" target="_blank" rel="noopener">https://hexo.io/plugins/</a></p><h1 id="4-加入的插件："><a href="#4-加入的插件：" class="headerlink" title="4.加入的插件："></a>4.加入的插件：</h1><ol><li>HEXO-自动摘录<a href="https://github.com/ashisherc/hexo-auto-excerpt" target="_blank" rel="noopener">https://github.com/ashisherc/hexo-auto-excerpt</a></li><li>HEXO辅助性live2d <a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">https://github.com/EYHN/hexo-helper-live2d</a></li><li>Hexo跨博客文章推荐插件 <a href="https://github.com/huiwang/hexo-recommended-posts" target="_blank" rel="noopener">https://github.com/huiwang/hexo-recommended-posts</a><br>4.实现点击出现桃心效果</li><li>在网站底部加上访问量</li></ol><p>【参考】<br> 1.<a href="https://www.jianshu.com/p/f054333ac9e6" target="_blank" rel="noopener">https://www.jianshu.com/p/f054333ac9e6</a></p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2018/03/08/“hexo博客再配置”/">http://jaymo666.github.io/2018/03/08/“hexo博客再配置”/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录更换电脑后开启的新功能&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://jaymo666.github.io/categories/hexo/"/>
    
    
      <category term="博客" scheme="http://jaymo666.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo" scheme="http://jaymo666.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://jaymo666.github.io/2018/03/07/hello-world/"/>
    <id>http://jaymo666.github.io/2018/03/07/hello-world/</id>
    <published>2018-03-07T10:59:51.630Z</published>
    <updated>2017-12-03T11:06:54.594Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2018/03/07/hello-world/">http://jaymo666.github.io/2018/03/07/hello-world/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>conda用法</title>
    <link href="http://jaymo666.github.io/2017/12/04/conda%E7%94%A8%E6%B3%95/"/>
    <id>http://jaymo666.github.io/2017/12/04/conda用法/</id>
    <published>2017-12-04T10:07:08.000Z</published>
    <updated>2017-12-04T10:09:42.413Z</updated>
    
    <content type="html"><![CDATA[<p>Conda简单用法及在python2与python3之间切换<a id="more"></a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=447960871&auto=0&height=66"></iframe><h1 id="安装scipy"><a href="#安装scipy" class="headerlink" title="安装scipy"></a>安装scipy</h1><p>conda install scipy</p><h1 id="conda会从从远程搜索scipy的相关信息和依赖项目，对于python-3-4，conda会同时安装numpy和mkl（运算加速的库）"><a href="#conda会从从远程搜索scipy的相关信息和依赖项目，对于python-3-4，conda会同时安装numpy和mkl（运算加速的库）" class="headerlink" title="conda会从从远程搜索scipy的相关信息和依赖项目，对于python 3.4，conda会同时安装numpy和mkl（运算加速的库）"></a>conda会从从远程搜索scipy的相关信息和依赖项目，对于python 3.4，conda会同时安装numpy和mkl（运算加速的库）</h1><h1 id="查看已经安装的packages"><a href="#查看已经安装的packages" class="headerlink" title="查看已经安装的packages"></a>查看已经安装的packages</h1><p>conda list</p><h1 id="最新版的conda是从site-packages文件夹中搜索已经安装的包，不依赖于pip，因此可以显示出通过各种方式安装的包"><a href="#最新版的conda是从site-packages文件夹中搜索已经安装的包，不依赖于pip，因此可以显示出通过各种方式安装的包" class="headerlink" title="最新版的conda是从site-packages文件夹中搜索已经安装的包，不依赖于pip，因此可以显示出通过各种方式安装的包"></a>最新版的conda是从site-packages文件夹中搜索已经安装的包，不依赖于pip，因此可以显示出通过各种方式安装的包</h1><h1 id="查看当前环境下已安装的包"><a href="#查看当前环境下已安装的包" class="headerlink" title="查看当前环境下已安装的包"></a>查看当前环境下已安装的包</h1><p>conda list</p><h1 id="查看某个指定环境的已安装包"><a href="#查看某个指定环境的已安装包" class="headerlink" title="查看某个指定环境的已安装包"></a>查看某个指定环境的已安装包</h1><p>conda list -n python34</p><h1 id="查找package信息"><a href="#查找package信息" class="headerlink" title="查找package信息"></a>查找package信息</h1><p>conda search numpy</p><h1 id="安装package"><a href="#安装package" class="headerlink" title="安装package"></a>安装package</h1><p>conda install -n python34 numpy</p><h1 id="如果不用-n指定环境名称，则被安装在当前活跃环境"><a href="#如果不用-n指定环境名称，则被安装在当前活跃环境" class="headerlink" title="如果不用-n指定环境名称，则被安装在当前活跃环境"></a>如果不用-n指定环境名称，则被安装在当前活跃环境</h1><h1 id="也可以通过-c指定通过某个channel安装"><a href="#也可以通过-c指定通过某个channel安装" class="headerlink" title="也可以通过-c指定通过某个channel安装"></a>也可以通过-c指定通过某个channel安装</h1><h1 id="更新package"><a href="#更新package" class="headerlink" title="更新package"></a>更新package</h1><p>conda update -n python34 numpy</p><h1 id="删除package"><a href="#删除package" class="headerlink" title="删除package"></a>删除package</h1><p>conda remove -n python34 numpy</p><p>conda将conda、python等都视为package，因此，完全可以使用conda来管理conda和python的版本，例如</p><h1 id="更新conda，保持conda最新"><a href="#更新conda，保持conda最新" class="headerlink" title="更新conda，保持conda最新"></a>更新conda，保持conda最新</h1><p>conda update conda</p><h1 id="更新anaconda"><a href="#更新anaconda" class="headerlink" title="更新anaconda"></a>更新anaconda</h1><p>conda update anaconda</p><h1 id="更新python"><a href="#更新python" class="headerlink" title="更新python"></a>更新python</h1><p>conda update python</p><h1 id="假设当前环境是python-3-4-conda会将python升级为3-4-x系列的当前最新版本"><a href="#假设当前环境是python-3-4-conda会将python升级为3-4-x系列的当前最新版本" class="headerlink" title="假设当前环境是python 3.4, conda会将python升级为3.4.x系列的当前最新版本"></a>假设当前环境是python 3.4, conda会将python升级为3.4.x系列的当前最新版本</h1><p>如果创建新的python环境，比如3.4，运行conda create -n python34 python=3.4之后，conda仅安装python 3.4相关的必须项，如python, pip等，如果希望该环境像默认环境那样，安装anaconda集合包，只需要：</p><h1 id="在当前环境下安装anaconda包集合"><a href="#在当前环境下安装anaconda包集合" class="headerlink" title="在当前环境下安装anaconda包集合"></a>在当前环境下安装anaconda包集合</h1><p>conda install anaconda</p><h1 id="结合创建环境的命令，以上操作可以合并为"><a href="#结合创建环境的命令，以上操作可以合并为" class="headerlink" title="结合创建环境的命令，以上操作可以合并为"></a>结合创建环境的命令，以上操作可以合并为</h1><p>conda create -n python34 python=3.4 anaconda</p><h1 id="也可以不用全部安装，根据需求安装自己需要的package即可"><a href="#也可以不用全部安装，根据需求安装自己需要的package即可" class="headerlink" title="也可以不用全部安装，根据需求安装自己需要的package即可"></a>也可以不用全部安装，根据需求安装自己需要的package即可</h1><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2017/12/04/conda用法/">http://jaymo666.github.io/2017/12/04/conda用法/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Conda简单用法及在python2与python3之间切换&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络管理员必备</title>
    <link href="http://jaymo666.github.io/2017/09/26/Network/"/>
    <id>http://jaymo666.github.io/2017/09/26/Network/</id>
    <published>2017-09-26T06:49:47.000Z</published>
    <updated>2017-12-03T11:30:29.248Z</updated>
    
    <content type="html"><![CDATA[<p>本文包括：</p><ul><li>[1]ping命令</li><li>[2]路由器和交换机的差异</li><li>[3]路由器的基本设置</li><li>[4]netsh网络配置命令</li><li>[5]安装失败（未签名）</li><li>[6]管理用户网络应用</li><li>[7]映射网络驱动器</li><li>[8]网络适配器的原理</li><li>[9]交换机的分类</li><li>[10]交换机的功能</li><li>[11]交换机的接口种类</li><li>[12]路由器的工作原理</li><li>[13]初识TCP/IP的分层<a id="more"></a></li></ul><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=447960871&auto=0&height=66"></iframe><h2 id="网络管理员必备"><a href="#网络管理员必备" class="headerlink" title="网络管理员必备"></a>网络管理员必备</h2><h3 id="1-ping命令"><a href="#1-ping命令" class="headerlink" title="[1]ping命令"></a>[1]ping命令</h3><p>“ping”命令是windows系统最长用的命令之一，是通过对一个网址<strong>发送测试数据包</strong>，看对方网址是否有响应并统计响应时间，以此<strong>测试网络</strong>，同时可以很好地帮助我们<strong>分析和判定网络故障</strong>。</p><p>方式：“ping IP地址/域名”</p><ol><li>输入“ping IP地址”回车，我们可以看到本机跟这台网络设备的连接状态，如下图所示是连接正常的。<br>例如：百度首页ip地址：119.75.217.109</li></ol><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\ping百度.JPG" alt="image"></p><p>2.还可以“ping 域名”,例如:ping baidu.com</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\pingbaiducom.JPG" alt="image"></p><p>3.如果“ping”后出现下图所示界面，说明本机跟这台网络设备的网络连接是不通的</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\pingcuo.JPG" alt="image"></p><p>4.键入“ping”直接回车我们还可以看到ping命令加其他参数的使用方法</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\ping.JPG" alt="image"></p><p>5.比如，我们使用“ping IP地址 -t”命令，可以持续的ping指定的主机，如果没有手动停止，ping命令会一直持续下去，我们可以通过“Ctrl+C”停止命令。其他参数的使用方法用户可以自己体验</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\pingt.JPG" alt="image"></p><hr><h3 id="2-路由器和交换机的差异"><a href="#2-路由器和交换机的差异" class="headerlink" title="[2]路由器和交换机的差异"></a>[2]路由器和交换机的差异</h3><h5 id="1-工作层次不同"><a href="#1-工作层次不同" class="headerlink" title="1. 工作层次不同:"></a>1. 工作层次不同:</h5><p>交换机工作在七层模型的第二层（即数据链路层）；而路由器工作在第三层（即网络层）。交换机由于工作在第二层，它的工作原理比较简单，而路由器在第三层，可以得到更多的协议信息，也可以做出更加智能的转发或映射。</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\77.JPG" alt="image"></p><blockquote><p>网络层（第三层）：能提供介质访问和链路管理等功能<br>数据链路层（第二层）：具有寻址和路由选择等功能</p></blockquote><h5 id="2-数据转发依据的对象不同"><a href="#2-数据转发依据的对象不同" class="headerlink" title="2. 数据转发依据的对象不同"></a>2. 数据转发依据的对象不同</h5><p>交换机是利用网络设备的<strong>物理地址（即MAC地址）</strong>来确定转发数据的目的地址；路由器是利用网络设备的<strong>IP地址</strong>来确定转发数据的目的地址。其中<strong>物理地址</strong>是设备本身自带的，由设备的网卡生产厂商分配，已经固化到网卡硬件中，<strong>不可修改</strong>；而<strong>IP地址是在系统软件中分配的，可以修改</strong>。</p><p>通过命令“ipconfig/all”，可以查看本机的物理地址和IP地址。如下图所示，就是我的计算机的网卡信息。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\ip.JPG" alt="image"></p><h5 id="3-路由器可以分割广播域，而交换机不能"><a href="#3-路由器可以分割广播域，而交换机不能" class="headerlink" title="3.路由器可以分割广播域，而交换机不能"></a>3.路由器可以分割广播域，而交换机不能</h5><p><strong>交换机只可以分割冲突域</strong>，不可以分割广播域，<strong>而路由器可以分割广播域</strong>。简单的来说，在同一个交换机下连接的设备，IP都在同一个网段，是属于同一个广播域的，如果不在同一网段，则无法进行通信；而路由器可以分配不同的广播域（即不同的网段），而这些不同网段的设备可以不穿过路由而进行相互通信。</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\广播域.JPG" alt="image"></p><blockquote><p>目前，虽然三层或者第三层以上交换机具有VLAN功能，也可以分割广播域，但是各个广播域之间是不可以相互通信的，他们之前如果要通信交流还是需要路由器的支持。</p></blockquote><h5 id="4-路由器有防火墙服务，而交换机没有"><a href="#4-路由器有防火墙服务，而交换机没有" class="headerlink" title="4.路由器有防火墙服务，而交换机没有"></a>4.路由器有防火墙服务，而交换机没有</h5><p>路由器设置的防火墙是运行在网络层的，通过设置特定的规定，允许或者限制传输的数据通过，或者过滤IP封包，禁止不符合规定的封包通过。而交换机不具备防火墙功能，如果只是通过交换机接通外部网络，相当于闭上眼、光着屁股在大街上跑，很不安全！</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\防火墙.JPG" alt="image"><br><strong>注意：数据安全很重要，路由器、交换机的使用都要慎重！注意保密保护工作！</strong></p><h3 id="3-路由器的基本设置"><a href="#3-路由器的基本设置" class="headerlink" title="[3]路由器的基本设置"></a>[3]路由器的基本设置</h3><p> 要实现多台计算机同时上网，主要设置的地方就是路由器，下面以企业中总路由器下的一个无线路由为大家介绍一下路由器的基本设置过程。</p><p> 1.通过<strong>浏览器登录路由器</strong>。如果是<strong>新路由器</strong>，可以查看路由后面贴<strong>标签</strong>出的默认IP和登录账号、密码；如果是正常<strong>使用中的路由器</strong>，登录地址可以查看计算机的网关，如果登录密码修改过，请咨询管理员。</p><blockquote><p> 电脑和路由器相连：一种是通过网线连接，一种是通过无线连接。</p></blockquote><p>电脑和路由器之间通过网线连接的话，你要在路由器上找到<strong>LAN口和WAN口</strong>。这里讲一下，WAN口全称Wide Area Network（广域网），LAN口全称Wide Area Network（局域网）。一般的路由有很多LAN口，一个WAN口。<strong>WAN口插主网线，LAN插电脑与路由连接的网线</strong>。这样电脑就和路由器连接了。</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\LAN.JPG" alt="image"></p><blockquote><p>电脑连接上了路由器，就可以在浏览器上输入路由器的地址进入路由器的设置界面了</p></blockquote><p>2.<strong>WAN口设置</strong>，“<strong>基本设置</strong>”中的“<strong>快速设置</strong>”，（1）如果外网地址没有固定IP，则类型选择动态；（2）如果外网地址有固定IP或者上层还有路由则将分配IP设置到wan口，如下图所示。</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\快速配置.JPG" alt="image"><br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\外网.JPG" alt="image"></p><p>3.<strong>LAN口的设置</strong>，“基本设置”中的“内网设置”，设置IP地址（即内网中网络设备的网关比如设置成192.168.1.1，如果上层有路由是192.168.1.1，则次路由器可以设置成其他网段192.168.x.1）、子网掩码。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\内网.JPG" alt="image"><br><strong><br>4.“DHCP服务器”的设置</strong>，如果让用户<strong>自动获取IP地址</strong>使用，需要使用DHCP服务器，可以限制用户自动获取IP地址的范围，如下图的“起始IP地址”和“结束IP地址”（可以在上网行为管理的IP地址组中看到）。</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\上网行为.JPG" alt="image"><br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\DHCP.JPG" alt="image"></p><p>5.<strong>无线的“基本设置”</strong>，要启用无线的话，勾选启用开关，并为无线网络设置一个名称，设置无线模式为“11b/g/n混合模式”，来兼容三种无线协议：802.11b、802.11g、802.11n。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\无线.JPG" alt="image"></p><p>6.<strong>无线的“安全设置”</strong>，如果需要做MAC地址绑定的安全管控，需要勾选mac地址“启用”：设置“允许”，将允许上网的计算机mac地址添加到mac地址列表；设置“禁用”，将不允许上网的计算机mac地址添加到mac地址列表。设置加密类型为常用的“WPA2-PSK”，并设置密码<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\无线安全.JPG" alt="image"></p><p>7.<strong>“上网行为管理”设置</strong>，设置允许或者不允许上网的时间段；如果需要管理QQ等常用聊天软件，可以在聊天软件高级设置里进行启用，将允许使用QQ等聊天软件的账号添加到例外列表。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\上班.JPG" alt="image"><br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\QQ.JPG" alt="image"></p><p>8.网络安全中设置内外网的“攻击防御”和“MAC地址绑定”（勾选“禁止未绑定IP/MAC的主机通过”，前面已经说过，不再赘述）<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\外网防御.JPG" alt="image"><br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\IPMAC.JPG" alt="image"></p><p>9.<strong>“端口映射”和“域名转发”</strong>，大多在系统集成中会用到，特别是监控设备想要远程访问，需要将设备的通讯端口等进行路由转发，此处需要注意的是，如果跨多层路由的话，每一层路由都是需要转发的。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\端口.JPG" alt="image"><br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\域名.JPG" alt="image"></p><p>10.修改路由器的登录密码。</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\修改密码.JPG" alt="image"></p><hr><h3 id="4-netsh网络配置命令"><a href="#4-netsh网络配置命令" class="headerlink" title="[4]netsh网络配置命令"></a>[4]netsh网络配置命令</h3><p>netsh是Network Shell的缩写，是windows为我们提供的功能强大的网络配置命令行工具。下面用几个常用的“netsh interface ip show”小命令介绍netsh的用法。</p><p>1.<strong>netsh interface ip show address</strong>:显示本机IP地址配置，包括以太网的ip和本地回环ip地址，以太网ip地址就是我们常说的为本机网卡分配的一个地址，这个容易理解；本地还有ip地址，是一种叫做本地回环接口虚接口，在windows系统中都会采用如下图所示的127.0.0.1这个地址，用以提高网络的健壮性。</p><p>2.如果在上一步的基础上想要显示更多信息，可以用命令：<strong>netsh interface ip show config</strong>。</p><p>3.netsh interface ip show dns:显示本机使用的DNS服务器，同样包括以太网和本地回环接口的DNS信息。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\DNS.JPG" alt="image"></p><p>4.<strong>netsh interface ip show ipnet</strong>:显示本IP地址所在的网络到媒体的映射，我们同时可以看到映射类型和所用接口等信息。</p><p>5.<strong>netsh interface ip show wins</strong>:如果设置了wins服务器，可以用此命令查看wins服务器的地址。</p><p>6.还有一个我喜欢用的不属于“<strong>netsh interface ip</strong>”这一系列的小命令，<strong>netsh firewall show state</strong>:<strong>查看本机防火墙的状态</strong>，每当我们公司某一台办公电脑在连接公司的某个系统连接不上的时候，我会用以查看防火墙状态，我们可以看到启用或禁用的功能模块，以及启用情况。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\防火.JPG" alt="image"></p><hr><h3 id="5-安装失败（未签名）"><a href="#5-安装失败（未签名）" class="headerlink" title="[5]安装失败（未签名）"></a>[5]安装失败（未签名）</h3><p>在我们安装驱动的时候，特别是用驱动精灵等驱动软件安装的时候，会出现“安装失败（未签名）”的情况，如何解决？</p><p>方法/步骤</p><p>1.单击开始菜单里的“运行”，或者通过“windows键+R”打开“运行”，在输入框中输入“sigverif”回车<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\签名.JPG" alt="image"></p><p>2.在打开的文件签名验证里点击“高级”按钮</p><p>3.如下图所示找到下载的驱动（如果未解压，需要先解压），然后点击“确认”按钮</p><p>4.切换到“正在记录”选项，选中如下图所示选项，点击“确定”按钮</p><p>5.回到第二步时候的界面，点击“开始”按钮，我们可以看到下图所示列表界面，点击“关闭”即可</p><p>6.从设备管理器安装驱动，右键单击我的电脑（xp）/计算机（win7）/这台电脑（win8），点击“管理”，在“计算机管理”中右侧边栏中单击“设备管理器”，找到我们要安装驱动的这个硬件，右键单击，选择“更新驱动程序”</p><p>7.勾选“从列表或指定位置安装”，点击“下一步”按钮</p><p>8.选择驱动程序解压后的文件夹，点击“下一步”按钮</p><p>9.到安装界面，用户需等待，知道出现安装成功的界面，点击“完成”按钮即可</p><p>10.返回到设备管理器，我们可以看到，此驱动已经安装完成</p><hr><h3 id="6-管理用户网络应用"><a href="#6-管理用户网络应用" class="headerlink" title="[6]管理用户网络应用"></a>[6]管理用户网络应用</h3><p>现在各种网络应用程序纷繁复杂，而p2p软件又是其中最为流行的一种，而且提供了多样化得登陆方式，在此，我们以最常用的QQ为例。</p><p>我们大家都知道，QQ本身支持UDP、HTTP和HTTPS三种登陆方式，而且可以使用代理，意思是说，只要你允许了HTTP协议，QQ就可以登陆。</p><p>现在我们以封锁QQ为例，介绍一下，如何利用路由级的网络防火墙管理用户网络应用。</p><h5 id="1-QQ登陆原理"><a href="#1-QQ登陆原理" class="headerlink" title="1.QQ登陆原理"></a>1.QQ登陆原理</h5><ol><li><p>QQ登录登陆的过程，由向服务器群的8000端口发送UDP数据包，从服务器群的回复中选择一个最快的作为登陆服务器。</p></li><li><p>如果没有服务器回复UDP数据包，则使用TCP80/443端口来进行连接。</p></li><li><p>QQ服务器：</p></li></ol><ul><li>UDP8000端口类18个</li><li>TCPHTTP连接服务器5个</li><li>会员VIP服务器使用HTTPS443连接</li></ul><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\QQ原理.JPG" alt="image"></p><h5 id="2-如何封锁"><a href="#2-如何封锁" class="headerlink" title="2.如何封锁"></a>2.如何封锁</h5><p>1.上面我们知道，QQ可以使用HTTP直接连接，一般不能封锁HTTP协议，所以最好的办法就是封锁它的服务器IP地址，但是QQ还可以使用代理登陆，这种情况我们就得在路由级防火墙中的HTTP检查机制中设置禁止QQ的HTTP连接。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\QQ代理.JPG" alt="image"><br>2.首先，配置用户访问规则，使用计算机集定义目的网络。也就是做好禁止内部客户访问QQ服务器的访问策略。</p><p>3.其次，配置HTTP策略，理由路由器的HTTP深层检查机制，禁止QQ使用HTTP代理。在允许ＱＱ使用HTTP代理的策略上点击右键，选中“配置HTTP”</p><p>4.在弹出的“为规则配置HTTP策略”对话框中，点击“签名”，然后点击“添加”，在弹出的“签名”对话框中，输入名称为“QQ”，指定签名搜索条件为在“请求URL”中搜索“tencent.com”，找到则阻止这个连接</p><p>5.最后，在防火墙策略选项中，点击“应用”来保存修改和更新防火墙策略，此时，QQ已经不能通过代理服务器登录了</p><hr><h3 id="7-映射网络驱动器"><a href="#7-映射网络驱动器" class="headerlink" title="[7]映射网络驱动器"></a>[7]映射网络驱动器</h3><p>映射网络驱动器” 的意思是将局域网中的某个目录（一般是共享的文件夹之类的）映射成本地驱动器号，就是说把网络上其他机器的共享的文件夹映射自己机器上的一个磁盘，这样可以提高访问时间，相当于一个打开共享的快捷方式。</p><p>1.首先，找到这个共享文件夹，我们可以在网络里找到这台设备，或者打开开始菜单的“运行”，输入：“\这台设备的IP地址”，比如此例中的“\192.168.1.52”<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\本机IP.JPG" alt="image"></p><p>2.在打开的共享界面，找到并右键单击要映射驱动器的文件件，选择“映射网络驱动器”<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\映射.JPG" alt="image"></p><p>3.在映射驱动器的界面，选择好驱动器盘符，点击“完成”即可完成设置</p><p>4.打开资源管理器，我们可以看到，已经有了该驱动器，日常使用过程中直接点击打开即可</p><hr><h3 id="8-网络适配器的原理"><a href="#8-网络适配器的原理" class="headerlink" title="[8]网络适配器的原理"></a>[8]网络适配器的原理</h3><p>网络适配器，也就是我们说的网卡，有些维修人员也叫网络接口卡，是计算机和网络电缆之间的物理接口，下面我们根据网络适配器需要完成的任务介绍一下它的工作原理。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\网卡.JPG" alt="image"></p><p>1.为在<strong>计算机使用的数据</strong>（<strong>并行数据</strong>）和<strong>电缆上传输的电信号</strong>（<strong>串行数据</strong>）之间提供数据转换的功能。比如我们用的一个共享打印机，计算机直接连接打印机用的是并行数据，而如果我们通过网络连接别人共享的打印机，就是通过串行数据转换为并行数据来实现。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\打印.JPG" alt="image"><br>2.判断从电缆接收的数据是否为传输给该计算机的数据。</p><p>3.在计算机和电缆之间控制数据流，每块网卡都有一个唯一的标识，我们一般叫做MAC地址，大部分网卡的MAC地址烧录在卡上的ROM芯片中，MAC地址有6段组成，通常表示为12个16进制数。<br>我们可以通过命令提示符查看本机网卡的信息，操作步骤：1、单击开始菜单里的“运行”，在输入框中输入“cmd”，然后回车。2、在命令提示符界面输入“ipconfig /all”命令，回车，我们可以看到以下信息。<br>如图所示的是本机无线网卡的信息，其中前3字节“A6-17-31”表示厂商代码，有IEEE负责分配；后3个字节“30-49-E2”表示网卡序号，由网卡厂商负责。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\MAC地址.JPG" alt="image"></p><hr><h3 id="9-交换机的分类"><a href="#9-交换机的分类" class="headerlink" title="[9]交换机的分类"></a>[9]交换机的分类</h3><p>交换机是网络连接的基础，有了交换机，就可以实现更多电脑的共享上网</p><p>1.广义上来讲，交换机分为两种：<strong>广域交换机</strong>和<strong>局域网交换机</strong>。广域网交换机主要用于电信领域，提供通信用的基础平台，我们平常接触很少；而局域网交换机是我们日常使用最多的，主要应用于日常的局域网络，连接计算机和网络打印机的终端设备<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\交换机.JPG" alt="image"></p><p>2.从传输介质和传输速度上可以分为以太网交换机、快速以太网交换机、千兆以太网交换机、FDDI交换机、ATM交换机和令牌交换机等</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\交换机速率.JPG" alt="image"></p><p>3.从规模应用上可以分为企业级、部门级和工作组交换机<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\交换机企业.JPG" alt="image"></p><h3 id="10-交换机的功能"><a href="#10-交换机的功能" class="headerlink" title="[10]交换机的功能"></a>[10]交换机的功能</h3><h5 id="1-交换机功能"><a href="#1-交换机功能" class="headerlink" title="1.交换机功能"></a>1.交换机功能</h5><p>学习功能，局域网内交换机会了解跟每一个插口相连接的<strong>MAC地址</strong>，并将地址同<strong>相应的端口</strong>映射起来存放在<strong>交换机缓存中的MAC地址表中</strong></p><h5 id="2-转发-过滤功能"><a href="#2-转发-过滤功能" class="headerlink" title="2.转发/过滤功能"></a>2.转发/过滤功能</h5><p>当一个数据帧的目的地址在MAC地址表中有映射时，它被转发到连接目的节点的端口而不是所有端口（如该数据帧为广播/组播帧则转发至所有端口）<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\MAC地址表.JPG" alt="image"></p><h5 id="3-消除回路功能"><a href="#3-消除回路功能" class="headerlink" title="3.消除回路功能"></a>3.消除回路功能</h5><p>当交换机包括一个冗余回路时，以太网交换机通过<strong>生成树协议</strong>避免回路的产生，同时允许存在<strong>后背路径</strong><br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\回路.JPG" alt="image"></p><h5 id="4-兼容功能"><a href="#4-兼容功能" class="headerlink" title="4.兼容功能"></a>4.兼容功能</h5><p>交换机除了能连接两种同类型的网络之外，还可以在不同类型的网路（如以太网和快速以太网）之间起到互联作用。而且现在的交换机没有很严格的类型之分，百兆交换机一般也会加两个千兆口或光纤接入口<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\消除.JPG" alt="image"></p><hr><h3 id="11-交换机的接口种"><a href="#11-交换机的接口种" class="headerlink" title="[11]交换机的接口种"></a>[11]交换机的接口种</h3><h5 id="1-双绞线RJ-45接口-水晶头"><a href="#1-双绞线RJ-45接口-水晶头" class="headerlink" title="1.双绞线RJ-45接口-水晶头"></a>1.双绞线RJ-45接口-水晶头</h5><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\水晶头.JPG" alt="image"></p><h5 id="2-光纤接口"><a href="#2-光纤接口" class="headerlink" title="2.光纤接口"></a>2.光纤接口</h5><p>光纤需要熔接到带插头的尾纤，常见的尾纤插头有SC。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\SC.JPG" alt="image"></p><hr><h3 id="12-路由器的工作原理"><a href="#12-路由器的工作原理" class="headerlink" title="[12]路由器的工作原理"></a>[12]路由器的工作原理</h3><p>路由器，大家都很熟悉了，办公室或者家里凡有两台以上的电脑需要上网的一般都安装了路由器，只有安装了路由器才能实现多台电脑同时上网。我们就了解下路由器的配置原理。</p><h5 id="1-路由器的概念"><a href="#1-路由器的概念" class="headerlink" title="1.路由器的概念"></a>1.路由器的概念</h5><p>1.所谓“路由”，就是把数据从一个地方传送到另一个地方的行为和动作，路由器就是执行这个动作的机器，英文名Router</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\路由.JPG" alt="image"></p><p>2.路由器能将不同网络或网段之间的数据信息进行“翻译”，以使他们能够相互“读”懂对方的数据，从而构建更大的网络。</p><h5 id="2-路由器的典型功能"><a href="#2-路由器的典型功能" class="headerlink" title="2.路由器的典型功能"></a>2.路由器的典型功能</h5><ul><li><strong>数据通道功能</strong></li></ul><p>包括转发决定、背板转发以及输出链路调度等，一般由特定的硬件来完成</p><ul><li><strong>控制功能</strong></li></ul><p>一般用软件来实现，包括与相邻路由器之间的信息交换、系统配置、系统管理等</p><h5 id="3-路由器的主要功能"><a href="#3-路由器的主要功能" class="headerlink" title="3.路由器的主要功能"></a>3.路由器的主要功能</h5><ul><li><strong>网络互连</strong></li></ul><p>路由器支持各种局域网和广域网接口，主要用于互连局域网和广域网，实现不同网络互相通信<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\互连.JPG" alt="image"></p><ul><li><strong>数据处理</strong></li></ul><p>提供包括分组过滤、分组转发、优先级、复用、加密、压缩和防火墙等功能<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\过滤.JPG" alt="image"></p><ul><li><strong>网络管理</strong></li></ul><p>路由器提供包括配置管理、性能管理、容错管理和流量控制管理等功能</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\管理.JPG" alt="image"></p><h5 id="4-路由器的工作原理"><a href="#4-路由器的工作原理" class="headerlink" title="4.路由器的工作原理"></a>4.路由器的工作原理</h5><ul><li><p>接收来自它连接的某个网络的数据</p></li><li><p>将数据向上传递，并且（必要时）重新组合IP数据报</p></li><li><p>检查IP头部中的目的地址，如果目的地址位于发出数据的那个网络，那么路由器就放下被认为已经达到目的地的数据，因为数据是在目的计算机所在网络上传输</p></li><li><p>如果数据要送往另一个网络，那么路由器就查询路由表，以确定数据要转发到的目的地</p></li><li><p>路由器确定哪个适配器负责接收数据后，就通过相应的软件传递数据，以便通过网络来传送数据</p></li></ul><hr><h3 id="13-初识TCP-IP的分层"><a href="#13-初识TCP-IP的分层" class="headerlink" title="[13]初识TCP/IP的分层"></a>[13]初识TCP/IP的分层</h3><p>大家可能经常使用TCP/IP协议，在进行网络配置或修改IP地址等操作的时候会用到该处，但很少有人去深入挖掘，在此我们简单的了解一下TCP/IP的分层。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\分层.JPG" alt="image"></p><h5 id="1-TCP-IP协议"><a href="#1-TCP-IP协议" class="headerlink" title="1.TCP/IP协议"></a>1.TCP/IP协议</h5><ul><li><p>Internet采用了TCP/IP协议，但这并不是一个单一的协议，我们可能知道，TCP即传输控制协议，IP为网间协议，TCP/IP我们常常描述为互联网协议集。但可能很少人知道TCP/IP也是一种分层模型。它是基于<strong>硬件层次</strong>上的四个概念性层次构成，分别是<strong>网络接口层（数据链路层）、IP层（网络层）、传输层、应用层</strong>。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\介质.JPG" alt="image"></p></li><li><p>网络接口层:也称数据链路层，这是TCP/IP最底层。功能:负责接收IP数据报并发送至选定的网络。</p></li><li><p>IP层:<strong>IP层处理机器之间的通信</strong>。功能:它接收来自传输层的请求，<strong>将带有目的地址的分组发送出去</strong>。将分组封装到数据报中，填入数据报头，使用路由算法以决定是直接将数据报传送至目的主机还是传给路由器，然后把数据报送至相应的网络接口来传送。</p></li><li>传输层:是提供应用层之间的通信，即端到端的通信。功能:<strong>管理信息流，提供可靠的传输服务</strong>，以确保数据无差错的地按序到达。</li></ul><h5 id="2-TCP-IP模型的分界线"><a href="#2-TCP-IP模型的分界线" class="headerlink" title="2.TCP/IP模型的分界线"></a>2.TCP/IP模型的分界线</h5><p>协议地址分界线:以区分高层和低层的寻址，<strong>高层寻址使用IP地址</strong>，<strong>低层寻址使用物理地址</strong>。应用程序IP层之上的协议软件只使用IP地址，而网络接口层处理物理地址。</p><ul><li>操作系统分界线:以区分系统与应用程序。<strong>在传输层和应用层之间。</strong></li><li><h5 id="3-复用与分解"><a href="#3-复用与分解" class="headerlink" title="3.复用与分解"></a>3.复用与分解</h5></li></ul><p>发送报文时，发送方在报文中加和了报文类型、选用协议等附加信息。所有的报文以帧的形式在网络中复用传送，形成一个分组流。在接收方收到分组时，参考附加信息对接收到的分组进行分解。</p><hr><p>参考网址：<a href="https://jingyan.baidu.com/season/38734" target="_blank" rel="noopener">https://jingyan.baidu.com/season/38734</a></p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2017/09/26/Network/">http://jaymo666.github.io/2017/09/26/Network/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[1]ping命令&lt;/li&gt;
&lt;li&gt;[2]路由器和交换机的差异&lt;/li&gt;
&lt;li&gt;[3]路由器的基本设置&lt;/li&gt;
&lt;li&gt;[4]netsh网络配置命令&lt;/li&gt;
&lt;li&gt;[5]安装失败（未签名）&lt;/li&gt;
&lt;li&gt;[6]管理用户网络应用&lt;/li&gt;
&lt;li&gt;[7]映射网络驱动器&lt;/li&gt;
&lt;li&gt;[8]网络适配器的原理&lt;/li&gt;
&lt;li&gt;[9]交换机的分类&lt;/li&gt;
&lt;li&gt;[10]交换机的功能&lt;/li&gt;
&lt;li&gt;[11]交换机的接口种类&lt;/li&gt;
&lt;li&gt;[12]路由器的工作原理&lt;/li&gt;
&lt;li&gt;[13]初识TCP/IP的分层&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="网络" scheme="http://jaymo666.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://jaymo666.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>网络管理员必备</title>
    <link href="http://jaymo666.github.io/2017/09/26/Network(1)/"/>
    <id>http://jaymo666.github.io/2017/09/26/Network(1)/</id>
    <published>2017-09-26T06:49:47.000Z</published>
    <updated>2017-12-03T12:42:18.345Z</updated>
    
    <content type="html"><![CDATA[<p>本文包括：</p><ul><li>[1]ping命令</li><li>[2]路由器和交换机的差异</li><li>[3]路由器的基本设置</li><li>[4]netsh网络配置命令</li><li>[5]安装失败（未签名）</li><li>[6]管理用户网络应用</li><li>[7]映射网络驱动器</li><li>[8]网络适配器的原理</li><li>[9]交换机的分类</li><li>[10]交换机的功能</li><li>[11]交换机的接口种类</li><li>[12]路由器的工作原理</li><li>[13]初识TCP/IP的分层<a id="more"></a></li></ul><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=447960871&auto=0&height=66"></iframe><h2 id="网络管理员必备"><a href="#网络管理员必备" class="headerlink" title="网络管理员必备"></a>网络管理员必备</h2><h3 id="1-ping命令"><a href="#1-ping命令" class="headerlink" title="[1]ping命令"></a>[1]ping命令</h3><p>“ping”命令是windows系统最长用的命令之一，是通过对一个网址<strong>发送测试数据包</strong>，看对方网址是否有响应并统计响应时间，以此<strong>测试网络</strong>，同时可以很好地帮助我们<strong>分析和判定网络故障</strong>。</p><p>方式：“ping IP地址/域名”</p><ol><li>输入“ping IP地址”回车，我们可以看到本机跟这台网络设备的连接状态，如下图所示是连接正常的。<br>例如：百度首页ip地址：119.75.217.109</li></ol><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\ping百度.JPG" alt="image"></p><p>2.还可以“ping 域名”,例如:ping baidu.com</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\pingbaiducom.JPG" alt="image"></p><p>3.如果“ping”后出现下图所示界面，说明本机跟这台网络设备的网络连接是不通的</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\pingcuo.JPG" alt="image"></p><p>4.键入“ping”直接回车我们还可以看到ping命令加其他参数的使用方法</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\ping.JPG" alt="image"></p><p>5.比如，我们使用“ping IP地址 -t”命令，可以持续的ping指定的主机，如果没有手动停止，ping命令会一直持续下去，我们可以通过“Ctrl+C”停止命令。其他参数的使用方法用户可以自己体验</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\pingt.JPG" alt="image"></p><hr><h3 id="2-路由器和交换机的差异"><a href="#2-路由器和交换机的差异" class="headerlink" title="[2]路由器和交换机的差异"></a>[2]路由器和交换机的差异</h3><h5 id="1-工作层次不同"><a href="#1-工作层次不同" class="headerlink" title="1. 工作层次不同:"></a>1. 工作层次不同:</h5><p>交换机工作在七层模型的第二层（即数据链路层）；而路由器工作在第三层（即网络层）。交换机由于工作在第二层，它的工作原理比较简单，而路由器在第三层，可以得到更多的协议信息，也可以做出更加智能的转发或映射。</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\77.JPG" alt="image"></p><blockquote><p>网络层（第三层）：能提供介质访问和链路管理等功能<br>数据链路层（第二层）：具有寻址和路由选择等功能</p></blockquote><h5 id="2-数据转发依据的对象不同"><a href="#2-数据转发依据的对象不同" class="headerlink" title="2. 数据转发依据的对象不同"></a>2. 数据转发依据的对象不同</h5><p>交换机是利用网络设备的<strong>物理地址（即MAC地址）</strong>来确定转发数据的目的地址；路由器是利用网络设备的<strong>IP地址</strong>来确定转发数据的目的地址。其中<strong>物理地址</strong>是设备本身自带的，由设备的网卡生产厂商分配，已经固化到网卡硬件中，<strong>不可修改</strong>；而<strong>IP地址是在系统软件中分配的，可以修改</strong>。</p><p>通过命令“ipconfig/all”，可以查看本机的物理地址和IP地址。如下图所示，就是我的计算机的网卡信息。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\ip.JPG" alt="image"></p><h5 id="3-路由器可以分割广播域，而交换机不能"><a href="#3-路由器可以分割广播域，而交换机不能" class="headerlink" title="3.路由器可以分割广播域，而交换机不能"></a>3.路由器可以分割广播域，而交换机不能</h5><p><strong>交换机只可以分割冲突域</strong>，不可以分割广播域，<strong>而路由器可以分割广播域</strong>。简单的来说，在同一个交换机下连接的设备，IP都在同一个网段，是属于同一个广播域的，如果不在同一网段，则无法进行通信；而路由器可以分配不同的广播域（即不同的网段），而这些不同网段的设备可以不穿过路由而进行相互通信。</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\广播域.JPG" alt="image"></p><blockquote><p>目前，虽然三层或者第三层以上交换机具有VLAN功能，也可以分割广播域，但是各个广播域之间是不可以相互通信的，他们之前如果要通信交流还是需要路由器的支持。</p></blockquote><h5 id="4-路由器有防火墙服务，而交换机没有"><a href="#4-路由器有防火墙服务，而交换机没有" class="headerlink" title="4.路由器有防火墙服务，而交换机没有"></a>4.路由器有防火墙服务，而交换机没有</h5><p>路由器设置的防火墙是运行在网络层的，通过设置特定的规定，允许或者限制传输的数据通过，或者过滤IP封包，禁止不符合规定的封包通过。而交换机不具备防火墙功能，如果只是通过交换机接通外部网络，相当于闭上眼、光着屁股在大街上跑，很不安全！</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\防火墙.JPG" alt="image"><br><strong>注意：数据安全很重要，路由器、交换机的使用都要慎重！注意保密保护工作！</strong></p><h3 id="3-路由器的基本设置"><a href="#3-路由器的基本设置" class="headerlink" title="[3]路由器的基本设置"></a>[3]路由器的基本设置</h3><p> 要实现多台计算机同时上网，主要设置的地方就是路由器，下面以企业中总路由器下的一个无线路由为大家介绍一下路由器的基本设置过程。</p><p> 1.通过<strong>浏览器登录路由器</strong>。如果是<strong>新路由器</strong>，可以查看路由后面贴<strong>标签</strong>出的默认IP和登录账号、密码；如果是正常<strong>使用中的路由器</strong>，登录地址可以查看计算机的网关，如果登录密码修改过，请咨询管理员。</p><blockquote><p> 电脑和路由器相连：一种是通过网线连接，一种是通过无线连接。</p></blockquote><p>电脑和路由器之间通过网线连接的话，你要在路由器上找到<strong>LAN口和WAN口</strong>。这里讲一下，WAN口全称Wide Area Network（广域网），LAN口全称Wide Area Network（局域网）。一般的路由有很多LAN口，一个WAN口。<strong>WAN口插主网线，LAN插电脑与路由连接的网线</strong>。这样电脑就和路由器连接了。</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\LAN.JPG" alt="image"></p><blockquote><p>电脑连接上了路由器，就可以在浏览器上输入路由器的地址进入路由器的设置界面了</p></blockquote><p>2.<strong>WAN口设置</strong>，“<strong>基本设置</strong>”中的“<strong>快速设置</strong>”，（1）如果外网地址没有固定IP，则类型选择动态；（2）如果外网地址有固定IP或者上层还有路由则将分配IP设置到wan口，如下图所示。</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\快速配置.JPG" alt="image"><br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\外网.JPG" alt="image"></p><p>3.<strong>LAN口的设置</strong>，“基本设置”中的“内网设置”，设置IP地址（即内网中网络设备的网关比如设置成192.168.1.1，如果上层有路由是192.168.1.1，则次路由器可以设置成其他网段192.168.x.1）、子网掩码。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\内网.JPG" alt="image"><br><strong><br>4.“DHCP服务器”的设置</strong>，如果让用户<strong>自动获取IP地址</strong>使用，需要使用DHCP服务器，可以限制用户自动获取IP地址的范围，如下图的“起始IP地址”和“结束IP地址”（可以在上网行为管理的IP地址组中看到）。</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\上网行为.JPG" alt="image"><br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\DHCP.JPG" alt="image"></p><p>5.<strong>无线的“基本设置”</strong>，要启用无线的话，勾选启用开关，并为无线网络设置一个名称，设置无线模式为“11b/g/n混合模式”，来兼容三种无线协议：802.11b、802.11g、802.11n。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\无线.JPG" alt="image"></p><p>6.<strong>无线的“安全设置”</strong>，如果需要做MAC地址绑定的安全管控，需要勾选mac地址“启用”：设置“允许”，将允许上网的计算机mac地址添加到mac地址列表；设置“禁用”，将不允许上网的计算机mac地址添加到mac地址列表。设置加密类型为常用的“WPA2-PSK”，并设置密码<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\无线安全.JPG" alt="image"></p><p>7.<strong>“上网行为管理”设置</strong>，设置允许或者不允许上网的时间段；如果需要管理QQ等常用聊天软件，可以在聊天软件高级设置里进行启用，将允许使用QQ等聊天软件的账号添加到例外列表。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\上班.JPG" alt="image"><br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\QQ.JPG" alt="image"></p><p>8.网络安全中设置内外网的“攻击防御”和“MAC地址绑定”（勾选“禁止未绑定IP/MAC的主机通过”，前面已经说过，不再赘述）<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\外网防御.JPG" alt="image"><br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\IPMAC.JPG" alt="image"></p><p>9.<strong>“端口映射”和“域名转发”</strong>，大多在系统集成中会用到，特别是监控设备想要远程访问，需要将设备的通讯端口等进行路由转发，此处需要注意的是，如果跨多层路由的话，每一层路由都是需要转发的。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\端口.JPG" alt="image"><br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\域名.JPG" alt="image"></p><p>10.修改路由器的登录密码。</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\修改密码.JPG" alt="image"></p><hr><h3 id="4-netsh网络配置命令"><a href="#4-netsh网络配置命令" class="headerlink" title="[4]netsh网络配置命令"></a>[4]netsh网络配置命令</h3><p>netsh是Network Shell的缩写，是windows为我们提供的功能强大的网络配置命令行工具。下面用几个常用的“netsh interface ip show”小命令介绍netsh的用法。</p><p>1.<strong>netsh interface ip show address</strong>:显示本机IP地址配置，包括以太网的ip和本地回环ip地址，以太网ip地址就是我们常说的为本机网卡分配的一个地址，这个容易理解；本地还有ip地址，是一种叫做本地回环接口虚接口，在windows系统中都会采用如下图所示的127.0.0.1这个地址，用以提高网络的健壮性。</p><p>2.如果在上一步的基础上想要显示更多信息，可以用命令：<strong>netsh interface ip show config</strong>。</p><p>3.netsh interface ip show dns:显示本机使用的DNS服务器，同样包括以太网和本地回环接口的DNS信息。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\DNS.JPG" alt="image"></p><p>4.<strong>netsh interface ip show ipnet</strong>:显示本IP地址所在的网络到媒体的映射，我们同时可以看到映射类型和所用接口等信息。</p><p>5.<strong>netsh interface ip show wins</strong>:如果设置了wins服务器，可以用此命令查看wins服务器的地址。</p><p>6.还有一个我喜欢用的不属于“<strong>netsh interface ip</strong>”这一系列的小命令，<strong>netsh firewall show state</strong>:<strong>查看本机防火墙的状态</strong>，每当我们公司某一台办公电脑在连接公司的某个系统连接不上的时候，我会用以查看防火墙状态，我们可以看到启用或禁用的功能模块，以及启用情况。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\防火.JPG" alt="image"></p><hr><h3 id="5-安装失败（未签名）"><a href="#5-安装失败（未签名）" class="headerlink" title="[5]安装失败（未签名）"></a>[5]安装失败（未签名）</h3><p>在我们安装驱动的时候，特别是用驱动精灵等驱动软件安装的时候，会出现“安装失败（未签名）”的情况，如何解决？</p><p>方法/步骤</p><p>1.单击开始菜单里的“运行”，或者通过“windows键+R”打开“运行”，在输入框中输入“sigverif”回车<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\签名.JPG" alt="image"></p><p>2.在打开的文件签名验证里点击“高级”按钮</p><p>3.如下图所示找到下载的驱动（如果未解压，需要先解压），然后点击“确认”按钮</p><p>4.切换到“正在记录”选项，选中如下图所示选项，点击“确定”按钮</p><p>5.回到第二步时候的界面，点击“开始”按钮，我们可以看到下图所示列表界面，点击“关闭”即可</p><p>6.从设备管理器安装驱动，右键单击我的电脑（xp）/计算机（win7）/这台电脑（win8），点击“管理”，在“计算机管理”中右侧边栏中单击“设备管理器”，找到我们要安装驱动的这个硬件，右键单击，选择“更新驱动程序”</p><p>7.勾选“从列表或指定位置安装”，点击“下一步”按钮</p><p>8.选择驱动程序解压后的文件夹，点击“下一步”按钮</p><p>9.到安装界面，用户需等待，知道出现安装成功的界面，点击“完成”按钮即可</p><p>10.返回到设备管理器，我们可以看到，此驱动已经安装完成</p><hr><h3 id="6-管理用户网络应用"><a href="#6-管理用户网络应用" class="headerlink" title="[6]管理用户网络应用"></a>[6]管理用户网络应用</h3><p>现在各种网络应用程序纷繁复杂，而p2p软件又是其中最为流行的一种，而且提供了多样化得登陆方式，在此，我们以最常用的QQ为例。</p><p>我们大家都知道，QQ本身支持UDP、HTTP和HTTPS三种登陆方式，而且可以使用代理，意思是说，只要你允许了HTTP协议，QQ就可以登陆。</p><p>现在我们以封锁QQ为例，介绍一下，如何利用路由级的网络防火墙管理用户网络应用。</p><h5 id="1-QQ登陆原理"><a href="#1-QQ登陆原理" class="headerlink" title="1.QQ登陆原理"></a>1.QQ登陆原理</h5><ol><li><p>QQ登录登陆的过程，由向服务器群的8000端口发送UDP数据包，从服务器群的回复中选择一个最快的作为登陆服务器。</p></li><li><p>如果没有服务器回复UDP数据包，则使用TCP80/443端口来进行连接。</p></li><li><p>QQ服务器：</p></li></ol><ul><li>UDP8000端口类18个</li><li>TCPHTTP连接服务器5个</li><li>会员VIP服务器使用HTTPS443连接</li></ul><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\QQ原理.JPG" alt="image"></p><h5 id="2-如何封锁"><a href="#2-如何封锁" class="headerlink" title="2.如何封锁"></a>2.如何封锁</h5><p>1.上面我们知道，QQ可以使用HTTP直接连接，一般不能封锁HTTP协议，所以最好的办法就是封锁它的服务器IP地址，但是QQ还可以使用代理登陆，这种情况我们就得在路由级防火墙中的HTTP检查机制中设置禁止QQ的HTTP连接。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\QQ代理.JPG" alt="image"><br>2.首先，配置用户访问规则，使用计算机集定义目的网络。也就是做好禁止内部客户访问QQ服务器的访问策略。</p><p>3.其次，配置HTTP策略，理由路由器的HTTP深层检查机制，禁止QQ使用HTTP代理。在允许ＱＱ使用HTTP代理的策略上点击右键，选中“配置HTTP”</p><p>4.在弹出的“为规则配置HTTP策略”对话框中，点击“签名”，然后点击“添加”，在弹出的“签名”对话框中，输入名称为“QQ”，指定签名搜索条件为在“请求URL”中搜索“tencent.com”，找到则阻止这个连接</p><p>5.最后，在防火墙策略选项中，点击“应用”来保存修改和更新防火墙策略，此时，QQ已经不能通过代理服务器登录了</p><hr><h3 id="7-映射网络驱动器"><a href="#7-映射网络驱动器" class="headerlink" title="[7]映射网络驱动器"></a>[7]映射网络驱动器</h3><p>映射网络驱动器” 的意思是将局域网中的某个目录（一般是共享的文件夹之类的）映射成本地驱动器号，就是说把网络上其他机器的共享的文件夹映射自己机器上的一个磁盘，这样可以提高访问时间，相当于一个打开共享的快捷方式。</p><p>1.首先，找到这个共享文件夹，我们可以在网络里找到这台设备，或者打开开始菜单的“运行”，输入：“\这台设备的IP地址”，比如此例中的“\192.168.1.52”<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\本机IP.JPG" alt="image"></p><p>2.在打开的共享界面，找到并右键单击要映射驱动器的文件件，选择“映射网络驱动器”<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\映射.JPG" alt="image"></p><p>3.在映射驱动器的界面，选择好驱动器盘符，点击“完成”即可完成设置</p><p>4.打开资源管理器，我们可以看到，已经有了该驱动器，日常使用过程中直接点击打开即可</p><hr><h3 id="8-网络适配器的原理"><a href="#8-网络适配器的原理" class="headerlink" title="[8]网络适配器的原理"></a>[8]网络适配器的原理</h3><p>网络适配器，也就是我们说的网卡，有些维修人员也叫网络接口卡，是计算机和网络电缆之间的物理接口，下面我们根据网络适配器需要完成的任务介绍一下它的工作原理。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\网卡.JPG" alt="image"></p><p>1.为在<strong>计算机使用的数据</strong>（<strong>并行数据</strong>）和<strong>电缆上传输的电信号</strong>（<strong>串行数据</strong>）之间提供数据转换的功能。比如我们用的一个共享打印机，计算机直接连接打印机用的是并行数据，而如果我们通过网络连接别人共享的打印机，就是通过串行数据转换为并行数据来实现。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\打印.JPG" alt="image"><br>2.判断从电缆接收的数据是否为传输给该计算机的数据。</p><p>3.在计算机和电缆之间控制数据流，每块网卡都有一个唯一的标识，我们一般叫做MAC地址，大部分网卡的MAC地址烧录在卡上的ROM芯片中，MAC地址有6段组成，通常表示为12个16进制数。<br>我们可以通过命令提示符查看本机网卡的信息，操作步骤：1、单击开始菜单里的“运行”，在输入框中输入“cmd”，然后回车。2、在命令提示符界面输入“ipconfig /all”命令，回车，我们可以看到以下信息。<br>如图所示的是本机无线网卡的信息，其中前3字节“A6-17-31”表示厂商代码，有IEEE负责分配；后3个字节“30-49-E2”表示网卡序号，由网卡厂商负责。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\MAC地址.JPG" alt="image"></p><hr><h3 id="9-交换机的分类"><a href="#9-交换机的分类" class="headerlink" title="[9]交换机的分类"></a>[9]交换机的分类</h3><p>交换机是网络连接的基础，有了交换机，就可以实现更多电脑的共享上网</p><p>1.广义上来讲，交换机分为两种：<strong>广域交换机</strong>和<strong>局域网交换机</strong>。广域网交换机主要用于电信领域，提供通信用的基础平台，我们平常接触很少；而局域网交换机是我们日常使用最多的，主要应用于日常的局域网络，连接计算机和网络打印机的终端设备<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\交换机.JPG" alt="image"></p><p>2.从传输介质和传输速度上可以分为以太网交换机、快速以太网交换机、千兆以太网交换机、FDDI交换机、ATM交换机和令牌交换机等</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\交换机速率.JPG" alt="image"></p><p>3.从规模应用上可以分为企业级、部门级和工作组交换机<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\交换机企业.JPG" alt="image"></p><h3 id="10-交换机的功能"><a href="#10-交换机的功能" class="headerlink" title="[10]交换机的功能"></a>[10]交换机的功能</h3><h5 id="1-交换机功能"><a href="#1-交换机功能" class="headerlink" title="1.交换机功能"></a>1.交换机功能</h5><p>学习功能，局域网内交换机会了解跟每一个插口相连接的<strong>MAC地址</strong>，并将地址同<strong>相应的端口</strong>映射起来存放在<strong>交换机缓存中的MAC地址表中</strong></p><h5 id="2-转发-过滤功能"><a href="#2-转发-过滤功能" class="headerlink" title="2.转发/过滤功能"></a>2.转发/过滤功能</h5><p>当一个数据帧的目的地址在MAC地址表中有映射时，它被转发到连接目的节点的端口而不是所有端口（如该数据帧为广播/组播帧则转发至所有端口）<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\MAC地址表.JPG" alt="image"></p><h5 id="3-消除回路功能"><a href="#3-消除回路功能" class="headerlink" title="3.消除回路功能"></a>3.消除回路功能</h5><p>当交换机包括一个冗余回路时，以太网交换机通过<strong>生成树协议</strong>避免回路的产生，同时允许存在<strong>后背路径</strong><br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\回路.JPG" alt="image"></p><h5 id="4-兼容功能"><a href="#4-兼容功能" class="headerlink" title="4.兼容功能"></a>4.兼容功能</h5><p>交换机除了能连接两种同类型的网络之外，还可以在不同类型的网路（如以太网和快速以太网）之间起到互联作用。而且现在的交换机没有很严格的类型之分，百兆交换机一般也会加两个千兆口或光纤接入口<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\消除.JPG" alt="image"></p><hr><h3 id="11-交换机的接口种"><a href="#11-交换机的接口种" class="headerlink" title="[11]交换机的接口种"></a>[11]交换机的接口种</h3><h5 id="1-双绞线RJ-45接口-水晶头"><a href="#1-双绞线RJ-45接口-水晶头" class="headerlink" title="1.双绞线RJ-45接口-水晶头"></a>1.双绞线RJ-45接口-水晶头</h5><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\水晶头.JPG" alt="image"></p><h5 id="2-光纤接口"><a href="#2-光纤接口" class="headerlink" title="2.光纤接口"></a>2.光纤接口</h5><p>光纤需要熔接到带插头的尾纤，常见的尾纤插头有SC。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\SC.JPG" alt="image"></p><hr><h3 id="12-路由器的工作原理"><a href="#12-路由器的工作原理" class="headerlink" title="[12]路由器的工作原理"></a>[12]路由器的工作原理</h3><p>路由器，大家都很熟悉了，办公室或者家里凡有两台以上的电脑需要上网的一般都安装了路由器，只有安装了路由器才能实现多台电脑同时上网。我们就了解下路由器的配置原理。</p><h5 id="1-路由器的概念"><a href="#1-路由器的概念" class="headerlink" title="1.路由器的概念"></a>1.路由器的概念</h5><p>1.所谓“路由”，就是把数据从一个地方传送到另一个地方的行为和动作，路由器就是执行这个动作的机器，英文名Router</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\路由.JPG" alt="image"></p><p>2.路由器能将不同网络或网段之间的数据信息进行“翻译”，以使他们能够相互“读”懂对方的数据，从而构建更大的网络。</p><h5 id="2-路由器的典型功能"><a href="#2-路由器的典型功能" class="headerlink" title="2.路由器的典型功能"></a>2.路由器的典型功能</h5><ul><li><strong>数据通道功能</strong></li></ul><p>包括转发决定、背板转发以及输出链路调度等，一般由特定的硬件来完成</p><ul><li><strong>控制功能</strong></li></ul><p>一般用软件来实现，包括与相邻路由器之间的信息交换、系统配置、系统管理等</p><h5 id="3-路由器的主要功能"><a href="#3-路由器的主要功能" class="headerlink" title="3.路由器的主要功能"></a>3.路由器的主要功能</h5><ul><li><strong>网络互连</strong></li></ul><p>路由器支持各种局域网和广域网接口，主要用于互连局域网和广域网，实现不同网络互相通信<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\互连.JPG" alt="image"></p><ul><li><strong>数据处理</strong></li></ul><p>提供包括分组过滤、分组转发、优先级、复用、加密、压缩和防火墙等功能<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\过滤.JPG" alt="image"></p><ul><li><strong>网络管理</strong></li></ul><p>路由器提供包括配置管理、性能管理、容错管理和流量控制管理等功能</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\管理.JPG" alt="image"></p><h5 id="4-路由器的工作原理"><a href="#4-路由器的工作原理" class="headerlink" title="4.路由器的工作原理"></a>4.路由器的工作原理</h5><ul><li><p>接收来自它连接的某个网络的数据</p></li><li><p>将数据向上传递，并且（必要时）重新组合IP数据报</p></li><li><p>检查IP头部中的目的地址，如果目的地址位于发出数据的那个网络，那么路由器就放下被认为已经达到目的地的数据，因为数据是在目的计算机所在网络上传输</p></li><li><p>如果数据要送往另一个网络，那么路由器就查询路由表，以确定数据要转发到的目的地</p></li><li><p>路由器确定哪个适配器负责接收数据后，就通过相应的软件传递数据，以便通过网络来传送数据</p></li></ul><hr><h3 id="13-初识TCP-IP的分层"><a href="#13-初识TCP-IP的分层" class="headerlink" title="[13]初识TCP/IP的分层"></a>[13]初识TCP/IP的分层</h3><p>大家可能经常使用TCP/IP协议，在进行网络配置或修改IP地址等操作的时候会用到该处，但很少有人去深入挖掘，在此我们简单的了解一下TCP/IP的分层。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\分层.JPG" alt="image"></p><h5 id="1-TCP-IP协议"><a href="#1-TCP-IP协议" class="headerlink" title="1.TCP/IP协议"></a>1.TCP/IP协议</h5><ul><li><p>Internet采用了TCP/IP协议，但这并不是一个单一的协议，我们可能知道，TCP即传输控制协议，IP为网间协议，TCP/IP我们常常描述为互联网协议集。但可能很少人知道TCP/IP也是一种分层模型。它是基于<strong>硬件层次</strong>上的四个概念性层次构成，分别是<strong>网络接口层（数据链路层）、IP层（网络层）、传输层、应用层</strong>。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\介质.JPG" alt="image"></p></li><li><p>网络接口层:也称数据链路层，这是TCP/IP最底层。功能:负责接收IP数据报并发送至选定的网络。</p></li><li><p>IP层:<strong>IP层处理机器之间的通信</strong>。功能:它接收来自传输层的请求，<strong>将带有目的地址的分组发送出去</strong>。将分组封装到数据报中，填入数据报头，使用路由算法以决定是直接将数据报传送至目的主机还是传给路由器，然后把数据报送至相应的网络接口来传送。</p></li><li>传输层:是提供应用层之间的通信，即端到端的通信。功能:<strong>管理信息流，提供可靠的传输服务</strong>，以确保数据无差错的地按序到达。</li></ul><h5 id="2-TCP-IP模型的分界线"><a href="#2-TCP-IP模型的分界线" class="headerlink" title="2.TCP/IP模型的分界线"></a>2.TCP/IP模型的分界线</h5><p>协议地址分界线:以区分高层和低层的寻址，<strong>高层寻址使用IP地址</strong>，<strong>低层寻址使用物理地址</strong>。应用程序IP层之上的协议软件只使用IP地址，而网络接口层处理物理地址。</p><ul><li>操作系统分界线:以区分系统与应用程序。<strong>在传输层和应用层之间。</strong></li><li><h5 id="3-复用与分解"><a href="#3-复用与分解" class="headerlink" title="3.复用与分解"></a>3.复用与分解</h5></li></ul><p>发送报文时，发送方在报文中加和了报文类型、选用协议等附加信息。所有的报文以帧的形式在网络中复用传送，形成一个分组流。在接收方收到分组时，参考附加信息对接收到的分组进行分解。</p><hr><p>参考网址：<a href="https://jingyan.baidu.com/season/38734" target="_blank" rel="noopener">https://jingyan.baidu.com/season/38734</a></p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2017/09/26/Network(1)/">http://jaymo666.github.io/2017/09/26/Network(1)/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[1]ping命令&lt;/li&gt;
&lt;li&gt;[2]路由器和交换机的差异&lt;/li&gt;
&lt;li&gt;[3]路由器的基本设置&lt;/li&gt;
&lt;li&gt;[4]netsh网络配置命令&lt;/li&gt;
&lt;li&gt;[5]安装失败（未签名）&lt;/li&gt;
&lt;li&gt;[6]管理用户网络应用&lt;/li&gt;
&lt;li&gt;[7]映射网络驱动器&lt;/li&gt;
&lt;li&gt;[8]网络适配器的原理&lt;/li&gt;
&lt;li&gt;[9]交换机的分类&lt;/li&gt;
&lt;li&gt;[10]交换机的功能&lt;/li&gt;
&lt;li&gt;[11]交换机的接口种类&lt;/li&gt;
&lt;li&gt;[12]路由器的工作原理&lt;/li&gt;
&lt;li&gt;[13]初识TCP/IP的分层&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="网络" scheme="http://jaymo666.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://jaymo666.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Threejs中的各种光源（Threejs第三章）</title>
    <link href="http://jaymo666.github.io/2017/09/22/Threejs3(1)/"/>
    <id>http://jaymo666.github.io/2017/09/22/Threejs3(1)/</id>
    <published>2017-09-22T06:34:47.000Z</published>
    <updated>2017-12-03T12:41:51.103Z</updated>
    
    <content type="html"><![CDATA[<p>本章你将了解<br>1、怎么使用光源<br>2、以及各种光源的区别，这些区别会通过实例对比来给大家讲清楚。这种对比方式应该是讲解最好的思路。<a id="more"></a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=447960871&auto=0&height=66"></iframe><h4 id="2-6-环境光和方向光"><a href="#2-6-环境光和方向光" class="headerlink" title="2.6 环境光和方向光"></a>2.6 环境光和方向光</h4><p>接下来，我们来看看多种光源同时存在于场景之中，对物体颜色的影响。</p><p>当环境光和方向光同时存在的时候，会出现怎么样的情况呢？可以把这种情况想成两种光源同时作用于物体，它产生的情况，和每种光源分别作用于物体，然后将两者的结果相加，是一样的效果。<br>例如：<br><code>0x00FF00 + 0xFF0000 = 0xFFFF00</code>，oxFFFF00 就是黄色。</p><h4 id="2-7-点光源"><a href="#2-7-点光源" class="headerlink" title="2.7 点光源"></a>2.7 点光源</h4><p>点光源是理想化为质点的向四面八方发出光线的光源。点光源是抽象化了的物理概念，为了把物理问题的研究简单化。就像平时说的光滑平面，质点，无空气阻力一样，点光源在现实中也是不存在的，指的是从一个点向周围空间均匀发光的光源。</p><p>点光源的特点是发光部分为一个小圆面，近似一个点</p><p>下面的例子介绍了怎么使用点光源：</p><pre><code>light = new THREE.PointLight(0xFF0000);light.position.set(0, 0,50);scene.add(light);</code></pre><p>效果如下图：</p><p><img src="http://www.hewebgl.com/attached/image/20130517/20130517101725_304.png" alt=""></p><h4 id="2-8-混合光源"><a href="#2-8-混合光源" class="headerlink" title="2.8 混合光源"></a>2.8 混合光源</h4><p>将方向光和点光源混合使用。</p><p>效果如图所示：<br><img src="http://www.hewebgl.com/attached/image/20130517/20130517102228_302.png" alt=""></p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2017/09/22/Threejs3(1)/">http://jaymo666.github.io/2017/09/22/Threejs3(1)/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章你将了解&lt;br&gt;1、怎么使用光源&lt;br&gt;2、以及各种光源的区别，这些区别会通过实例对比来给大家讲清楚。这种对比方式应该是讲解最好的思路。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://jaymo666.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="http://jaymo666.github.io/tags/js/"/>
    
      <category term="初级" scheme="http://jaymo666.github.io/tags/%E5%88%9D%E7%BA%A7/"/>
    
      <category term="3D" scheme="http://jaymo666.github.io/tags/3D/"/>
    
      <category term="threejs" scheme="http://jaymo666.github.io/tags/threejs/"/>
    
  </entry>
  
  <entry>
    <title>Threejs中的各种光源（Threejs第三章）</title>
    <link href="http://jaymo666.github.io/2017/09/22/Threejs3/"/>
    <id>http://jaymo666.github.io/2017/09/22/Threejs3/</id>
    <published>2017-09-22T06:34:47.000Z</published>
    <updated>2017-12-03T11:29:43.126Z</updated>
    
    <content type="html"><![CDATA[<p>本章你将了解<br>1、怎么使用光源<br>2、以及各种光源的区别，这些区别会通过实例对比来给大家讲清楚。这种对比方式应该是讲解最好的思路。<a id="more"></a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=447960871&auto=0&height=66"></iframe><h4 id="2-6-环境光和方向光"><a href="#2-6-环境光和方向光" class="headerlink" title="2.6 环境光和方向光"></a>2.6 环境光和方向光</h4><p>接下来，我们来看看多种光源同时存在于场景之中，对物体颜色的影响。</p><p>当环境光和方向光同时存在的时候，会出现怎么样的情况呢？可以把这种情况想成两种光源同时作用于物体，它产生的情况，和每种光源分别作用于物体，然后将两者的结果相加，是一样的效果。<br>例如：<br><code>0x00FF00 + 0xFF0000 = 0xFFFF00</code>，oxFFFF00 就是黄色。</p><h4 id="2-7-点光源"><a href="#2-7-点光源" class="headerlink" title="2.7 点光源"></a>2.7 点光源</h4><p>点光源是理想化为质点的向四面八方发出光线的光源。点光源是抽象化了的物理概念，为了把物理问题的研究简单化。就像平时说的光滑平面，质点，无空气阻力一样，点光源在现实中也是不存在的，指的是从一个点向周围空间均匀发光的光源。</p><p>点光源的特点是发光部分为一个小圆面，近似一个点</p><p>下面的例子介绍了怎么使用点光源：</p><pre><code>light = new THREE.PointLight(0xFF0000);light.position.set(0, 0,50);scene.add(light);</code></pre><p>效果如下图：</p><p><img src="http://www.hewebgl.com/attached/image/20130517/20130517101725_304.png" alt=""></p><h4 id="2-8-混合光源"><a href="#2-8-混合光源" class="headerlink" title="2.8 混合光源"></a>2.8 混合光源</h4><p>将方向光和点光源混合使用。</p><p>效果如图所示：<br><img src="http://www.hewebgl.com/attached/image/20130517/20130517102228_302.png" alt=""></p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2017/09/22/Threejs3/">http://jaymo666.github.io/2017/09/22/Threejs3/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章你将了解&lt;br&gt;1、怎么使用光源&lt;br&gt;2、以及各种光源的区别，这些区别会通过实例对比来给大家讲清楚。这种对比方式应该是讲解最好的思路。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://jaymo666.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="http://jaymo666.github.io/tags/js/"/>
    
      <category term="初级" scheme="http://jaymo666.github.io/tags/%E5%88%9D%E7%BA%A7/"/>
    
      <category term="3D" scheme="http://jaymo666.github.io/tags/3D/"/>
    
      <category term="threejs" scheme="http://jaymo666.github.io/tags/threejs/"/>
    
  </entry>
  
  <entry>
    <title>Threejs中的各种光源（Threejs第二章）</title>
    <link href="http://jaymo666.github.io/2017/09/22/Threejs2/"/>
    <id>http://jaymo666.github.io/2017/09/22/Threejs2/</id>
    <published>2017-09-22T05:34:47.000Z</published>
    <updated>2017-12-03T11:29:52.275Z</updated>
    
    <content type="html"><![CDATA[<p>作为3D技术的发展趋势，浏览器端3D技术越来越被一些技术公司重视。由此，Threejs非常注重3D渲染效果的真实性，对渲染真实性来说，使用光源是比不可少的技巧。Threejs，在光源方面提供了多种光源供选择。<a id="more"></a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=447960871&auto=0&height=66"></iframe><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="1-Threejs中的各种光源"><a href="#1-Threejs中的各种光源" class="headerlink" title="1.Threejs中的各种光源"></a>1.Threejs中的各种光源</h3><h4 id="1-1光源基类"><a href="#1-1光源基类" class="headerlink" title="1.1光源基类"></a>1.1光源基类</h4><p>在Threejs中，光源用Light表示，它是所有光源的基类。它的构造函数是：<br><strong>THREE.Light ( hex )</strong></p><p>它有一个参数hex，接受一个16进制的颜色值。例如要定义一种红色的光源，我们可以这样来定义：</p><pre><code>Var redLight = new THREE.Light(0xFF0000);</code></pre><h4 id="1-2由基类派生出来的其他种类光源"><a href="#1-2由基类派生出来的其他种类光源" class="headerlink" title="1.2由基类派生出来的其他种类光源"></a>1.2由基类派生出来的其他种类光源</h4><p><strong>THREE.Light只是其他所有光源的基类</strong>，要让光源除了具有颜色的特性之外，我们需要其他光源。看看，下面的类图，是目前光源的继承结构。<br><img src="http://www.hewebgl.com/attached/image/20130515/20130515163339_12.jpg" alt=""></p><p>环境光是经过多次反射而来的光称为环境光，无法确定其最初的方向。环境光是一种无处不在的光。环境光源放出的光线被认为来自任何方向。因此，当你仅为场景指定环境光时，所有的物体无论法向量如何，都将表现为同样的明暗程度。 （这是因为，反射光可以从各个方向进入您的眼睛）</p><h5 id="1-2-1-环境光"><a href="#1-2-1-环境光" class="headerlink" title="1.2.1 环境光"></a>1.2.1 <strong>环境光</strong></h5><p>用<code>THREE.AmbientLight</code>来表示，它的构造函数如下所示：<br><strong>    THREE.AmbientLight( hex )</strong></p><p>它仍然接受一个16进制的颜色值，作为光源的颜色。环境光将照射场景中的所有物体，让物体显示出某种颜色。环境光的使用例子如下所示：</p><pre><code>var light = new THREE.AmbientLight( 0xff0000 );scene.add( light );</code></pre><p>只需要将光源加入场景，场景就能够通过光源渲染出好的效果来了。</p><h5 id="1-2-2点光源"><a href="#1-2-2点光源" class="headerlink" title="1.2.2点光源"></a>1.2.2<strong>点光源</strong></h5><p>由这种光源放出的光线来自同一点，且方向辐射自四面八方。例如蜡烛放出的光，萤火虫放出的光。</p><p>点光源用PointLight来表示，它的构造函数如下所示：</p><p>PointLight( color, intensity, distance )</p><p>这个类的参数稍微复杂一些，我们花点时间来解释一下：</p><ul><li><p>Color：光的颜色</p></li><li><p>Intensity：光的强度，默认是1.0,就是说是100%强度的灯光，</p></li><li><p>distance：光的距离，从光源所在的位置，经过distance这段距离之后，光的强度将从Intensity衰减为0。 默认情况下，这个值为0.0，表示光源强度不衰减。</p></li></ul><p>#####1.2.3<strong>聚光灯</strong><br>这种光源的光线从一个锥体中射出，在被照射的物体上产生聚光的效果。使用这种光源需要指定光的射出方向以及锥体的顶角α。聚光灯示例如图所示：<br><img src="http://www.hewebgl.com/attached/image/20130516/20130516165745_434.jpg" alt=""></p><p>聚光灯的构造函数是：<br><strong><br>THREE.SpotLight( hex, intensity, distance, angle, exponent )</strong></p><p>函数的参数如下所示：</p><ul><li><p>Hex：聚光灯发出的颜色，如0xFFFFFF</p></li><li><p>Intensity：光源的强度，默认是1.0，如果为0.5，则强度是一半，意思是颜色会淡一些。和上面点光源一样。</p></li><li><p>Distance：光线的强度，从最大值衰减到0，需要的距离。 默认为0，表示光不衰减，如果非0，则表示从光源的位置到Distance的距离，光都在线性衰减。到离光源距离Distance时，光源强度为0.</p></li></ul><p>Angle：聚光灯着色的角度，用弧度作为单位，这个角度是和光源的方向形成的角度。</p><p>exponent：光源模型中，衰减的一个参数，越大衰减约快。</p><h3 id="2-材质与光源的关系"><a href="#2-材质与光源的关系" class="headerlink" title="2.材质与光源的关系"></a>2.材质与光源的关系</h3><p>材质与光源有什么关系？什么是材质？</p><h4 id="2-1-材质的真相"><a href="#2-1-材质的真相" class="headerlink" title="2.1 材质的真相"></a>2.1 材质的真相</h4><blockquote><p>材质就是物体的质地。材质就是材料和质感的完美结合。</p></blockquote><p>在渲染程序中，它是表面<strong>各可视属性的结合</strong>，这些可视属性是指表面的色彩、纹理、光滑度、透明度、反射率、折射率、发光度等。正是有了这些属性，才能让我们识别三维中的模型是什么做成的，也正是有了这些属性，我们计算机三维的虚拟世界才会和真实世界一样缤纷多彩。</p><p>这就是材质的真相吗？答案是否定的。不要奇怪，我们必须仔细分析产生不同材质的原因，才能让我们更好的把握质感。那么，材质的真相到底是什么呢？仍然是光，离开光材质是无法体现的。　</p><p>首先，我们来看一些例子。这些例子是一系类的，掌握一个，我们就印下了一个脚印.</p><h5 id="2-2-脚印一：不带任何光源的物体"><a href="#2-2-脚印一：不带任何光源的物体" class="headerlink" title="2.2  脚印一：不带任何光源的物体"></a>2.2  脚印一：不带任何光源的物体</h5><p>我们首先在屏幕上画一个物体，不带任何的光源，定义物体的颜色为黑色，其值为0x000000，定义材质如下：</p><p>var material = new THREE.MeshLambertMaterial( { color:0x000000} ); // 这是兰伯特材质，材质中的一种</p><p>先看看最终的运行截图，如下所示：<br><img src="http://www.hewebgl.com/attached/image/20130515/20130515170232_15.png" alt=""></p><p>由这幅图得出结论，当没有任何光源的时候，最终的颜色将是材质的颜色。但是这个结论目前来说，并没有依据。<br><strong><br>结论：当没有任何光源的时候，最终的颜色将是黑色，无论材质是什么颜色。</strong></p><h4 id="2-3-脚印二：兰伯特材质与光源"><a href="#2-3-脚印二：兰伯特材质与光源" class="headerlink" title="2.3 脚印二：兰伯特材质与光源"></a>2.3 脚印二：兰伯特材质与光源</h4><p>最常见的材质之一就是Lambert材质，这是在灰暗的或不光滑的表面产生<strong>均匀散射</strong>而形成的材质类型。比如一张纸就是Lambert表面。 首先它粗糙不均匀，不会产生镜面效果。我们在阅读书籍的时候，没有发现书上一处亮，一处不亮吧，它非常均匀，这就是兰伯特材质。</p><p>有的朋友觉得纸不粗糙啊，你怎么说它粗糙吗？人的肉眼是不好分辨出来，它粗不粗糙的。</p><p>Lambert材质表面会在所有方向上均匀地散射灯光，这就会使颜色看上去比较均匀。想想一张纸，无论什么颜色，是不是纸的各个部分颜色都比较均匀呢。</p><p>Lambert材质的图例如下所示：<br><img src="http://www.hewebgl.com/attached/image/20130515/20130515170358_794.jpg" alt=""><br>Lambert材质会受环境光的影响，呈现环境光的颜色，与材质本身颜色关系不大。</p><p>我们现在来做一个例子</p><p>例子：红色环境光照射下的长方体，它用的是淡红色(0x880000)的兰伯特材质。效果如下图：</p><p><img src="http://www.hewebgl.com/attached/image/20130515/20130515170419_688.png" alt=""></p><p>最后整个效果中，长方体呈现的是红色。我们要说的是，长方体显示红色，是因为<strong>长方体反射了红色的光</strong>，长方体本身的颜色是0x880000，光源的颜色是0xFF0000，红色的光照在物体上，物体反射了红色的光，所以呈现红色。<br><strong><br>我们现在一直在使用环境光，从环境光的构造函数来看，它只有颜色，其位置对场景中的物体并没有影响，因为他是均匀的反射到物体的表面的。</strong></p><h4 id="2-4-脚印三：环境光对物体的影响"><a href="#2-4-脚印三：环境光对物体的影响" class="headerlink" title="2.4 脚印三：环境光对物体的影响"></a>2.4 脚印三：环境光对物体的影响</h4><p>环境光就是在场景中无处不在的光，它对物体的影响是均匀的，也就是无论你从物体的那个角度观察，物体的颜色都是一样的，这就是伟大的环境光。</p><p><strong>你可以把环境光放在任何一个位置，它的光线是不会衰减的，是永恒的某个强度的一种光源。</strong></p><h4 id="2-5脚印四：方向光（平行光）"><a href="#2-5脚印四：方向光（平行光）" class="headerlink" title="2.5脚印四：方向光（平行光）"></a>2.5脚印四：方向光（平行光）</h4><p>平行光又称为方向光（Directional Light），是一组没有衰减的平行的光线，类似太阳光的效果。</p><p>方向光的模型如图：<br><img src="http://www.hewebgl.com/attached/image/20130516/20130516171702_524.jpg" alt=""><br>方向光的构造函数如下所示：</p><p><strong>THREE.DirectionalLight = function ( hex, intensity )</strong></p><p>其参数如下：</p><ul><li><p>Hex：关系的颜色，用16进制表示</p></li><li><p>Intensity：光线的强度，默认为1。因为RGB的三个值均在0~255之间，不能反映出光照的强度变化，光照越强，物体表面就更明亮。它的取值范围是0到1。如果为0，表示光线基本没什么作用，那么物体就会显示为黑色。呆会你可以尝试来更改这个参数，看看实际的效果</p></li></ul><p>我们来看一个方向光的例子：</p><p>一个红色的方向光，把它放在（0,0,1）的位置，密度为1，照射在一个长方体中。效果如下图所示：</p><p><img src="http://www.hewebgl.com/attached/image/20130516/20130516172030_538.png" alt=""></p><p>平行光有一个方向，它的方向是如何决定的呢？<br>方向由<strong>位置</strong>和<strong>原点</strong>（0,0,0）来决定，方向光只与方向有关，与离物体的远近无关。分别将平行光放到（0,0,100），（0,0,50），（0,0,25），（0,0,1），渲染的结果还是红色和黑色，见下图，<strong>颜色的深浅不与离物体的距离相关。</strong></p><p>但是它与方向有关，如果，我们灯光的位置改为（1,0,0.5），那么效果如图所示：<br><img src="http://www.hewebgl.com/attached/image/20130516/20130516172333_384.png" alt=""></p><p>未完待续</p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2017/09/22/Threejs2/">http://jaymo666.github.io/2017/09/22/Threejs2/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为3D技术的发展趋势，浏览器端3D技术越来越被一些技术公司重视。由此，Threejs非常注重3D渲染效果的真实性，对渲染真实性来说，使用光源是比不可少的技巧。Threejs，在光源方面提供了多种光源供选择。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://jaymo666.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="http://jaymo666.github.io/tags/js/"/>
    
      <category term="初级" scheme="http://jaymo666.github.io/tags/%E5%88%9D%E7%BA%A7/"/>
    
      <category term="3D" scheme="http://jaymo666.github.io/tags/3D/"/>
    
      <category term="threejs" scheme="http://jaymo666.github.io/tags/threejs/"/>
    
  </entry>
  
  <entry>
    <title>Threejs中的各种光源（Threejs第二章）</title>
    <link href="http://jaymo666.github.io/2017/09/22/Threejs2(1)/"/>
    <id>http://jaymo666.github.io/2017/09/22/Threejs2(1)/</id>
    <published>2017-09-22T05:34:47.000Z</published>
    <updated>2017-12-03T12:41:54.229Z</updated>
    
    <content type="html"><![CDATA[<p>作为3D技术的发展趋势，浏览器端3D技术越来越被一些技术公司重视。由此，Threejs非常注重3D渲染效果的真实性，对渲染真实性来说，使用光源是比不可少的技巧。Threejs，在光源方面提供了多种光源供选择。<a id="more"></a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=447960871&auto=0&height=66"></iframe><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="1-Threejs中的各种光源"><a href="#1-Threejs中的各种光源" class="headerlink" title="1.Threejs中的各种光源"></a>1.Threejs中的各种光源</h3><h4 id="1-1光源基类"><a href="#1-1光源基类" class="headerlink" title="1.1光源基类"></a>1.1光源基类</h4><p>在Threejs中，光源用Light表示，它是所有光源的基类。它的构造函数是：<br><strong>THREE.Light ( hex )</strong></p><p>它有一个参数hex，接受一个16进制的颜色值。例如要定义一种红色的光源，我们可以这样来定义：</p><pre><code>Var redLight = new THREE.Light(0xFF0000);</code></pre><h4 id="1-2由基类派生出来的其他种类光源"><a href="#1-2由基类派生出来的其他种类光源" class="headerlink" title="1.2由基类派生出来的其他种类光源"></a>1.2由基类派生出来的其他种类光源</h4><p><strong>THREE.Light只是其他所有光源的基类</strong>，要让光源除了具有颜色的特性之外，我们需要其他光源。看看，下面的类图，是目前光源的继承结构。<br><img src="http://www.hewebgl.com/attached/image/20130515/20130515163339_12.jpg" alt=""></p><p>环境光是经过多次反射而来的光称为环境光，无法确定其最初的方向。环境光是一种无处不在的光。环境光源放出的光线被认为来自任何方向。因此，当你仅为场景指定环境光时，所有的物体无论法向量如何，都将表现为同样的明暗程度。 （这是因为，反射光可以从各个方向进入您的眼睛）</p><h5 id="1-2-1-环境光"><a href="#1-2-1-环境光" class="headerlink" title="1.2.1 环境光"></a>1.2.1 <strong>环境光</strong></h5><p>用<code>THREE.AmbientLight</code>来表示，它的构造函数如下所示：<br><strong>    THREE.AmbientLight( hex )</strong></p><p>它仍然接受一个16进制的颜色值，作为光源的颜色。环境光将照射场景中的所有物体，让物体显示出某种颜色。环境光的使用例子如下所示：</p><pre><code>var light = new THREE.AmbientLight( 0xff0000 );scene.add( light );</code></pre><p>只需要将光源加入场景，场景就能够通过光源渲染出好的效果来了。</p><h5 id="1-2-2点光源"><a href="#1-2-2点光源" class="headerlink" title="1.2.2点光源"></a>1.2.2<strong>点光源</strong></h5><p>由这种光源放出的光线来自同一点，且方向辐射自四面八方。例如蜡烛放出的光，萤火虫放出的光。</p><p>点光源用PointLight来表示，它的构造函数如下所示：</p><p>PointLight( color, intensity, distance )</p><p>这个类的参数稍微复杂一些，我们花点时间来解释一下：</p><ul><li><p>Color：光的颜色</p></li><li><p>Intensity：光的强度，默认是1.0,就是说是100%强度的灯光，</p></li><li><p>distance：光的距离，从光源所在的位置，经过distance这段距离之后，光的强度将从Intensity衰减为0。 默认情况下，这个值为0.0，表示光源强度不衰减。</p></li></ul><p>#####1.2.3<strong>聚光灯</strong><br>这种光源的光线从一个锥体中射出，在被照射的物体上产生聚光的效果。使用这种光源需要指定光的射出方向以及锥体的顶角α。聚光灯示例如图所示：<br><img src="http://www.hewebgl.com/attached/image/20130516/20130516165745_434.jpg" alt=""></p><p>聚光灯的构造函数是：<br><strong><br>THREE.SpotLight( hex, intensity, distance, angle, exponent )</strong></p><p>函数的参数如下所示：</p><ul><li><p>Hex：聚光灯发出的颜色，如0xFFFFFF</p></li><li><p>Intensity：光源的强度，默认是1.0，如果为0.5，则强度是一半，意思是颜色会淡一些。和上面点光源一样。</p></li><li><p>Distance：光线的强度，从最大值衰减到0，需要的距离。 默认为0，表示光不衰减，如果非0，则表示从光源的位置到Distance的距离，光都在线性衰减。到离光源距离Distance时，光源强度为0.</p></li></ul><p>Angle：聚光灯着色的角度，用弧度作为单位，这个角度是和光源的方向形成的角度。</p><p>exponent：光源模型中，衰减的一个参数，越大衰减约快。</p><h3 id="2-材质与光源的关系"><a href="#2-材质与光源的关系" class="headerlink" title="2.材质与光源的关系"></a>2.材质与光源的关系</h3><p>材质与光源有什么关系？什么是材质？</p><h4 id="2-1-材质的真相"><a href="#2-1-材质的真相" class="headerlink" title="2.1 材质的真相"></a>2.1 材质的真相</h4><blockquote><p>材质就是物体的质地。材质就是材料和质感的完美结合。</p></blockquote><p>在渲染程序中，它是表面<strong>各可视属性的结合</strong>，这些可视属性是指表面的色彩、纹理、光滑度、透明度、反射率、折射率、发光度等。正是有了这些属性，才能让我们识别三维中的模型是什么做成的，也正是有了这些属性，我们计算机三维的虚拟世界才会和真实世界一样缤纷多彩。</p><p>这就是材质的真相吗？答案是否定的。不要奇怪，我们必须仔细分析产生不同材质的原因，才能让我们更好的把握质感。那么，材质的真相到底是什么呢？仍然是光，离开光材质是无法体现的。　</p><p>首先，我们来看一些例子。这些例子是一系类的，掌握一个，我们就印下了一个脚印.</p><h5 id="2-2-脚印一：不带任何光源的物体"><a href="#2-2-脚印一：不带任何光源的物体" class="headerlink" title="2.2  脚印一：不带任何光源的物体"></a>2.2  脚印一：不带任何光源的物体</h5><p>我们首先在屏幕上画一个物体，不带任何的光源，定义物体的颜色为黑色，其值为0x000000，定义材质如下：</p><p>var material = new THREE.MeshLambertMaterial( { color:0x000000} ); // 这是兰伯特材质，材质中的一种</p><p>先看看最终的运行截图，如下所示：<br><img src="http://www.hewebgl.com/attached/image/20130515/20130515170232_15.png" alt=""></p><p>由这幅图得出结论，当没有任何光源的时候，最终的颜色将是材质的颜色。但是这个结论目前来说，并没有依据。<br><strong><br>结论：当没有任何光源的时候，最终的颜色将是黑色，无论材质是什么颜色。</strong></p><h4 id="2-3-脚印二：兰伯特材质与光源"><a href="#2-3-脚印二：兰伯特材质与光源" class="headerlink" title="2.3 脚印二：兰伯特材质与光源"></a>2.3 脚印二：兰伯特材质与光源</h4><p>最常见的材质之一就是Lambert材质，这是在灰暗的或不光滑的表面产生<strong>均匀散射</strong>而形成的材质类型。比如一张纸就是Lambert表面。 首先它粗糙不均匀，不会产生镜面效果。我们在阅读书籍的时候，没有发现书上一处亮，一处不亮吧，它非常均匀，这就是兰伯特材质。</p><p>有的朋友觉得纸不粗糙啊，你怎么说它粗糙吗？人的肉眼是不好分辨出来，它粗不粗糙的。</p><p>Lambert材质表面会在所有方向上均匀地散射灯光，这就会使颜色看上去比较均匀。想想一张纸，无论什么颜色，是不是纸的各个部分颜色都比较均匀呢。</p><p>Lambert材质的图例如下所示：<br><img src="http://www.hewebgl.com/attached/image/20130515/20130515170358_794.jpg" alt=""><br>Lambert材质会受环境光的影响，呈现环境光的颜色，与材质本身颜色关系不大。</p><p>我们现在来做一个例子</p><p>例子：红色环境光照射下的长方体，它用的是淡红色(0x880000)的兰伯特材质。效果如下图：</p><p><img src="http://www.hewebgl.com/attached/image/20130515/20130515170419_688.png" alt=""></p><p>最后整个效果中，长方体呈现的是红色。我们要说的是，长方体显示红色，是因为<strong>长方体反射了红色的光</strong>，长方体本身的颜色是0x880000，光源的颜色是0xFF0000，红色的光照在物体上，物体反射了红色的光，所以呈现红色。<br><strong><br>我们现在一直在使用环境光，从环境光的构造函数来看，它只有颜色，其位置对场景中的物体并没有影响，因为他是均匀的反射到物体的表面的。</strong></p><h4 id="2-4-脚印三：环境光对物体的影响"><a href="#2-4-脚印三：环境光对物体的影响" class="headerlink" title="2.4 脚印三：环境光对物体的影响"></a>2.4 脚印三：环境光对物体的影响</h4><p>环境光就是在场景中无处不在的光，它对物体的影响是均匀的，也就是无论你从物体的那个角度观察，物体的颜色都是一样的，这就是伟大的环境光。</p><p><strong>你可以把环境光放在任何一个位置，它的光线是不会衰减的，是永恒的某个强度的一种光源。</strong></p><h4 id="2-5脚印四：方向光（平行光）"><a href="#2-5脚印四：方向光（平行光）" class="headerlink" title="2.5脚印四：方向光（平行光）"></a>2.5脚印四：方向光（平行光）</h4><p>平行光又称为方向光（Directional Light），是一组没有衰减的平行的光线，类似太阳光的效果。</p><p>方向光的模型如图：<br><img src="http://www.hewebgl.com/attached/image/20130516/20130516171702_524.jpg" alt=""><br>方向光的构造函数如下所示：</p><p><strong>THREE.DirectionalLight = function ( hex, intensity )</strong></p><p>其参数如下：</p><ul><li><p>Hex：关系的颜色，用16进制表示</p></li><li><p>Intensity：光线的强度，默认为1。因为RGB的三个值均在0~255之间，不能反映出光照的强度变化，光照越强，物体表面就更明亮。它的取值范围是0到1。如果为0，表示光线基本没什么作用，那么物体就会显示为黑色。呆会你可以尝试来更改这个参数，看看实际的效果</p></li></ul><p>我们来看一个方向光的例子：</p><p>一个红色的方向光，把它放在（0,0,1）的位置，密度为1，照射在一个长方体中。效果如下图所示：</p><p><img src="http://www.hewebgl.com/attached/image/20130516/20130516172030_538.png" alt=""></p><p>平行光有一个方向，它的方向是如何决定的呢？<br>方向由<strong>位置</strong>和<strong>原点</strong>（0,0,0）来决定，方向光只与方向有关，与离物体的远近无关。分别将平行光放到（0,0,100），（0,0,50），（0,0,25），（0,0,1），渲染的结果还是红色和黑色，见下图，<strong>颜色的深浅不与离物体的距离相关。</strong></p><p>但是它与方向有关，如果，我们灯光的位置改为（1,0,0.5），那么效果如图所示：<br><img src="http://www.hewebgl.com/attached/image/20130516/20130516172333_384.png" alt=""></p><p>未完待续</p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2017/09/22/Threejs2(1)/">http://jaymo666.github.io/2017/09/22/Threejs2(1)/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为3D技术的发展趋势，浏览器端3D技术越来越被一些技术公司重视。由此，Threejs非常注重3D渲染效果的真实性，对渲染真实性来说，使用光源是比不可少的技巧。Threejs，在光源方面提供了多种光源供选择。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://jaymo666.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="http://jaymo666.github.io/tags/js/"/>
    
      <category term="初级" scheme="http://jaymo666.github.io/tags/%E5%88%9D%E7%BA%A7/"/>
    
      <category term="3D" scheme="http://jaymo666.github.io/tags/3D/"/>
    
      <category term="threejs" scheme="http://jaymo666.github.io/tags/threejs/"/>
    
  </entry>
  
  <entry>
    <title>Vue进阶之路——深入响应式原理</title>
    <link href="http://jaymo666.github.io/2017/09/21/Vue%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86(1)/"/>
    <id>http://jaymo666.github.io/2017/09/21/Vue进阶之路——深入响应式原理(1)/</id>
    <published>2017-09-21T15:54:46.000Z</published>
    <updated>2017-12-03T12:41:44.165Z</updated>
    
    <content type="html"><![CDATA[<p>Vue 最显著的特性之一便是不太引人注意的响应式系统<br><a id="more"></a></p><blockquote><p>Vue 最显著的特性之一便是不太引人注意的<strong>响应式系统</strong>(reactivity system)。<strong>模型层</strong>(model)只是普通 JavaScript <strong>对象</strong>，修改它则更新<strong>视图</strong>(view)。</p></blockquote><h2 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h2><p>把一个普通 <code>JavaScript</code> 对象传给 Vue 实例的 <code>data</code>选项，Vue 将<strong>遍历</strong>此对象所有的属性，并使用 <code>Object.defineProperty</code> 把这些属性全部转为<code>getter</code>/<code>setter</code>。</p><p>每个组件实例都有相应的 <code>watcher</code> 实例对象，它会在组件渲染的过程中<strong>把属性记录为依赖</strong>，之后当依赖项的 <code>setter</code>被调用时，会通知 <code>watcher</code> 重新计算，从而致使它关联的组件得以更新。</p><p><img src="https://cn.vuejs.org/images/data.png" alt=""></p><h2 id="变化检测问题"><a href="#变化检测问题" class="headerlink" title="变化检测问题"></a>变化检测问题</h2><p>受现代 JavaScript 的限制,<strong>Vue 不能检测到对象属性的添加或删除</strong>。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以<strong>属性必须在 data 对象上存在</strong>才能让 Vue 转换它，这样才能让它是响应的。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data:&#123;</span><br><span class="line">  a:1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// `vm.a` 是响应的</span><br><span class="line">vm.b = 2</span><br><span class="line">// `vm.b` 是非响应的</span><br></pre></td></tr></table></figure></p><p>Vue 不允许在已经创建的实例上动态添加新的<strong>根级响应式属性</strong>(root-level reactive property)。然而它可以使用 <code>Vue.set(object, key, value)</code>方法将响应属性添加到嵌套的对象上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(vm.someObject, &apos;b&apos;, 2)</span><br></pre></td></tr></table></figure><p>您还可以使用<code>vm.$set</code>实例方法，这也是全局 Vue.set 方法的<code>别名</code>：</p><p>有时你想<strong>向已有对象上添加一些属性</strong>，例如使用 <code>Object.assign()</code>或 <code>_.extend()</code> 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以<strong>创建一个新的对象</strong>，让它包含原对象的属性和新的属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`</span><br><span class="line">this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;)</span><br></pre></td></tr></table></figure></p><h2 id="声明响应式属性"><a href="#声明响应式属性" class="headerlink" title="声明响应式属性"></a>声明响应式属性</h2><p>由于 Vue 不允许动态添加根级响应式属性，所以你必须<strong>在初始化实例前声明根级响应式属性，哪怕只是一个空值:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    // 声明 message 为一个空值字符串</span><br><span class="line">    message: &apos;&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: &apos;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">// 之后设置 `message` </span><br><span class="line">vm.message = &apos;Hello!&apos;</span><br></pre></td></tr></table></figure><p>如果你在 data 选项中<strong>未声明 message</strong>，Vue 将<strong>警告</strong>你渲染函数在试图访问的属性不存在。</p><p><code>data</code>对象就像组件状态的概要，提前声明所有的响应式属性，可以让组件代码<strong>在以后重新阅读</strong>或<strong>其他开发人员阅读时更易于被理解</strong>。</p><h2 id="异步更新队列"><a href="#异步更新队列" class="headerlink" title="异步更新队列"></a>异步更新队列</h2><p>可能你还没有注意到，Vue 异步执行 DOM 更新。只要观察到<strong>数据变化</strong>，Vue 将<strong>开启一个队列</strong>，并缓冲在同一事件循环中发生的所有数据改变。<strong>如果同一个 watcher 被多次触发，只会一次推入到队列中。</strong>这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际（已去重的）工作。Vue 在内部尝试对异步队列使用原生的 <code>Promise.then</code> 和<code>MutationObserver</code>，如果执行环境不支持，会采用 <code>setTimeout(fn, 0)</code> 代替。</p><p>例如，当你设置 <code>vm.someData = &#39;new value&#39;</code>，<strong>该组件不会立即重新渲染。</strong>当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 <code>Vue.nextTick(callback)</code>。这样回调函数在 DOM 更新完成后就会调用。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;123&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.message = &apos;new message&apos; // 更改数据</span><br><span class="line">vm.$el.textContent === &apos;new message&apos; // false</span><br><span class="line">Vue.nextTick(function () &#123;</span><br><span class="line">  vm.$el.textContent === &apos;new message&apos; // true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在组件内使用 <code>vm.$nextTick()</code> 实例方法特别方便，因为它不需要全局<code>Vue</code>，并且回调函数中的 <code>this</code> 将自动绑定到当前的 Vue 实例上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;example&apos;, &#123;</span><br><span class="line">  template: &apos;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&apos;,</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &apos;没有更新&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateMessage: function () &#123;</span><br><span class="line">      this.message = &apos;更新完成&apos;</span><br><span class="line">      console.log(this.$el.textContent) // =&gt; &apos;没有更新&apos;</span><br><span class="line">      this.$nextTick(function () &#123;</span><br><span class="line">        console.log(this.$el.textContent) // =&gt; &apos;更新完成&apos;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><!--PC和WAP自适应版--><p><div id="SOHUCS" sid="SourceID"></div> </p><p><script type="text/javascript"><br>(function(){<br>var appid = ‘cysmzRdbl’;<br>var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;<br>var width = window.innerWidth || document.documentElement.clientWidth;<br>if (width &lt; 960) {<br>window.document.write(‘<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '">&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“<a href="https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})})">https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})})</a>; } })(); </script></p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2017/09/21/Vue进阶之路——深入响应式原理(1)/">http://jaymo666.github.io/2017/09/21/Vue进阶之路——深入响应式原理(1)/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue 最显著的特性之一便是不太引人注意的响应式系统&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://jaymo666.github.io/categories/JS/"/>
    
    
      <category term="js" scheme="http://jaymo666.github.io/tags/js/"/>
    
      <category term="初级" scheme="http://jaymo666.github.io/tags/%E5%88%9D%E7%BA%A7/"/>
    
      <category term="Vue" scheme="http://jaymo666.github.io/tags/Vue/"/>
    
      <category term="框架" scheme="http://jaymo666.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
</feed>
