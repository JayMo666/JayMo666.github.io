<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JayMo个人网站</title>
  
  <subtitle>打造属于自己的超能力</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jaymo666.github.io/"/>
  <updated>2018-04-03T07:26:53.047Z</updated>
  <id>http://jaymo666.github.io/</id>
  
  <author>
    <name>莫爵贵(JayMo)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js十大排序算法详解</title>
    <link href="http://jaymo666.github.io/2018/04/03/js%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://jaymo666.github.io/2018/04/03/js十大排序算法详解/</id>
    <published>2018-04-03T07:20:16.000Z</published>
    <updated>2018-04-03T07:26:53.047Z</updated>
    
    <content type="html"><![CDATA[<p>用js实现的十大经典算法，有简单的例子+原理图+动图<a id="more"></a></p><h2 id="十大经典算法导图"><a href="#十大经典算法导图" class="headerlink" title="十大经典算法导图"></a>十大经典算法导图</h2><p><img src="http://ww1.sinaimg.cn/large/006ij6n6gy1fpzdft7jc8j30qu0gc42s.jpg" alt=""></p><p>图片名词解释：</p><ul><li>n: 数据规模</li><li>k:“桶”的个数</li><li>In-place: 占用常数内存，不占用额外内存</li><li>Out-place: 占用额外内存</li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="原始人冒泡排序"><a href="#原始人冒泡排序" class="headerlink" title="原始人冒泡排序"></a>原始人冒泡排序</h3><p>原理图：<br><img src="http://ww1.sinaimg.cn/large/006ij6n6gy1fpzcm4hx1lj30c3086my6.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//从小到大,先排好最大的（最后面的）</span><br><span class="line">        function bubbleSort(arr) &#123;</span><br><span class="line">            var len = arr.length;</span><br><span class="line">            for (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">                for (var j = 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">                    if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                        var temp = arr[j + 1];</span><br><span class="line">                        arr[j + 1] = arr[j];</span><br><span class="line">                        arr[j] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            return arr;</span><br><span class="line">        &#125;</span><br><span class="line">        var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];</span><br><span class="line">        console.log(bubbleSort(arr))</span><br></pre></td></tr></table></figure><h3 id="进化版冒泡排序"><a href="#进化版冒泡排序" class="headerlink" title="进化版冒泡排序"></a>进化版冒泡排序</h3><blockquote><p>对上述冒泡排序的一种优化， 优化思路：当一次遍历前后数组不产生变化时，说明该数组已经有序，结束排序。</p></blockquote><p>原理图：<br><img src="http://ww1.sinaimg.cn/large/006ij6n6gy1fpzcnft0mcj30c3086410.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 如果在某次的排序中没有出现交换的情况，</span><br><span class="line">        // 那么说明在无序的元素现在已经是有序了，就可以直接返回了。</span><br><span class="line">        function bubbleSort2(array) &#123;</span><br><span class="line">            console.time(&apos;2.改进后冒泡排序耗时&apos;);</span><br><span class="line">            var len = array.length,</span><br><span class="line">                i, j, tmp, exchange;</span><br><span class="line"></span><br><span class="line">            for (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">                exchange = 0;</span><br><span class="line">                for (var j = 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">                    if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                        var temp = arr[j + 1];</span><br><span class="line">                        arr[j + 1] = arr[j];</span><br><span class="line">                        arr[j] = temp;</span><br><span class="line">                        exchange = 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!exchange) return arr;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            console.timeEnd(&apos;2.改进后冒泡排序耗时&apos;);</span><br><span class="line">            return arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];</span><br><span class="line">        console.log(bubbleSort2(arr));</span><br></pre></td></tr></table></figure><p>冒泡动图：<br><img src="https://images2015.cnblogs.com/blog/1093977/201707/1093977-20170718164306583-1106893271.gif" alt=""></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote><p>实现思路跟冒泡排序差不多， 可以说是冒泡排序的衍生版本；</p></blockquote><p>原理图：</p><p><img src="http://ww1.sinaimg.cn/large/006ij6n6gy1fpzco4jxq5j30af07gdgc.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function selectionSort(arr) &#123;</span><br><span class="line">　　var len = arr.length;</span><br><span class="line">　　var minIndex, temp;</span><br><span class="line">　　console.time(&apos;选择排序耗时&apos;);</span><br><span class="line">　　for (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">　　　　minIndex = i;</span><br><span class="line">　　　　for (var j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">　　　　　　if (arr[j] &lt; arr[minIndex]) &#123; //寻找最小的数</span><br><span class="line">　　　　　　　　minIndex = j; //将最小数的索引保存</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　temp = arr[i];</span><br><span class="line">　　　　arr[i] = arr[minIndex];</span><br><span class="line">　　　　arr[minIndex] = temp;</span><br><span class="line">　　&#125;</span><br><span class="line">　　console.timeEnd(&apos;选择排序耗时&apos;);</span><br><span class="line">　　return arr;</span><br><span class="line">&#125;</span><br><span class="line">var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];</span><br><span class="line">console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]；</span><br></pre></td></tr></table></figure><p>选择排序动图：</p><p><img src="https://images2015.cnblogs.com/blog/1093977/201707/1093977-20170718165159083-345710938.gif" alt=""></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote><p>最普通的排序算法， 从数组下标1开始每增1项排序一次，越往后遍历次数越多；</p></blockquote><blockquote><p>打个比方就类比水浒传一百单八将的排名吧，每个好汉来了不知道自己排老几，怎么办，那就和已经排过级别的人比较，然后找到其对应的位置，单八将宋万、杜迁先上的梁山，先默认杜迁第一来的也是单八将最厉害的，然后宋万来了，一比较宋万厉害，那宋万排第一，杜迁排第二，接下来朱贵来了，朱贵没他们两个厉害，那就排第三，再后来林冲来了，林冲比他们三个都厉害，那林冲排第一，宋万第二，杜迁第三，朱贵第四，依次类推。梁山排名其实就是典型的插入排序。</p></blockquote><p>原理图：</p><p><img src="https://images0.cnblogs.com/blog2015/687225/201508/231533515818732.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function insertionSort(array) &#123;</span><br><span class="line">　　console.time(&apos;插入排序耗时：&apos;);</span><br><span class="line">　　for (var i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">　　　　var key = array[i];//key是要插入的元素</span><br><span class="line">　　　　var j = i - 1;</span><br><span class="line">　　　　while ( array[j] &gt; key) &#123;</span><br><span class="line">　　　　　　array[j + 1] = array[j];</span><br><span class="line">　　　　　    j--;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　array[j + 1] = key;</span><br><span class="line">　　&#125;</span><br><span class="line">　　console.timeEnd(&apos;插入排序耗时：&apos;);</span><br><span class="line">　　return array;</span><br><span class="line">&#125;</span><br><span class="line">var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];</span><br><span class="line">console.log(insertionSort(arr));</span><br></pre></td></tr></table></figure><h2 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h2><blockquote><p>插入排序的一种优化实现， 通过二分法减少遍历时间。</p></blockquote><p>原理图：<br><img src="https://images0.cnblogs.com/blog2015/687225/201508/231534358169080.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function binaryInsertionSort(array) &#123;</span><br><span class="line">　　console.time(&apos;二分插入排序耗时：&apos;);</span><br><span class="line">　　for (var i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">　　　　var key = array[i], left = 0, right = i - 1;</span><br><span class="line">　　　　while (left &lt;= right) &#123;</span><br><span class="line">　　　　　　var middle = parseInt((left + right) / 2);</span><br><span class="line">　　　　　　if (key &lt; array[middle]) &#123;</span><br><span class="line">　　　　　　　　right = middle - 1;</span><br><span class="line">　　　　　　&#125; else &#123;</span><br><span class="line">　　　　　　　　left = middle + 1;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　for (var j = i - 1; j &gt;= left; j--) &#123;</span><br><span class="line">　　　　　　array[j + 1] = array[j];</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　array[left] = key;</span><br><span class="line">　　&#125;</span><br><span class="line">　　console.timeEnd(&apos;二分插入排序耗时：&apos;);</span><br><span class="line">　　return array;</span><br><span class="line">&#125;</span><br><span class="line">var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];</span><br><span class="line">console.log(binaryInsertionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50];</span><br></pre></td></tr></table></figure><p>代码解释：<br>首先外层循环没什么疑问，就是简单的遍历一遍数组，那么先看while循环，left和right两个变量可以简单的类比上面插入排序中的已排序的首末两个位置，然后选取未排序的第一个值和已排序的中间位置的值进行比较，这样的话也就是在最坏的情况下每层循环也只是计算了已排序的序列长度的一半的次数，简而言之就是在无限逼近left和right值，找到未排序第一个值应该在的位置。</p><p>还是以梁山排名为例子，在宋江没有到梁上之前，每个上梁上的人跟已经排过名的从大往小进行比较，然后找到自己的位置，在老大宋江来之后，后续人慢慢多了，然后宋老大就订了条规矩，就是每个新来的人和已排过名次的位于中间名次的好汉进行比较，胜了往前一位比较，败了往后一位比较，然后找到自己的位置。好了，while循环解释完毕，那么下面又多了一条for循环，这又是什么鬼？</p><p>不要着急，待小编与你慢慢道来，看不懂没关系，先看循环体，循环体的意思就是把前一个值给后一个，然后看循环条件是从i-1的位置从后往前依次将前一个元素的值给后一个，先不要管i-1是谁，先问 i 是谁，i 不就是未排序的第一个元素么，不就是我们拿来对已进行排序的元素么，简而言之不就是新上梁山的好汉么，那么从left值开始到 i-1 的位置依次将前一个元素的值给后一个无非就是空出 left 的位置，left 的位置不就是新上梁上好汉的位置！</p><p>二分插入排序动图：<br><img src="https://images2015.cnblogs.com/blog/1093977/201707/1093977-20170718195933005-962384786.gif" alt=""></p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一</p><p>原理：</p><blockquote><p>先将整个待排序记录序列分割成若干个子序列，在序列内分别进行直接插入排序，待整个序列基本有序时，再对全体记录进行一次直接插入排序;<br>像比赛一样，1-6一组，2-7一组，每差5为一组进行比较，之后再每差2为一组进行比较，最后就是两两比较</p></blockquote><p>原理图：<br><img src="http://ww1.sinaimg.cn/large/006ij6n6gy1fpzdqkzq4sj30dc0d1n06.jpg" alt="希尔排序"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function shellSort(arr) &#123;</span><br><span class="line">　　var len = arr.length,</span><br><span class="line">　　temp,</span><br><span class="line">　　gap = 1;</span><br><span class="line">　　console.time(&apos;希尔排序耗时:&apos;);</span><br><span class="line">　　while(gap &lt; len/5) &#123; //动态定义间隔序列</span><br><span class="line">　　　　gap =gap*5+1;</span><br><span class="line">　　&#125;</span><br><span class="line">　　for (gap; gap &gt; 0; gap = Math.floor(gap/5)) &#123;</span><br><span class="line">　　　　for (var i = gap; i &lt; len; i++) &#123;</span><br><span class="line">　　　　　　temp = arr[i];</span><br><span class="line">　　　　　　for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123;</span><br><span class="line">　　　　　　　　arr[j+gap] = arr[j];</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　　　arr[j+gap] = temp;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　console.timeEnd(&apos;希尔排序耗时:&apos;);</span><br><span class="line">　　return arr;</span><br><span class="line">&#125;</span><br><span class="line">var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];</span><br><span class="line">console.log(shellSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]；</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">       function shellSort2(a) &#123;</span><br><span class="line">    　　var n = a.length;</span><br><span class="line">        var i, j, gap;</span><br><span class="line"></span><br><span class="line">    for (gap = n / 2; gap &gt; 0; gap /= 2) //步长 </span><br><span class="line">    &#123;</span><br><span class="line">        for (i = 0; i &lt; gap; i++)        //循环每一组，直接插入排序 </span><br><span class="line">        &#123;</span><br><span class="line">            for (j = i + gap; j &lt; n; j += gap) //组内排序  </span><br><span class="line">                if (a[j] &lt; a[j - gap])  //a[j]与a[j-gap]将交换</span><br><span class="line">                &#123;</span><br><span class="line">                    var temp = a[j];</span><br><span class="line">                    var k = j - gap;</span><br><span class="line">                    while (k &gt;= 0 &amp;&amp; a[k] &gt; temp)  //</span><br><span class="line">                    &#123;</span><br><span class="line">                        a[k + gap] = a[k];  //a[j]=a[j-gap]</span><br><span class="line">                        k -= gap;  //</span><br><span class="line">                    &#125;</span><br><span class="line">                    a[k + gap] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>原理图：<br><img src="https://images0.cnblogs.com/blog2015/687225/201508/231540595036165.jpg" alt=""></p><blockquote><p>比如现在有个十万人的司令部，习大大是首长，习大大跟司令说了，把所有的人按年龄排序，司令想了，让我一个人也忙活不过来啊，这怎么办，然后就把任务下达给军长，军长下达给师长，依次类推，排长再把一个排分成两个小队，小队再分成两个小组，最后分成两个人一组或一人一组，接下来就是组员之间进行比较，完了小队与小队比较，排与排之间比较，依次类推，最后军团和军团比较，形成最后的序列。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function mergeSort(arr) &#123; //采用自上而下的递归方法</span><br><span class="line">　　var len = arr.length;</span><br><span class="line">　　if(len &lt; 2) &#123;</span><br><span class="line">　　　　return arr;</span><br><span class="line">　　&#125;</span><br><span class="line">　　var middle = Math.floor(len / 2),</span><br><span class="line">　　left = arr.slice(0, middle),</span><br><span class="line">　　right = arr.slice(middle);</span><br><span class="line">　　return merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function merge(left, right)&#123;</span><br><span class="line">　　var result = [];</span><br><span class="line">　　console.time(&apos;归并排序耗时&apos;);</span><br><span class="line">　　while (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">　　　　if (left[0] &lt;= right[0]) &#123;</span><br><span class="line">　　　　　　result.push(left.shift());</span><br><span class="line">　　　　&#125; else &#123;</span><br><span class="line">　　　　　　result.push(right.shift());</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line"> </span><br><span class="line">　　while (left.length)&#123;</span><br><span class="line">　　　　result.push(left.shift());</span><br><span class="line">　　&#125;</span><br><span class="line">　　while (right.length)&#123;</span><br><span class="line">　　　　result.push(right.shift());</span><br><span class="line">　　&#125;</span><br><span class="line">　　console.timeEnd(&apos;归并排序耗时&apos;);</span><br><span class="line">　　return result;</span><br><span class="line">&#125;</span><br><span class="line">var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];</span><br><span class="line">console.log(mergeSort(arr));</span><br></pre></td></tr></table></figure><p>并归排序动图：<br><img src="https://images2015.cnblogs.com/blog/1093977/201707/1093977-20170719101142724-1183690310.gif" alt="image"></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序在诸多算法排序中可能不是最好的， 但在JS语言实现中差不多是最快的！<br>阮一峰老师研究JS实现排序时曾只针对该种排序进行讲解：<a href="http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html" target="_blank" rel="noopener">javascript的快速排序实现</a>。</p><p>步骤：</p><ol><li>在数据集之中，选择一个元素作为”基准”（pivot）。</li><li>所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。</li><li>对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</li></ol><p>原理图：</p><p><img src="https://images0.cnblogs.com/blog2015/687225/201508/231537564105629.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var quickSort2 = function(arr) &#123;</span><br><span class="line">　　console.time(&apos;2.快速排序耗时&apos;);</span><br><span class="line">　　if (arr.length &lt;= 1) &#123; return arr; &#125;</span><br><span class="line">　　var pivotIndex = Math.floor(arr.length / 2);</span><br><span class="line">　　var pivot = arr.splice(pivotIndex, 1)[0];</span><br><span class="line">　　console.log(pivot)</span><br><span class="line">　　var left = [];</span><br><span class="line">　　var right = [];</span><br><span class="line">　　for (var i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">　　　　if (arr[i] &lt; pivot) &#123;</span><br><span class="line">　　　　　　left.push(arr[i]);</span><br><span class="line">　　　　&#125; else &#123;</span><br><span class="line">　　　　　　right.push(arr[i]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　console.timeEnd(&apos;2.快速排序耗时&apos;);</span><br><span class="line">　　return quickSort2(left).concat([pivot], quickSort2(right));</span><br><span class="line">&#125;;</span><br><span class="line">var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];</span><br><span class="line">console.log(quickSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]；</span><br></pre></td></tr></table></figure><p>快速排序动图<br><img src="https://images2015.cnblogs.com/blog/1093977/201707/1093977-20170720144911458-343191376.gif" alt="image"></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><blockquote><p>因为js模拟二叉树比较麻烦，所以堆排序的优势用js语言无法体现， 相对而言C语言的链表在实现上更能表现堆排序，堆排序或许更适合指针类的计算机语言。</p></blockquote><p>原理图：</p><p>1.调整二叉树，形成大根堆(子节点都比父节点小)。<br><img src="https://images0.cnblogs.com/blog2015/687225/201508/231539382698148.png" alt="image"><br>2.交换堆第一元素跟最后元素位置，最后元素弹出堆。然后继续回到1，调整堆。<br><img src="https://images0.cnblogs.com/blog2015/687225/201508/231539568002875.png" alt="image"><br>3.重复2， 当所有节点弹出堆后；弹出的节点值就是有序的了。<br><img src="https://images0.cnblogs.com/blog2015/687225/201508/231540164726220.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function heapSort(array) &#123;</span><br><span class="line">　　console.time(&apos;堆排序耗时&apos;);</span><br><span class="line">　　//建堆</span><br><span class="line">　　var heapSize = array.length, temp;</span><br><span class="line">　　for (var i = Math.floor(heapSize / 2) - 1; i &gt;= 0; i--) &#123;　　</span><br><span class="line">　　　　heapify(array, i, heapSize);</span><br><span class="line">　　&#125;</span><br><span class="line">　　//堆排序</span><br><span class="line">　　for (var j = heapSize - 1; j &gt;= 1; j--) &#123;</span><br><span class="line">　　　　temp = array[0];</span><br><span class="line">　　　　array[0] = array[j];</span><br><span class="line">　　　　array[j] = temp;</span><br><span class="line">　　　　console.log(array)</span><br><span class="line">　　　　heapify(array, 0, --heapSize);</span><br><span class="line">　　&#125;</span><br><span class="line">　　console.timeEnd(&apos;堆排序耗时&apos;);</span><br><span class="line">　　return array;</span><br><span class="line">&#125;</span><br><span class="line">function heapify(arr, x, len) &#123;</span><br><span class="line">　　var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;</span><br><span class="line">　　if (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class="line">　　　　largest = l;</span><br><span class="line">　　&#125;</span><br><span class="line">　　if (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class="line">　　　　largest = r;</span><br><span class="line">　　&#125;</span><br><span class="line">　　if (largest != x) &#123;</span><br><span class="line">　　　　temp = arr[x];</span><br><span class="line">　　　　arr[x] = arr[largest];</span><br><span class="line">　　　　arr[largest] = temp;</span><br><span class="line">　　　　console.log(arr)</span><br><span class="line">　　　　heapify(arr, largest, len);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line">var arr=[91,60,96,13,35,65,46,65,10,30,20,31,77,81,22];</span><br><span class="line">console.log(heapSort(arr));//[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96]；</span><br></pre></td></tr></table></figure><p>这种算法有两个难点，一是建堆，而是堆排序。首先明白什么是堆，堆其实可以这么理解，类似金字塔，一层有一个元素，两层有两个元素，三层有四个元素，每层从数组中取元素，从左到右的顺序放到堆相应的位置上，也就是说每一层元素个数为2n-1 ；（n 代表行数），这就完成了建堆。</p><p>那么想，堆排序中最后一位不就是2n-m（n代表总行数，m代表差多少位不到完成堆的位数），那该元素的父级是谁，2n-1-m/2，2n-1-m/2是谁？拿总位数除以2就知道了，没错就是数组的中间值，这也是编者为什么从中间值入手的原因了。</p><p>而对于 l = 2<em>x +1 与 r = 2</em>x+2 ，不正是每个父级元素对应的子堆么，每一层的堆排序都能够把本层的最大值剔除出来，这样当所有 层循环结束之后，序列也就完成了。</p><p>这一点小编觉得和归并排序有点类似，都是细分到最小单元，从最小单元比较，但是同归并排序有两大点不同，一是堆排序并不像归并那么无序，只是一味的平分数组，而堆排序则是按原始序列排出金字塔式的结构，把最大值一层层往上冒，冒到金字塔最顶端的时候把它踢出来，这样达到排序的效果。<br>堆排序动图：<img src="https://images2015.cnblogs.com/blog/1093977/201707/1093977-20170720162940240-260464315.gif" alt="image"></p><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function countingSort(array) &#123;</span><br><span class="line">　　var len = array.length,</span><br><span class="line">　　B = [],</span><br><span class="line">　　C = [],</span><br><span class="line">　　min = max = array[0];</span><br><span class="line">　　console.time(&apos;计数排序耗时&apos;);</span><br><span class="line">　　for (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">　　　　min = min &lt;= array[i] ? min : array[i];</span><br><span class="line">　　　　max = max &gt;= array[i] ? max : array[i];</span><br><span class="line">　　　　C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1;</span><br><span class="line">　　&#125;</span><br><span class="line">　　for (var k = 0; k &lt;len; k++) &#123;</span><br><span class="line">　　　　var length = C[k]；</span><br><span class="line">　　　　for(var m = 0 ;m &lt;length ; m++)&#123;</span><br><span class="line">　　　　　　B.push(k);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　console.timeEnd(&apos;计数排序耗时&apos;);</span><br><span class="line">　　return B;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2];</span><br><span class="line">console.log(countingSort(arr)); //[1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9]；</span><br></pre></td></tr></table></figure><p>C数组的下标对应的数值就是该下标出现的次数<br>动图：<br><img src="https://images2015.cnblogs.com/blog/1093977/201707/1093977-20170720184113068-1226664727.gif" alt="image"></p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><blockquote><p>一看到这个名字就会觉得奇特，几个意思，我排序还要再准备几个桶不成？还真别说，想用桶排序还得真准备几个桶，但是此桶非彼桶，这个桶是用来装数据用的。其实桶排序和计数排序还有点类似，计数排序是找一个空数组把值作为下标找到其位置，再把出现的次数给存起来，这似乎看似很完美，但也有局限性，不用小编说相信读者也能明白，既然计数是把原数组的值当做下标来看待，那么该值必然是整数，那假如出现小数怎么办？这时候就出现了一种通用版的计数排序——桶排序。</p></blockquote><p>简单例子：</p><blockquote><p>期末考试完了老师要将同学们的分数按照从高到低排序。小哼的班上只有5个同学，这5个同学分别考了5分、3分、5分、2分和8分，哎，考得真是惨不忍睹（满分是10分）。接下来将分数进行从大到小排序，排序后是8 5 5 3 2。</p></blockquote><p>首先我们需要申请一个大小为11的数组int a[11]。OK，现在你已经有了11个变量，编号从a[0]~a[10]。刚开始的时候，我们将a[0]~a[10]都初始化为0，表示这些分数还都没有人得过。例如a[0]等于0就表示目前还没有人得过0分，同理a[1]等于0就表示目前还没有人得过1分……a[10]等于0就表示目前还没有人得过10分。</p><p>下面开始处理每一个人的分数，第一个人的分数是5分，我们就将相对应的a[5]的值在原来的基础增加1，即将a[5]的值从0改为1，表示5分出现过了一次。</p><p>第二个人的分数是3分，我们就把相对应的a[3]的值在原来的基础上增加1，即将a[3]的值从0改为1，表示3分出现过了一次。</p><p>注意啦！第三个人的分数也是5分，所以a[5]的值需要在此基础上再增加1，即将a[5]的值从1改为2，表示5分出现过了两次。</p><p>按照刚才的方法处理第四个和第五个人的分数。最终结果就出来了</p><p>你发现没有，a[0]~a[10]中的数值其实就是0分到10分每个分数出现的次数。接下来，我们只需要将出现过的分数打印出来就可以了，出现几次就打印几次，具体如下。</p><blockquote><p>桶排序与计数排序很相似，不过现在的桶不单计数，是实实在在地放入元素。举个例子，学校要对所有老师按年龄进行排序，这么多老师很难操作，那么先让他们按年龄段进行分组，20－30岁的一组，30－40岁一组，50－60岁一组，然后组内再排序。这样效率就大大提高了。桶排序也是于这种思想。</p></blockquote><p>操作步骤：</p><ol><li>确认范围，亦即求取原数组的最大值与最小值。</li><li>确认需要多少个桶（这个通常作为参数传入，不能大于原数组长度），然后最大值减最小值，除以桶的数量，但得每个桶最多能放多个元素，我们称这个数为桶的最大容量。</li><li>遍历原数组的所有元素，除以这个最大容量，就能得到它要放入的桶的编号了。在放入时可以使用插入排序，也可以在合并时才使用快速排序。</li><li>对所有桶进行遍历，如果桶内的元素已经排好序，直接一个个取出来，放到结果数组就行了。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">var arr = [2,5,3,0,2,8,0,3,4,3]</span><br><span class="line">   function bucketSort(array, num)&#123;</span><br><span class="line">    if(array.length &lt;= 1)&#123;</span><br><span class="line">      return array</span><br><span class="line">    &#125;</span><br><span class="line">    var n = array.length;</span><br><span class="line">    var min = Math.min.apply(0, array)</span><br><span class="line">    var max = Math.max.apply(0, array)</span><br><span class="line">    if(max === min)&#123;</span><br><span class="line">       return array</span><br><span class="line">    &#125;</span><br><span class="line">    var capacity = (max - min + 1) /num;</span><br><span class="line">    var buckets = new Array(max - min + 1)</span><br><span class="line">    for(var i = 0; i &lt; n; i++)&#123;</span><br><span class="line">      var el = array[i];//el可能是负数</span><br><span class="line">      var index = Math.floor((el - min) / capacity)</span><br><span class="line">      var bucket = buckets[index]</span><br><span class="line">      if(bucket)&#123;</span><br><span class="line">         var jn = bucket.length;</span><br><span class="line">         if(el &gt;= bucket[jn-1])&#123;</span><br><span class="line">            bucket[jn] = el</span><br><span class="line">         &#125;else&#123;</span><br><span class="line">            insertSort: </span><br><span class="line">            for(var j = 0; j &lt; jn; j++)&#123;</span><br><span class="line">                if(bucket[j] &gt; el)&#123;</span><br><span class="line">                    while(jn &gt; j)&#123; //全部向后挪一位</span><br><span class="line">                        bucket[jn] = bucket[jn-1]</span><br><span class="line">                        jn--</span><br><span class="line">                    &#125;</span><br><span class="line">                    bucket[j] = el //让el占据bucket[j]的位置</span><br><span class="line">                    break insertSort;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">         buckets[index] = [el]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var index = 0</span><br><span class="line">    for(var i = 0; i &lt; num; i++)&#123;</span><br><span class="line">        var bucket = buckets[i]</span><br><span class="line">        for(var k = 0, kn = bucket.length; k &lt; kn; k++)&#123;</span><br><span class="line">            array[index++] = bucket[k]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line"> &#125;</span><br><span class="line"> console.log(  bucketSort(arr,4) )</span><br><span class="line"> //[ 0, 0, 2, 2, 3, 3, 3, 4, 5, 8 ]</span><br></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><blockquote><p>基数排序按照对位数分组的顺序的不同，可以分为LSD（Least significant digit）基数排序和MSD（Most significant digit）基数排序。</p></blockquote><h3 id="LSD基数排序"><a href="#LSD基数排序" class="headerlink" title="LSD基数排序"></a>LSD基数排序</h3><p>LSD基数排序，是按照从低位到高位的顺序进行分组排序。MSD基数排序，是按照从高位到低位的顺序进行分组排序<br>对于序列中的每个整数的每一位都可以看成是一个桶，而该位上的数字就可以认为是这个桶的键值。比如下面数组</p><p>[170, 45, 75, 90, 802, 2, 24, 66]</p><p>首先我们要确认最大值，一个for循环得最大数，因为最大数的位数最长。</p><p>然后，建立10个桶，亦即10个数组。</p><p>然后再遍历所有元素，取其个位数，个位数是什么就放进对应编号的数组，1放进1号桶。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0号桶： 170，90</span><br><span class="line">1号桶： 无</span><br><span class="line">2号桶： 802，2</span><br><span class="line">3号桶： 无</span><br><span class="line">4号桶： 24</span><br><span class="line">5号桶： 45， 75</span><br><span class="line">6号桶： 66</span><br><span class="line">7－9号桶： 无</span><br></pre></td></tr></table></figure></p><p> 然后再依次将元素从桶里最出来，覆盖原数组，或放到一个新数组，我们把这个经过第一次排序的数组叫sorted。</p><p>sorted = [170,90,802,2,24,45,75,66]</p><p>然后我们再一次遍历sorted数组的元素，这次取十位的值。这时要注意，2不存在十位，那么默认为0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0号桶： 2，802</span><br><span class="line"> 1号桶： 无</span><br><span class="line"> 2号桶： 24</span><br><span class="line"> 3号桶： 无</span><br><span class="line"> 4号桶： 45</span><br><span class="line"> 5号桶： 无</span><br><span class="line"> 6号桶： 66</span><br><span class="line"> 7号桶： 170， 75</span><br><span class="line"> 8号桶： 无</span><br><span class="line"> 9号桶： 90</span><br></pre></td></tr></table></figure><p> 再全部取出来</p><p>sorted = [2，802,24，45，66，170，75，90]</p><p>开始百位上的入桶操作，没有百位就默认为0：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0号桶： 2，24，45，66，75，90</span><br><span class="line">1号桶： 170</span><br><span class="line">2－7号桶：无</span><br><span class="line">8号桶： 802</span><br><span class="line">9号桶： 无</span><br></pre></td></tr></table></figure></p><p>再全部取出来</p><p>sorted = [2，24，45，66，75，90，170，802]</p><p>没有千位数，那么循环结束，返回结果桶sorted</p><p>从程序描述如下：<br><img src="http://ww1.sinaimg.cn/large/006ij6n6gy1fpzhmh1ggaj30df0aead6.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">function radixSort(array) &#123;</span><br><span class="line">    var max = Math.max.apply(0, array);</span><br><span class="line">    var times = getLoopTimes(max),</span><br><span class="line">        len = array.length;</span><br><span class="line">    var buckets = [];</span><br><span class="line">    for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        buckets[i] = []; //初始化10个桶</span><br><span class="line">    &#125;</span><br><span class="line">    for (var radix = 1; radix &lt;= times; radix++) &#123;</span><br><span class="line">        //个位，十位，百位，千位这样循环</span><br><span class="line">        lsdRadixSort(array, buckets, len, radix);</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line">// 根据数字某个位数上的值得到桶的编号</span><br><span class="line">function getBucketNumer(num, d) &#123;</span><br><span class="line">    return (num + &quot;&quot;).reverse()[d];</span><br><span class="line">&#125;</span><br><span class="line">//或者这个</span><br><span class="line">function getBucketNumer(num, i) &#123;</span><br><span class="line">    return Math.floor((num / Math.pow(10, i)) % 10);</span><br><span class="line">&#125;</span><br><span class="line">//获取数字的位数</span><br><span class="line">function getLoopTimes(num) &#123;</span><br><span class="line">    var digits = 0;</span><br><span class="line">    do &#123;</span><br><span class="line">        if (num &gt; 1) &#123;</span><br><span class="line">            digits++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while ((num = num / 10));</span><br><span class="line">    return digits;</span><br><span class="line">&#125;</span><br><span class="line">function lsdRadixSort(array, buckets, len, radix) &#123;</span><br><span class="line">    //入桶</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        let el = array[i];</span><br><span class="line">        let index = getBucketNumer(el, radix);</span><br><span class="line">        buckets[index].push(el);</span><br><span class="line">    &#125;</span><br><span class="line">    var k = 0;</span><br><span class="line">    //重写原桶</span><br><span class="line">    for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        let bucket = buckets[i];</span><br><span class="line">        for (let j = 0; j &lt; bucket.length; j++) &#123;</span><br><span class="line">            array[k++] = bucket[j];</span><br><span class="line">        &#125;</span><br><span class="line">        bucket.length = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// test</span><br><span class="line">var arr = [278, 109, 63, 930, 589, 184, 505, 269, 8, 83];</span><br><span class="line">console.log(radixSort(arr));</span><br></pre></td></tr></table></figure><h3 id="字符串使用基数排序实现字典排序"><a href="#字符串使用基数排序实现字典排序" class="headerlink" title="字符串使用基数排序实现字典排序"></a>字符串使用基数排序实现字典排序</h3><blockquote><p>此外，基数排序不局限于数字，可以稍作变换，就能应用于字符串的字典排序中。我们先来一个简单的例子，只对都是小写字母的字符串数组进行排序。</p></blockquote><p>小写字母一共26个，考虑到长度不一样的情况，我们需要对够短的字符串进行补充，这时补上什么好呢？我们不能直接上0，而是补空白。然后根据字母与数字的对应关系，弄27个桶，空字符串对应0，a对应1，b对应2…. 字典排序是从左边开始比较， 因此我们需要用到MST基数排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">var character = &#123;&#125;;</span><br><span class="line">&quot;abcdefghijklmnopqrstuvwxyz&quot;.split(&quot;&quot;).forEach(function(el, i) &#123;</span><br><span class="line">    character[el] = i + 1;</span><br><span class="line">&#125;);</span><br><span class="line">function toNum(c, length) &#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    arr.c = c;</span><br><span class="line">    for (var i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        arr[i] = character[c[i]] || 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">function getBucketNumer(arr, i) &#123;</span><br><span class="line">    return arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function radixSort(array) &#123;</span><br><span class="line">    var len = array.length;</span><br><span class="line">    var loopTimes = 0;</span><br><span class="line"></span><br><span class="line">    //求出最长的字符串，并得它的长度，那也是最高位</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        let el = array[i];</span><br><span class="line">        var charLen = el.length;</span><br><span class="line">        if (charLen &gt; loopTimes) &#123;</span><br><span class="line">            loopTimes = charLen;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将字符串转换为数字数组</span><br><span class="line">    var nums = [];</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        nums.push(toNum(array[i], loopTimes));</span><br><span class="line">    &#125;</span><br><span class="line">    //开始多关键字排序</span><br><span class="line">    msdRadixSort(nums, len, 0, loopTimes);</span><br><span class="line">    //变回字符串</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        array[i] = nums[i].c;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function msdRadixSort(array, len, radix, radixs) &#123;</span><br><span class="line">    var buckets = [];</span><br><span class="line">    for (var i = 0; i &lt;= 26; i++) &#123;</span><br><span class="line">        buckets[i] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    //入桶</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        let el = array[i];</span><br><span class="line">        let index = getBucketNumer(el, radix);</span><br><span class="line">        buckets[index].push(el);</span><br><span class="line">    &#125;</span><br><span class="line">    //递归子桶</span><br><span class="line">    for (let i = 0; i &lt;= 26; i++) &#123;</span><br><span class="line">        let el = buckets[i];</span><br><span class="line">        //el.c是用来识别是桶还是我们临时创建的数字字符串</span><br><span class="line">        if (el.length &gt; 1 &amp;&amp; !el.c &amp;&amp; radix &lt; radixs) &#123;</span><br><span class="line">            msdRadixSort(el, el.length, radix + 1, radixs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var k = 0;</span><br><span class="line">    //重写原桶</span><br><span class="line">    for (let i = 0; i &lt;= 26; i++) &#123;</span><br><span class="line">        let bucket = buckets[i];</span><br><span class="line">        for (let j = 0; j &lt; bucket.length; j++) &#123;</span><br><span class="line">            array[k++] = bucket[j];</span><br><span class="line">        &#125;</span><br><span class="line">        bucket.length = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var array = [&quot;ac&quot;, &quot;ee&quot;, &quot;ef&quot;, &quot;b&quot;, &quot;z&quot;, &quot;f&quot;, &quot;ep&quot;, &quot;gaaa&quot;, &quot;azh&quot;, &quot;az&quot;, &quot;r&quot;];</span><br><span class="line"></span><br><span class="line">var a = radixSort(array);</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure></p><p>基数排序动图</p><p><img src="https://images2015.cnblogs.com/blog/1093977/201707/1093977-20170720230230990-296833526.gif" alt="image"></p><h3 id="基数排序-vs-计数排序-vs-桶排序"><a href="#基数排序-vs-计数排序-vs-桶排序" class="headerlink" title="基数排序 vs 计数排序 vs 桶排序"></a>基数排序 vs 计数排序 vs 桶排序</h3><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ul><h2 id="参考来源："><a href="#参考来源：" class="headerlink" title="参考来源："></a>参考来源：</h2><ul><li><a href="https://www.cnblogs.com/liyongshuai/p/7197962.html" target="_blank" rel="noopener">https://www.cnblogs.com/liyongshuai/p/7197962.html</a></li><li><a href="https://www.cnblogs.com/wteam-xq/p/4752610.html" target="_blank" rel="noopener">https://www.cnblogs.com/wteam-xq/p/4752610.html</a></li><li><a href="https://segmentfault.com/a/1190000012923917#articleHeader2" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012923917#articleHeader2</a></li></ul><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2018/04/03/js十大排序算法详解/">http://jaymo666.github.io/2018/04/03/js十大排序算法详解/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用js实现的十大经典算法，有简单的例子+原理图+动图&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://jaymo666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="js" scheme="http://jaymo666.github.io/tags/js/"/>
    
      <category term="算法" scheme="http://jaymo666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>用mock实现前端所需数据</title>
    <link href="http://jaymo666.github.io/2018/04/01/%E7%94%A8mock%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E6%89%80%E9%9C%80%E6%95%B0%E6%8D%AE/"/>
    <id>http://jaymo666.github.io/2018/04/01/用mock实现前端所需数据/</id>
    <published>2018-04-01T12:36:39.000Z</published>
    <updated>2018-04-01T13:09:27.535Z</updated>
    
    <content type="html"><![CDATA[<p>mock.js的小demo及mock语法简述及JSON.stringify用法<a id="more"></a></p><p>[TOC]</p><h2 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h2><ul><li>mock.js 官网:<a href="http://mockjs.com/" target="_blank" rel="noopener">http://mockjs.com/</a></li><li>（进阶的有eolinker，是基于mock.js的可视化模拟数据API接口）:<a href="https://www.eolinker.com/" target="_blank" rel="noopener">https://www.eolinker.com/</a></li></ul><h2 id="Mock概述："><a href="#Mock概述：" class="headerlink" title="Mock概述："></a>Mock概述：</h2><p>Mock.js实现的功能</p><ul><li>基于 数据模板 生成数据</li><li>基于 HTML模板 生成数据</li><li>拦截并模拟 Ajax请求</li></ul><h2 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h2><h3 id="浏览器："><a href="#浏览器：" class="headerlink" title="浏览器："></a>浏览器：</h3><blockquote><p>index.html:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;http://mockjs.com/dist/mock.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var data = Mock.mock(&#123;</span><br><span class="line">            &apos;list|1-10&apos;: [&#123;</span><br><span class="line">                &apos;id|+1&apos;: 1</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;);</span><br><span class="line">        $(&apos;&lt;pre&gt;&apos;).text(JSON.stringify(data, null, 4))</span><br><span class="line">            .appendTo(&apos;body&apos;);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        //JQuery</span><br><span class="line">        //配置模拟数据</span><br><span class="line">        Mock.mock(&apos;http://g.cn&apos;,&#123;</span><br><span class="line">            &apos;name&apos;:&apos;@name&apos;,</span><br><span class="line">            &apos;age|1-100&apos;:100,</span><br><span class="line">            &apos;color&apos;:&apos;@color&apos;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        //发送Ajax请求</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url:&apos;http://g.cn&apos;,</span><br><span class="line">            dataType:&apos;json&apos;</span><br><span class="line">        &#125;).done(function(data,status,xhr)&#123;</span><br><span class="line">            console.log(</span><br><span class="line">                JSON.stringify(data,null,4)</span><br><span class="line">            )</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>页面返回值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;list&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;id&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;id&quot;: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;id&quot;: 3</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>浏览器控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">index.html:33 &#123;</span><br><span class="line">    &quot;name&quot;: &quot;Deborah Williams&quot;,</span><br><span class="line">    &quot;age&quot;: 2,</span><br><span class="line">    &quot;color&quot;: &quot;#ecf279&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>Mock.js 的语法规范包括两部分：</p><ul><li>数据模板定义（Data Temaplte Definition，DTD）</li><li>数据占位符定义（Data Placeholder Definition，DPD）</li></ul><h3 id="数据模板定义-DTD"><a href="#数据模板定义-DTD" class="headerlink" title="数据模板定义 DTD"></a>数据模板定义 DTD</h3><p>数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 属性名   name</span><br><span class="line">// 生成规则 rule</span><br><span class="line">// 属性值   value</span><br><span class="line">&apos;name|rule&apos;: value</span><br></pre></td></tr></table></figure></p><p>注意：</p><ul><li>属性名 和 生成规则 之间用 | 分隔。</li><li>生成规则 是可选的。</li><li>生成规则 有 7 种格式：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&apos;name|min-max&apos;: value</span><br><span class="line">&apos;name|count&apos;: value</span><br><span class="line">&apos;name|min-max.dmin-dmax&apos;: value</span><br><span class="line">&apos;name|min-max.dcount&apos;: value</span><br><span class="line">&apos;name|count.dmin-dmax&apos;: value</span><br><span class="line">&apos;name|count.dcount&apos;: value</span><br><span class="line">&apos;name|+step&apos;: value</span><br></pre></td></tr></table></figure><p>生成规则 的 含义 需要依赖 属性值 才能确定。</p><p>属性值 中可以含有 @占位符。<br>属性值 还指定了最终值的初始值和类型。</p><h3 id="数据占位符定义-DPD"><a href="#数据占位符定义-DPD" class="headerlink" title="数据占位符定义 DPD"></a>数据占位符定义 DPD</h3><blockquote><p>占位符 只是在属性值字符串中占个位置，并不出现在最终的属性值中。占位符 的格式为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@占位符</span><br><span class="line">@占位符(参数 [, 参数])</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>用 @ 来标识其后的字符串是 占位符。</li><li>占位符 引用的是 Mock.Random 中的方法。</li><li>通过 Mock.Random.extend() 来扩展自定义占位符。</li><li>占位符 也可以引用 数据模板 中的属性。</li><li>占位符 会优先引用 数据模板 中的属性</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> name: &#123;</span><br><span class="line"> first: &apos;@FIRST&apos;,</span><br><span class="line"> middle: &apos;@FIRST&apos;,</span><br><span class="line"> last: &apos;@LAST&apos;,</span><br><span class="line"> full: &apos;@first @middle @last&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// =&gt;</span><br><span class="line">&#123;</span><br><span class="line"> &quot;name&quot;: &#123;</span><br><span class="line"> &quot;first&quot;: &quot;Charles&quot;,</span><br><span class="line"> &quot;middle&quot;: &quot;Brenda&quot;,</span><br><span class="line"> &quot;last&quot;: &quot;Lopez&quot;,</span><br><span class="line"> &quot;full&quot;: &quot;Charles Brenda Lopez&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="Mock-mock-rurl-rtype-template-function-options"><a href="#Mock-mock-rurl-rtype-template-function-options" class="headerlink" title="Mock.mock( rurl?, rtype?, template|function(options) )"></a>Mock.mock( rurl?, rtype?, template|function(options) )</h3><p>根据数据模板生成模拟数据。<br>参数的含义和默认值如下所示：</p><ul><li>参数 rurl：可选。表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。例如 /\/domain\/list.json/、’/domian/list.json’。</li><li>参数 rtype：可选。表示需要拦截的 Ajax 请求类型。例如 GET、POST、PUT、DELETE 等。</li><li>参数 template：可选。表示数据模板，可以是对象或字符串。例如 { ‘data|1-10’:[{}] }、‘@EMAIL’。</li><li>参数 function(options)：可选。表示用于生成响应数据的函数。</li><li>参数 options：指向本次请求的 Ajax 选项集。</li></ul><h3 id="Mock-mockjax-library"><a href="#Mock-mockjax-library" class="headerlink" title="Mock.mockjax(library)"></a>Mock.mockjax(library)</h3><p>覆盖（拦截） Ajax 请求，目前内置支持 jQuery、Zepto、KISSY。</p><h3 id="Mock-Random"><a href="#Mock-Random" class="headerlink" title="Mock.Random"></a>Mock.Random</h3><p>Mock.Random 是一个工具类，用于生成各种随机数据。Mock.Random 的方法在数据模板中称为“占位符”，引用格式为 @占位符(参数 [, 参数]) 。</p><h3 id="Mock-tpl-input-options-helpers-partials"><a href="#Mock-tpl-input-options-helpers-partials" class="headerlink" title="Mock.tpl(input,options,helpers,partials)"></a>Mock.tpl(input,options,helpers,partials)</h3><p>基于 Handlebars、Mustache 的 HTML 模板生成模拟数据。</p><p>方法使用详情请参考<a href="http://mockjs.com/#mock" target="_blank" rel="noopener">mock.js文档</a></p><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="JSON-stringify-方法"><a href="#JSON-stringify-方法" class="headerlink" title="JSON.stringify 方法"></a>JSON.stringify 方法</h3><blockquote><p>把一个对象通过 stringify 之后提交给后台或者存储在 Storage 里是很常用的手段。</p></blockquote><blockquote><p>demo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var data = [</span><br><span class="line">    &#123;name: &quot;王尼玛&quot;, sex:1, age: 30&#125;,</span><br><span class="line">    &#123;name: &quot;王尼美&quot;, sex:0, age: 20&#125;,</span><br><span class="line">    &#123;name: &quot;王大锤&quot;, sex:1, age: 30&#125;</span><br><span class="line">];</span><br><span class="line">var str_json = JSON.stringify(data);</span><br><span class="line">console.log(str_json);</span><br></pre></td></tr></table></figure></p></blockquote><p>这个是我们日常用法，非常简单，对吧。</p><p>比如说，我们的数据非常复杂，还有类似头像，昵称，个人签名之类的信息。<br>可是我保存在本地，只需要用户名，和性别，肿么破呢？<br>也许你会说 so easy, 遍历数据重新提取下即可。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var data = [</span><br><span class="line">    &#123;name: &quot;王尼玛&quot;, sex:1, age: 30&#125;,</span><br><span class="line">    &#123;name: &quot;王尼美&quot;, sex:0, age: 20&#125;,</span><br><span class="line">    &#123;name: &quot;王大锤&quot;, sex:1, age: 30&#125;</span><br><span class="line">];</span><br><span class="line">for (var i=0, new_data=[]; i&lt;data.length; i++) &#123;</span><br><span class="line">    new_data.push(&#123;</span><br><span class="line">        name: data[i].name,</span><br><span class="line">        sex:  data[i].sex</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">var str_json = JSON.stringify(new_data);</span><br><span class="line">console.log(str_json);</span><br></pre></td></tr></table></figure></p><p>确实分分钟搞定。</p><p>其实我们只需要用 stringify 第二个参数即可简单处理这种问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var data = [</span><br><span class="line">    &#123;name: &quot;王尼玛&quot;, sex:1, age: 30&#125;,</span><br><span class="line">    &#123;name: &quot;王尼美&quot;, sex:0, age: 20&#125;,</span><br><span class="line">    &#123;name: &quot;王大锤&quot;, sex:1, age: 30&#125;</span><br><span class="line">];</span><br><span class="line">var str_json = JSON.stringify(data, [&quot;name&quot;, &quot;sex&quot;]);</span><br><span class="line">console.log(str_json);</span><br></pre></td></tr></table></figure></p><p>第二个参数如此强悍，为我们省去了不少麻烦。</p><p>还有第三个参数，用于格式化字符串用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var data = [</span><br><span class="line">    &#123;name: &quot;王尼玛&quot;, sex:1, age: 30&#125;,</span><br><span class="line">    &#123;name: &quot;王尼美&quot;, sex:0, age: 20&#125;,</span><br><span class="line">    &#123;name: &quot;王大锤&quot;, sex:1, age: 30&#125;</span><br><span class="line">];</span><br><span class="line">var str_json = JSON.stringify(data, null, &quot;\t&quot;);</span><br><span class="line">console.log(str_json);</span><br><span class="line">str_json = JSON.stringify(data, [&quot;name&quot;, &quot;sex&quot;], &quot;\t&quot;);</span><br><span class="line">console.log(str_json);</span><br></pre></td></tr></table></figure><p>不想要的 key 返回 undefined 即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var data = [</span><br><span class="line">    &#123;name: &quot;王尼玛&quot;, sex:1, age: 30&#125;,</span><br><span class="line">    &#123;name: &quot;王尼美&quot;, sex:0, age: 20&#125;,</span><br><span class="line">    &#123;name: &quot;王大锤&quot;, sex:1, age: 30&#125;</span><br><span class="line">];</span><br><span class="line">var str_json = JSON.stringify(data, function (k, v) &#123;</span><br><span class="line">    if (k === &quot;sex&quot;) &#123;</span><br><span class="line">        return [&quot;女&quot;, &quot;男&quot;][v];</span><br><span class="line">    &#125; else if (k === &quot;age&quot; ) &#123;</span><br><span class="line">        return undefined;</span><br><span class="line">    &#125;</span><br><span class="line">    return v;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(str_json);</span><br></pre></td></tr></table></figure></p><p>JSON.stringify(str, null, 4) //表示使用四个空格缩进</p><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><ul><li><a href="https://segmentfault.com/a/1190000003087224" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003087224</a></li><li><a href="https://www.cnblogs.com/52cik/p/js-json-stringify.html" target="_blank" rel="noopener">https://www.cnblogs.com/52cik/p/js-json-stringify.html</a></li></ul><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2018/04/01/用mock实现前端所需数据/">http://jaymo666.github.io/2018/04/01/用mock实现前端所需数据/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mock.js的小demo及mock语法简述及JSON.stringify用法&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Ajax概念-简单例子复习/Ajax概念+简单例子复习</title>
    <link href="http://jaymo666.github.io/2018/03/28/Ajax%E6%A6%82%E5%BF%B5-%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90%E5%A4%8D%E4%B9%A0/"/>
    <id>http://jaymo666.github.io/2018/03/28/Ajax概念-简单例子复习/</id>
    <published>2018-03-28T02:58:55.000Z</published>
    <updated>2018-03-28T13:05:37.003Z</updated>
    
    <content type="html"><![CDATA[<p>Ajax概念-简单例子复习/Ajax概念+简单例子复习<a id="more"></a></p><h1 id="Ajax概念-简单例子复习-Ajax概念-简单例子复习"><a href="#Ajax概念-简单例子复习-Ajax概念-简单例子复习" class="headerlink" title="Ajax概念-简单例子复习/Ajax概念+简单例子复习"></a>Ajax概念-简单例子复习/Ajax概念+简单例子复习</h1><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><blockquote><p>同步：页面请求实时传给服务器，导致必填数据没有填的时候，要回到页面上重新从头填写，耗时长、客户体验差。</p></blockquote><blockquote><p>异步：在页面必填项写上必填选项，不用通过传给服务器判断必填内容是否已经填写完整，耗时短、用户体验强。</p></blockquote><h2 id="异步："><a href="#异步：" class="headerlink" title="异步："></a>异步：</h2><blockquote><p>XMLHttpRequest： XMLHttpRequest对象的出现分割了同步和异步。XMLHttpRequest出现之前是同步的，出现之后是异步的。</p></blockquote><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><ol><li>利用html+css来实现页面，表达信息；</li><li>用XMLHttpRequest和web服务器进行数据的异步交换</li><li>运用js操作DOM，实现动态局部刷新；</li></ol><h2 id="创建XMLhttpRequest对象"><a href="#创建XMLhttpRequest对象" class="headerlink" title="创建XMLhttpRequest对象"></a>创建XMLhttpRequest对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var request;</span><br><span class="line">if(window.XMLHttpRequest)&#123;</span><br><span class="line">    request = new XMLHtpRequest();</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    request = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//IE5,IE6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ajax-HTTP请求"><a href="#Ajax-HTTP请求" class="headerlink" title="Ajax+HTTP请求"></a>Ajax+HTTP请求</h2><h4 id="HTTP请求，简洁版"><a href="#HTTP请求，简洁版" class="headerlink" title="HTTP请求，简洁版"></a>HTTP请求，简洁版</h4><ul><li>建立TCP连接</li><li>Web浏览器向Web服务器发送请求命令</li><li>Web服务器发送请求头</li><li>Web服务器应答</li><li>Web服务器向浏览器发送数据</li><li>Web服务器关闭TCP连接</li></ul><h4 id="http-状态码"><a href="#http-状态码" class="headerlink" title="http 状态码"></a>http 状态码</h4><ul><li>1XX 信息类 表示收到web浏览器请求</li><li>2xx 成功 200</li><li>3xx 重定向，表示请求没有成功，</li><li>4xx 表示客户端错误</li><li>5xx 服务器错误，表示服务器不能完成对请求的处理</li></ul><h4 id="XMLHttpRequest发送方法"><a href="#XMLHttpRequest发送方法" class="headerlink" title="XMLHttpRequest发送方法"></a>XMLHttpRequest发送方法</h4><ul><li>open（method,url,async）//async:同步false；异步：true（默认）</li><li>send(string)</li></ul><p><strong>例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">request.open(&quot;GET&quot;,  &quot;get.php&quot;,true);</span><br><span class="line">request.send();</span><br><span class="line"></span><br><span class="line">request.open(&quot;POST&quot;, &quot;post.php&quot;,true)；</span><br><span class="line">request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);//写在中间，引用表单时，告诉服务器是什么格式，Content-type&quot;告诉服务器是表单格式，页面表单数据向服务端传输时的编码方式application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">request.send(&quot;name=jaymo&amp;sex=男&quot;);</span><br></pre></td></tr></table></figure><h4 id="XMLHttpRequest取得相应"><a href="#XMLHttpRequest取得相应" class="headerlink" title="XMLHttpRequest取得相应"></a>XMLHttpRequest取得相应</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var request=new XMLHttpRequest();</span><br><span class="line">    request.open(&quot;GET&quot;,&quot;get.php&quot;,true);</span><br><span class="line">    request.send();</span><br><span class="line">    request.onreadyStatechange=function()&#123;</span><br><span class="line">    if（request.readyState===4&amp;&amp;request.status===200）&#123;</span><br><span class="line">    //做一些事</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h4 id="例子简介："><a href="#例子简介：" class="headerlink" title="例子简介："></a>例子简介：</h4><ul><li>html：用来查询员工查询和新建</li><li>php：用来查询和新建的后台接口</li><li>XAMPP </li></ul><h5 id="启动xampp"><a href="#启动xampp" class="headerlink" title="启动xampp"></a>启动xampp</h5><p>修改端口，改为8088；<br>在浏览器输入：<a href="http://localhost:8088/" target="_blank" rel="noopener">http://localhost:8088/</a><br></p><h4 id="建立php文件："><a href="#建立php文件：" class="headerlink" title="建立php文件："></a>建立php文件：</h4><p>test.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;测试页面&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">echo &quot; Hello World! 这是测试页面。&quot;;</span><br><span class="line">?&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h5 id="真正例子"><a href="#真正例子" class="headerlink" title="真正例子"></a>真正例子</h5><h2 id="json解析"><a href="#json解析" class="headerlink" title="json解析"></a>json解析</h2><p>第一种方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var jsondata=&apos;&#123;&quot;staff&quot;:[&#123;&quot;name&quot;:&quot;红旗&quot;,&quot;age&quot;:18&#125;,&#123;&quot;name&quot;:&quot;郭靖&quot;,&quot;age&quot;:16&#125;]&#125;&apos;;</span><br><span class="line">var jsonobj=eval(&apos;(&apos;+jsondata+&apos;)&apos;);</span><br><span class="line">alert(jsonobj.staff[0].name);</span><br></pre></td></tr></table></figure></p><p>第二种方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var jsondata=&apos;&#123;&quot;staff&quot;:[&#123;&quot;name&quot;:&quot;红旗&quot;,&quot;age&quot;:18&#125;,&#123;&quot;name&quot;:&quot;郭靖&quot;,&quot;age&quot;:16&#125;]&#125;&apos;;</span><br><span class="line">var jsonobj=JSON.parse(jsondata);</span><br><span class="line">alert(jsonobj.staff[0].name);</span><br></pre></td></tr></table></figure></p><blockquote><p>在JavaScript中有eval和JSON.parse两种方式，推荐后者，因为前者是不安全的，它不能验证json格式的合法性，不能避免在json中直接执行JavaScript代码，从而造成潜在威胁的存在。推荐用JSONlint进行json在线验证</p></blockquote><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2018/03/28/Ajax概念-简单例子复习/">http://jaymo666.github.io/2018/03/28/Ajax概念-简单例子复习/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ajax概念-简单例子复习/Ajax概念+简单例子复习&lt;/p&gt;
    
    </summary>
    
      <category term="Ajax" scheme="http://jaymo666.github.io/categories/Ajax/"/>
    
    
      <category term="Ajax" scheme="http://jaymo666.github.io/tags/Ajax/"/>
    
      <category term="json" scheme="http://jaymo666.github.io/tags/json/"/>
    
      <category term="jQuery" scheme="http://jaymo666.github.io/tags/jQuery/"/>
    
      <category term="js" scheme="http://jaymo666.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JSON的使用</title>
    <link href="http://jaymo666.github.io/2018/03/28/JSON%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://jaymo666.github.io/2018/03/28/JSON的使用/</id>
    <published>2018-03-28T02:35:19.000Z</published>
    <updated>2018-03-28T02:55:46.363Z</updated>
    
    <content type="html"><![CDATA[<p>Json复习<a id="more"></a></p><h1 id="JSON的使用"><a href="#JSON的使用" class="headerlink" title="JSON的使用"></a>JSON的使用</h1><h2 id="JSON的两种格式"><a href="#JSON的两种格式" class="headerlink" title="JSON的两种格式"></a>JSON的两种格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;JSON&quot;,&quot;address&quot;:&quot;北京市西城区&quot;,&quot;age&quot;:25&#125;//JSON的对象格式的字符串</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;&quot;name&quot;:&quot;JSON&quot;,&quot;address&quot;:&quot;北京市西城区&quot;,&quot;age&quot;:25&#125;]//数组对象格式</span><br></pre></td></tr></table></figure><p>区别与联系：</p><blockquote><p>对象格式和数组对象格式唯一的不同则是在对象格式的基础上加上了[]，再来看具体的结构，可以看出都是以键值对的形式出现的，中间以英文状态下的逗号（,）分隔。</p></blockquote><h2 id="两个重要函数"><a href="#两个重要函数" class="headerlink" title="两个重要函数"></a>两个重要函数</h2><h4 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h4><h4 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h4><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>JSON字符串:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var str1 = &apos;&#123; &quot;name&quot;: &quot;cxh&quot;, &quot;sex&quot;: &quot;man&quot; &#125;&apos;;</span><br></pre></td></tr></table></figure></p><p>JSON对象:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj1= &#123; &quot;name&quot;: &quot;cxh&quot;, &quot;sex&quot;: &quot;man&quot; &#125;;</span><br></pre></td></tr></table></figure></p><h4 id="JSON字符串转换为JSON对象"><a href="#JSON字符串转换为JSON对象" class="headerlink" title="JSON字符串转换为JSON对象"></a>JSON字符串转换为JSON对象</h4><p>要使用上面的str1，必须使用下面的方法先转化为JSON对象：</p><p>由JSON字符串转换为JSON对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = eval(&apos;(&apos; + str1+ &apos;)&apos;);</span><br><span class="line">console.log(obj);</span><br><span class="line">//或者</span><br><span class="line">var obj = JSON.parse(str1); </span><br><span class="line">console.log(obj);</span><br></pre></td></tr></table></figure></p><p>一般，从后台传入到前台的是json字符串，不是真正的json对象，因此需要使用eval函数转换。 将字符串转换为json对象使用函数eval，或JSON.parse(str)。其中：eval(“(“ + str+ “)”)；</p><h4 id="SON对象转化为JSON字符串"><a href="#SON对象转化为JSON字符串" class="headerlink" title="SON对象转化为JSON字符串"></a>SON对象转化为JSON字符串</h4><p>使用toJSONString()或者全局方法JSON.stringify()将JSON对象转化为JSON字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var last=JSON.stringify(obj1); //将JSON对象转化为JSON字符</span><br><span class="line">console.log(last);</span><br><span class="line">typeof last;</span><br></pre></td></tr></table></figure><h2 id="Js-中对-Json-数组的常用操作"><a href="#Js-中对-Json-数组的常用操作" class="headerlink" title="Js 中对 Json 数组的常用操作"></a>Js 中对 Json 数组的常用操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var persons = [</span><br><span class="line">    &#123;name: &quot;tina&quot;, age: 14&#125;,</span><br><span class="line">    &#123;name: &quot;timo&quot;, age: 15&#125;,</span><br><span class="line">    &#123;name: &quot;lily&quot;, age: 16&#125;,</span><br><span class="line">    &#123;name: &quot;lucy&quot;, age: 16&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="根据对象属性值得到相应对象"><a href="#根据对象属性值得到相应对象" class="headerlink" title="根据对象属性值得到相应对象"></a>根据对象属性值得到相应对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//1. 获取 name 等于 lily 的对象</span><br><span class="line">var lily=persons.filter((p)=&gt;&#123;</span><br><span class="line">    return p.name==&quot;lily&quot;;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(lily);</span><br><span class="line"></span><br><span class="line">//注：filter()方法返回的是一个数组</span><br><span class="line">var twins = persons.filter((p) =&gt; &#123;</span><br><span class="line">    return p.age == 16;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(twins); </span><br><span class="line">// 打印结果 [&#123;name: &quot;lily&quot;, age: 16&#125;,&#123;name: &quot;lucy&quot;, age: 16&#125;]</span><br></pre></td></tr></table></figure><h4 id="删除其中一个对象"><a href="#删除其中一个对象" class="headerlink" title="删除其中一个对象"></a>删除其中一个对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 删除 name 等于 tina 的对象，利用splice()方法</span><br><span class="line"></span><br><span class="line">// 1. 首先我们要得到这个对象</span><br><span class="line">var tina = persons.filter((p) =&gt; &#123;</span><br><span class="line">    return p.name == &quot;tina&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//2. 其次得到这个对象在数组中对应的索引</span><br><span class="line">var index = persons.indexOf(tina[0]);</span><br><span class="line"></span><br><span class="line">//3. 如果存在则将其删除，index &gt; -1 代表存在</span><br><span class="line">index &gt; -1 &amp;&amp; persons.splice(index, 1);</span><br><span class="line"></span><br><span class="line">console.log(persons);</span><br></pre></td></tr></table></figure><h4 id="修改其中一个对象的属性值"><a href="#修改其中一个对象的属性值" class="headerlink" title="修改其中一个对象的属性值"></a>修改其中一个对象的属性值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//将 name 等于 timo 的 age 修改为 20</span><br><span class="line"></span><br><span class="line">//1. 得到 timo 对象</span><br><span class="line">var timo = persons.filter((p) =&gt; &#123;</span><br><span class="line">    return p.name == &quot;timo&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//2. 修改age</span><br><span class="line">timo[0].age = 20;</span><br></pre></td></tr></table></figure><h4 id="往数组中添加一个对象"><a href="#往数组中添加一个对象" class="headerlink" title="往数组中添加一个对象"></a>往数组中添加一个对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">persons.push(&#123;name: &quot;similar&quot;, age: 18&#125;);</span><br></pre></td></tr></table></figure><h2 id="js-数组转json，json转数组"><a href="#js-数组转json，json转数组" class="headerlink" title="js 数组转json，json转数组"></a>js 数组转json，json转数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//数组转json串</span><br><span class="line">var arr = [1,2,3, &#123; a : 1 &#125; ];</span><br><span class="line">JSON.stringify( arr );</span><br><span class="line"></span><br><span class="line">//json字符串转数组</span><br><span class="line">var jsonStr = &apos;[1,2,3,&#123;&quot;a&quot;:1&#125;]&apos;;</span><br><span class="line">JSON.parse( jsonStr );</span><br></pre></td></tr></table></figure><h2 id="js解析json数组"><a href="#js解析json数组" class="headerlink" title="js解析json数组"></a>js解析json数组</h2><blockquote><p>解析json数组即对JSONArray的遍历</p></blockquote><h4 id="对于标准的json数组如"><a href="#对于标准的json数组如" class="headerlink" title="对于标准的json数组如"></a>对于标准的json数组如</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var result=[&#123;&quot;flag&quot;:1,&quot;macId&quot;:&quot;2&quot;,&quot;mbId&quot;:0,&quot;userName&quot;:&quot;XXX&quot;&#125;,&#123;&quot;flag&quot;:1,&quot;macId&quot;:&quot;1&quot;,&quot;mbId&quot;:1,&quot;userName&quot;:&quot;YYY&quot;&#125;]</span><br></pre></td></tr></table></figure><p>进行遍历的时候，可以直接通过for循环遍历这个数组，有两种方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//1</span><br><span class="line">for (var i = 0; i &lt; result.length; i++) &#123;</span><br><span class="line">        //result[i]表示获得第i个json对象即JSONObject</span><br><span class="line">        //result[i]通过.字段名称即可获得指定字段的值</span><br><span class="line">       console.log(result[i].userName);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> //2</span><br><span class="line"> for(var i in result)&#123;</span><br><span class="line">        //表示遍历数组，而i表示的是数组的下标值，</span><br><span class="line">        //result[i]表示获得第i个json对象即JSONObject</span><br><span class="line">        //result[i]通过.字段名称即可获得指定字段的值</span><br><span class="line">        result[i].userName;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="对于不标准的json数组如"><a href="#对于不标准的json数组如" class="headerlink" title="对于不标准的json数组如"></a>对于不标准的json数组如</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var result2=&#123;&quot;datas&quot;:[&#123;&quot;flag&quot;:1,&quot;macId&quot;:&quot;2&quot;,&quot;mbId&quot;:0,&quot;userName&quot;:&quot;XXX&quot;&#125;,&#123;&quot;flag&quot;:1,&quot;macId&quot;:&quot;1&quot;,&quot;mbId&quot;:1,&quot;userName&quot;:&quot;YYY&quot;&#125;]&#125;;</span><br></pre></td></tr></table></figure><p>进行遍历之前得先解析出标准的json数组格式即[{},{}]</p><blockquote><p>var data= result2.datas;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//1.  for (var i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">        //data[i]表示获得第i个json对象即JSONObject</span><br><span class="line">        //data[i]通过.字段名称即可获得指定字段的值</span><br><span class="line">        data[i].userName;</span><br><span class="line">    &#125;</span><br><span class="line">//2.</span><br><span class="line">  for(var i in data)&#123;</span><br><span class="line">        //表示遍历数组，而i表示的是数组的下标值，</span><br><span class="line">        //data[i]表示获得第i个json对象即JSONObject</span><br><span class="line">        //data[i]通过.字段名称即可获得指定字段的值</span><br><span class="line">        data[i].userName;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2018/03/28/JSON的使用/">http://jaymo666.github.io/2018/03/28/JSON的使用/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Json复习&lt;/p&gt;
    
    </summary>
    
      <category term="json" scheme="http://jaymo666.github.io/categories/json/"/>
    
    
      <category term="json" scheme="http://jaymo666.github.io/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>在npm发布第一个包</title>
    <link href="http://jaymo666.github.io/2018/03/14/%E5%9C%A8npm%E5%8F%91%E5%B8%83%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%85/"/>
    <id>http://jaymo666.github.io/2018/03/14/在npm发布第一个包/</id>
    <published>2018-03-14T12:39:50.000Z</published>
    <updated>2018-03-14T13:59:26.157Z</updated>
    
    <content type="html"><![CDATA[<p>第一个npm包:web-plus<a id="more"></a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=447960871&auto=0&height=66"></iframe><h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><ul><li>安装node.js</li><li>注册一个github账户用于托管代码</li><li>注册一个npm账户</li><li>开发你的module，更新至github</li><li>发布module至npm<h2 id="github创建项目"><a href="#github创建项目" class="headerlink" title="github创建项目"></a>github创建项目</h2></li></ul><p>终端进入到项目文件夹，执行npm init命令，构建模块的描述文件，系统会提示你输入所需的信息，不想输入就直接Enter跳过。这里主要的几个配置如下:</p><ul><li>name就是你要发布的module名</li><li>version版本信息（每发布一次版本号都必须大于上一次发布的版本号）；</li><li>entry入口文件</li></ul><h2 id="开发："><a href="#开发：" class="headerlink" title="开发："></a>开发：</h2><blockquote><p>npm init</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">$ npm init</span><br><span class="line">This utility will walk you through creating a package.json file.</span><br><span class="line">It only covers the most common items, and tries to guess sensible defaults.</span><br><span class="line"></span><br><span class="line">See `npm help json` for definitive documentation on these fields</span><br><span class="line">and exactly what they do.</span><br><span class="line"></span><br><span class="line">Use `npm install &lt;pkg&gt;` afterwards to install a package and</span><br><span class="line">save it as a dependency in the package.json file.</span><br><span class="line"></span><br><span class="line">Press ^C at any time to quit.</span><br><span class="line">package name: (npm-module) web-plus</span><br><span class="line">version: (1.0.0)</span><br><span class="line">description: 前端常用代码片段</span><br><span class="line">entry point: (index.js)</span><br><span class="line">test command:</span><br><span class="line">git repository: git@github.com:JayMo666/webplus.git</span><br><span class="line">keywords: web</span><br><span class="line">author: JayMo</span><br><span class="line">license: (ISC) MIT</span><br><span class="line">About to write to F:\npm\npm-module\package.json:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;web-plus&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;前端常用代码片段&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;repository&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;git&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;git+ssh://git@github.com/JayMo666/webplus.git&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;web&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;author&quot;: &quot;JayMo&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">  &quot;bugs&quot;: &#123;</span><br><span class="line">    &quot;url&quot;: &quot;https://github.com/JayMo666/webplus/issues&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;homepage&quot;: &quot;https://github.com/JayMo666/webplus#readme&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Is this ok? (yes)</span><br></pre></td></tr></table></figure><h3 id="npm注册"><a href="#npm注册" class="headerlink" title="npm注册"></a>npm注册</h3><h3 id="npm-命令"><a href="#npm-命令" class="headerlink" title="npm 命令"></a>npm 命令</h3><p>1.首先增加用户</p><blockquote><p>npm adduser<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm adduser</span><br><span class="line">Username: jaymo666</span><br><span class="line">Password: *******</span><br><span class="line">Email: (this IS public) 1294****8@qq.com</span><br><span class="line">Logged in as jaymo666 on https://registry.npmjs.org/.</span><br></pre></td></tr></table></figure></p></blockquote><p>2.查看当前登录用户</p><blockquote><p>npm whoami</p></blockquote><p>3.登录命令（这里已经登录，不用执行此命令）</p><blockquote><p>npm login</p></blockquote><h2 id="开发包-编程"><a href="#开发包-编程" class="headerlink" title="开发包-编程"></a>开发包-编程</h2><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><ul><li>a.js</li><li>index.js （这个是入口文件，要和package.json 文件中的  “main”的值一样）</li><li>package.json (npm init 生成的）</li></ul><h4 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h4><p>index.js:就开发一个简单地hello程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function hello(name)&#123;</span><br><span class="line">  console.log(&quot;hello &quot;+ name);</span><br><span class="line">&#125;</span><br><span class="line">exports.hello=hello;</span><br></pre></td></tr></table></figure><p>b.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var h=require(&apos;./index&apos;);</span><br><span class="line">h.hello(&apos;jaymo&apos;);</span><br></pre></td></tr></table></figure><p>##5.发布npm包</p><blockquote><p>npm publish<br>进入npm个人中心，可以看到自己的npm包已经发布在上面了</p></blockquote><p>##6.获取npm包</p><blockquote><p>npm install package-name<br>此处package-name使用web-plus即可<br>可以看到，多了一个node_modules目录，里面多了一个web-plus文件夹，里面放的就是我们刚才创建的npm包，包含a.js、index.js、package.json三个文件</p></blockquote><p>##7.使用npm包<br>跟使用普通的npm包一样，问了测试简单，创建一个index.js，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = require(&apos;web-plus&apos;)</span><br><span class="line">a.hello(&apos;jaymo&apos;)</span><br></pre></td></tr></table></figure></p><p>执行<code>node index</code>即可看见输出了hello jaymo</p><p>##8.更新npm包<br>更新npm包也是使用<code>npm publish</code>命令发布，不过必须更改npm包的版本号，即package.json的version字段，否则会报错<br>1.查看版本</p><blockquote><p>npm version<br>2.修改版本<br>npm version 版本<br>3.然后发布<br>npm publish</p></blockquote><p>##9.易出现的错误：</p><ul><li>如果在发布的文件下运行a.js文件测试：</li></ul><p><code>node a</code><br>如果出现：Cannot find module ‘web-plus’错误，可能是在a文件中require(‘./文件名’);引入出错</p><ul><li>如果是使用npm包出现Cannot find module ‘web-plus’错误，可能是：发布的包中package.json文件中main（入口文件）的值不是主文件名（在这里为index.js)</li></ul><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2018/03/14/在npm发布第一个包/">http://jaymo666.github.io/2018/03/14/在npm发布第一个包/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一个npm包:web-plus&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo博客再配置</title>
    <link href="http://jaymo666.github.io/2018/03/08/%E2%80%9Chexo%E5%8D%9A%E5%AE%A2%E5%86%8D%E9%85%8D%E7%BD%AE%E2%80%9D/"/>
    <id>http://jaymo666.github.io/2018/03/08/“hexo博客再配置”/</id>
    <published>2018-03-08T04:09:30.000Z</published>
    <updated>2018-03-08T07:00:49.228Z</updated>
    
    <content type="html"><![CDATA[<p>记录更换电脑后开启的新功能<a id="more"></a></p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=447960871&auto=0&height=66"></iframe></p><h1 id="1-已结开启的功能"><a href="#1-已结开启的功能" class="headerlink" title="1.已结开启的功能"></a>1.已结开启的功能</h1><h2 id="1-1设置-RSS"><a href="#1-1设置-RSS" class="headerlink" title="1.1设置 RSS"></a>1.1设置 RSS</h2><h2 id="1-2侧边栏社交链接"><a href="#1-2侧边栏社交链接" class="headerlink" title="1.2侧边栏社交链接"></a>1.2侧边栏社交链接</h2><h2 id="1-3设置「动画效果」"><a href="#1-3设置「动画效果」" class="headerlink" title="1.3设置「动画效果」"></a>1.3设置「动画效果」</h2><h2 id="1-4设置「背景动画」"><a href="#1-4设置「背景动画」" class="headerlink" title="1.4设置「背景动画」"></a>1.4设置「背景动画」</h2><h1 id="2-待开启"><a href="#2-待开启" class="headerlink" title="2.待开启"></a>2.待开启</h1><h2 id="2-1设置字体"><a href="#2-1设置字体" class="headerlink" title="2.1设置字体"></a>2.1设置字体</h2><h2 id="2-2开启打赏功能"><a href="#2-2开启打赏功能" class="headerlink" title="2.2开启打赏功能"></a>2.2开启打赏功能</h2><h2 id="2-3订阅微信公众号"><a href="#2-3订阅微信公众号" class="headerlink" title="2.3订阅微信公众号"></a>2.3订阅微信公众号</h2><h1 id="3-hexo-官方插件地址："><a href="#3-hexo-官方插件地址：" class="headerlink" title="3.hexo 官方插件地址："></a>3.hexo 官方插件地址：</h1><p><a href="https://hexo.io/plugins/" target="_blank" rel="noopener">https://hexo.io/plugins/</a></p><h1 id="4-加入的插件："><a href="#4-加入的插件：" class="headerlink" title="4.加入的插件："></a>4.加入的插件：</h1><ol><li>HEXO-自动摘录<a href="https://github.com/ashisherc/hexo-auto-excerpt" target="_blank" rel="noopener">https://github.com/ashisherc/hexo-auto-excerpt</a></li><li>HEXO辅助性live2d <a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">https://github.com/EYHN/hexo-helper-live2d</a></li><li>Hexo跨博客文章推荐插件 <a href="https://github.com/huiwang/hexo-recommended-posts" target="_blank" rel="noopener">https://github.com/huiwang/hexo-recommended-posts</a><br>4.实现点击出现桃心效果</li><li>在网站底部加上访问量</li></ol><p>【参考】<br> 1.<a href="https://www.jianshu.com/p/f054333ac9e6" target="_blank" rel="noopener">https://www.jianshu.com/p/f054333ac9e6</a></p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2018/03/08/“hexo博客再配置”/">http://jaymo666.github.io/2018/03/08/“hexo博客再配置”/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录更换电脑后开启的新功能&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://jaymo666.github.io/categories/hexo/"/>
    
    
      <category term="博客" scheme="http://jaymo666.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo" scheme="http://jaymo666.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>迁移hexo到新电脑</title>
    <link href="http://jaymo666.github.io/2018/03/08/%E8%BF%81%E7%A7%BBhexo%E5%88%B0%E6%96%B0%E7%94%B5%E8%84%91/"/>
    <id>http://jaymo666.github.io/2018/03/08/迁移hexo到新电脑/</id>
    <published>2018-03-08T04:09:30.000Z</published>
    <updated>2018-03-08T04:39:53.924Z</updated>
    
    <content type="html"><![CDATA[<p>在更换新电脑的情况下恢复博客，保留了源码…<a id="more"></a></p><p>1、从官网Git下载git，在新电脑上安装，因为https速度慢，而且每次都要输入口令，常用的是使用ssh。使用下面方法创建：<br>（1）打开git bash，在用户主目录下运行：ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com" target="_blank" rel="noopener">youremail@example.com</a>“ 把其中的邮件地址换成自己的邮件地址，然后一路回车<br>（2）最后完成后，会在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，千万不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。<br>（3）登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」，你就应该看到已经添加的Key。<br>注意：不要在git版本库中运行ssh，然后又将它提交，这样就把密码泄露出去了。<br>（3）<a href="https://coding.net" target="_blank" rel="noopener">https://coding.net</a> 中的ssh与github的共用</p><p>2、下载Node.js，并安装</p><p>3、打开git bash客户端，输入 npm install hexo-cli -g，开始安装hexo</p><p>4、下面就将原来的文件拷贝到新电脑中，但是要注意哪些文件是必须的，哪些文件是可以删除的。<br>（1）讨论下哪些文件是必须拷贝的：首先是之前自己修改的文件，像站点配置_config.yml，theme文件夹里面的主题，以及source里面自己写的博客文件，这些肯定要拷贝的。除此之外，还有三个文件需要有，就是scaffolds文件夹（文章的模板）、package.json（说明使用哪些包）和.gitignore（限定在提交的时候哪些文件可以忽略）。其实，这三个文件不是我们修改的，所以即使丢失了，也没有关系，我们可以建立一个新的文件夹，然后在里面执行hexo init，就会生成这三个文件，我们只需要将它们拷贝过来使用即可。总结：_config.yml，theme/，source/，scaffolds/，package.json，.gitignore，是需要拷贝的。<br>（2）再讨论下哪些文件是不必拷贝的，或者说可以删除的：首先是.git文件，无论是在站点根目录下，还是主题目录下的.git文件，都可以删掉。然后是文件夹node_modules（在用npm install会重新生成），public（这个在用hexo g时会重新生成），.deploy_git文件夹（在使用hexo d时也会重新生成），db.json文件。其实上面这些文件也就是.gitignore文件里面记载的可以忽略的内容。总结：.git/，public/，.deploy_git/，db.json文件需要删除。</p><p>5、在git bash中切换目录到新拷贝的文件夹里，使用 npm install 命令，进行模块安装。很明显我们这里没用hexo init初始化，因为有的文件我们已经拷贝生成过来了，所以不必用hexo init去整体初始化，如果不慎在此时用了hexo init，则站点的配置文件_config.yml里面内容会被清空使用默认值，所以这一步一定要慎重，不要用hexo init。</p><p>6、安装其他的一些必要组件，如果在node_modules里面有的，就不要重复安装了：<br>（1）为了使用hexo d来部署到git上，需要安装<br>npm install hexo-deployer-git –save<br>（2）为了建立RSS订阅，需要安装<br>npm install hexo-generator-feed –save<br>（3）为了建立站点地图，需要安装<br>npm install hexo-generator-sitemap –save<br>插件安装后，有的需要对配置文件_config.yml进行配置，具体怎么配置，可以参考上面插件在github主页上的具体说明</p><p>7、使用hexo g，然后使用hexo d进行部署，如果都没有出错，就转移成功了！</p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2018/03/08/迁移hexo到新电脑/">http://jaymo666.github.io/2018/03/08/迁移hexo到新电脑/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在更换新电脑的情况下恢复博客，保留了源码…&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://jaymo666.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://jaymo666.github.io/tags/hexo/"/>
    
      <category term="github" scheme="http://jaymo666.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://jaymo666.github.io/2018/03/07/hello-world/"/>
    <id>http://jaymo666.github.io/2018/03/07/hello-world/</id>
    <published>2018-03-07T10:59:51.630Z</published>
    <updated>2017-12-03T11:06:54.594Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2018/03/07/hello-world/">http://jaymo666.github.io/2018/03/07/hello-world/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>conda用法</title>
    <link href="http://jaymo666.github.io/2017/12/04/conda%E7%94%A8%E6%B3%95/"/>
    <id>http://jaymo666.github.io/2017/12/04/conda用法/</id>
    <published>2017-12-04T10:07:08.000Z</published>
    <updated>2017-12-04T10:09:42.413Z</updated>
    
    <content type="html"><![CDATA[<p>Conda简单用法及在python2与python3之间切换<a id="more"></a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=447960871&auto=0&height=66"></iframe><h1 id="安装scipy"><a href="#安装scipy" class="headerlink" title="安装scipy"></a>安装scipy</h1><p>conda install scipy</p><h1 id="conda会从从远程搜索scipy的相关信息和依赖项目，对于python-3-4，conda会同时安装numpy和mkl（运算加速的库）"><a href="#conda会从从远程搜索scipy的相关信息和依赖项目，对于python-3-4，conda会同时安装numpy和mkl（运算加速的库）" class="headerlink" title="conda会从从远程搜索scipy的相关信息和依赖项目，对于python 3.4，conda会同时安装numpy和mkl（运算加速的库）"></a>conda会从从远程搜索scipy的相关信息和依赖项目，对于python 3.4，conda会同时安装numpy和mkl（运算加速的库）</h1><h1 id="查看已经安装的packages"><a href="#查看已经安装的packages" class="headerlink" title="查看已经安装的packages"></a>查看已经安装的packages</h1><p>conda list</p><h1 id="最新版的conda是从site-packages文件夹中搜索已经安装的包，不依赖于pip，因此可以显示出通过各种方式安装的包"><a href="#最新版的conda是从site-packages文件夹中搜索已经安装的包，不依赖于pip，因此可以显示出通过各种方式安装的包" class="headerlink" title="最新版的conda是从site-packages文件夹中搜索已经安装的包，不依赖于pip，因此可以显示出通过各种方式安装的包"></a>最新版的conda是从site-packages文件夹中搜索已经安装的包，不依赖于pip，因此可以显示出通过各种方式安装的包</h1><h1 id="查看当前环境下已安装的包"><a href="#查看当前环境下已安装的包" class="headerlink" title="查看当前环境下已安装的包"></a>查看当前环境下已安装的包</h1><p>conda list</p><h1 id="查看某个指定环境的已安装包"><a href="#查看某个指定环境的已安装包" class="headerlink" title="查看某个指定环境的已安装包"></a>查看某个指定环境的已安装包</h1><p>conda list -n python34</p><h1 id="查找package信息"><a href="#查找package信息" class="headerlink" title="查找package信息"></a>查找package信息</h1><p>conda search numpy</p><h1 id="安装package"><a href="#安装package" class="headerlink" title="安装package"></a>安装package</h1><p>conda install -n python34 numpy</p><h1 id="如果不用-n指定环境名称，则被安装在当前活跃环境"><a href="#如果不用-n指定环境名称，则被安装在当前活跃环境" class="headerlink" title="如果不用-n指定环境名称，则被安装在当前活跃环境"></a>如果不用-n指定环境名称，则被安装在当前活跃环境</h1><h1 id="也可以通过-c指定通过某个channel安装"><a href="#也可以通过-c指定通过某个channel安装" class="headerlink" title="也可以通过-c指定通过某个channel安装"></a>也可以通过-c指定通过某个channel安装</h1><h1 id="更新package"><a href="#更新package" class="headerlink" title="更新package"></a>更新package</h1><p>conda update -n python34 numpy</p><h1 id="删除package"><a href="#删除package" class="headerlink" title="删除package"></a>删除package</h1><p>conda remove -n python34 numpy</p><p>conda将conda、python等都视为package，因此，完全可以使用conda来管理conda和python的版本，例如</p><h1 id="更新conda，保持conda最新"><a href="#更新conda，保持conda最新" class="headerlink" title="更新conda，保持conda最新"></a>更新conda，保持conda最新</h1><p>conda update conda</p><h1 id="更新anaconda"><a href="#更新anaconda" class="headerlink" title="更新anaconda"></a>更新anaconda</h1><p>conda update anaconda</p><h1 id="更新python"><a href="#更新python" class="headerlink" title="更新python"></a>更新python</h1><p>conda update python</p><h1 id="假设当前环境是python-3-4-conda会将python升级为3-4-x系列的当前最新版本"><a href="#假设当前环境是python-3-4-conda会将python升级为3-4-x系列的当前最新版本" class="headerlink" title="假设当前环境是python 3.4, conda会将python升级为3.4.x系列的当前最新版本"></a>假设当前环境是python 3.4, conda会将python升级为3.4.x系列的当前最新版本</h1><p>如果创建新的python环境，比如3.4，运行conda create -n python34 python=3.4之后，conda仅安装python 3.4相关的必须项，如python, pip等，如果希望该环境像默认环境那样，安装anaconda集合包，只需要：</p><h1 id="在当前环境下安装anaconda包集合"><a href="#在当前环境下安装anaconda包集合" class="headerlink" title="在当前环境下安装anaconda包集合"></a>在当前环境下安装anaconda包集合</h1><p>conda install anaconda</p><h1 id="结合创建环境的命令，以上操作可以合并为"><a href="#结合创建环境的命令，以上操作可以合并为" class="headerlink" title="结合创建环境的命令，以上操作可以合并为"></a>结合创建环境的命令，以上操作可以合并为</h1><p>conda create -n python34 python=3.4 anaconda</p><h1 id="也可以不用全部安装，根据需求安装自己需要的package即可"><a href="#也可以不用全部安装，根据需求安装自己需要的package即可" class="headerlink" title="也可以不用全部安装，根据需求安装自己需要的package即可"></a>也可以不用全部安装，根据需求安装自己需要的package即可</h1><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2017/12/04/conda用法/">http://jaymo666.github.io/2017/12/04/conda用法/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Conda简单用法及在python2与python3之间切换&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络管理员必备</title>
    <link href="http://jaymo666.github.io/2017/09/26/Network/"/>
    <id>http://jaymo666.github.io/2017/09/26/Network/</id>
    <published>2017-09-26T06:49:47.000Z</published>
    <updated>2017-12-03T11:30:29.248Z</updated>
    
    <content type="html"><![CDATA[<p>本文包括：</p><ul><li>[1]ping命令</li><li>[2]路由器和交换机的差异</li><li>[3]路由器的基本设置</li><li>[4]netsh网络配置命令</li><li>[5]安装失败（未签名）</li><li>[6]管理用户网络应用</li><li>[7]映射网络驱动器</li><li>[8]网络适配器的原理</li><li>[9]交换机的分类</li><li>[10]交换机的功能</li><li>[11]交换机的接口种类</li><li>[12]路由器的工作原理</li><li>[13]初识TCP/IP的分层<a id="more"></a></li></ul><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=447960871&auto=0&height=66"></iframe><h2 id="网络管理员必备"><a href="#网络管理员必备" class="headerlink" title="网络管理员必备"></a>网络管理员必备</h2><h3 id="1-ping命令"><a href="#1-ping命令" class="headerlink" title="[1]ping命令"></a>[1]ping命令</h3><p>“ping”命令是windows系统最长用的命令之一，是通过对一个网址<strong>发送测试数据包</strong>，看对方网址是否有响应并统计响应时间，以此<strong>测试网络</strong>，同时可以很好地帮助我们<strong>分析和判定网络故障</strong>。</p><p>方式：“ping IP地址/域名”</p><ol><li>输入“ping IP地址”回车，我们可以看到本机跟这台网络设备的连接状态，如下图所示是连接正常的。<br>例如：百度首页ip地址：119.75.217.109</li></ol><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\ping百度.JPG" alt="image"></p><p>2.还可以“ping 域名”,例如:ping baidu.com</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\pingbaiducom.JPG" alt="image"></p><p>3.如果“ping”后出现下图所示界面，说明本机跟这台网络设备的网络连接是不通的</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\pingcuo.JPG" alt="image"></p><p>4.键入“ping”直接回车我们还可以看到ping命令加其他参数的使用方法</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\ping.JPG" alt="image"></p><p>5.比如，我们使用“ping IP地址 -t”命令，可以持续的ping指定的主机，如果没有手动停止，ping命令会一直持续下去，我们可以通过“Ctrl+C”停止命令。其他参数的使用方法用户可以自己体验</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\pingt.JPG" alt="image"></p><hr><h3 id="2-路由器和交换机的差异"><a href="#2-路由器和交换机的差异" class="headerlink" title="[2]路由器和交换机的差异"></a>[2]路由器和交换机的差异</h3><h5 id="1-工作层次不同"><a href="#1-工作层次不同" class="headerlink" title="1. 工作层次不同:"></a>1. 工作层次不同:</h5><p>交换机工作在七层模型的第二层（即数据链路层）；而路由器工作在第三层（即网络层）。交换机由于工作在第二层，它的工作原理比较简单，而路由器在第三层，可以得到更多的协议信息，也可以做出更加智能的转发或映射。</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\77.JPG" alt="image"></p><blockquote><p>网络层（第三层）：能提供介质访问和链路管理等功能<br>数据链路层（第二层）：具有寻址和路由选择等功能</p></blockquote><h5 id="2-数据转发依据的对象不同"><a href="#2-数据转发依据的对象不同" class="headerlink" title="2. 数据转发依据的对象不同"></a>2. 数据转发依据的对象不同</h5><p>交换机是利用网络设备的<strong>物理地址（即MAC地址）</strong>来确定转发数据的目的地址；路由器是利用网络设备的<strong>IP地址</strong>来确定转发数据的目的地址。其中<strong>物理地址</strong>是设备本身自带的，由设备的网卡生产厂商分配，已经固化到网卡硬件中，<strong>不可修改</strong>；而<strong>IP地址是在系统软件中分配的，可以修改</strong>。</p><p>通过命令“ipconfig/all”，可以查看本机的物理地址和IP地址。如下图所示，就是我的计算机的网卡信息。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\ip.JPG" alt="image"></p><h5 id="3-路由器可以分割广播域，而交换机不能"><a href="#3-路由器可以分割广播域，而交换机不能" class="headerlink" title="3.路由器可以分割广播域，而交换机不能"></a>3.路由器可以分割广播域，而交换机不能</h5><p><strong>交换机只可以分割冲突域</strong>，不可以分割广播域，<strong>而路由器可以分割广播域</strong>。简单的来说，在同一个交换机下连接的设备，IP都在同一个网段，是属于同一个广播域的，如果不在同一网段，则无法进行通信；而路由器可以分配不同的广播域（即不同的网段），而这些不同网段的设备可以不穿过路由而进行相互通信。</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\广播域.JPG" alt="image"></p><blockquote><p>目前，虽然三层或者第三层以上交换机具有VLAN功能，也可以分割广播域，但是各个广播域之间是不可以相互通信的，他们之前如果要通信交流还是需要路由器的支持。</p></blockquote><h5 id="4-路由器有防火墙服务，而交换机没有"><a href="#4-路由器有防火墙服务，而交换机没有" class="headerlink" title="4.路由器有防火墙服务，而交换机没有"></a>4.路由器有防火墙服务，而交换机没有</h5><p>路由器设置的防火墙是运行在网络层的，通过设置特定的规定，允许或者限制传输的数据通过，或者过滤IP封包，禁止不符合规定的封包通过。而交换机不具备防火墙功能，如果只是通过交换机接通外部网络，相当于闭上眼、光着屁股在大街上跑，很不安全！</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\防火墙.JPG" alt="image"><br><strong>注意：数据安全很重要，路由器、交换机的使用都要慎重！注意保密保护工作！</strong></p><h3 id="3-路由器的基本设置"><a href="#3-路由器的基本设置" class="headerlink" title="[3]路由器的基本设置"></a>[3]路由器的基本设置</h3><p> 要实现多台计算机同时上网，主要设置的地方就是路由器，下面以企业中总路由器下的一个无线路由为大家介绍一下路由器的基本设置过程。</p><p> 1.通过<strong>浏览器登录路由器</strong>。如果是<strong>新路由器</strong>，可以查看路由后面贴<strong>标签</strong>出的默认IP和登录账号、密码；如果是正常<strong>使用中的路由器</strong>，登录地址可以查看计算机的网关，如果登录密码修改过，请咨询管理员。</p><blockquote><p> 电脑和路由器相连：一种是通过网线连接，一种是通过无线连接。</p></blockquote><p>电脑和路由器之间通过网线连接的话，你要在路由器上找到<strong>LAN口和WAN口</strong>。这里讲一下，WAN口全称Wide Area Network（广域网），LAN口全称Wide Area Network（局域网）。一般的路由有很多LAN口，一个WAN口。<strong>WAN口插主网线，LAN插电脑与路由连接的网线</strong>。这样电脑就和路由器连接了。</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\LAN.JPG" alt="image"></p><blockquote><p>电脑连接上了路由器，就可以在浏览器上输入路由器的地址进入路由器的设置界面了</p></blockquote><p>2.<strong>WAN口设置</strong>，“<strong>基本设置</strong>”中的“<strong>快速设置</strong>”，（1）如果外网地址没有固定IP，则类型选择动态；（2）如果外网地址有固定IP或者上层还有路由则将分配IP设置到wan口，如下图所示。</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\快速配置.JPG" alt="image"><br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\外网.JPG" alt="image"></p><p>3.<strong>LAN口的设置</strong>，“基本设置”中的“内网设置”，设置IP地址（即内网中网络设备的网关比如设置成192.168.1.1，如果上层有路由是192.168.1.1，则次路由器可以设置成其他网段192.168.x.1）、子网掩码。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\内网.JPG" alt="image"><br><strong><br>4.“DHCP服务器”的设置</strong>，如果让用户<strong>自动获取IP地址</strong>使用，需要使用DHCP服务器，可以限制用户自动获取IP地址的范围，如下图的“起始IP地址”和“结束IP地址”（可以在上网行为管理的IP地址组中看到）。</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\上网行为.JPG" alt="image"><br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\DHCP.JPG" alt="image"></p><p>5.<strong>无线的“基本设置”</strong>，要启用无线的话，勾选启用开关，并为无线网络设置一个名称，设置无线模式为“11b/g/n混合模式”，来兼容三种无线协议：802.11b、802.11g、802.11n。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\无线.JPG" alt="image"></p><p>6.<strong>无线的“安全设置”</strong>，如果需要做MAC地址绑定的安全管控，需要勾选mac地址“启用”：设置“允许”，将允许上网的计算机mac地址添加到mac地址列表；设置“禁用”，将不允许上网的计算机mac地址添加到mac地址列表。设置加密类型为常用的“WPA2-PSK”，并设置密码<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\无线安全.JPG" alt="image"></p><p>7.<strong>“上网行为管理”设置</strong>，设置允许或者不允许上网的时间段；如果需要管理QQ等常用聊天软件，可以在聊天软件高级设置里进行启用，将允许使用QQ等聊天软件的账号添加到例外列表。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\上班.JPG" alt="image"><br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\QQ.JPG" alt="image"></p><p>8.网络安全中设置内外网的“攻击防御”和“MAC地址绑定”（勾选“禁止未绑定IP/MAC的主机通过”，前面已经说过，不再赘述）<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\外网防御.JPG" alt="image"><br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\IPMAC.JPG" alt="image"></p><p>9.<strong>“端口映射”和“域名转发”</strong>，大多在系统集成中会用到，特别是监控设备想要远程访问，需要将设备的通讯端口等进行路由转发，此处需要注意的是，如果跨多层路由的话，每一层路由都是需要转发的。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\端口.JPG" alt="image"><br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\域名.JPG" alt="image"></p><p>10.修改路由器的登录密码。</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\修改密码.JPG" alt="image"></p><hr><h3 id="4-netsh网络配置命令"><a href="#4-netsh网络配置命令" class="headerlink" title="[4]netsh网络配置命令"></a>[4]netsh网络配置命令</h3><p>netsh是Network Shell的缩写，是windows为我们提供的功能强大的网络配置命令行工具。下面用几个常用的“netsh interface ip show”小命令介绍netsh的用法。</p><p>1.<strong>netsh interface ip show address</strong>:显示本机IP地址配置，包括以太网的ip和本地回环ip地址，以太网ip地址就是我们常说的为本机网卡分配的一个地址，这个容易理解；本地还有ip地址，是一种叫做本地回环接口虚接口，在windows系统中都会采用如下图所示的127.0.0.1这个地址，用以提高网络的健壮性。</p><p>2.如果在上一步的基础上想要显示更多信息，可以用命令：<strong>netsh interface ip show config</strong>。</p><p>3.netsh interface ip show dns:显示本机使用的DNS服务器，同样包括以太网和本地回环接口的DNS信息。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\DNS.JPG" alt="image"></p><p>4.<strong>netsh interface ip show ipnet</strong>:显示本IP地址所在的网络到媒体的映射，我们同时可以看到映射类型和所用接口等信息。</p><p>5.<strong>netsh interface ip show wins</strong>:如果设置了wins服务器，可以用此命令查看wins服务器的地址。</p><p>6.还有一个我喜欢用的不属于“<strong>netsh interface ip</strong>”这一系列的小命令，<strong>netsh firewall show state</strong>:<strong>查看本机防火墙的状态</strong>，每当我们公司某一台办公电脑在连接公司的某个系统连接不上的时候，我会用以查看防火墙状态，我们可以看到启用或禁用的功能模块，以及启用情况。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\防火.JPG" alt="image"></p><hr><h3 id="5-安装失败（未签名）"><a href="#5-安装失败（未签名）" class="headerlink" title="[5]安装失败（未签名）"></a>[5]安装失败（未签名）</h3><p>在我们安装驱动的时候，特别是用驱动精灵等驱动软件安装的时候，会出现“安装失败（未签名）”的情况，如何解决？</p><p>方法/步骤</p><p>1.单击开始菜单里的“运行”，或者通过“windows键+R”打开“运行”，在输入框中输入“sigverif”回车<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\签名.JPG" alt="image"></p><p>2.在打开的文件签名验证里点击“高级”按钮</p><p>3.如下图所示找到下载的驱动（如果未解压，需要先解压），然后点击“确认”按钮</p><p>4.切换到“正在记录”选项，选中如下图所示选项，点击“确定”按钮</p><p>5.回到第二步时候的界面，点击“开始”按钮，我们可以看到下图所示列表界面，点击“关闭”即可</p><p>6.从设备管理器安装驱动，右键单击我的电脑（xp）/计算机（win7）/这台电脑（win8），点击“管理”，在“计算机管理”中右侧边栏中单击“设备管理器”，找到我们要安装驱动的这个硬件，右键单击，选择“更新驱动程序”</p><p>7.勾选“从列表或指定位置安装”，点击“下一步”按钮</p><p>8.选择驱动程序解压后的文件夹，点击“下一步”按钮</p><p>9.到安装界面，用户需等待，知道出现安装成功的界面，点击“完成”按钮即可</p><p>10.返回到设备管理器，我们可以看到，此驱动已经安装完成</p><hr><h3 id="6-管理用户网络应用"><a href="#6-管理用户网络应用" class="headerlink" title="[6]管理用户网络应用"></a>[6]管理用户网络应用</h3><p>现在各种网络应用程序纷繁复杂，而p2p软件又是其中最为流行的一种，而且提供了多样化得登陆方式，在此，我们以最常用的QQ为例。</p><p>我们大家都知道，QQ本身支持UDP、HTTP和HTTPS三种登陆方式，而且可以使用代理，意思是说，只要你允许了HTTP协议，QQ就可以登陆。</p><p>现在我们以封锁QQ为例，介绍一下，如何利用路由级的网络防火墙管理用户网络应用。</p><h5 id="1-QQ登陆原理"><a href="#1-QQ登陆原理" class="headerlink" title="1.QQ登陆原理"></a>1.QQ登陆原理</h5><ol><li><p>QQ登录登陆的过程，由向服务器群的8000端口发送UDP数据包，从服务器群的回复中选择一个最快的作为登陆服务器。</p></li><li><p>如果没有服务器回复UDP数据包，则使用TCP80/443端口来进行连接。</p></li><li><p>QQ服务器：</p></li></ol><ul><li>UDP8000端口类18个</li><li>TCPHTTP连接服务器5个</li><li>会员VIP服务器使用HTTPS443连接</li></ul><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\QQ原理.JPG" alt="image"></p><h5 id="2-如何封锁"><a href="#2-如何封锁" class="headerlink" title="2.如何封锁"></a>2.如何封锁</h5><p>1.上面我们知道，QQ可以使用HTTP直接连接，一般不能封锁HTTP协议，所以最好的办法就是封锁它的服务器IP地址，但是QQ还可以使用代理登陆，这种情况我们就得在路由级防火墙中的HTTP检查机制中设置禁止QQ的HTTP连接。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\QQ代理.JPG" alt="image"><br>2.首先，配置用户访问规则，使用计算机集定义目的网络。也就是做好禁止内部客户访问QQ服务器的访问策略。</p><p>3.其次，配置HTTP策略，理由路由器的HTTP深层检查机制，禁止QQ使用HTTP代理。在允许ＱＱ使用HTTP代理的策略上点击右键，选中“配置HTTP”</p><p>4.在弹出的“为规则配置HTTP策略”对话框中，点击“签名”，然后点击“添加”，在弹出的“签名”对话框中，输入名称为“QQ”，指定签名搜索条件为在“请求URL”中搜索“tencent.com”，找到则阻止这个连接</p><p>5.最后，在防火墙策略选项中，点击“应用”来保存修改和更新防火墙策略，此时，QQ已经不能通过代理服务器登录了</p><hr><h3 id="7-映射网络驱动器"><a href="#7-映射网络驱动器" class="headerlink" title="[7]映射网络驱动器"></a>[7]映射网络驱动器</h3><p>映射网络驱动器” 的意思是将局域网中的某个目录（一般是共享的文件夹之类的）映射成本地驱动器号，就是说把网络上其他机器的共享的文件夹映射自己机器上的一个磁盘，这样可以提高访问时间，相当于一个打开共享的快捷方式。</p><p>1.首先，找到这个共享文件夹，我们可以在网络里找到这台设备，或者打开开始菜单的“运行”，输入：“\这台设备的IP地址”，比如此例中的“\192.168.1.52”<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\本机IP.JPG" alt="image"></p><p>2.在打开的共享界面，找到并右键单击要映射驱动器的文件件，选择“映射网络驱动器”<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\映射.JPG" alt="image"></p><p>3.在映射驱动器的界面，选择好驱动器盘符，点击“完成”即可完成设置</p><p>4.打开资源管理器，我们可以看到，已经有了该驱动器，日常使用过程中直接点击打开即可</p><hr><h3 id="8-网络适配器的原理"><a href="#8-网络适配器的原理" class="headerlink" title="[8]网络适配器的原理"></a>[8]网络适配器的原理</h3><p>网络适配器，也就是我们说的网卡，有些维修人员也叫网络接口卡，是计算机和网络电缆之间的物理接口，下面我们根据网络适配器需要完成的任务介绍一下它的工作原理。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\网卡.JPG" alt="image"></p><p>1.为在<strong>计算机使用的数据</strong>（<strong>并行数据</strong>）和<strong>电缆上传输的电信号</strong>（<strong>串行数据</strong>）之间提供数据转换的功能。比如我们用的一个共享打印机，计算机直接连接打印机用的是并行数据，而如果我们通过网络连接别人共享的打印机，就是通过串行数据转换为并行数据来实现。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\打印.JPG" alt="image"><br>2.判断从电缆接收的数据是否为传输给该计算机的数据。</p><p>3.在计算机和电缆之间控制数据流，每块网卡都有一个唯一的标识，我们一般叫做MAC地址，大部分网卡的MAC地址烧录在卡上的ROM芯片中，MAC地址有6段组成，通常表示为12个16进制数。<br>我们可以通过命令提示符查看本机网卡的信息，操作步骤：1、单击开始菜单里的“运行”，在输入框中输入“cmd”，然后回车。2、在命令提示符界面输入“ipconfig /all”命令，回车，我们可以看到以下信息。<br>如图所示的是本机无线网卡的信息，其中前3字节“A6-17-31”表示厂商代码，有IEEE负责分配；后3个字节“30-49-E2”表示网卡序号，由网卡厂商负责。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\MAC地址.JPG" alt="image"></p><hr><h3 id="9-交换机的分类"><a href="#9-交换机的分类" class="headerlink" title="[9]交换机的分类"></a>[9]交换机的分类</h3><p>交换机是网络连接的基础，有了交换机，就可以实现更多电脑的共享上网</p><p>1.广义上来讲，交换机分为两种：<strong>广域交换机</strong>和<strong>局域网交换机</strong>。广域网交换机主要用于电信领域，提供通信用的基础平台，我们平常接触很少；而局域网交换机是我们日常使用最多的，主要应用于日常的局域网络，连接计算机和网络打印机的终端设备<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\交换机.JPG" alt="image"></p><p>2.从传输介质和传输速度上可以分为以太网交换机、快速以太网交换机、千兆以太网交换机、FDDI交换机、ATM交换机和令牌交换机等</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\交换机速率.JPG" alt="image"></p><p>3.从规模应用上可以分为企业级、部门级和工作组交换机<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\交换机企业.JPG" alt="image"></p><h3 id="10-交换机的功能"><a href="#10-交换机的功能" class="headerlink" title="[10]交换机的功能"></a>[10]交换机的功能</h3><h5 id="1-交换机功能"><a href="#1-交换机功能" class="headerlink" title="1.交换机功能"></a>1.交换机功能</h5><p>学习功能，局域网内交换机会了解跟每一个插口相连接的<strong>MAC地址</strong>，并将地址同<strong>相应的端口</strong>映射起来存放在<strong>交换机缓存中的MAC地址表中</strong></p><h5 id="2-转发-过滤功能"><a href="#2-转发-过滤功能" class="headerlink" title="2.转发/过滤功能"></a>2.转发/过滤功能</h5><p>当一个数据帧的目的地址在MAC地址表中有映射时，它被转发到连接目的节点的端口而不是所有端口（如该数据帧为广播/组播帧则转发至所有端口）<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\MAC地址表.JPG" alt="image"></p><h5 id="3-消除回路功能"><a href="#3-消除回路功能" class="headerlink" title="3.消除回路功能"></a>3.消除回路功能</h5><p>当交换机包括一个冗余回路时，以太网交换机通过<strong>生成树协议</strong>避免回路的产生，同时允许存在<strong>后背路径</strong><br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\回路.JPG" alt="image"></p><h5 id="4-兼容功能"><a href="#4-兼容功能" class="headerlink" title="4.兼容功能"></a>4.兼容功能</h5><p>交换机除了能连接两种同类型的网络之外，还可以在不同类型的网路（如以太网和快速以太网）之间起到互联作用。而且现在的交换机没有很严格的类型之分，百兆交换机一般也会加两个千兆口或光纤接入口<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\消除.JPG" alt="image"></p><hr><h3 id="11-交换机的接口种"><a href="#11-交换机的接口种" class="headerlink" title="[11]交换机的接口种"></a>[11]交换机的接口种</h3><h5 id="1-双绞线RJ-45接口-水晶头"><a href="#1-双绞线RJ-45接口-水晶头" class="headerlink" title="1.双绞线RJ-45接口-水晶头"></a>1.双绞线RJ-45接口-水晶头</h5><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\水晶头.JPG" alt="image"></p><h5 id="2-光纤接口"><a href="#2-光纤接口" class="headerlink" title="2.光纤接口"></a>2.光纤接口</h5><p>光纤需要熔接到带插头的尾纤，常见的尾纤插头有SC。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\SC.JPG" alt="image"></p><hr><h3 id="12-路由器的工作原理"><a href="#12-路由器的工作原理" class="headerlink" title="[12]路由器的工作原理"></a>[12]路由器的工作原理</h3><p>路由器，大家都很熟悉了，办公室或者家里凡有两台以上的电脑需要上网的一般都安装了路由器，只有安装了路由器才能实现多台电脑同时上网。我们就了解下路由器的配置原理。</p><h5 id="1-路由器的概念"><a href="#1-路由器的概念" class="headerlink" title="1.路由器的概念"></a>1.路由器的概念</h5><p>1.所谓“路由”，就是把数据从一个地方传送到另一个地方的行为和动作，路由器就是执行这个动作的机器，英文名Router</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\路由.JPG" alt="image"></p><p>2.路由器能将不同网络或网段之间的数据信息进行“翻译”，以使他们能够相互“读”懂对方的数据，从而构建更大的网络。</p><h5 id="2-路由器的典型功能"><a href="#2-路由器的典型功能" class="headerlink" title="2.路由器的典型功能"></a>2.路由器的典型功能</h5><ul><li><strong>数据通道功能</strong></li></ul><p>包括转发决定、背板转发以及输出链路调度等，一般由特定的硬件来完成</p><ul><li><strong>控制功能</strong></li></ul><p>一般用软件来实现，包括与相邻路由器之间的信息交换、系统配置、系统管理等</p><h5 id="3-路由器的主要功能"><a href="#3-路由器的主要功能" class="headerlink" title="3.路由器的主要功能"></a>3.路由器的主要功能</h5><ul><li><strong>网络互连</strong></li></ul><p>路由器支持各种局域网和广域网接口，主要用于互连局域网和广域网，实现不同网络互相通信<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\互连.JPG" alt="image"></p><ul><li><strong>数据处理</strong></li></ul><p>提供包括分组过滤、分组转发、优先级、复用、加密、压缩和防火墙等功能<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\过滤.JPG" alt="image"></p><ul><li><strong>网络管理</strong></li></ul><p>路由器提供包括配置管理、性能管理、容错管理和流量控制管理等功能</p><p><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\管理.JPG" alt="image"></p><h5 id="4-路由器的工作原理"><a href="#4-路由器的工作原理" class="headerlink" title="4.路由器的工作原理"></a>4.路由器的工作原理</h5><ul><li><p>接收来自它连接的某个网络的数据</p></li><li><p>将数据向上传递，并且（必要时）重新组合IP数据报</p></li><li><p>检查IP头部中的目的地址，如果目的地址位于发出数据的那个网络，那么路由器就放下被认为已经达到目的地的数据，因为数据是在目的计算机所在网络上传输</p></li><li><p>如果数据要送往另一个网络，那么路由器就查询路由表，以确定数据要转发到的目的地</p></li><li><p>路由器确定哪个适配器负责接收数据后，就通过相应的软件传递数据，以便通过网络来传送数据</p></li></ul><hr><h3 id="13-初识TCP-IP的分层"><a href="#13-初识TCP-IP的分层" class="headerlink" title="[13]初识TCP/IP的分层"></a>[13]初识TCP/IP的分层</h3><p>大家可能经常使用TCP/IP协议，在进行网络配置或修改IP地址等操作的时候会用到该处，但很少有人去深入挖掘，在此我们简单的了解一下TCP/IP的分层。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\分层.JPG" alt="image"></p><h5 id="1-TCP-IP协议"><a href="#1-TCP-IP协议" class="headerlink" title="1.TCP/IP协议"></a>1.TCP/IP协议</h5><ul><li><p>Internet采用了TCP/IP协议，但这并不是一个单一的协议，我们可能知道，TCP即传输控制协议，IP为网间协议，TCP/IP我们常常描述为互联网协议集。但可能很少人知道TCP/IP也是一种分层模型。它是基于<strong>硬件层次</strong>上的四个概念性层次构成，分别是<strong>网络接口层（数据链路层）、IP层（网络层）、传输层、应用层</strong>。<br><img src="/2017/09/26/Network/C:/Users\可汗金斯\Desktop\介质.JPG" alt="image"></p></li><li><p>网络接口层:也称数据链路层，这是TCP/IP最底层。功能:负责接收IP数据报并发送至选定的网络。</p></li><li><p>IP层:<strong>IP层处理机器之间的通信</strong>。功能:它接收来自传输层的请求，<strong>将带有目的地址的分组发送出去</strong>。将分组封装到数据报中，填入数据报头，使用路由算法以决定是直接将数据报传送至目的主机还是传给路由器，然后把数据报送至相应的网络接口来传送。</p></li><li>传输层:是提供应用层之间的通信，即端到端的通信。功能:<strong>管理信息流，提供可靠的传输服务</strong>，以确保数据无差错的地按序到达。</li></ul><h5 id="2-TCP-IP模型的分界线"><a href="#2-TCP-IP模型的分界线" class="headerlink" title="2.TCP/IP模型的分界线"></a>2.TCP/IP模型的分界线</h5><p>协议地址分界线:以区分高层和低层的寻址，<strong>高层寻址使用IP地址</strong>，<strong>低层寻址使用物理地址</strong>。应用程序IP层之上的协议软件只使用IP地址，而网络接口层处理物理地址。</p><ul><li>操作系统分界线:以区分系统与应用程序。<strong>在传输层和应用层之间。</strong></li><li><h5 id="3-复用与分解"><a href="#3-复用与分解" class="headerlink" title="3.复用与分解"></a>3.复用与分解</h5></li></ul><p>发送报文时，发送方在报文中加和了报文类型、选用协议等附加信息。所有的报文以帧的形式在网络中复用传送，形成一个分组流。在接收方收到分组时，参考附加信息对接收到的分组进行分解。</p><hr><p>参考网址：<a href="https://jingyan.baidu.com/season/38734" target="_blank" rel="noopener">https://jingyan.baidu.com/season/38734</a></p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2017/09/26/Network/">http://jaymo666.github.io/2017/09/26/Network/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[1]ping命令&lt;/li&gt;
&lt;li&gt;[2]路由器和交换机的差异&lt;/li&gt;
&lt;li&gt;[3]路由器的基本设置&lt;/li&gt;
&lt;li&gt;[4]netsh网络配置命令&lt;/li&gt;
&lt;li&gt;[5]安装失败（未签名）&lt;/li&gt;
&lt;li&gt;[6]管理用户网络应用&lt;/li&gt;
&lt;li&gt;[7]映射网络驱动器&lt;/li&gt;
&lt;li&gt;[8]网络适配器的原理&lt;/li&gt;
&lt;li&gt;[9]交换机的分类&lt;/li&gt;
&lt;li&gt;[10]交换机的功能&lt;/li&gt;
&lt;li&gt;[11]交换机的接口种类&lt;/li&gt;
&lt;li&gt;[12]路由器的工作原理&lt;/li&gt;
&lt;li&gt;[13]初识TCP/IP的分层&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="网络" scheme="http://jaymo666.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://jaymo666.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>网络管理员必备</title>
    <link href="http://jaymo666.github.io/2017/09/26/Network(1)/"/>
    <id>http://jaymo666.github.io/2017/09/26/Network(1)/</id>
    <published>2017-09-26T06:49:47.000Z</published>
    <updated>2017-12-03T12:42:18.345Z</updated>
    
    <content type="html"><![CDATA[<p>本文包括：</p><ul><li>[1]ping命令</li><li>[2]路由器和交换机的差异</li><li>[3]路由器的基本设置</li><li>[4]netsh网络配置命令</li><li>[5]安装失败（未签名）</li><li>[6]管理用户网络应用</li><li>[7]映射网络驱动器</li><li>[8]网络适配器的原理</li><li>[9]交换机的分类</li><li>[10]交换机的功能</li><li>[11]交换机的接口种类</li><li>[12]路由器的工作原理</li><li>[13]初识TCP/IP的分层<a id="more"></a></li></ul><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=447960871&auto=0&height=66"></iframe><h2 id="网络管理员必备"><a href="#网络管理员必备" class="headerlink" title="网络管理员必备"></a>网络管理员必备</h2><h3 id="1-ping命令"><a href="#1-ping命令" class="headerlink" title="[1]ping命令"></a>[1]ping命令</h3><p>“ping”命令是windows系统最长用的命令之一，是通过对一个网址<strong>发送测试数据包</strong>，看对方网址是否有响应并统计响应时间，以此<strong>测试网络</strong>，同时可以很好地帮助我们<strong>分析和判定网络故障</strong>。</p><p>方式：“ping IP地址/域名”</p><ol><li>输入“ping IP地址”回车，我们可以看到本机跟这台网络设备的连接状态，如下图所示是连接正常的。<br>例如：百度首页ip地址：119.75.217.109</li></ol><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\ping百度.JPG" alt="image"></p><p>2.还可以“ping 域名”,例如:ping baidu.com</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\pingbaiducom.JPG" alt="image"></p><p>3.如果“ping”后出现下图所示界面，说明本机跟这台网络设备的网络连接是不通的</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\pingcuo.JPG" alt="image"></p><p>4.键入“ping”直接回车我们还可以看到ping命令加其他参数的使用方法</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\ping.JPG" alt="image"></p><p>5.比如，我们使用“ping IP地址 -t”命令，可以持续的ping指定的主机，如果没有手动停止，ping命令会一直持续下去，我们可以通过“Ctrl+C”停止命令。其他参数的使用方法用户可以自己体验</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\pingt.JPG" alt="image"></p><hr><h3 id="2-路由器和交换机的差异"><a href="#2-路由器和交换机的差异" class="headerlink" title="[2]路由器和交换机的差异"></a>[2]路由器和交换机的差异</h3><h5 id="1-工作层次不同"><a href="#1-工作层次不同" class="headerlink" title="1. 工作层次不同:"></a>1. 工作层次不同:</h5><p>交换机工作在七层模型的第二层（即数据链路层）；而路由器工作在第三层（即网络层）。交换机由于工作在第二层，它的工作原理比较简单，而路由器在第三层，可以得到更多的协议信息，也可以做出更加智能的转发或映射。</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\77.JPG" alt="image"></p><blockquote><p>网络层（第三层）：能提供介质访问和链路管理等功能<br>数据链路层（第二层）：具有寻址和路由选择等功能</p></blockquote><h5 id="2-数据转发依据的对象不同"><a href="#2-数据转发依据的对象不同" class="headerlink" title="2. 数据转发依据的对象不同"></a>2. 数据转发依据的对象不同</h5><p>交换机是利用网络设备的<strong>物理地址（即MAC地址）</strong>来确定转发数据的目的地址；路由器是利用网络设备的<strong>IP地址</strong>来确定转发数据的目的地址。其中<strong>物理地址</strong>是设备本身自带的，由设备的网卡生产厂商分配，已经固化到网卡硬件中，<strong>不可修改</strong>；而<strong>IP地址是在系统软件中分配的，可以修改</strong>。</p><p>通过命令“ipconfig/all”，可以查看本机的物理地址和IP地址。如下图所示，就是我的计算机的网卡信息。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\ip.JPG" alt="image"></p><h5 id="3-路由器可以分割广播域，而交换机不能"><a href="#3-路由器可以分割广播域，而交换机不能" class="headerlink" title="3.路由器可以分割广播域，而交换机不能"></a>3.路由器可以分割广播域，而交换机不能</h5><p><strong>交换机只可以分割冲突域</strong>，不可以分割广播域，<strong>而路由器可以分割广播域</strong>。简单的来说，在同一个交换机下连接的设备，IP都在同一个网段，是属于同一个广播域的，如果不在同一网段，则无法进行通信；而路由器可以分配不同的广播域（即不同的网段），而这些不同网段的设备可以不穿过路由而进行相互通信。</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\广播域.JPG" alt="image"></p><blockquote><p>目前，虽然三层或者第三层以上交换机具有VLAN功能，也可以分割广播域，但是各个广播域之间是不可以相互通信的，他们之前如果要通信交流还是需要路由器的支持。</p></blockquote><h5 id="4-路由器有防火墙服务，而交换机没有"><a href="#4-路由器有防火墙服务，而交换机没有" class="headerlink" title="4.路由器有防火墙服务，而交换机没有"></a>4.路由器有防火墙服务，而交换机没有</h5><p>路由器设置的防火墙是运行在网络层的，通过设置特定的规定，允许或者限制传输的数据通过，或者过滤IP封包，禁止不符合规定的封包通过。而交换机不具备防火墙功能，如果只是通过交换机接通外部网络，相当于闭上眼、光着屁股在大街上跑，很不安全！</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\防火墙.JPG" alt="image"><br><strong>注意：数据安全很重要，路由器、交换机的使用都要慎重！注意保密保护工作！</strong></p><h3 id="3-路由器的基本设置"><a href="#3-路由器的基本设置" class="headerlink" title="[3]路由器的基本设置"></a>[3]路由器的基本设置</h3><p> 要实现多台计算机同时上网，主要设置的地方就是路由器，下面以企业中总路由器下的一个无线路由为大家介绍一下路由器的基本设置过程。</p><p> 1.通过<strong>浏览器登录路由器</strong>。如果是<strong>新路由器</strong>，可以查看路由后面贴<strong>标签</strong>出的默认IP和登录账号、密码；如果是正常<strong>使用中的路由器</strong>，登录地址可以查看计算机的网关，如果登录密码修改过，请咨询管理员。</p><blockquote><p> 电脑和路由器相连：一种是通过网线连接，一种是通过无线连接。</p></blockquote><p>电脑和路由器之间通过网线连接的话，你要在路由器上找到<strong>LAN口和WAN口</strong>。这里讲一下，WAN口全称Wide Area Network（广域网），LAN口全称Wide Area Network（局域网）。一般的路由有很多LAN口，一个WAN口。<strong>WAN口插主网线，LAN插电脑与路由连接的网线</strong>。这样电脑就和路由器连接了。</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\LAN.JPG" alt="image"></p><blockquote><p>电脑连接上了路由器，就可以在浏览器上输入路由器的地址进入路由器的设置界面了</p></blockquote><p>2.<strong>WAN口设置</strong>，“<strong>基本设置</strong>”中的“<strong>快速设置</strong>”，（1）如果外网地址没有固定IP，则类型选择动态；（2）如果外网地址有固定IP或者上层还有路由则将分配IP设置到wan口，如下图所示。</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\快速配置.JPG" alt="image"><br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\外网.JPG" alt="image"></p><p>3.<strong>LAN口的设置</strong>，“基本设置”中的“内网设置”，设置IP地址（即内网中网络设备的网关比如设置成192.168.1.1，如果上层有路由是192.168.1.1，则次路由器可以设置成其他网段192.168.x.1）、子网掩码。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\内网.JPG" alt="image"><br><strong><br>4.“DHCP服务器”的设置</strong>，如果让用户<strong>自动获取IP地址</strong>使用，需要使用DHCP服务器，可以限制用户自动获取IP地址的范围，如下图的“起始IP地址”和“结束IP地址”（可以在上网行为管理的IP地址组中看到）。</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\上网行为.JPG" alt="image"><br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\DHCP.JPG" alt="image"></p><p>5.<strong>无线的“基本设置”</strong>，要启用无线的话，勾选启用开关，并为无线网络设置一个名称，设置无线模式为“11b/g/n混合模式”，来兼容三种无线协议：802.11b、802.11g、802.11n。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\无线.JPG" alt="image"></p><p>6.<strong>无线的“安全设置”</strong>，如果需要做MAC地址绑定的安全管控，需要勾选mac地址“启用”：设置“允许”，将允许上网的计算机mac地址添加到mac地址列表；设置“禁用”，将不允许上网的计算机mac地址添加到mac地址列表。设置加密类型为常用的“WPA2-PSK”，并设置密码<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\无线安全.JPG" alt="image"></p><p>7.<strong>“上网行为管理”设置</strong>，设置允许或者不允许上网的时间段；如果需要管理QQ等常用聊天软件，可以在聊天软件高级设置里进行启用，将允许使用QQ等聊天软件的账号添加到例外列表。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\上班.JPG" alt="image"><br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\QQ.JPG" alt="image"></p><p>8.网络安全中设置内外网的“攻击防御”和“MAC地址绑定”（勾选“禁止未绑定IP/MAC的主机通过”，前面已经说过，不再赘述）<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\外网防御.JPG" alt="image"><br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\IPMAC.JPG" alt="image"></p><p>9.<strong>“端口映射”和“域名转发”</strong>，大多在系统集成中会用到，特别是监控设备想要远程访问，需要将设备的通讯端口等进行路由转发，此处需要注意的是，如果跨多层路由的话，每一层路由都是需要转发的。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\端口.JPG" alt="image"><br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\域名.JPG" alt="image"></p><p>10.修改路由器的登录密码。</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\修改密码.JPG" alt="image"></p><hr><h3 id="4-netsh网络配置命令"><a href="#4-netsh网络配置命令" class="headerlink" title="[4]netsh网络配置命令"></a>[4]netsh网络配置命令</h3><p>netsh是Network Shell的缩写，是windows为我们提供的功能强大的网络配置命令行工具。下面用几个常用的“netsh interface ip show”小命令介绍netsh的用法。</p><p>1.<strong>netsh interface ip show address</strong>:显示本机IP地址配置，包括以太网的ip和本地回环ip地址，以太网ip地址就是我们常说的为本机网卡分配的一个地址，这个容易理解；本地还有ip地址，是一种叫做本地回环接口虚接口，在windows系统中都会采用如下图所示的127.0.0.1这个地址，用以提高网络的健壮性。</p><p>2.如果在上一步的基础上想要显示更多信息，可以用命令：<strong>netsh interface ip show config</strong>。</p><p>3.netsh interface ip show dns:显示本机使用的DNS服务器，同样包括以太网和本地回环接口的DNS信息。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\DNS.JPG" alt="image"></p><p>4.<strong>netsh interface ip show ipnet</strong>:显示本IP地址所在的网络到媒体的映射，我们同时可以看到映射类型和所用接口等信息。</p><p>5.<strong>netsh interface ip show wins</strong>:如果设置了wins服务器，可以用此命令查看wins服务器的地址。</p><p>6.还有一个我喜欢用的不属于“<strong>netsh interface ip</strong>”这一系列的小命令，<strong>netsh firewall show state</strong>:<strong>查看本机防火墙的状态</strong>，每当我们公司某一台办公电脑在连接公司的某个系统连接不上的时候，我会用以查看防火墙状态，我们可以看到启用或禁用的功能模块，以及启用情况。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\防火.JPG" alt="image"></p><hr><h3 id="5-安装失败（未签名）"><a href="#5-安装失败（未签名）" class="headerlink" title="[5]安装失败（未签名）"></a>[5]安装失败（未签名）</h3><p>在我们安装驱动的时候，特别是用驱动精灵等驱动软件安装的时候，会出现“安装失败（未签名）”的情况，如何解决？</p><p>方法/步骤</p><p>1.单击开始菜单里的“运行”，或者通过“windows键+R”打开“运行”，在输入框中输入“sigverif”回车<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\签名.JPG" alt="image"></p><p>2.在打开的文件签名验证里点击“高级”按钮</p><p>3.如下图所示找到下载的驱动（如果未解压，需要先解压），然后点击“确认”按钮</p><p>4.切换到“正在记录”选项，选中如下图所示选项，点击“确定”按钮</p><p>5.回到第二步时候的界面，点击“开始”按钮，我们可以看到下图所示列表界面，点击“关闭”即可</p><p>6.从设备管理器安装驱动，右键单击我的电脑（xp）/计算机（win7）/这台电脑（win8），点击“管理”，在“计算机管理”中右侧边栏中单击“设备管理器”，找到我们要安装驱动的这个硬件，右键单击，选择“更新驱动程序”</p><p>7.勾选“从列表或指定位置安装”，点击“下一步”按钮</p><p>8.选择驱动程序解压后的文件夹，点击“下一步”按钮</p><p>9.到安装界面，用户需等待，知道出现安装成功的界面，点击“完成”按钮即可</p><p>10.返回到设备管理器，我们可以看到，此驱动已经安装完成</p><hr><h3 id="6-管理用户网络应用"><a href="#6-管理用户网络应用" class="headerlink" title="[6]管理用户网络应用"></a>[6]管理用户网络应用</h3><p>现在各种网络应用程序纷繁复杂，而p2p软件又是其中最为流行的一种，而且提供了多样化得登陆方式，在此，我们以最常用的QQ为例。</p><p>我们大家都知道，QQ本身支持UDP、HTTP和HTTPS三种登陆方式，而且可以使用代理，意思是说，只要你允许了HTTP协议，QQ就可以登陆。</p><p>现在我们以封锁QQ为例，介绍一下，如何利用路由级的网络防火墙管理用户网络应用。</p><h5 id="1-QQ登陆原理"><a href="#1-QQ登陆原理" class="headerlink" title="1.QQ登陆原理"></a>1.QQ登陆原理</h5><ol><li><p>QQ登录登陆的过程，由向服务器群的8000端口发送UDP数据包，从服务器群的回复中选择一个最快的作为登陆服务器。</p></li><li><p>如果没有服务器回复UDP数据包，则使用TCP80/443端口来进行连接。</p></li><li><p>QQ服务器：</p></li></ol><ul><li>UDP8000端口类18个</li><li>TCPHTTP连接服务器5个</li><li>会员VIP服务器使用HTTPS443连接</li></ul><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\QQ原理.JPG" alt="image"></p><h5 id="2-如何封锁"><a href="#2-如何封锁" class="headerlink" title="2.如何封锁"></a>2.如何封锁</h5><p>1.上面我们知道，QQ可以使用HTTP直接连接，一般不能封锁HTTP协议，所以最好的办法就是封锁它的服务器IP地址，但是QQ还可以使用代理登陆，这种情况我们就得在路由级防火墙中的HTTP检查机制中设置禁止QQ的HTTP连接。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\QQ代理.JPG" alt="image"><br>2.首先，配置用户访问规则，使用计算机集定义目的网络。也就是做好禁止内部客户访问QQ服务器的访问策略。</p><p>3.其次，配置HTTP策略，理由路由器的HTTP深层检查机制，禁止QQ使用HTTP代理。在允许ＱＱ使用HTTP代理的策略上点击右键，选中“配置HTTP”</p><p>4.在弹出的“为规则配置HTTP策略”对话框中，点击“签名”，然后点击“添加”，在弹出的“签名”对话框中，输入名称为“QQ”，指定签名搜索条件为在“请求URL”中搜索“tencent.com”，找到则阻止这个连接</p><p>5.最后，在防火墙策略选项中，点击“应用”来保存修改和更新防火墙策略，此时，QQ已经不能通过代理服务器登录了</p><hr><h3 id="7-映射网络驱动器"><a href="#7-映射网络驱动器" class="headerlink" title="[7]映射网络驱动器"></a>[7]映射网络驱动器</h3><p>映射网络驱动器” 的意思是将局域网中的某个目录（一般是共享的文件夹之类的）映射成本地驱动器号，就是说把网络上其他机器的共享的文件夹映射自己机器上的一个磁盘，这样可以提高访问时间，相当于一个打开共享的快捷方式。</p><p>1.首先，找到这个共享文件夹，我们可以在网络里找到这台设备，或者打开开始菜单的“运行”，输入：“\这台设备的IP地址”，比如此例中的“\192.168.1.52”<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\本机IP.JPG" alt="image"></p><p>2.在打开的共享界面，找到并右键单击要映射驱动器的文件件，选择“映射网络驱动器”<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\映射.JPG" alt="image"></p><p>3.在映射驱动器的界面，选择好驱动器盘符，点击“完成”即可完成设置</p><p>4.打开资源管理器，我们可以看到，已经有了该驱动器，日常使用过程中直接点击打开即可</p><hr><h3 id="8-网络适配器的原理"><a href="#8-网络适配器的原理" class="headerlink" title="[8]网络适配器的原理"></a>[8]网络适配器的原理</h3><p>网络适配器，也就是我们说的网卡，有些维修人员也叫网络接口卡，是计算机和网络电缆之间的物理接口，下面我们根据网络适配器需要完成的任务介绍一下它的工作原理。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\网卡.JPG" alt="image"></p><p>1.为在<strong>计算机使用的数据</strong>（<strong>并行数据</strong>）和<strong>电缆上传输的电信号</strong>（<strong>串行数据</strong>）之间提供数据转换的功能。比如我们用的一个共享打印机，计算机直接连接打印机用的是并行数据，而如果我们通过网络连接别人共享的打印机，就是通过串行数据转换为并行数据来实现。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\打印.JPG" alt="image"><br>2.判断从电缆接收的数据是否为传输给该计算机的数据。</p><p>3.在计算机和电缆之间控制数据流，每块网卡都有一个唯一的标识，我们一般叫做MAC地址，大部分网卡的MAC地址烧录在卡上的ROM芯片中，MAC地址有6段组成，通常表示为12个16进制数。<br>我们可以通过命令提示符查看本机网卡的信息，操作步骤：1、单击开始菜单里的“运行”，在输入框中输入“cmd”，然后回车。2、在命令提示符界面输入“ipconfig /all”命令，回车，我们可以看到以下信息。<br>如图所示的是本机无线网卡的信息，其中前3字节“A6-17-31”表示厂商代码，有IEEE负责分配；后3个字节“30-49-E2”表示网卡序号，由网卡厂商负责。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\MAC地址.JPG" alt="image"></p><hr><h3 id="9-交换机的分类"><a href="#9-交换机的分类" class="headerlink" title="[9]交换机的分类"></a>[9]交换机的分类</h3><p>交换机是网络连接的基础，有了交换机，就可以实现更多电脑的共享上网</p><p>1.广义上来讲，交换机分为两种：<strong>广域交换机</strong>和<strong>局域网交换机</strong>。广域网交换机主要用于电信领域，提供通信用的基础平台，我们平常接触很少；而局域网交换机是我们日常使用最多的，主要应用于日常的局域网络，连接计算机和网络打印机的终端设备<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\交换机.JPG" alt="image"></p><p>2.从传输介质和传输速度上可以分为以太网交换机、快速以太网交换机、千兆以太网交换机、FDDI交换机、ATM交换机和令牌交换机等</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\交换机速率.JPG" alt="image"></p><p>3.从规模应用上可以分为企业级、部门级和工作组交换机<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\交换机企业.JPG" alt="image"></p><h3 id="10-交换机的功能"><a href="#10-交换机的功能" class="headerlink" title="[10]交换机的功能"></a>[10]交换机的功能</h3><h5 id="1-交换机功能"><a href="#1-交换机功能" class="headerlink" title="1.交换机功能"></a>1.交换机功能</h5><p>学习功能，局域网内交换机会了解跟每一个插口相连接的<strong>MAC地址</strong>，并将地址同<strong>相应的端口</strong>映射起来存放在<strong>交换机缓存中的MAC地址表中</strong></p><h5 id="2-转发-过滤功能"><a href="#2-转发-过滤功能" class="headerlink" title="2.转发/过滤功能"></a>2.转发/过滤功能</h5><p>当一个数据帧的目的地址在MAC地址表中有映射时，它被转发到连接目的节点的端口而不是所有端口（如该数据帧为广播/组播帧则转发至所有端口）<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\MAC地址表.JPG" alt="image"></p><h5 id="3-消除回路功能"><a href="#3-消除回路功能" class="headerlink" title="3.消除回路功能"></a>3.消除回路功能</h5><p>当交换机包括一个冗余回路时，以太网交换机通过<strong>生成树协议</strong>避免回路的产生，同时允许存在<strong>后背路径</strong><br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\回路.JPG" alt="image"></p><h5 id="4-兼容功能"><a href="#4-兼容功能" class="headerlink" title="4.兼容功能"></a>4.兼容功能</h5><p>交换机除了能连接两种同类型的网络之外，还可以在不同类型的网路（如以太网和快速以太网）之间起到互联作用。而且现在的交换机没有很严格的类型之分，百兆交换机一般也会加两个千兆口或光纤接入口<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\消除.JPG" alt="image"></p><hr><h3 id="11-交换机的接口种"><a href="#11-交换机的接口种" class="headerlink" title="[11]交换机的接口种"></a>[11]交换机的接口种</h3><h5 id="1-双绞线RJ-45接口-水晶头"><a href="#1-双绞线RJ-45接口-水晶头" class="headerlink" title="1.双绞线RJ-45接口-水晶头"></a>1.双绞线RJ-45接口-水晶头</h5><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\水晶头.JPG" alt="image"></p><h5 id="2-光纤接口"><a href="#2-光纤接口" class="headerlink" title="2.光纤接口"></a>2.光纤接口</h5><p>光纤需要熔接到带插头的尾纤，常见的尾纤插头有SC。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\SC.JPG" alt="image"></p><hr><h3 id="12-路由器的工作原理"><a href="#12-路由器的工作原理" class="headerlink" title="[12]路由器的工作原理"></a>[12]路由器的工作原理</h3><p>路由器，大家都很熟悉了，办公室或者家里凡有两台以上的电脑需要上网的一般都安装了路由器，只有安装了路由器才能实现多台电脑同时上网。我们就了解下路由器的配置原理。</p><h5 id="1-路由器的概念"><a href="#1-路由器的概念" class="headerlink" title="1.路由器的概念"></a>1.路由器的概念</h5><p>1.所谓“路由”，就是把数据从一个地方传送到另一个地方的行为和动作，路由器就是执行这个动作的机器，英文名Router</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\路由.JPG" alt="image"></p><p>2.路由器能将不同网络或网段之间的数据信息进行“翻译”，以使他们能够相互“读”懂对方的数据，从而构建更大的网络。</p><h5 id="2-路由器的典型功能"><a href="#2-路由器的典型功能" class="headerlink" title="2.路由器的典型功能"></a>2.路由器的典型功能</h5><ul><li><strong>数据通道功能</strong></li></ul><p>包括转发决定、背板转发以及输出链路调度等，一般由特定的硬件来完成</p><ul><li><strong>控制功能</strong></li></ul><p>一般用软件来实现，包括与相邻路由器之间的信息交换、系统配置、系统管理等</p><h5 id="3-路由器的主要功能"><a href="#3-路由器的主要功能" class="headerlink" title="3.路由器的主要功能"></a>3.路由器的主要功能</h5><ul><li><strong>网络互连</strong></li></ul><p>路由器支持各种局域网和广域网接口，主要用于互连局域网和广域网，实现不同网络互相通信<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\互连.JPG" alt="image"></p><ul><li><strong>数据处理</strong></li></ul><p>提供包括分组过滤、分组转发、优先级、复用、加密、压缩和防火墙等功能<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\过滤.JPG" alt="image"></p><ul><li><strong>网络管理</strong></li></ul><p>路由器提供包括配置管理、性能管理、容错管理和流量控制管理等功能</p><p><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\管理.JPG" alt="image"></p><h5 id="4-路由器的工作原理"><a href="#4-路由器的工作原理" class="headerlink" title="4.路由器的工作原理"></a>4.路由器的工作原理</h5><ul><li><p>接收来自它连接的某个网络的数据</p></li><li><p>将数据向上传递，并且（必要时）重新组合IP数据报</p></li><li><p>检查IP头部中的目的地址，如果目的地址位于发出数据的那个网络，那么路由器就放下被认为已经达到目的地的数据，因为数据是在目的计算机所在网络上传输</p></li><li><p>如果数据要送往另一个网络，那么路由器就查询路由表，以确定数据要转发到的目的地</p></li><li><p>路由器确定哪个适配器负责接收数据后，就通过相应的软件传递数据，以便通过网络来传送数据</p></li></ul><hr><h3 id="13-初识TCP-IP的分层"><a href="#13-初识TCP-IP的分层" class="headerlink" title="[13]初识TCP/IP的分层"></a>[13]初识TCP/IP的分层</h3><p>大家可能经常使用TCP/IP协议，在进行网络配置或修改IP地址等操作的时候会用到该处，但很少有人去深入挖掘，在此我们简单的了解一下TCP/IP的分层。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\分层.JPG" alt="image"></p><h5 id="1-TCP-IP协议"><a href="#1-TCP-IP协议" class="headerlink" title="1.TCP/IP协议"></a>1.TCP/IP协议</h5><ul><li><p>Internet采用了TCP/IP协议，但这并不是一个单一的协议，我们可能知道，TCP即传输控制协议，IP为网间协议，TCP/IP我们常常描述为互联网协议集。但可能很少人知道TCP/IP也是一种分层模型。它是基于<strong>硬件层次</strong>上的四个概念性层次构成，分别是<strong>网络接口层（数据链路层）、IP层（网络层）、传输层、应用层</strong>。<br><img src="/2017/09/26/Network(1)/C:/Users\可汗金斯\Desktop\介质.JPG" alt="image"></p></li><li><p>网络接口层:也称数据链路层，这是TCP/IP最底层。功能:负责接收IP数据报并发送至选定的网络。</p></li><li><p>IP层:<strong>IP层处理机器之间的通信</strong>。功能:它接收来自传输层的请求，<strong>将带有目的地址的分组发送出去</strong>。将分组封装到数据报中，填入数据报头，使用路由算法以决定是直接将数据报传送至目的主机还是传给路由器，然后把数据报送至相应的网络接口来传送。</p></li><li>传输层:是提供应用层之间的通信，即端到端的通信。功能:<strong>管理信息流，提供可靠的传输服务</strong>，以确保数据无差错的地按序到达。</li></ul><h5 id="2-TCP-IP模型的分界线"><a href="#2-TCP-IP模型的分界线" class="headerlink" title="2.TCP/IP模型的分界线"></a>2.TCP/IP模型的分界线</h5><p>协议地址分界线:以区分高层和低层的寻址，<strong>高层寻址使用IP地址</strong>，<strong>低层寻址使用物理地址</strong>。应用程序IP层之上的协议软件只使用IP地址，而网络接口层处理物理地址。</p><ul><li>操作系统分界线:以区分系统与应用程序。<strong>在传输层和应用层之间。</strong></li><li><h5 id="3-复用与分解"><a href="#3-复用与分解" class="headerlink" title="3.复用与分解"></a>3.复用与分解</h5></li></ul><p>发送报文时，发送方在报文中加和了报文类型、选用协议等附加信息。所有的报文以帧的形式在网络中复用传送，形成一个分组流。在接收方收到分组时，参考附加信息对接收到的分组进行分解。</p><hr><p>参考网址：<a href="https://jingyan.baidu.com/season/38734" target="_blank" rel="noopener">https://jingyan.baidu.com/season/38734</a></p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2017/09/26/Network(1)/">http://jaymo666.github.io/2017/09/26/Network(1)/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[1]ping命令&lt;/li&gt;
&lt;li&gt;[2]路由器和交换机的差异&lt;/li&gt;
&lt;li&gt;[3]路由器的基本设置&lt;/li&gt;
&lt;li&gt;[4]netsh网络配置命令&lt;/li&gt;
&lt;li&gt;[5]安装失败（未签名）&lt;/li&gt;
&lt;li&gt;[6]管理用户网络应用&lt;/li&gt;
&lt;li&gt;[7]映射网络驱动器&lt;/li&gt;
&lt;li&gt;[8]网络适配器的原理&lt;/li&gt;
&lt;li&gt;[9]交换机的分类&lt;/li&gt;
&lt;li&gt;[10]交换机的功能&lt;/li&gt;
&lt;li&gt;[11]交换机的接口种类&lt;/li&gt;
&lt;li&gt;[12]路由器的工作原理&lt;/li&gt;
&lt;li&gt;[13]初识TCP/IP的分层&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="网络" scheme="http://jaymo666.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://jaymo666.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Threejs中的各种光源（Threejs第三章）</title>
    <link href="http://jaymo666.github.io/2017/09/22/Threejs3/"/>
    <id>http://jaymo666.github.io/2017/09/22/Threejs3/</id>
    <published>2017-09-22T06:34:47.000Z</published>
    <updated>2017-12-03T11:29:43.126Z</updated>
    
    <content type="html"><![CDATA[<p>本章你将了解<br>1、怎么使用光源<br>2、以及各种光源的区别，这些区别会通过实例对比来给大家讲清楚。这种对比方式应该是讲解最好的思路。<a id="more"></a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=447960871&auto=0&height=66"></iframe><h4 id="2-6-环境光和方向光"><a href="#2-6-环境光和方向光" class="headerlink" title="2.6 环境光和方向光"></a>2.6 环境光和方向光</h4><p>接下来，我们来看看多种光源同时存在于场景之中，对物体颜色的影响。</p><p>当环境光和方向光同时存在的时候，会出现怎么样的情况呢？可以把这种情况想成两种光源同时作用于物体，它产生的情况，和每种光源分别作用于物体，然后将两者的结果相加，是一样的效果。<br>例如：<br><code>0x00FF00 + 0xFF0000 = 0xFFFF00</code>，oxFFFF00 就是黄色。</p><h4 id="2-7-点光源"><a href="#2-7-点光源" class="headerlink" title="2.7 点光源"></a>2.7 点光源</h4><p>点光源是理想化为质点的向四面八方发出光线的光源。点光源是抽象化了的物理概念，为了把物理问题的研究简单化。就像平时说的光滑平面，质点，无空气阻力一样，点光源在现实中也是不存在的，指的是从一个点向周围空间均匀发光的光源。</p><p>点光源的特点是发光部分为一个小圆面，近似一个点</p><p>下面的例子介绍了怎么使用点光源：</p><pre><code>light = new THREE.PointLight(0xFF0000);light.position.set(0, 0,50);scene.add(light);</code></pre><p>效果如下图：</p><p><img src="http://www.hewebgl.com/attached/image/20130517/20130517101725_304.png" alt=""></p><h4 id="2-8-混合光源"><a href="#2-8-混合光源" class="headerlink" title="2.8 混合光源"></a>2.8 混合光源</h4><p>将方向光和点光源混合使用。</p><p>效果如图所示：<br><img src="http://www.hewebgl.com/attached/image/20130517/20130517102228_302.png" alt=""></p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2017/09/22/Threejs3/">http://jaymo666.github.io/2017/09/22/Threejs3/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章你将了解&lt;br&gt;1、怎么使用光源&lt;br&gt;2、以及各种光源的区别，这些区别会通过实例对比来给大家讲清楚。这种对比方式应该是讲解最好的思路。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://jaymo666.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="http://jaymo666.github.io/tags/js/"/>
    
      <category term="初级" scheme="http://jaymo666.github.io/tags/%E5%88%9D%E7%BA%A7/"/>
    
      <category term="3D" scheme="http://jaymo666.github.io/tags/3D/"/>
    
      <category term="threejs" scheme="http://jaymo666.github.io/tags/threejs/"/>
    
  </entry>
  
  <entry>
    <title>Threejs中的各种光源（Threejs第三章）</title>
    <link href="http://jaymo666.github.io/2017/09/22/Threejs3(1)/"/>
    <id>http://jaymo666.github.io/2017/09/22/Threejs3(1)/</id>
    <published>2017-09-22T06:34:47.000Z</published>
    <updated>2017-12-03T12:41:51.103Z</updated>
    
    <content type="html"><![CDATA[<p>本章你将了解<br>1、怎么使用光源<br>2、以及各种光源的区别，这些区别会通过实例对比来给大家讲清楚。这种对比方式应该是讲解最好的思路。<a id="more"></a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=447960871&auto=0&height=66"></iframe><h4 id="2-6-环境光和方向光"><a href="#2-6-环境光和方向光" class="headerlink" title="2.6 环境光和方向光"></a>2.6 环境光和方向光</h4><p>接下来，我们来看看多种光源同时存在于场景之中，对物体颜色的影响。</p><p>当环境光和方向光同时存在的时候，会出现怎么样的情况呢？可以把这种情况想成两种光源同时作用于物体，它产生的情况，和每种光源分别作用于物体，然后将两者的结果相加，是一样的效果。<br>例如：<br><code>0x00FF00 + 0xFF0000 = 0xFFFF00</code>，oxFFFF00 就是黄色。</p><h4 id="2-7-点光源"><a href="#2-7-点光源" class="headerlink" title="2.7 点光源"></a>2.7 点光源</h4><p>点光源是理想化为质点的向四面八方发出光线的光源。点光源是抽象化了的物理概念，为了把物理问题的研究简单化。就像平时说的光滑平面，质点，无空气阻力一样，点光源在现实中也是不存在的，指的是从一个点向周围空间均匀发光的光源。</p><p>点光源的特点是发光部分为一个小圆面，近似一个点</p><p>下面的例子介绍了怎么使用点光源：</p><pre><code>light = new THREE.PointLight(0xFF0000);light.position.set(0, 0,50);scene.add(light);</code></pre><p>效果如下图：</p><p><img src="http://www.hewebgl.com/attached/image/20130517/20130517101725_304.png" alt=""></p><h4 id="2-8-混合光源"><a href="#2-8-混合光源" class="headerlink" title="2.8 混合光源"></a>2.8 混合光源</h4><p>将方向光和点光源混合使用。</p><p>效果如图所示：<br><img src="http://www.hewebgl.com/attached/image/20130517/20130517102228_302.png" alt=""></p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2017/09/22/Threejs3(1)/">http://jaymo666.github.io/2017/09/22/Threejs3(1)/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章你将了解&lt;br&gt;1、怎么使用光源&lt;br&gt;2、以及各种光源的区别，这些区别会通过实例对比来给大家讲清楚。这种对比方式应该是讲解最好的思路。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://jaymo666.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="http://jaymo666.github.io/tags/js/"/>
    
      <category term="初级" scheme="http://jaymo666.github.io/tags/%E5%88%9D%E7%BA%A7/"/>
    
      <category term="3D" scheme="http://jaymo666.github.io/tags/3D/"/>
    
      <category term="threejs" scheme="http://jaymo666.github.io/tags/threejs/"/>
    
  </entry>
  
  <entry>
    <title>Threejs中的各种光源（Threejs第二章）</title>
    <link href="http://jaymo666.github.io/2017/09/22/Threejs2(1)/"/>
    <id>http://jaymo666.github.io/2017/09/22/Threejs2(1)/</id>
    <published>2017-09-22T05:34:47.000Z</published>
    <updated>2017-12-03T12:41:54.229Z</updated>
    
    <content type="html"><![CDATA[<p>作为3D技术的发展趋势，浏览器端3D技术越来越被一些技术公司重视。由此，Threejs非常注重3D渲染效果的真实性，对渲染真实性来说，使用光源是比不可少的技巧。Threejs，在光源方面提供了多种光源供选择。<a id="more"></a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=447960871&auto=0&height=66"></iframe><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="1-Threejs中的各种光源"><a href="#1-Threejs中的各种光源" class="headerlink" title="1.Threejs中的各种光源"></a>1.Threejs中的各种光源</h3><h4 id="1-1光源基类"><a href="#1-1光源基类" class="headerlink" title="1.1光源基类"></a>1.1光源基类</h4><p>在Threejs中，光源用Light表示，它是所有光源的基类。它的构造函数是：<br><strong>THREE.Light ( hex )</strong></p><p>它有一个参数hex，接受一个16进制的颜色值。例如要定义一种红色的光源，我们可以这样来定义：</p><pre><code>Var redLight = new THREE.Light(0xFF0000);</code></pre><h4 id="1-2由基类派生出来的其他种类光源"><a href="#1-2由基类派生出来的其他种类光源" class="headerlink" title="1.2由基类派生出来的其他种类光源"></a>1.2由基类派生出来的其他种类光源</h4><p><strong>THREE.Light只是其他所有光源的基类</strong>，要让光源除了具有颜色的特性之外，我们需要其他光源。看看，下面的类图，是目前光源的继承结构。<br><img src="http://www.hewebgl.com/attached/image/20130515/20130515163339_12.jpg" alt=""></p><p>环境光是经过多次反射而来的光称为环境光，无法确定其最初的方向。环境光是一种无处不在的光。环境光源放出的光线被认为来自任何方向。因此，当你仅为场景指定环境光时，所有的物体无论法向量如何，都将表现为同样的明暗程度。 （这是因为，反射光可以从各个方向进入您的眼睛）</p><h5 id="1-2-1-环境光"><a href="#1-2-1-环境光" class="headerlink" title="1.2.1 环境光"></a>1.2.1 <strong>环境光</strong></h5><p>用<code>THREE.AmbientLight</code>来表示，它的构造函数如下所示：<br><strong>    THREE.AmbientLight( hex )</strong></p><p>它仍然接受一个16进制的颜色值，作为光源的颜色。环境光将照射场景中的所有物体，让物体显示出某种颜色。环境光的使用例子如下所示：</p><pre><code>var light = new THREE.AmbientLight( 0xff0000 );scene.add( light );</code></pre><p>只需要将光源加入场景，场景就能够通过光源渲染出好的效果来了。</p><h5 id="1-2-2点光源"><a href="#1-2-2点光源" class="headerlink" title="1.2.2点光源"></a>1.2.2<strong>点光源</strong></h5><p>由这种光源放出的光线来自同一点，且方向辐射自四面八方。例如蜡烛放出的光，萤火虫放出的光。</p><p>点光源用PointLight来表示，它的构造函数如下所示：</p><p>PointLight( color, intensity, distance )</p><p>这个类的参数稍微复杂一些，我们花点时间来解释一下：</p><ul><li><p>Color：光的颜色</p></li><li><p>Intensity：光的强度，默认是1.0,就是说是100%强度的灯光，</p></li><li><p>distance：光的距离，从光源所在的位置，经过distance这段距离之后，光的强度将从Intensity衰减为0。 默认情况下，这个值为0.0，表示光源强度不衰减。</p></li></ul><p>#####1.2.3<strong>聚光灯</strong><br>这种光源的光线从一个锥体中射出，在被照射的物体上产生聚光的效果。使用这种光源需要指定光的射出方向以及锥体的顶角α。聚光灯示例如图所示：<br><img src="http://www.hewebgl.com/attached/image/20130516/20130516165745_434.jpg" alt=""></p><p>聚光灯的构造函数是：<br><strong><br>THREE.SpotLight( hex, intensity, distance, angle, exponent )</strong></p><p>函数的参数如下所示：</p><ul><li><p>Hex：聚光灯发出的颜色，如0xFFFFFF</p></li><li><p>Intensity：光源的强度，默认是1.0，如果为0.5，则强度是一半，意思是颜色会淡一些。和上面点光源一样。</p></li><li><p>Distance：光线的强度，从最大值衰减到0，需要的距离。 默认为0，表示光不衰减，如果非0，则表示从光源的位置到Distance的距离，光都在线性衰减。到离光源距离Distance时，光源强度为0.</p></li></ul><p>Angle：聚光灯着色的角度，用弧度作为单位，这个角度是和光源的方向形成的角度。</p><p>exponent：光源模型中，衰减的一个参数，越大衰减约快。</p><h3 id="2-材质与光源的关系"><a href="#2-材质与光源的关系" class="headerlink" title="2.材质与光源的关系"></a>2.材质与光源的关系</h3><p>材质与光源有什么关系？什么是材质？</p><h4 id="2-1-材质的真相"><a href="#2-1-材质的真相" class="headerlink" title="2.1 材质的真相"></a>2.1 材质的真相</h4><blockquote><p>材质就是物体的质地。材质就是材料和质感的完美结合。</p></blockquote><p>在渲染程序中，它是表面<strong>各可视属性的结合</strong>，这些可视属性是指表面的色彩、纹理、光滑度、透明度、反射率、折射率、发光度等。正是有了这些属性，才能让我们识别三维中的模型是什么做成的，也正是有了这些属性，我们计算机三维的虚拟世界才会和真实世界一样缤纷多彩。</p><p>这就是材质的真相吗？答案是否定的。不要奇怪，我们必须仔细分析产生不同材质的原因，才能让我们更好的把握质感。那么，材质的真相到底是什么呢？仍然是光，离开光材质是无法体现的。　</p><p>首先，我们来看一些例子。这些例子是一系类的，掌握一个，我们就印下了一个脚印.</p><h5 id="2-2-脚印一：不带任何光源的物体"><a href="#2-2-脚印一：不带任何光源的物体" class="headerlink" title="2.2  脚印一：不带任何光源的物体"></a>2.2  脚印一：不带任何光源的物体</h5><p>我们首先在屏幕上画一个物体，不带任何的光源，定义物体的颜色为黑色，其值为0x000000，定义材质如下：</p><p>var material = new THREE.MeshLambertMaterial( { color:0x000000} ); // 这是兰伯特材质，材质中的一种</p><p>先看看最终的运行截图，如下所示：<br><img src="http://www.hewebgl.com/attached/image/20130515/20130515170232_15.png" alt=""></p><p>由这幅图得出结论，当没有任何光源的时候，最终的颜色将是材质的颜色。但是这个结论目前来说，并没有依据。<br><strong><br>结论：当没有任何光源的时候，最终的颜色将是黑色，无论材质是什么颜色。</strong></p><h4 id="2-3-脚印二：兰伯特材质与光源"><a href="#2-3-脚印二：兰伯特材质与光源" class="headerlink" title="2.3 脚印二：兰伯特材质与光源"></a>2.3 脚印二：兰伯特材质与光源</h4><p>最常见的材质之一就是Lambert材质，这是在灰暗的或不光滑的表面产生<strong>均匀散射</strong>而形成的材质类型。比如一张纸就是Lambert表面。 首先它粗糙不均匀，不会产生镜面效果。我们在阅读书籍的时候，没有发现书上一处亮，一处不亮吧，它非常均匀，这就是兰伯特材质。</p><p>有的朋友觉得纸不粗糙啊，你怎么说它粗糙吗？人的肉眼是不好分辨出来，它粗不粗糙的。</p><p>Lambert材质表面会在所有方向上均匀地散射灯光，这就会使颜色看上去比较均匀。想想一张纸，无论什么颜色，是不是纸的各个部分颜色都比较均匀呢。</p><p>Lambert材质的图例如下所示：<br><img src="http://www.hewebgl.com/attached/image/20130515/20130515170358_794.jpg" alt=""><br>Lambert材质会受环境光的影响，呈现环境光的颜色，与材质本身颜色关系不大。</p><p>我们现在来做一个例子</p><p>例子：红色环境光照射下的长方体，它用的是淡红色(0x880000)的兰伯特材质。效果如下图：</p><p><img src="http://www.hewebgl.com/attached/image/20130515/20130515170419_688.png" alt=""></p><p>最后整个效果中，长方体呈现的是红色。我们要说的是，长方体显示红色，是因为<strong>长方体反射了红色的光</strong>，长方体本身的颜色是0x880000，光源的颜色是0xFF0000，红色的光照在物体上，物体反射了红色的光，所以呈现红色。<br><strong><br>我们现在一直在使用环境光，从环境光的构造函数来看，它只有颜色，其位置对场景中的物体并没有影响，因为他是均匀的反射到物体的表面的。</strong></p><h4 id="2-4-脚印三：环境光对物体的影响"><a href="#2-4-脚印三：环境光对物体的影响" class="headerlink" title="2.4 脚印三：环境光对物体的影响"></a>2.4 脚印三：环境光对物体的影响</h4><p>环境光就是在场景中无处不在的光，它对物体的影响是均匀的，也就是无论你从物体的那个角度观察，物体的颜色都是一样的，这就是伟大的环境光。</p><p><strong>你可以把环境光放在任何一个位置，它的光线是不会衰减的，是永恒的某个强度的一种光源。</strong></p><h4 id="2-5脚印四：方向光（平行光）"><a href="#2-5脚印四：方向光（平行光）" class="headerlink" title="2.5脚印四：方向光（平行光）"></a>2.5脚印四：方向光（平行光）</h4><p>平行光又称为方向光（Directional Light），是一组没有衰减的平行的光线，类似太阳光的效果。</p><p>方向光的模型如图：<br><img src="http://www.hewebgl.com/attached/image/20130516/20130516171702_524.jpg" alt=""><br>方向光的构造函数如下所示：</p><p><strong>THREE.DirectionalLight = function ( hex, intensity )</strong></p><p>其参数如下：</p><ul><li><p>Hex：关系的颜色，用16进制表示</p></li><li><p>Intensity：光线的强度，默认为1。因为RGB的三个值均在0~255之间，不能反映出光照的强度变化，光照越强，物体表面就更明亮。它的取值范围是0到1。如果为0，表示光线基本没什么作用，那么物体就会显示为黑色。呆会你可以尝试来更改这个参数，看看实际的效果</p></li></ul><p>我们来看一个方向光的例子：</p><p>一个红色的方向光，把它放在（0,0,1）的位置，密度为1，照射在一个长方体中。效果如下图所示：</p><p><img src="http://www.hewebgl.com/attached/image/20130516/20130516172030_538.png" alt=""></p><p>平行光有一个方向，它的方向是如何决定的呢？<br>方向由<strong>位置</strong>和<strong>原点</strong>（0,0,0）来决定，方向光只与方向有关，与离物体的远近无关。分别将平行光放到（0,0,100），（0,0,50），（0,0,25），（0,0,1），渲染的结果还是红色和黑色，见下图，<strong>颜色的深浅不与离物体的距离相关。</strong></p><p>但是它与方向有关，如果，我们灯光的位置改为（1,0,0.5），那么效果如图所示：<br><img src="http://www.hewebgl.com/attached/image/20130516/20130516172333_384.png" alt=""></p><p>未完待续</p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2017/09/22/Threejs2(1)/">http://jaymo666.github.io/2017/09/22/Threejs2(1)/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为3D技术的发展趋势，浏览器端3D技术越来越被一些技术公司重视。由此，Threejs非常注重3D渲染效果的真实性，对渲染真实性来说，使用光源是比不可少的技巧。Threejs，在光源方面提供了多种光源供选择。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://jaymo666.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="http://jaymo666.github.io/tags/js/"/>
    
      <category term="初级" scheme="http://jaymo666.github.io/tags/%E5%88%9D%E7%BA%A7/"/>
    
      <category term="3D" scheme="http://jaymo666.github.io/tags/3D/"/>
    
      <category term="threejs" scheme="http://jaymo666.github.io/tags/threejs/"/>
    
  </entry>
  
  <entry>
    <title>Threejs中的各种光源（Threejs第二章）</title>
    <link href="http://jaymo666.github.io/2017/09/22/Threejs2/"/>
    <id>http://jaymo666.github.io/2017/09/22/Threejs2/</id>
    <published>2017-09-22T05:34:47.000Z</published>
    <updated>2017-12-03T11:29:52.275Z</updated>
    
    <content type="html"><![CDATA[<p>作为3D技术的发展趋势，浏览器端3D技术越来越被一些技术公司重视。由此，Threejs非常注重3D渲染效果的真实性，对渲染真实性来说，使用光源是比不可少的技巧。Threejs，在光源方面提供了多种光源供选择。<a id="more"></a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=447960871&auto=0&height=66"></iframe><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="1-Threejs中的各种光源"><a href="#1-Threejs中的各种光源" class="headerlink" title="1.Threejs中的各种光源"></a>1.Threejs中的各种光源</h3><h4 id="1-1光源基类"><a href="#1-1光源基类" class="headerlink" title="1.1光源基类"></a>1.1光源基类</h4><p>在Threejs中，光源用Light表示，它是所有光源的基类。它的构造函数是：<br><strong>THREE.Light ( hex )</strong></p><p>它有一个参数hex，接受一个16进制的颜色值。例如要定义一种红色的光源，我们可以这样来定义：</p><pre><code>Var redLight = new THREE.Light(0xFF0000);</code></pre><h4 id="1-2由基类派生出来的其他种类光源"><a href="#1-2由基类派生出来的其他种类光源" class="headerlink" title="1.2由基类派生出来的其他种类光源"></a>1.2由基类派生出来的其他种类光源</h4><p><strong>THREE.Light只是其他所有光源的基类</strong>，要让光源除了具有颜色的特性之外，我们需要其他光源。看看，下面的类图，是目前光源的继承结构。<br><img src="http://www.hewebgl.com/attached/image/20130515/20130515163339_12.jpg" alt=""></p><p>环境光是经过多次反射而来的光称为环境光，无法确定其最初的方向。环境光是一种无处不在的光。环境光源放出的光线被认为来自任何方向。因此，当你仅为场景指定环境光时，所有的物体无论法向量如何，都将表现为同样的明暗程度。 （这是因为，反射光可以从各个方向进入您的眼睛）</p><h5 id="1-2-1-环境光"><a href="#1-2-1-环境光" class="headerlink" title="1.2.1 环境光"></a>1.2.1 <strong>环境光</strong></h5><p>用<code>THREE.AmbientLight</code>来表示，它的构造函数如下所示：<br><strong>    THREE.AmbientLight( hex )</strong></p><p>它仍然接受一个16进制的颜色值，作为光源的颜色。环境光将照射场景中的所有物体，让物体显示出某种颜色。环境光的使用例子如下所示：</p><pre><code>var light = new THREE.AmbientLight( 0xff0000 );scene.add( light );</code></pre><p>只需要将光源加入场景，场景就能够通过光源渲染出好的效果来了。</p><h5 id="1-2-2点光源"><a href="#1-2-2点光源" class="headerlink" title="1.2.2点光源"></a>1.2.2<strong>点光源</strong></h5><p>由这种光源放出的光线来自同一点，且方向辐射自四面八方。例如蜡烛放出的光，萤火虫放出的光。</p><p>点光源用PointLight来表示，它的构造函数如下所示：</p><p>PointLight( color, intensity, distance )</p><p>这个类的参数稍微复杂一些，我们花点时间来解释一下：</p><ul><li><p>Color：光的颜色</p></li><li><p>Intensity：光的强度，默认是1.0,就是说是100%强度的灯光，</p></li><li><p>distance：光的距离，从光源所在的位置，经过distance这段距离之后，光的强度将从Intensity衰减为0。 默认情况下，这个值为0.0，表示光源强度不衰减。</p></li></ul><p>#####1.2.3<strong>聚光灯</strong><br>这种光源的光线从一个锥体中射出，在被照射的物体上产生聚光的效果。使用这种光源需要指定光的射出方向以及锥体的顶角α。聚光灯示例如图所示：<br><img src="http://www.hewebgl.com/attached/image/20130516/20130516165745_434.jpg" alt=""></p><p>聚光灯的构造函数是：<br><strong><br>THREE.SpotLight( hex, intensity, distance, angle, exponent )</strong></p><p>函数的参数如下所示：</p><ul><li><p>Hex：聚光灯发出的颜色，如0xFFFFFF</p></li><li><p>Intensity：光源的强度，默认是1.0，如果为0.5，则强度是一半，意思是颜色会淡一些。和上面点光源一样。</p></li><li><p>Distance：光线的强度，从最大值衰减到0，需要的距离。 默认为0，表示光不衰减，如果非0，则表示从光源的位置到Distance的距离，光都在线性衰减。到离光源距离Distance时，光源强度为0.</p></li></ul><p>Angle：聚光灯着色的角度，用弧度作为单位，这个角度是和光源的方向形成的角度。</p><p>exponent：光源模型中，衰减的一个参数，越大衰减约快。</p><h3 id="2-材质与光源的关系"><a href="#2-材质与光源的关系" class="headerlink" title="2.材质与光源的关系"></a>2.材质与光源的关系</h3><p>材质与光源有什么关系？什么是材质？</p><h4 id="2-1-材质的真相"><a href="#2-1-材质的真相" class="headerlink" title="2.1 材质的真相"></a>2.1 材质的真相</h4><blockquote><p>材质就是物体的质地。材质就是材料和质感的完美结合。</p></blockquote><p>在渲染程序中，它是表面<strong>各可视属性的结合</strong>，这些可视属性是指表面的色彩、纹理、光滑度、透明度、反射率、折射率、发光度等。正是有了这些属性，才能让我们识别三维中的模型是什么做成的，也正是有了这些属性，我们计算机三维的虚拟世界才会和真实世界一样缤纷多彩。</p><p>这就是材质的真相吗？答案是否定的。不要奇怪，我们必须仔细分析产生不同材质的原因，才能让我们更好的把握质感。那么，材质的真相到底是什么呢？仍然是光，离开光材质是无法体现的。　</p><p>首先，我们来看一些例子。这些例子是一系类的，掌握一个，我们就印下了一个脚印.</p><h5 id="2-2-脚印一：不带任何光源的物体"><a href="#2-2-脚印一：不带任何光源的物体" class="headerlink" title="2.2  脚印一：不带任何光源的物体"></a>2.2  脚印一：不带任何光源的物体</h5><p>我们首先在屏幕上画一个物体，不带任何的光源，定义物体的颜色为黑色，其值为0x000000，定义材质如下：</p><p>var material = new THREE.MeshLambertMaterial( { color:0x000000} ); // 这是兰伯特材质，材质中的一种</p><p>先看看最终的运行截图，如下所示：<br><img src="http://www.hewebgl.com/attached/image/20130515/20130515170232_15.png" alt=""></p><p>由这幅图得出结论，当没有任何光源的时候，最终的颜色将是材质的颜色。但是这个结论目前来说，并没有依据。<br><strong><br>结论：当没有任何光源的时候，最终的颜色将是黑色，无论材质是什么颜色。</strong></p><h4 id="2-3-脚印二：兰伯特材质与光源"><a href="#2-3-脚印二：兰伯特材质与光源" class="headerlink" title="2.3 脚印二：兰伯特材质与光源"></a>2.3 脚印二：兰伯特材质与光源</h4><p>最常见的材质之一就是Lambert材质，这是在灰暗的或不光滑的表面产生<strong>均匀散射</strong>而形成的材质类型。比如一张纸就是Lambert表面。 首先它粗糙不均匀，不会产生镜面效果。我们在阅读书籍的时候，没有发现书上一处亮，一处不亮吧，它非常均匀，这就是兰伯特材质。</p><p>有的朋友觉得纸不粗糙啊，你怎么说它粗糙吗？人的肉眼是不好分辨出来，它粗不粗糙的。</p><p>Lambert材质表面会在所有方向上均匀地散射灯光，这就会使颜色看上去比较均匀。想想一张纸，无论什么颜色，是不是纸的各个部分颜色都比较均匀呢。</p><p>Lambert材质的图例如下所示：<br><img src="http://www.hewebgl.com/attached/image/20130515/20130515170358_794.jpg" alt=""><br>Lambert材质会受环境光的影响，呈现环境光的颜色，与材质本身颜色关系不大。</p><p>我们现在来做一个例子</p><p>例子：红色环境光照射下的长方体，它用的是淡红色(0x880000)的兰伯特材质。效果如下图：</p><p><img src="http://www.hewebgl.com/attached/image/20130515/20130515170419_688.png" alt=""></p><p>最后整个效果中，长方体呈现的是红色。我们要说的是，长方体显示红色，是因为<strong>长方体反射了红色的光</strong>，长方体本身的颜色是0x880000，光源的颜色是0xFF0000，红色的光照在物体上，物体反射了红色的光，所以呈现红色。<br><strong><br>我们现在一直在使用环境光，从环境光的构造函数来看，它只有颜色，其位置对场景中的物体并没有影响，因为他是均匀的反射到物体的表面的。</strong></p><h4 id="2-4-脚印三：环境光对物体的影响"><a href="#2-4-脚印三：环境光对物体的影响" class="headerlink" title="2.4 脚印三：环境光对物体的影响"></a>2.4 脚印三：环境光对物体的影响</h4><p>环境光就是在场景中无处不在的光，它对物体的影响是均匀的，也就是无论你从物体的那个角度观察，物体的颜色都是一样的，这就是伟大的环境光。</p><p><strong>你可以把环境光放在任何一个位置，它的光线是不会衰减的，是永恒的某个强度的一种光源。</strong></p><h4 id="2-5脚印四：方向光（平行光）"><a href="#2-5脚印四：方向光（平行光）" class="headerlink" title="2.5脚印四：方向光（平行光）"></a>2.5脚印四：方向光（平行光）</h4><p>平行光又称为方向光（Directional Light），是一组没有衰减的平行的光线，类似太阳光的效果。</p><p>方向光的模型如图：<br><img src="http://www.hewebgl.com/attached/image/20130516/20130516171702_524.jpg" alt=""><br>方向光的构造函数如下所示：</p><p><strong>THREE.DirectionalLight = function ( hex, intensity )</strong></p><p>其参数如下：</p><ul><li><p>Hex：关系的颜色，用16进制表示</p></li><li><p>Intensity：光线的强度，默认为1。因为RGB的三个值均在0~255之间，不能反映出光照的强度变化，光照越强，物体表面就更明亮。它的取值范围是0到1。如果为0，表示光线基本没什么作用，那么物体就会显示为黑色。呆会你可以尝试来更改这个参数，看看实际的效果</p></li></ul><p>我们来看一个方向光的例子：</p><p>一个红色的方向光，把它放在（0,0,1）的位置，密度为1，照射在一个长方体中。效果如下图所示：</p><p><img src="http://www.hewebgl.com/attached/image/20130516/20130516172030_538.png" alt=""></p><p>平行光有一个方向，它的方向是如何决定的呢？<br>方向由<strong>位置</strong>和<strong>原点</strong>（0,0,0）来决定，方向光只与方向有关，与离物体的远近无关。分别将平行光放到（0,0,100），（0,0,50），（0,0,25），（0,0,1），渲染的结果还是红色和黑色，见下图，<strong>颜色的深浅不与离物体的距离相关。</strong></p><p>但是它与方向有关，如果，我们灯光的位置改为（1,0,0.5），那么效果如图所示：<br><img src="http://www.hewebgl.com/attached/image/20130516/20130516172333_384.png" alt=""></p><p>未完待续</p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2017/09/22/Threejs2/">http://jaymo666.github.io/2017/09/22/Threejs2/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为3D技术的发展趋势，浏览器端3D技术越来越被一些技术公司重视。由此，Threejs非常注重3D渲染效果的真实性，对渲染真实性来说，使用光源是比不可少的技巧。Threejs，在光源方面提供了多种光源供选择。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://jaymo666.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="http://jaymo666.github.io/tags/js/"/>
    
      <category term="初级" scheme="http://jaymo666.github.io/tags/%E5%88%9D%E7%BA%A7/"/>
    
      <category term="3D" scheme="http://jaymo666.github.io/tags/3D/"/>
    
      <category term="threejs" scheme="http://jaymo666.github.io/tags/threejs/"/>
    
  </entry>
  
  <entry>
    <title>Vue进阶之路——深入响应式原理</title>
    <link href="http://jaymo666.github.io/2017/09/21/Vue%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86(1)/"/>
    <id>http://jaymo666.github.io/2017/09/21/Vue进阶之路——深入响应式原理(1)/</id>
    <published>2017-09-21T15:54:46.000Z</published>
    <updated>2017-12-03T12:41:44.165Z</updated>
    
    <content type="html"><![CDATA[<p>Vue 最显著的特性之一便是不太引人注意的响应式系统<br><a id="more"></a></p><blockquote><p>Vue 最显著的特性之一便是不太引人注意的<strong>响应式系统</strong>(reactivity system)。<strong>模型层</strong>(model)只是普通 JavaScript <strong>对象</strong>，修改它则更新<strong>视图</strong>(view)。</p></blockquote><h2 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h2><p>把一个普通 <code>JavaScript</code> 对象传给 Vue 实例的 <code>data</code>选项，Vue 将<strong>遍历</strong>此对象所有的属性，并使用 <code>Object.defineProperty</code> 把这些属性全部转为<code>getter</code>/<code>setter</code>。</p><p>每个组件实例都有相应的 <code>watcher</code> 实例对象，它会在组件渲染的过程中<strong>把属性记录为依赖</strong>，之后当依赖项的 <code>setter</code>被调用时，会通知 <code>watcher</code> 重新计算，从而致使它关联的组件得以更新。</p><p><img src="https://cn.vuejs.org/images/data.png" alt=""></p><h2 id="变化检测问题"><a href="#变化检测问题" class="headerlink" title="变化检测问题"></a>变化检测问题</h2><p>受现代 JavaScript 的限制,<strong>Vue 不能检测到对象属性的添加或删除</strong>。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以<strong>属性必须在 data 对象上存在</strong>才能让 Vue 转换它，这样才能让它是响应的。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data:&#123;</span><br><span class="line">  a:1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// `vm.a` 是响应的</span><br><span class="line">vm.b = 2</span><br><span class="line">// `vm.b` 是非响应的</span><br></pre></td></tr></table></figure></p><p>Vue 不允许在已经创建的实例上动态添加新的<strong>根级响应式属性</strong>(root-level reactive property)。然而它可以使用 <code>Vue.set(object, key, value)</code>方法将响应属性添加到嵌套的对象上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(vm.someObject, &apos;b&apos;, 2)</span><br></pre></td></tr></table></figure><p>您还可以使用<code>vm.$set</code>实例方法，这也是全局 Vue.set 方法的<code>别名</code>：</p><p>有时你想<strong>向已有对象上添加一些属性</strong>，例如使用 <code>Object.assign()</code>或 <code>_.extend()</code> 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以<strong>创建一个新的对象</strong>，让它包含原对象的属性和新的属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`</span><br><span class="line">this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;)</span><br></pre></td></tr></table></figure></p><h2 id="声明响应式属性"><a href="#声明响应式属性" class="headerlink" title="声明响应式属性"></a>声明响应式属性</h2><p>由于 Vue 不允许动态添加根级响应式属性，所以你必须<strong>在初始化实例前声明根级响应式属性，哪怕只是一个空值:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    // 声明 message 为一个空值字符串</span><br><span class="line">    message: &apos;&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: &apos;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">// 之后设置 `message` </span><br><span class="line">vm.message = &apos;Hello!&apos;</span><br></pre></td></tr></table></figure><p>如果你在 data 选项中<strong>未声明 message</strong>，Vue 将<strong>警告</strong>你渲染函数在试图访问的属性不存在。</p><p><code>data</code>对象就像组件状态的概要，提前声明所有的响应式属性，可以让组件代码<strong>在以后重新阅读</strong>或<strong>其他开发人员阅读时更易于被理解</strong>。</p><h2 id="异步更新队列"><a href="#异步更新队列" class="headerlink" title="异步更新队列"></a>异步更新队列</h2><p>可能你还没有注意到，Vue 异步执行 DOM 更新。只要观察到<strong>数据变化</strong>，Vue 将<strong>开启一个队列</strong>，并缓冲在同一事件循环中发生的所有数据改变。<strong>如果同一个 watcher 被多次触发，只会一次推入到队列中。</strong>这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际（已去重的）工作。Vue 在内部尝试对异步队列使用原生的 <code>Promise.then</code> 和<code>MutationObserver</code>，如果执行环境不支持，会采用 <code>setTimeout(fn, 0)</code> 代替。</p><p>例如，当你设置 <code>vm.someData = &#39;new value&#39;</code>，<strong>该组件不会立即重新渲染。</strong>当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 <code>Vue.nextTick(callback)</code>。这样回调函数在 DOM 更新完成后就会调用。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;123&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.message = &apos;new message&apos; // 更改数据</span><br><span class="line">vm.$el.textContent === &apos;new message&apos; // false</span><br><span class="line">Vue.nextTick(function () &#123;</span><br><span class="line">  vm.$el.textContent === &apos;new message&apos; // true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在组件内使用 <code>vm.$nextTick()</code> 实例方法特别方便，因为它不需要全局<code>Vue</code>，并且回调函数中的 <code>this</code> 将自动绑定到当前的 Vue 实例上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;example&apos;, &#123;</span><br><span class="line">  template: &apos;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&apos;,</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &apos;没有更新&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateMessage: function () &#123;</span><br><span class="line">      this.message = &apos;更新完成&apos;</span><br><span class="line">      console.log(this.$el.textContent) // =&gt; &apos;没有更新&apos;</span><br><span class="line">      this.$nextTick(function () &#123;</span><br><span class="line">        console.log(this.$el.textContent) // =&gt; &apos;更新完成&apos;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><!--PC和WAP自适应版--><p><div id="SOHUCS" sid="SourceID"></div> </p><p><script type="text/javascript"><br>(function(){<br>var appid = ‘cysmzRdbl’;<br>var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;<br>var width = window.innerWidth || document.documentElement.clientWidth;<br>if (width &lt; 960) {<br>window.document.write(‘<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '">&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“<a href="https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})})">https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})})</a>; } })(); </script></p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2017/09/21/Vue进阶之路——深入响应式原理(1)/">http://jaymo666.github.io/2017/09/21/Vue进阶之路——深入响应式原理(1)/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue 最显著的特性之一便是不太引人注意的响应式系统&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://jaymo666.github.io/categories/JS/"/>
    
    
      <category term="js" scheme="http://jaymo666.github.io/tags/js/"/>
    
      <category term="初级" scheme="http://jaymo666.github.io/tags/%E5%88%9D%E7%BA%A7/"/>
    
      <category term="Vue" scheme="http://jaymo666.github.io/tags/Vue/"/>
    
      <category term="框架" scheme="http://jaymo666.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Vue进阶之路——过渡效果</title>
    <link href="http://jaymo666.github.io/2017/09/21/Vue%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C(1)/"/>
    <id>http://jaymo666.github.io/2017/09/21/Vue进阶之路——过渡效果(1)/</id>
    <published>2017-09-21T15:54:46.000Z</published>
    <updated>2017-12-03T12:41:46.193Z</updated>
    
    <content type="html"><![CDATA[<p>Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。<br>包括以下工具：</p><ul><li>在 CSS 过渡和动画中自动应用 class</li><li>可以配合使用第三方 CSS 动画库，如 Animate.css</li><li>在过渡钩子函数中使用 JavaScript 直接操作 DOM</li><li>可以配合使用第三方 JavaScript 动画库，如 Velocity.js</li></ul><h2 id="单元素-组件的过渡"><a href="#单元素-组件的过渡" class="headerlink" title="单元素/组件的过渡"></a>单元素/组件的过渡</h2><p>Vue 提供了 <code>transition</code> 的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡</p><ul><li>条件渲染 （使用 v-if）</li><li>条件展示 （使用 v-show）</li><li>动态组件</li><li>组件根节点<br>这里是一个典型的例子：<br>HTMl:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;show = !show&quot;&gt;</span><br><span class="line">    Toggle</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">  &lt;transition name=&quot;fade&quot;&gt;</span><br><span class="line">    &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><p>JS:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#demo&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    show: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>CSS:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.fade-enter-active, .fade-leave-active &#123;</span><br><span class="line">  transition: opacity .5s</span><br><span class="line">&#125;</span><br><span class="line">.fade-enter, .fade-leave-to /* .fade-leave-active in &lt;2.1.8 */ &#123;</span><br><span class="line">  opacity: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当插入或删除包含在 <code>transition</code> 组件中的元素时，Vue 将会做以下处理：</p><ul><li>自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。</li><li>如果过渡组件提供了<code>JavaScript 钩子函数</code>，这些钩子函数将在恰当的时机被调用。</li><li>如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，和Vue的 <code>nextTick</code>概念不同)</li><li><h3 id="过渡的-CSS-类名"><a href="#过渡的-CSS-类名" class="headerlink" title="过渡的-CSS-类名"></a>过渡的-CSS-类名</h3></li></ul><p>会有 6 个(CSS)类名在 enter/leave 的过渡中切换:</p><ol><li>v-enter</li><li>v-enter-active</li><li>v-enter-to</li><li>v-leave</li><li>v-leave-active</li><li>v-leave-to</li></ol><p><img src="https://cn.vuejs.org/images/transition.png" alt=""></p><p>对于这些在 enter/leave 过渡中切换的类名，<code>v-</code> 是这些类名的前缀。使用 <code>&lt;transition name=&quot;my-transition&quot;&gt;</code> 可以重置前缀，比如 <code>v-enter</code>替换为 <code>my-transition-enter</code>。</p><h3 id="CSS-过渡"><a href="#CSS-过渡" class="headerlink" title="CSS 过渡"></a>CSS 过渡</h3><p>CSS 动画用法同 CSS 过渡，区别是在动画中 <code>v-enter</code>类名在节点插入 DOM 后不会立即删除，而是在<code>animationend</code> 事件触发时删除。</p><p>示例： (省略了兼容性前缀)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example-2&quot;&gt;</span><br><span class="line">  &lt;button @click=&quot;show = !show&quot;&gt;Toggle show&lt;/button&gt;</span><br><span class="line">  &lt;transition name=&quot;bounce&quot;&gt;</span><br><span class="line">    &lt;p v-if=&quot;show&quot;&gt;Look at me!&lt;/p&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#example-2&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    show: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.bounce-enter-active &#123;</span><br><span class="line">  animation: bounce-in .5s;</span><br><span class="line">&#125;</span><br><span class="line">.bounce-leave-active &#123;</span><br><span class="line">  animation: bounce-out .5s;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes bounce-in &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    transform: scale(0);</span><br><span class="line">  &#125;</span><br><span class="line">  50% &#123;</span><br><span class="line">    transform: scale(1.5);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    transform: scale(1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes bounce-out &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    transform: scale(1);</span><br><span class="line">  &#125;</span><br><span class="line">  50% &#123;</span><br><span class="line">    transform: scale(1.5);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    transform: scale(0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义过渡类名"><a href="#自定义过渡类名" class="headerlink" title="自定义过渡类名"></a>自定义过渡类名</h3><p>我们可以通过以下特性来自定义过渡类名：</p><ul><li>enter-class</li><li>enter-active-class</li><li>leave-class</li><li>leave-active-class</li></ul><p>他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 <code>Animate.css</code> 结合使用十分有用。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=&quot;https://unpkg.com/animate.css@3.5.1/animate.min.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;</span><br><span class="line">&lt;div id=&quot;example-3&quot;&gt;</span><br><span class="line">  &lt;button @click=&quot;show = !show&quot;&gt;</span><br><span class="line">    Toggle render</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">  &lt;transition</span><br><span class="line">    name=&quot;custom-classes-transition&quot;</span><br><span class="line">    enter-active-class=&quot;animated tada&quot;</span><br><span class="line">    leave-active-class=&quot;animated bounceOutRight&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h3 id="同时使用-Transitions-和-Animations"><a href="#同时使用-Transitions-和-Animations" class="headerlink" title="同时使用 Transitions 和 Animations"></a>同时使用 Transitions 和 Animations</h3><p>Vue 为了知道过渡的完成，必须设置相应的<strong>事件监听器</strong>。它可以是 <code>transitionend</code>或 <code>animationend</code> ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。</p><h3 id="JavaScript-钩子"><a href="#JavaScript-钩子" class="headerlink" title="JavaScript 钩子"></a>JavaScript 钩子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition</span><br><span class="line">  v-on:before-enter=&quot;beforeEnter&quot;</span><br><span class="line">  v-on:enter=&quot;enter&quot;</span><br><span class="line">  v-on:after-enter=&quot;afterEnter&quot;</span><br><span class="line">  v-on:enter-cancelled=&quot;enterCancelled&quot;</span><br><span class="line">  v-on:before-leave=&quot;beforeLeave&quot;</span><br><span class="line">  v-on:leave=&quot;leave&quot;</span><br><span class="line">  v-on:after-leave=&quot;afterLeave&quot;</span><br><span class="line">  v-on:leave-cancelled=&quot;leaveCancelled&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;!-- ... --&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">methods: &#123;</span><br><span class="line">  // --------</span><br><span class="line">  // 进入中</span><br><span class="line">  // --------</span><br><span class="line">  beforeEnter: function (el) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  // 此回调函数是可选项的设置</span><br><span class="line">  // 与 CSS 结合时使用</span><br><span class="line">  enter: function (el, done) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    done()</span><br><span class="line">  &#125;,</span><br><span class="line">  afterEnter: function (el) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  enterCancelled: function (el) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  // --------</span><br><span class="line">  // 离开时</span><br><span class="line">  // --------</span><br><span class="line">  beforeLeave: function (el) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  // 此回调函数是可选项的设置</span><br><span class="line">  // 与 CSS 结合时使用</span><br><span class="line">  leave: function (el, done) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    done()</span><br><span class="line">  &#125;,</span><br><span class="line">  afterLeave: function (el) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  // leaveCancelled 只用于 v-show 中</span><br><span class="line">  leaveCancelled: function (el) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些钩子函数可以结合 <code>CSS transitions/animations</code>使用，也可以单独使用。</p><blockquote><p>当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。 否则，它们会被同步调用，过渡会立即完成。</p></blockquote><blockquote><p><strong>推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。</strong></p></blockquote><h2 id="初始渲染的过渡"><a href="#初始渲染的过渡" class="headerlink" title="初始渲染的过渡"></a>初始渲染的过渡</h2><p>可以通过<code>appear</code> 特性设置节点的在初始渲染的过渡<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition appear&gt;</span><br><span class="line">  &lt;!-- ... --&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></p><p>这里默认和进入和离开过渡一样，同样也可以自定义 CSS 类名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition</span><br><span class="line">  appear</span><br><span class="line">  appear-class=&quot;custom-appear-class&quot;</span><br><span class="line">  appear-active-class=&quot;custom-appear-active-class&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;!-- ... --&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure><p>自定义 JavaScript 钩子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition</span><br><span class="line">  appear</span><br><span class="line">  v-on:before-appear=&quot;customBeforeAppearHook&quot;</span><br><span class="line">  v-on:appear=&quot;customAppearHook&quot;</span><br><span class="line">  v-on:after-appear=&quot;customAfterAppearHook&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;!-- ... --&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></p><h2 id="多个元素的过渡"><a href="#多个元素的过渡" class="headerlink" title="多个元素的过渡"></a>多个元素的过渡</h2><p> 对于原生标签可以使用 <code>v-if</code>/<code>v-else</code> 。最常见的多标签过渡是<strong>一个列表</strong>和<strong>描述这个列表</strong>为空消息的元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">  &lt;table v-if=&quot;items.length &gt; 0&quot;&gt;</span><br><span class="line">&lt;!-- ... --&gt;</span><br><span class="line">  &lt;/table&gt;</span><br><span class="line">  &lt;p v-else&gt;Sorry, no items found.&lt;/p&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>当有<strong>相同标签名</strong>的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，<strong>给在 &lt;transition组件中的多个元素设置 key 是一个更好的实践。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">  &lt;button v-if=&quot;isEditing&quot; key=&quot;save&quot;&gt;</span><br><span class="line">    Save</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">  &lt;button v-else key=&quot;edit&quot;&gt;</span><br><span class="line">    Edit</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="过渡模式"><a href="#过渡模式" class="headerlink" title="过渡模式"></a>过渡模式</h3><ul><li>in-out: 新元素先进行过渡，完成之后当前元素过渡离开。</li><li>out-in: 当前元素先进行过渡，完成之后新元素过渡进入。</li></ul><h2 id="多个组件的过渡"><a href="#多个组件的过渡" class="headerlink" title="多个组件的过渡"></a>多个组件的过渡</h2><p>多个组件的过渡简单很多 - 我们不需要使用 key 特性。相反，我们只需要使用<strong>动态组件</strong>:</p><h2 id="列表过渡"><a href="#列表过渡" class="headerlink" title="列表过渡"></a>列表过渡</h2><p>怎么同时渲染整个列表，比如使用<code>v-for</code>？在这种场景中，使用 <code>&lt;transition-group&gt;</code>组件。在我们深入例子之前，先了解关于这个组件的几个特点：</p><ul><li>不同于 <code>&lt;transition&gt;</code>， 它会以一个真实元素呈现：默认为一个 <code>&lt;span&gt;</code>。你也可以通过 tag 特性更换为其他元素。</li><li>内部元素 总是需要 提供<code>唯一的 key</code> 属性值</li></ul><h3 id="列表的位移过渡"><a href="#列表的位移过渡" class="headerlink" title="列表的位移过渡"></a>列表的位移过渡</h3><p><code>&lt;transition-group&gt;</code> 组件还有一个特殊之处。不仅可以进入和离开动画，还可以<strong>改变定位。</strong>要使用这个新功能只需了解新增的 <code>v-move</code>特性，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过 <code>name</code> 属性来自定义前缀，也可以通过 <code>move-class</code> 属性手动设置。<br>v-move 对于设置过渡的切换时机和过渡曲线非常有用，你会看到如下的例子：</p><!--PC和WAP自适应版--><p><div id="SOHUCS" sid="SourceID"></div> </p><p><script type="text/javascript"><br>(function(){<br>var appid = ‘cysmzRdbl’;<br>var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;<br>var width = window.innerWidth || document.documentElement.clientWidth;<br>if (width &lt; 960) {<br>window.document.write(‘<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '">&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“<a href="https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})})">https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})})</a>; } })(); </script></p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2017/09/21/Vue进阶之路——过渡效果(1)/">http://jaymo666.github.io/2017/09/21/Vue进阶之路——过渡效果(1)/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://jaymo666.github.io/categories/JS/"/>
    
    
      <category term="js" scheme="http://jaymo666.github.io/tags/js/"/>
    
      <category term="初级" scheme="http://jaymo666.github.io/tags/%E5%88%9D%E7%BA%A7/"/>
    
      <category term="Vue" scheme="http://jaymo666.github.io/tags/Vue/"/>
    
      <category term="框架" scheme="http://jaymo666.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Vue进阶之路——深入响应式原理</title>
    <link href="http://jaymo666.github.io/2017/09/21/Vue%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <id>http://jaymo666.github.io/2017/09/21/Vue进阶之路——深入响应式原理/</id>
    <published>2017-09-21T15:54:46.000Z</published>
    <updated>2017-12-03T11:29:32.892Z</updated>
    
    <content type="html"><![CDATA[<p>Vue 最显著的特性之一便是不太引人注意的响应式系统<br><a id="more"></a></p><blockquote><p>Vue 最显著的特性之一便是不太引人注意的<strong>响应式系统</strong>(reactivity system)。<strong>模型层</strong>(model)只是普通 JavaScript <strong>对象</strong>，修改它则更新<strong>视图</strong>(view)。</p></blockquote><h2 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h2><p>把一个普通 <code>JavaScript</code> 对象传给 Vue 实例的 <code>data</code>选项，Vue 将<strong>遍历</strong>此对象所有的属性，并使用 <code>Object.defineProperty</code> 把这些属性全部转为<code>getter</code>/<code>setter</code>。</p><p>每个组件实例都有相应的 <code>watcher</code> 实例对象，它会在组件渲染的过程中<strong>把属性记录为依赖</strong>，之后当依赖项的 <code>setter</code>被调用时，会通知 <code>watcher</code> 重新计算，从而致使它关联的组件得以更新。</p><p><img src="https://cn.vuejs.org/images/data.png" alt=""></p><h2 id="变化检测问题"><a href="#变化检测问题" class="headerlink" title="变化检测问题"></a>变化检测问题</h2><p>受现代 JavaScript 的限制,<strong>Vue 不能检测到对象属性的添加或删除</strong>。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以<strong>属性必须在 data 对象上存在</strong>才能让 Vue 转换它，这样才能让它是响应的。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data:&#123;</span><br><span class="line">  a:1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// `vm.a` 是响应的</span><br><span class="line">vm.b = 2</span><br><span class="line">// `vm.b` 是非响应的</span><br></pre></td></tr></table></figure></p><p>Vue 不允许在已经创建的实例上动态添加新的<strong>根级响应式属性</strong>(root-level reactive property)。然而它可以使用 <code>Vue.set(object, key, value)</code>方法将响应属性添加到嵌套的对象上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(vm.someObject, &apos;b&apos;, 2)</span><br></pre></td></tr></table></figure><p>您还可以使用<code>vm.$set</code>实例方法，这也是全局 Vue.set 方法的<code>别名</code>：</p><p>有时你想<strong>向已有对象上添加一些属性</strong>，例如使用 <code>Object.assign()</code>或 <code>_.extend()</code> 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以<strong>创建一个新的对象</strong>，让它包含原对象的属性和新的属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`</span><br><span class="line">this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;)</span><br></pre></td></tr></table></figure></p><h2 id="声明响应式属性"><a href="#声明响应式属性" class="headerlink" title="声明响应式属性"></a>声明响应式属性</h2><p>由于 Vue 不允许动态添加根级响应式属性，所以你必须<strong>在初始化实例前声明根级响应式属性，哪怕只是一个空值:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    // 声明 message 为一个空值字符串</span><br><span class="line">    message: &apos;&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: &apos;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">// 之后设置 `message` </span><br><span class="line">vm.message = &apos;Hello!&apos;</span><br></pre></td></tr></table></figure><p>如果你在 data 选项中<strong>未声明 message</strong>，Vue 将<strong>警告</strong>你渲染函数在试图访问的属性不存在。</p><p><code>data</code>对象就像组件状态的概要，提前声明所有的响应式属性，可以让组件代码<strong>在以后重新阅读</strong>或<strong>其他开发人员阅读时更易于被理解</strong>。</p><h2 id="异步更新队列"><a href="#异步更新队列" class="headerlink" title="异步更新队列"></a>异步更新队列</h2><p>可能你还没有注意到，Vue 异步执行 DOM 更新。只要观察到<strong>数据变化</strong>，Vue 将<strong>开启一个队列</strong>，并缓冲在同一事件循环中发生的所有数据改变。<strong>如果同一个 watcher 被多次触发，只会一次推入到队列中。</strong>这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际（已去重的）工作。Vue 在内部尝试对异步队列使用原生的 <code>Promise.then</code> 和<code>MutationObserver</code>，如果执行环境不支持，会采用 <code>setTimeout(fn, 0)</code> 代替。</p><p>例如，当你设置 <code>vm.someData = &#39;new value&#39;</code>，<strong>该组件不会立即重新渲染。</strong>当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 <code>Vue.nextTick(callback)</code>。这样回调函数在 DOM 更新完成后就会调用。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;123&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.message = &apos;new message&apos; // 更改数据</span><br><span class="line">vm.$el.textContent === &apos;new message&apos; // false</span><br><span class="line">Vue.nextTick(function () &#123;</span><br><span class="line">  vm.$el.textContent === &apos;new message&apos; // true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在组件内使用 <code>vm.$nextTick()</code> 实例方法特别方便，因为它不需要全局<code>Vue</code>，并且回调函数中的 <code>this</code> 将自动绑定到当前的 Vue 实例上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;example&apos;, &#123;</span><br><span class="line">  template: &apos;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&apos;,</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &apos;没有更新&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateMessage: function () &#123;</span><br><span class="line">      this.message = &apos;更新完成&apos;</span><br><span class="line">      console.log(this.$el.textContent) // =&gt; &apos;没有更新&apos;</span><br><span class="line">      this.$nextTick(function () &#123;</span><br><span class="line">        console.log(this.$el.textContent) // =&gt; &apos;更新完成&apos;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><!--PC和WAP自适应版--><p><div id="SOHUCS" sid="SourceID"></div> </p><p><script type="text/javascript"><br>(function(){<br>var appid = ‘cysmzRdbl’;<br>var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;<br>var width = window.innerWidth || document.documentElement.clientWidth;<br>if (width &lt; 960) {<br>window.document.write(‘<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '">&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“<a href="https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})})">https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})})</a>; } })(); </script></p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2017/09/21/Vue进阶之路——深入响应式原理/">http://jaymo666.github.io/2017/09/21/Vue进阶之路——深入响应式原理/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue 最显著的特性之一便是不太引人注意的响应式系统&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://jaymo666.github.io/categories/JS/"/>
    
    
      <category term="js" scheme="http://jaymo666.github.io/tags/js/"/>
    
      <category term="初级" scheme="http://jaymo666.github.io/tags/%E5%88%9D%E7%BA%A7/"/>
    
      <category term="Vue" scheme="http://jaymo666.github.io/tags/Vue/"/>
    
      <category term="框架" scheme="http://jaymo666.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Vue进阶之路——过渡效果</title>
    <link href="http://jaymo666.github.io/2017/09/21/Vue%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C/"/>
    <id>http://jaymo666.github.io/2017/09/21/Vue进阶之路——过渡效果/</id>
    <published>2017-09-21T15:54:46.000Z</published>
    <updated>2017-12-03T11:29:35.636Z</updated>
    
    <content type="html"><![CDATA[<p>Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。<br>包括以下工具：</p><ul><li>在 CSS 过渡和动画中自动应用 class</li><li>可以配合使用第三方 CSS 动画库，如 Animate.css</li><li>在过渡钩子函数中使用 JavaScript 直接操作 DOM</li><li>可以配合使用第三方 JavaScript 动画库，如 Velocity.js</li></ul><h2 id="单元素-组件的过渡"><a href="#单元素-组件的过渡" class="headerlink" title="单元素/组件的过渡"></a>单元素/组件的过渡</h2><p>Vue 提供了 <code>transition</code> 的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡</p><ul><li>条件渲染 （使用 v-if）</li><li>条件展示 （使用 v-show）</li><li>动态组件</li><li>组件根节点<br>这里是一个典型的例子：<br>HTMl:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;show = !show&quot;&gt;</span><br><span class="line">    Toggle</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">  &lt;transition name=&quot;fade&quot;&gt;</span><br><span class="line">    &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><p>JS:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#demo&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    show: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>CSS:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.fade-enter-active, .fade-leave-active &#123;</span><br><span class="line">  transition: opacity .5s</span><br><span class="line">&#125;</span><br><span class="line">.fade-enter, .fade-leave-to /* .fade-leave-active in &lt;2.1.8 */ &#123;</span><br><span class="line">  opacity: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当插入或删除包含在 <code>transition</code> 组件中的元素时，Vue 将会做以下处理：</p><ul><li>自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。</li><li>如果过渡组件提供了<code>JavaScript 钩子函数</code>，这些钩子函数将在恰当的时机被调用。</li><li>如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，和Vue的 <code>nextTick</code>概念不同)</li><li><h3 id="过渡的-CSS-类名"><a href="#过渡的-CSS-类名" class="headerlink" title="过渡的-CSS-类名"></a>过渡的-CSS-类名</h3></li></ul><p>会有 6 个(CSS)类名在 enter/leave 的过渡中切换:</p><ol><li>v-enter</li><li>v-enter-active</li><li>v-enter-to</li><li>v-leave</li><li>v-leave-active</li><li>v-leave-to</li></ol><p><img src="https://cn.vuejs.org/images/transition.png" alt=""></p><p>对于这些在 enter/leave 过渡中切换的类名，<code>v-</code> 是这些类名的前缀。使用 <code>&lt;transition name=&quot;my-transition&quot;&gt;</code> 可以重置前缀，比如 <code>v-enter</code>替换为 <code>my-transition-enter</code>。</p><h3 id="CSS-过渡"><a href="#CSS-过渡" class="headerlink" title="CSS 过渡"></a>CSS 过渡</h3><p>CSS 动画用法同 CSS 过渡，区别是在动画中 <code>v-enter</code>类名在节点插入 DOM 后不会立即删除，而是在<code>animationend</code> 事件触发时删除。</p><p>示例： (省略了兼容性前缀)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example-2&quot;&gt;</span><br><span class="line">  &lt;button @click=&quot;show = !show&quot;&gt;Toggle show&lt;/button&gt;</span><br><span class="line">  &lt;transition name=&quot;bounce&quot;&gt;</span><br><span class="line">    &lt;p v-if=&quot;show&quot;&gt;Look at me!&lt;/p&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#example-2&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    show: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.bounce-enter-active &#123;</span><br><span class="line">  animation: bounce-in .5s;</span><br><span class="line">&#125;</span><br><span class="line">.bounce-leave-active &#123;</span><br><span class="line">  animation: bounce-out .5s;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes bounce-in &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    transform: scale(0);</span><br><span class="line">  &#125;</span><br><span class="line">  50% &#123;</span><br><span class="line">    transform: scale(1.5);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    transform: scale(1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes bounce-out &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    transform: scale(1);</span><br><span class="line">  &#125;</span><br><span class="line">  50% &#123;</span><br><span class="line">    transform: scale(1.5);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    transform: scale(0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义过渡类名"><a href="#自定义过渡类名" class="headerlink" title="自定义过渡类名"></a>自定义过渡类名</h3><p>我们可以通过以下特性来自定义过渡类名：</p><ul><li>enter-class</li><li>enter-active-class</li><li>leave-class</li><li>leave-active-class</li></ul><p>他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 <code>Animate.css</code> 结合使用十分有用。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=&quot;https://unpkg.com/animate.css@3.5.1/animate.min.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;</span><br><span class="line">&lt;div id=&quot;example-3&quot;&gt;</span><br><span class="line">  &lt;button @click=&quot;show = !show&quot;&gt;</span><br><span class="line">    Toggle render</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">  &lt;transition</span><br><span class="line">    name=&quot;custom-classes-transition&quot;</span><br><span class="line">    enter-active-class=&quot;animated tada&quot;</span><br><span class="line">    leave-active-class=&quot;animated bounceOutRight&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h3 id="同时使用-Transitions-和-Animations"><a href="#同时使用-Transitions-和-Animations" class="headerlink" title="同时使用 Transitions 和 Animations"></a>同时使用 Transitions 和 Animations</h3><p>Vue 为了知道过渡的完成，必须设置相应的<strong>事件监听器</strong>。它可以是 <code>transitionend</code>或 <code>animationend</code> ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。</p><h3 id="JavaScript-钩子"><a href="#JavaScript-钩子" class="headerlink" title="JavaScript 钩子"></a>JavaScript 钩子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition</span><br><span class="line">  v-on:before-enter=&quot;beforeEnter&quot;</span><br><span class="line">  v-on:enter=&quot;enter&quot;</span><br><span class="line">  v-on:after-enter=&quot;afterEnter&quot;</span><br><span class="line">  v-on:enter-cancelled=&quot;enterCancelled&quot;</span><br><span class="line">  v-on:before-leave=&quot;beforeLeave&quot;</span><br><span class="line">  v-on:leave=&quot;leave&quot;</span><br><span class="line">  v-on:after-leave=&quot;afterLeave&quot;</span><br><span class="line">  v-on:leave-cancelled=&quot;leaveCancelled&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;!-- ... --&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">methods: &#123;</span><br><span class="line">  // --------</span><br><span class="line">  // 进入中</span><br><span class="line">  // --------</span><br><span class="line">  beforeEnter: function (el) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  // 此回调函数是可选项的设置</span><br><span class="line">  // 与 CSS 结合时使用</span><br><span class="line">  enter: function (el, done) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    done()</span><br><span class="line">  &#125;,</span><br><span class="line">  afterEnter: function (el) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  enterCancelled: function (el) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  // --------</span><br><span class="line">  // 离开时</span><br><span class="line">  // --------</span><br><span class="line">  beforeLeave: function (el) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  // 此回调函数是可选项的设置</span><br><span class="line">  // 与 CSS 结合时使用</span><br><span class="line">  leave: function (el, done) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    done()</span><br><span class="line">  &#125;,</span><br><span class="line">  afterLeave: function (el) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  // leaveCancelled 只用于 v-show 中</span><br><span class="line">  leaveCancelled: function (el) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些钩子函数可以结合 <code>CSS transitions/animations</code>使用，也可以单独使用。</p><blockquote><p>当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。 否则，它们会被同步调用，过渡会立即完成。</p></blockquote><blockquote><p><strong>推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。</strong></p></blockquote><h2 id="初始渲染的过渡"><a href="#初始渲染的过渡" class="headerlink" title="初始渲染的过渡"></a>初始渲染的过渡</h2><p>可以通过<code>appear</code> 特性设置节点的在初始渲染的过渡<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition appear&gt;</span><br><span class="line">  &lt;!-- ... --&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></p><p>这里默认和进入和离开过渡一样，同样也可以自定义 CSS 类名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition</span><br><span class="line">  appear</span><br><span class="line">  appear-class=&quot;custom-appear-class&quot;</span><br><span class="line">  appear-active-class=&quot;custom-appear-active-class&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;!-- ... --&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure><p>自定义 JavaScript 钩子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition</span><br><span class="line">  appear</span><br><span class="line">  v-on:before-appear=&quot;customBeforeAppearHook&quot;</span><br><span class="line">  v-on:appear=&quot;customAppearHook&quot;</span><br><span class="line">  v-on:after-appear=&quot;customAfterAppearHook&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;!-- ... --&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></p><h2 id="多个元素的过渡"><a href="#多个元素的过渡" class="headerlink" title="多个元素的过渡"></a>多个元素的过渡</h2><p> 对于原生标签可以使用 <code>v-if</code>/<code>v-else</code> 。最常见的多标签过渡是<strong>一个列表</strong>和<strong>描述这个列表</strong>为空消息的元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">  &lt;table v-if=&quot;items.length &gt; 0&quot;&gt;</span><br><span class="line">&lt;!-- ... --&gt;</span><br><span class="line">  &lt;/table&gt;</span><br><span class="line">  &lt;p v-else&gt;Sorry, no items found.&lt;/p&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>当有<strong>相同标签名</strong>的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，<strong>给在 &lt;transition组件中的多个元素设置 key 是一个更好的实践。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">  &lt;button v-if=&quot;isEditing&quot; key=&quot;save&quot;&gt;</span><br><span class="line">    Save</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">  &lt;button v-else key=&quot;edit&quot;&gt;</span><br><span class="line">    Edit</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="过渡模式"><a href="#过渡模式" class="headerlink" title="过渡模式"></a>过渡模式</h3><ul><li>in-out: 新元素先进行过渡，完成之后当前元素过渡离开。</li><li>out-in: 当前元素先进行过渡，完成之后新元素过渡进入。</li></ul><h2 id="多个组件的过渡"><a href="#多个组件的过渡" class="headerlink" title="多个组件的过渡"></a>多个组件的过渡</h2><p>多个组件的过渡简单很多 - 我们不需要使用 key 特性。相反，我们只需要使用<strong>动态组件</strong>:</p><h2 id="列表过渡"><a href="#列表过渡" class="headerlink" title="列表过渡"></a>列表过渡</h2><p>怎么同时渲染整个列表，比如使用<code>v-for</code>？在这种场景中，使用 <code>&lt;transition-group&gt;</code>组件。在我们深入例子之前，先了解关于这个组件的几个特点：</p><ul><li>不同于 <code>&lt;transition&gt;</code>， 它会以一个真实元素呈现：默认为一个 <code>&lt;span&gt;</code>。你也可以通过 tag 特性更换为其他元素。</li><li>内部元素 总是需要 提供<code>唯一的 key</code> 属性值</li></ul><h3 id="列表的位移过渡"><a href="#列表的位移过渡" class="headerlink" title="列表的位移过渡"></a>列表的位移过渡</h3><p><code>&lt;transition-group&gt;</code> 组件还有一个特殊之处。不仅可以进入和离开动画，还可以<strong>改变定位。</strong>要使用这个新功能只需了解新增的 <code>v-move</code>特性，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过 <code>name</code> 属性来自定义前缀，也可以通过 <code>move-class</code> 属性手动设置。<br>v-move 对于设置过渡的切换时机和过渡曲线非常有用，你会看到如下的例子：</p><!--PC和WAP自适应版--><p><div id="SOHUCS" sid="SourceID"></div> </p><p><script type="text/javascript"><br>(function(){<br>var appid = ‘cysmzRdbl’;<br>var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;<br>var width = window.innerWidth || document.documentElement.clientWidth;<br>if (width &lt; 960) {<br>window.document.write(‘<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '">&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“<a href="https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})})">https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})})</a>; } })(); </script></p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2017/09/21/Vue进阶之路——过渡效果/">http://jaymo666.github.io/2017/09/21/Vue进阶之路——过渡效果/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://jaymo666.github.io/categories/JS/"/>
    
    
      <category term="js" scheme="http://jaymo666.github.io/tags/js/"/>
    
      <category term="初级" scheme="http://jaymo666.github.io/tags/%E5%88%9D%E7%BA%A7/"/>
    
      <category term="Vue" scheme="http://jaymo666.github.io/tags/Vue/"/>
    
      <category term="框架" scheme="http://jaymo666.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Threejs</title>
    <link href="http://jaymo666.github.io/2017/09/21/Threejs/"/>
    <id>http://jaymo666.github.io/2017/09/21/Threejs/</id>
    <published>2017-09-21T15:38:32.000Z</published>
    <updated>2017-12-03T11:29:54.568Z</updated>
    
    <content type="html"><![CDATA[<p>一门3D技术语言。<br><a id="more"></a><br>什么是threejs，很简单，你将它理解成three + js就可以了。three表示3D的意思，js表示javascript的意思。那么合起来，three.js就是使用javascript 来写3D程序的意思。<br>Javascript是运行在网页端的脚本语言，那么毫无疑问Three.js也是运行在浏览器上的。<!-- more --></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=447960871&auto=0&height=66"></iframe><p>##第一章<br>来学习three.js之前最好了解一下WebGL。<br>什么是WebGL?</p><blockquote><p>WebGL是在浏览器中实现三维效果的一套规范。</p></blockquote><p>使用<code>WebGL</code>原生的API来写3D程序是一件非常痛苦的事情，幸好，有很多同行花业余时间写了一些WebGL开源框架，其中three.js就是非常优秀的一个，它掩 盖了很多麻烦的细节，那么，就让我们一起来看看，什么是<code>three.js</code>吧</p><h3 id="1-启程："><a href="#1-启程：" class="headerlink" title="1. 启程："></a>1. 启程：</h3><p>实际上，我们要使用 Three.js 展示一些画面到浏览器上, 我们需要下面这三样东西:一个<strong>场景</strong>(scene)， 一个<strong>摄像头</strong>(camera) , 和一个<strong>渲染器</strong>(renderer)， 所以我们使用一个相机渲染一个场景.</p><pre><code>var scene = new THREE.Scene();    // 场景var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);// 透视相机var renderer = new THREE.WebGLRenderer();    // 渲染器renderer.setSize(window.innerWidth, window.innerHeight);    // 设置渲染器的大小为窗口的内宽度，也就是内容区的宽度document.body.appendChild(renderer.domElement);</code></pre><p><strong>场景是所有物体的容器</strong>，如果要显示一个苹果，就需要将苹果对象加入场景中。</p><p>另一个组件是相机，<strong>相机决定了场景中那个角度的景色会显示出来</strong>。相机就像人的眼睛一样，人站在不同位置，抬头或者低头都能够看到不同的景色。</p><p>场景只有一种，但是相机却又很多种。和现实中一样，不同的相机确定了呈相的各个方面。比如有的相机适合人像，有的相机适合风景，专业的摄影师根据实际用途不一样，选择不同的相机。对程序员来说，只要设置不同的相机参数，就能够让相机产生不一样的效果。</p><h3 id="2-三维空间"><a href="#2-三维空间" class="headerlink" title="2. 三维空间"></a>2. 三维空间</h3><p><strong>两种基本的相机</strong></p><ol><li>透视相机</li><li>正投影相机</li></ol><h5 id="2-1-单反、双反都是相机"><a href="#2-1-单反、双反都是相机" class="headerlink" title="2.1. 单反、双反都是相机"></a>2.1. 单反、双反都是相机</h5><p>2.1.1 认识相机<br>在Threejs中相机的表示是<code>THREE.Camera</code>，它是相机的抽象基类，其子类有两种相机，分别是<strong>正投影相机</strong><code>THREE.OrthographicCamera</code>和<strong>透视投影相机</strong><code>THREE.PerspectiveCamera</code>。类图如下所示：<br><img src="http://www.hewebgl.com/attached/image/20130530/20130530145028_752.png" alt="相机的抽象基类及其子类"></p><p>正投影相机有时候也叫正交投影摄像机，下图显示了正交摄像机投影和透视投影之间的差别。</p><p><img src="http://www.hewebgl.com/attached/image/20130530/20130530145454_509.png" alt="正交摄像机投影和透视投影之间的差别图"></p><p>2.1.2 两者的区别</p><p>正投影和透视投影的区别是：透视投影有一个基本点，就是远处的物体比近处的物体小。</p><p>在工程建筑领域，正投影的例子很多，例如下面就是一个正投影的例子：<br><img src="http://www.hewebgl.com/attached/image/20130530/20130530145820_901.jpg" alt="正投影图"><br>其特点是，远近高低比例都相同。</p><h5 id="2-2-正投影相机"><a href="#2-2-正投影相机" class="headerlink" title="2.2 正投影相机"></a>2.2 正投影相机</h5><p>下面我们来介绍正投影相机，正投影的构造函数如下所示：</p><p><strong>OrthographicCamera( left, right, top, bottom, near, far )</strong></p><p>结合下面一个图，我们来看看，各个参数的意思。<br><img src="http://www.hewebgl.com/attached/image/20130530/20130530145859_920.jpg" alt=""></p><p>1、 left参数</p><p>left：左平面距离相机中心点的垂直距离。从图中可以看出，左平面是屏幕里面的那个平面。</p><p>2、 right参数</p><p>right：右平面距离相机中心点的垂直距离。从图中可以看出，右平面是屏幕稍微外面一点的那个平面。</p><p>3、 top参数</p><p>top：顶平面距离相机中心点的垂直距离。上图中的顶平面，是长方体头朝天的平面。</p><p>4、 bottom参数</p><p>bottom：底平面距离相机中心点的垂直距离。底平面是头朝地的平面。</p><p>5、near参数</p><p>near：近平面距离相机中心点的垂直距离。近平面是左边竖着的那个平面。</p><p>6、far参数</p><p>far：远平面距离相机中心点的垂直距离。远平面是右边竖着的那个平面。</p><p>有了这些参数和相机中心点，我们这里将<strong>相机的中心点又定义为相机的位置</strong>。通过这些参数，我们就能够在三维空间中唯一的确定上图的一个长方体。<strong>这个长方体也叫做视景体</strong>。</p><blockquote><p>投影变换的目的就是定义一个视景体，使得视景体外多余的部分裁剪掉，最终图像只是视景体内的有关部分。</p></blockquote><p>好了，看一个简单的例子：</p><pre><code>var camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );scene.add( camera );</code></pre><p>这个例子将浏览器窗口的宽度和高度作为了视景体的高度和宽度，相机正好在窗口的中心点上。这也是我们一般的设置方法，基本上为了方便，我们不会设置其他的值。</p><h5 id="2-3-透视投影相机"><a href="#2-3-透视投影相机" class="headerlink" title="2.3 透视投影相机"></a>2.3 透视投影相机</h5><p>透视投影相机的构造函数如下所示：</p><p><strong>PerspectiveCamera( fov, aspect, near, far )</strong></p><p>我们来欣赏一幅图来看看这个函数的各个参数的意思：<br><img src="http://www.hewebgl.com/attached/image/20130530/20130530151418_279.jpg" alt=""></p><p>先来明确这个图里涉及的概念。<br>1、视角fov：这个最难理解,我的理解是,眼睛睁开的角度,即,视角的大小,如果设置为0,相当你闭上眼睛了,所以什么也看不到,如果为180,那么可以认为你的视界很广阔,但是在180度的时候，往往物体很小，因为他在你的整个可视区域中的比例变小了。</p><p>2、近平面near：这个呢，表示你近处的裁面的距离。补充一下，也可以认为是眼睛距离近处的距离，假设为10米远，请不要设置为负值，Three.js就傻了,不知道怎么算了,</p><p>3、远平面far：这个呢，表示你远处的裁面,</p><p>4、纵横比aspect：实际窗口的纵横比，即宽度除以高度。这个值越大，说明你宽度越大</p><p>好了，看看下面一个简单的例子：</p><pre><code>var camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );scene.add( camera );</code></pre><p>未完待续。。。</p><!--PC和WAP自适应版--><p><div id="SOHUCS" sid="SourceID"></div> </p><p><script type="text/javascript"><br>(function(){<br>var appid = ‘cysmzRdbl’;<br>var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;<br>var width = window.innerWidth || document.documentElement.clientWidth;<br>if (width &lt; 960) {<br>window.document.write(‘<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '">&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“<a href="https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})})">https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})})</a>; } })(); </script></p><hr><p>本作品采用 <a href="https://creativecommons.org/licenses/by-sa/2.5/cn/" target="_blank" rel="noopener">知识共享署名 2.5 中国大陆许可协议 </a>进行许可，欢迎转载，但转载请注明来自<a href="https://jaymo666.github.io/">JayMo</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文永久链接：<a href="http://jaymo666.github.io/2017/09/21/Threejs/">http://jaymo666.github.io/2017/09/21/Threejs/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一门3D技术语言。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://jaymo666.github.io/categories/JS/"/>
    
      <category term="3D" scheme="http://jaymo666.github.io/categories/JS/3D/"/>
    
    
      <category term="js" scheme="http://jaymo666.github.io/tags/js/"/>
    
      <category term="初级" scheme="http://jaymo666.github.io/tags/%E5%88%9D%E7%BA%A7/"/>
    
      <category term="可视化" scheme="http://jaymo666.github.io/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="3D" scheme="http://jaymo666.github.io/tags/3D/"/>
    
  </entry>
  
</feed>
