<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[迁移hexo到新电脑]]></title>
    <url>%2F2018%2F03%2F08%2F%E8%BF%81%E7%A7%BBhexo%E5%88%B0%E6%96%B0%E7%94%B5%E8%84%91%2F</url>
    <content type="text"><![CDATA[在更换新电脑的情况下恢复博客，保留了源码 1、从官网Git下载git，在新电脑上安装，因为https速度慢，而且每次都要输入口令，常用的是使用ssh。使用下面方法创建：（1）打开git bash，在用户主目录下运行：ssh-keygen -t rsa -C “youremail@example.com“ 把其中的邮件地址换成自己的邮件地址，然后一路回车（2）最后完成后，会在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，千万不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。（3）登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」，你就应该看到已经添加的Key。注意：不要在git版本库中运行ssh，然后又将它提交，这样就把密码泄露出去了。（3）https://coding.net 中的ssh与github的共用 2、下载Node.js，并安装 3、打开git bash客户端，输入 npm install hexo-cli -g，开始安装hexo 4、下面就将原来的文件拷贝到新电脑中，但是要注意哪些文件是必须的，哪些文件是可以删除的。（1）讨论下哪些文件是必须拷贝的：首先是之前自己修改的文件，像站点配置_config.yml，theme文件夹里面的主题，以及source里面自己写的博客文件，这些肯定要拷贝的。除此之外，还有三个文件需要有，就是scaffolds文件夹（文章的模板）、package.json（说明使用哪些包）和.gitignore（限定在提交的时候哪些文件可以忽略）。其实，这三个文件不是我们修改的，所以即使丢失了，也没有关系，我们可以建立一个新的文件夹，然后在里面执行hexo init，就会生成这三个文件，我们只需要将它们拷贝过来使用即可。总结：_config.yml，theme/，source/，scaffolds/，package.json，.gitignore，是需要拷贝的。（2）再讨论下哪些文件是不必拷贝的，或者说可以删除的：首先是.git文件，无论是在站点根目录下，还是主题目录下的.git文件，都可以删掉。然后是文件夹node_modules（在用npm install会重新生成），public（这个在用hexo g时会重新生成），.deploy_git文件夹（在使用hexo d时也会重新生成），db.json文件。其实上面这些文件也就是.gitignore文件里面记载的可以忽略的内容。总结：.git/，public/，.deploy_git/，db.json文件需要删除。 5、在git bash中切换目录到新拷贝的文件夹里，使用 npm install 命令，进行模块安装。很明显我们这里没用hexo init初始化，因为有的文件我们已经拷贝生成过来了，所以不必用hexo init去整体初始化，如果不慎在此时用了hexo init，则站点的配置文件_config.yml里面内容会被清空使用默认值，所以这一步一定要慎重，不要用hexo init。 6、安装其他的一些必要组件，如果在node_modules里面有的，就不要重复安装了：（1）为了使用hexo d来部署到git上，需要安装npm install hexo-deployer-git –save（2）为了建立RSS订阅，需要安装npm install hexo-generator-feed –save（3）为了建立站点地图，需要安装npm install hexo-generator-sitemap –save插件安装后，有的需要对配置文件_config.yml进行配置，具体怎么配置，可以参考上面插件在github主页上的具体说明 7、使用hexo g，然后使用hexo d进行部署，如果都没有出错，就转移成功了！ 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2018/03/08/迁移hexo到新电脑/]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客再配置]]></title>
    <url>%2F2018%2F03%2F08%2F%E2%80%9Chexo%E5%8D%9A%E5%AE%A2%E5%86%8D%E9%85%8D%E7%BD%AE%E2%80%9D%2F</url>
    <content type="text"><![CDATA[记录更换电脑后开启的新功能 #1.已结开启的功能 ##1.1设置 RSS ##1.2侧边栏社交链接 ##1.3设置「动画效果」 ##1.4设置「背景动画」 #2.待开启 ##2.1设置字体 ##2.2开启打赏功能 ##2.3订阅微信公众号 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2018/03/08/“hexo博客再配置”/]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2018/03/07/hello-world/]]></content>
  </entry>
  <entry>
    <title><![CDATA[conda用法]]></title>
    <url>%2F2017%2F12%2F04%2Fconda%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Conda简单用法及在python2与python3之间切换 安装scipyconda install scipy conda会从从远程搜索scipy的相关信息和依赖项目，对于python 3.4，conda会同时安装numpy和mkl（运算加速的库）查看已经安装的packagesconda list 最新版的conda是从site-packages文件夹中搜索已经安装的包，不依赖于pip，因此可以显示出通过各种方式安装的包查看当前环境下已安装的包conda list 查看某个指定环境的已安装包conda list -n python34 查找package信息conda search numpy 安装packageconda install -n python34 numpy 如果不用-n指定环境名称，则被安装在当前活跃环境也可以通过-c指定通过某个channel安装更新packageconda update -n python34 numpy 删除packageconda remove -n python34 numpy conda将conda、python等都视为package，因此，完全可以使用conda来管理conda和python的版本，例如 更新conda，保持conda最新conda update conda 更新anacondaconda update anaconda 更新pythonconda update python 假设当前环境是python 3.4, conda会将python升级为3.4.x系列的当前最新版本如果创建新的python环境，比如3.4，运行conda create -n python34 python=3.4之后，conda仅安装python 3.4相关的必须项，如python, pip等，如果希望该环境像默认环境那样，安装anaconda集合包，只需要： 在当前环境下安装anaconda包集合conda install anaconda 结合创建环境的命令，以上操作可以合并为conda create -n python34 python=3.4 anaconda 也可以不用全部安装，根据需求安装自己需要的package即可 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/12/04/conda用法/]]></content>
  </entry>
  <entry>
    <title><![CDATA[网络管理员必备]]></title>
    <url>%2F2017%2F09%2F26%2FNetwork(1)%2F</url>
    <content type="text"><![CDATA[本文包括： [1]ping命令 [2]路由器和交换机的差异 [3]路由器的基本设置 [4]netsh网络配置命令 [5]安装失败（未签名） [6]管理用户网络应用 [7]映射网络驱动器 [8]网络适配器的原理 [9]交换机的分类 [10]交换机的功能 [11]交换机的接口种类 [12]路由器的工作原理 [13]初识TCP/IP的分层 网络管理员必备[1]ping命令“ping”命令是windows系统最长用的命令之一，是通过对一个网址发送测试数据包，看对方网址是否有响应并统计响应时间，以此测试网络，同时可以很好地帮助我们分析和判定网络故障。 方式：“ping IP地址/域名” 输入“ping IP地址”回车，我们可以看到本机跟这台网络设备的连接状态，如下图所示是连接正常的。例如：百度首页ip地址：119.75.217.109 2.还可以“ping 域名”,例如:ping baidu.com 3.如果“ping”后出现下图所示界面，说明本机跟这台网络设备的网络连接是不通的 4.键入“ping”直接回车我们还可以看到ping命令加其他参数的使用方法 5.比如，我们使用“ping IP地址 -t”命令，可以持续的ping指定的主机，如果没有手动停止，ping命令会一直持续下去，我们可以通过“Ctrl+C”停止命令。其他参数的使用方法用户可以自己体验 [2]路由器和交换机的差异1. 工作层次不同:交换机工作在七层模型的第二层（即数据链路层）；而路由器工作在第三层（即网络层）。交换机由于工作在第二层，它的工作原理比较简单，而路由器在第三层，可以得到更多的协议信息，也可以做出更加智能的转发或映射。 网络层（第三层）：能提供介质访问和链路管理等功能数据链路层（第二层）：具有寻址和路由选择等功能 2. 数据转发依据的对象不同交换机是利用网络设备的物理地址（即MAC地址）来确定转发数据的目的地址；路由器是利用网络设备的IP地址来确定转发数据的目的地址。其中物理地址是设备本身自带的，由设备的网卡生产厂商分配，已经固化到网卡硬件中，不可修改；而IP地址是在系统软件中分配的，可以修改。 通过命令“ipconfig/all”，可以查看本机的物理地址和IP地址。如下图所示，就是我的计算机的网卡信息。 3.路由器可以分割广播域，而交换机不能交换机只可以分割冲突域，不可以分割广播域，而路由器可以分割广播域。简单的来说，在同一个交换机下连接的设备，IP都在同一个网段，是属于同一个广播域的，如果不在同一网段，则无法进行通信；而路由器可以分配不同的广播域（即不同的网段），而这些不同网段的设备可以不穿过路由而进行相互通信。 目前，虽然三层或者第三层以上交换机具有VLAN功能，也可以分割广播域，但是各个广播域之间是不可以相互通信的，他们之前如果要通信交流还是需要路由器的支持。 4.路由器有防火墙服务，而交换机没有路由器设置的防火墙是运行在网络层的，通过设置特定的规定，允许或者限制传输的数据通过，或者过滤IP封包，禁止不符合规定的封包通过。而交换机不具备防火墙功能，如果只是通过交换机接通外部网络，相当于闭上眼、光着屁股在大街上跑，很不安全！ 注意：数据安全很重要，路由器、交换机的使用都要慎重！注意保密保护工作！ [3]路由器的基本设置 要实现多台计算机同时上网，主要设置的地方就是路由器，下面以企业中总路由器下的一个无线路由为大家介绍一下路由器的基本设置过程。 1.通过浏览器登录路由器。如果是新路由器，可以查看路由后面贴标签出的默认IP和登录账号、密码；如果是正常使用中的路由器，登录地址可以查看计算机的网关，如果登录密码修改过，请咨询管理员。 电脑和路由器相连：一种是通过网线连接，一种是通过无线连接。 电脑和路由器之间通过网线连接的话，你要在路由器上找到LAN口和WAN口。这里讲一下，WAN口全称Wide Area Network（广域网），LAN口全称Wide Area Network（局域网）。一般的路由有很多LAN口，一个WAN口。WAN口插主网线，LAN插电脑与路由连接的网线。这样电脑就和路由器连接了。 电脑连接上了路由器，就可以在浏览器上输入路由器的地址进入路由器的设置界面了 2.WAN口设置，“基本设置”中的“快速设置”，（1）如果外网地址没有固定IP，则类型选择动态；（2）如果外网地址有固定IP或者上层还有路由则将分配IP设置到wan口，如下图所示。 3.LAN口的设置，“基本设置”中的“内网设置”，设置IP地址（即内网中网络设备的网关比如设置成192.168.1.1，如果上层有路由是192.168.1.1，则次路由器可以设置成其他网段192.168.x.1）、子网掩码。4.“DHCP服务器”的设置，如果让用户自动获取IP地址使用，需要使用DHCP服务器，可以限制用户自动获取IP地址的范围，如下图的“起始IP地址”和“结束IP地址”（可以在上网行为管理的IP地址组中看到）。 5.无线的“基本设置”，要启用无线的话，勾选启用开关，并为无线网络设置一个名称，设置无线模式为“11b/g/n混合模式”，来兼容三种无线协议：802.11b、802.11g、802.11n。 6.无线的“安全设置”，如果需要做MAC地址绑定的安全管控，需要勾选mac地址“启用”：设置“允许”，将允许上网的计算机mac地址添加到mac地址列表；设置“禁用”，将不允许上网的计算机mac地址添加到mac地址列表。设置加密类型为常用的“WPA2-PSK”，并设置密码 7.“上网行为管理”设置，设置允许或者不允许上网的时间段；如果需要管理QQ等常用聊天软件，可以在聊天软件高级设置里进行启用，将允许使用QQ等聊天软件的账号添加到例外列表。 8.网络安全中设置内外网的“攻击防御”和“MAC地址绑定”（勾选“禁止未绑定IP/MAC的主机通过”，前面已经说过，不再赘述） 9.“端口映射”和“域名转发”，大多在系统集成中会用到，特别是监控设备想要远程访问，需要将设备的通讯端口等进行路由转发，此处需要注意的是，如果跨多层路由的话，每一层路由都是需要转发的。 10.修改路由器的登录密码。 [4]netsh网络配置命令netsh是Network Shell的缩写，是windows为我们提供的功能强大的网络配置命令行工具。下面用几个常用的“netsh interface ip show”小命令介绍netsh的用法。 1.netsh interface ip show address:显示本机IP地址配置，包括以太网的ip和本地回环ip地址，以太网ip地址就是我们常说的为本机网卡分配的一个地址，这个容易理解；本地还有ip地址，是一种叫做本地回环接口虚接口，在windows系统中都会采用如下图所示的127.0.0.1这个地址，用以提高网络的健壮性。 2.如果在上一步的基础上想要显示更多信息，可以用命令：netsh interface ip show config。 3.netsh interface ip show dns:显示本机使用的DNS服务器，同样包括以太网和本地回环接口的DNS信息。 4.netsh interface ip show ipnet:显示本IP地址所在的网络到媒体的映射，我们同时可以看到映射类型和所用接口等信息。 5.netsh interface ip show wins:如果设置了wins服务器，可以用此命令查看wins服务器的地址。 6.还有一个我喜欢用的不属于“netsh interface ip”这一系列的小命令，netsh firewall show state:查看本机防火墙的状态，每当我们公司某一台办公电脑在连接公司的某个系统连接不上的时候，我会用以查看防火墙状态，我们可以看到启用或禁用的功能模块，以及启用情况。 [5]安装失败（未签名）在我们安装驱动的时候，特别是用驱动精灵等驱动软件安装的时候，会出现“安装失败（未签名）”的情况，如何解决？ 方法/步骤 1.单击开始菜单里的“运行”，或者通过“windows键+R”打开“运行”，在输入框中输入“sigverif”回车 2.在打开的文件签名验证里点击“高级”按钮 3.如下图所示找到下载的驱动（如果未解压，需要先解压），然后点击“确认”按钮 4.切换到“正在记录”选项，选中如下图所示选项，点击“确定”按钮 5.回到第二步时候的界面，点击“开始”按钮，我们可以看到下图所示列表界面，点击“关闭”即可 6.从设备管理器安装驱动，右键单击我的电脑（xp）/计算机（win7）/这台电脑（win8），点击“管理”，在“计算机管理”中右侧边栏中单击“设备管理器”，找到我们要安装驱动的这个硬件，右键单击，选择“更新驱动程序” 7.勾选“从列表或指定位置安装”，点击“下一步”按钮 8.选择驱动程序解压后的文件夹，点击“下一步”按钮 9.到安装界面，用户需等待，知道出现安装成功的界面，点击“完成”按钮即可 10.返回到设备管理器，我们可以看到，此驱动已经安装完成 [6]管理用户网络应用现在各种网络应用程序纷繁复杂，而p2p软件又是其中最为流行的一种，而且提供了多样化得登陆方式，在此，我们以最常用的QQ为例。 我们大家都知道，QQ本身支持UDP、HTTP和HTTPS三种登陆方式，而且可以使用代理，意思是说，只要你允许了HTTP协议，QQ就可以登陆。 现在我们以封锁QQ为例，介绍一下，如何利用路由级的网络防火墙管理用户网络应用。 1.QQ登陆原理 QQ登录登陆的过程，由向服务器群的8000端口发送UDP数据包，从服务器群的回复中选择一个最快的作为登陆服务器。 如果没有服务器回复UDP数据包，则使用TCP80/443端口来进行连接。 QQ服务器： UDP8000端口类18个 TCPHTTP连接服务器5个 会员VIP服务器使用HTTPS443连接 2.如何封锁1.上面我们知道，QQ可以使用HTTP直接连接，一般不能封锁HTTP协议，所以最好的办法就是封锁它的服务器IP地址，但是QQ还可以使用代理登陆，这种情况我们就得在路由级防火墙中的HTTP检查机制中设置禁止QQ的HTTP连接。2.首先，配置用户访问规则，使用计算机集定义目的网络。也就是做好禁止内部客户访问QQ服务器的访问策略。 3.其次，配置HTTP策略，理由路由器的HTTP深层检查机制，禁止QQ使用HTTP代理。在允许ＱＱ使用HTTP代理的策略上点击右键，选中“配置HTTP” 4.在弹出的“为规则配置HTTP策略”对话框中，点击“签名”，然后点击“添加”，在弹出的“签名”对话框中，输入名称为“QQ”，指定签名搜索条件为在“请求URL”中搜索“tencent.com”，找到则阻止这个连接 5.最后，在防火墙策略选项中，点击“应用”来保存修改和更新防火墙策略，此时，QQ已经不能通过代理服务器登录了 [7]映射网络驱动器映射网络驱动器” 的意思是将局域网中的某个目录（一般是共享的文件夹之类的）映射成本地驱动器号，就是说把网络上其他机器的共享的文件夹映射自己机器上的一个磁盘，这样可以提高访问时间，相当于一个打开共享的快捷方式。 1.首先，找到这个共享文件夹，我们可以在网络里找到这台设备，或者打开开始菜单的“运行”，输入：“\这台设备的IP地址”，比如此例中的“\192.168.1.52” 2.在打开的共享界面，找到并右键单击要映射驱动器的文件件，选择“映射网络驱动器” 3.在映射驱动器的界面，选择好驱动器盘符，点击“完成”即可完成设置 4.打开资源管理器，我们可以看到，已经有了该驱动器，日常使用过程中直接点击打开即可 [8]网络适配器的原理网络适配器，也就是我们说的网卡，有些维修人员也叫网络接口卡，是计算机和网络电缆之间的物理接口，下面我们根据网络适配器需要完成的任务介绍一下它的工作原理。 1.为在计算机使用的数据（并行数据）和电缆上传输的电信号（串行数据）之间提供数据转换的功能。比如我们用的一个共享打印机，计算机直接连接打印机用的是并行数据，而如果我们通过网络连接别人共享的打印机，就是通过串行数据转换为并行数据来实现。2.判断从电缆接收的数据是否为传输给该计算机的数据。 3.在计算机和电缆之间控制数据流，每块网卡都有一个唯一的标识，我们一般叫做MAC地址，大部分网卡的MAC地址烧录在卡上的ROM芯片中，MAC地址有6段组成，通常表示为12个16进制数。我们可以通过命令提示符查看本机网卡的信息，操作步骤：1、单击开始菜单里的“运行”，在输入框中输入“cmd”，然后回车。2、在命令提示符界面输入“ipconfig /all”命令，回车，我们可以看到以下信息。如图所示的是本机无线网卡的信息，其中前3字节“A6-17-31”表示厂商代码，有IEEE负责分配；后3个字节“30-49-E2”表示网卡序号，由网卡厂商负责。 [9]交换机的分类交换机是网络连接的基础，有了交换机，就可以实现更多电脑的共享上网 1.广义上来讲，交换机分为两种：广域交换机和局域网交换机。广域网交换机主要用于电信领域，提供通信用的基础平台，我们平常接触很少；而局域网交换机是我们日常使用最多的，主要应用于日常的局域网络，连接计算机和网络打印机的终端设备 2.从传输介质和传输速度上可以分为以太网交换机、快速以太网交换机、千兆以太网交换机、FDDI交换机、ATM交换机和令牌交换机等 3.从规模应用上可以分为企业级、部门级和工作组交换机 [10]交换机的功能1.交换机功能学习功能，局域网内交换机会了解跟每一个插口相连接的MAC地址，并将地址同相应的端口映射起来存放在交换机缓存中的MAC地址表中 2.转发/过滤功能当一个数据帧的目的地址在MAC地址表中有映射时，它被转发到连接目的节点的端口而不是所有端口（如该数据帧为广播/组播帧则转发至所有端口） 3.消除回路功能当交换机包括一个冗余回路时，以太网交换机通过生成树协议避免回路的产生，同时允许存在后背路径 4.兼容功能交换机除了能连接两种同类型的网络之外，还可以在不同类型的网路（如以太网和快速以太网）之间起到互联作用。而且现在的交换机没有很严格的类型之分，百兆交换机一般也会加两个千兆口或光纤接入口 [11]交换机的接口种1.双绞线RJ-45接口-水晶头 2.光纤接口光纤需要熔接到带插头的尾纤，常见的尾纤插头有SC。 [12]路由器的工作原理路由器，大家都很熟悉了，办公室或者家里凡有两台以上的电脑需要上网的一般都安装了路由器，只有安装了路由器才能实现多台电脑同时上网。我们就了解下路由器的配置原理。 1.路由器的概念1.所谓“路由”，就是把数据从一个地方传送到另一个地方的行为和动作，路由器就是执行这个动作的机器，英文名Router 2.路由器能将不同网络或网段之间的数据信息进行“翻译”，以使他们能够相互“读”懂对方的数据，从而构建更大的网络。 2.路由器的典型功能 数据通道功能 包括转发决定、背板转发以及输出链路调度等，一般由特定的硬件来完成 控制功能 一般用软件来实现，包括与相邻路由器之间的信息交换、系统配置、系统管理等 3.路由器的主要功能 网络互连 路由器支持各种局域网和广域网接口，主要用于互连局域网和广域网，实现不同网络互相通信 数据处理 提供包括分组过滤、分组转发、优先级、复用、加密、压缩和防火墙等功能 网络管理 路由器提供包括配置管理、性能管理、容错管理和流量控制管理等功能 4.路由器的工作原理 接收来自它连接的某个网络的数据 将数据向上传递，并且（必要时）重新组合IP数据报 检查IP头部中的目的地址，如果目的地址位于发出数据的那个网络，那么路由器就放下被认为已经达到目的地的数据，因为数据是在目的计算机所在网络上传输 如果数据要送往另一个网络，那么路由器就查询路由表，以确定数据要转发到的目的地 路由器确定哪个适配器负责接收数据后，就通过相应的软件传递数据，以便通过网络来传送数据 [13]初识TCP/IP的分层大家可能经常使用TCP/IP协议，在进行网络配置或修改IP地址等操作的时候会用到该处，但很少有人去深入挖掘，在此我们简单的了解一下TCP/IP的分层。 1.TCP/IP协议 Internet采用了TCP/IP协议，但这并不是一个单一的协议，我们可能知道，TCP即传输控制协议，IP为网间协议，TCP/IP我们常常描述为互联网协议集。但可能很少人知道TCP/IP也是一种分层模型。它是基于硬件层次上的四个概念性层次构成，分别是网络接口层（数据链路层）、IP层（网络层）、传输层、应用层。 网络接口层:也称数据链路层，这是TCP/IP最底层。功能:负责接收IP数据报并发送至选定的网络。 IP层:IP层处理机器之间的通信。功能:它接收来自传输层的请求，将带有目的地址的分组发送出去。将分组封装到数据报中，填入数据报头，使用路由算法以决定是直接将数据报传送至目的主机还是传给路由器，然后把数据报送至相应的网络接口来传送。 传输层:是提供应用层之间的通信，即端到端的通信。功能:管理信息流，提供可靠的传输服务，以确保数据无差错的地按序到达。 2.TCP/IP模型的分界线协议地址分界线:以区分高层和低层的寻址，高层寻址使用IP地址，低层寻址使用物理地址。应用程序IP层之上的协议软件只使用IP地址，而网络接口层处理物理地址。 操作系统分界线:以区分系统与应用程序。在传输层和应用层之间。 3.复用与分解 发送报文时，发送方在报文中加和了报文类型、选用协议等附加信息。所有的报文以帧的形式在网络中复用传送，形成一个分组流。在接收方收到分组时，参考附加信息对接收到的分组进行分解。 参考网址：https://jingyan.baidu.com/season/38734 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/26/Network(1)/]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络管理员必备]]></title>
    <url>%2F2017%2F09%2F26%2FNetwork%2F</url>
    <content type="text"><![CDATA[本文包括： [1]ping命令 [2]路由器和交换机的差异 [3]路由器的基本设置 [4]netsh网络配置命令 [5]安装失败（未签名） [6]管理用户网络应用 [7]映射网络驱动器 [8]网络适配器的原理 [9]交换机的分类 [10]交换机的功能 [11]交换机的接口种类 [12]路由器的工作原理 [13]初识TCP/IP的分层 网络管理员必备[1]ping命令“ping”命令是windows系统最长用的命令之一，是通过对一个网址发送测试数据包，看对方网址是否有响应并统计响应时间，以此测试网络，同时可以很好地帮助我们分析和判定网络故障。 方式：“ping IP地址/域名” 输入“ping IP地址”回车，我们可以看到本机跟这台网络设备的连接状态，如下图所示是连接正常的。例如：百度首页ip地址：119.75.217.109 2.还可以“ping 域名”,例如:ping baidu.com 3.如果“ping”后出现下图所示界面，说明本机跟这台网络设备的网络连接是不通的 4.键入“ping”直接回车我们还可以看到ping命令加其他参数的使用方法 5.比如，我们使用“ping IP地址 -t”命令，可以持续的ping指定的主机，如果没有手动停止，ping命令会一直持续下去，我们可以通过“Ctrl+C”停止命令。其他参数的使用方法用户可以自己体验 [2]路由器和交换机的差异1. 工作层次不同:交换机工作在七层模型的第二层（即数据链路层）；而路由器工作在第三层（即网络层）。交换机由于工作在第二层，它的工作原理比较简单，而路由器在第三层，可以得到更多的协议信息，也可以做出更加智能的转发或映射。 网络层（第三层）：能提供介质访问和链路管理等功能数据链路层（第二层）：具有寻址和路由选择等功能 2. 数据转发依据的对象不同交换机是利用网络设备的物理地址（即MAC地址）来确定转发数据的目的地址；路由器是利用网络设备的IP地址来确定转发数据的目的地址。其中物理地址是设备本身自带的，由设备的网卡生产厂商分配，已经固化到网卡硬件中，不可修改；而IP地址是在系统软件中分配的，可以修改。 通过命令“ipconfig/all”，可以查看本机的物理地址和IP地址。如下图所示，就是我的计算机的网卡信息。 3.路由器可以分割广播域，而交换机不能交换机只可以分割冲突域，不可以分割广播域，而路由器可以分割广播域。简单的来说，在同一个交换机下连接的设备，IP都在同一个网段，是属于同一个广播域的，如果不在同一网段，则无法进行通信；而路由器可以分配不同的广播域（即不同的网段），而这些不同网段的设备可以不穿过路由而进行相互通信。 目前，虽然三层或者第三层以上交换机具有VLAN功能，也可以分割广播域，但是各个广播域之间是不可以相互通信的，他们之前如果要通信交流还是需要路由器的支持。 4.路由器有防火墙服务，而交换机没有路由器设置的防火墙是运行在网络层的，通过设置特定的规定，允许或者限制传输的数据通过，或者过滤IP封包，禁止不符合规定的封包通过。而交换机不具备防火墙功能，如果只是通过交换机接通外部网络，相当于闭上眼、光着屁股在大街上跑，很不安全！ 注意：数据安全很重要，路由器、交换机的使用都要慎重！注意保密保护工作！ [3]路由器的基本设置 要实现多台计算机同时上网，主要设置的地方就是路由器，下面以企业中总路由器下的一个无线路由为大家介绍一下路由器的基本设置过程。 1.通过浏览器登录路由器。如果是新路由器，可以查看路由后面贴标签出的默认IP和登录账号、密码；如果是正常使用中的路由器，登录地址可以查看计算机的网关，如果登录密码修改过，请咨询管理员。 电脑和路由器相连：一种是通过网线连接，一种是通过无线连接。 电脑和路由器之间通过网线连接的话，你要在路由器上找到LAN口和WAN口。这里讲一下，WAN口全称Wide Area Network（广域网），LAN口全称Wide Area Network（局域网）。一般的路由有很多LAN口，一个WAN口。WAN口插主网线，LAN插电脑与路由连接的网线。这样电脑就和路由器连接了。 电脑连接上了路由器，就可以在浏览器上输入路由器的地址进入路由器的设置界面了 2.WAN口设置，“基本设置”中的“快速设置”，（1）如果外网地址没有固定IP，则类型选择动态；（2）如果外网地址有固定IP或者上层还有路由则将分配IP设置到wan口，如下图所示。 3.LAN口的设置，“基本设置”中的“内网设置”，设置IP地址（即内网中网络设备的网关比如设置成192.168.1.1，如果上层有路由是192.168.1.1，则次路由器可以设置成其他网段192.168.x.1）、子网掩码。4.“DHCP服务器”的设置，如果让用户自动获取IP地址使用，需要使用DHCP服务器，可以限制用户自动获取IP地址的范围，如下图的“起始IP地址”和“结束IP地址”（可以在上网行为管理的IP地址组中看到）。 5.无线的“基本设置”，要启用无线的话，勾选启用开关，并为无线网络设置一个名称，设置无线模式为“11b/g/n混合模式”，来兼容三种无线协议：802.11b、802.11g、802.11n。 6.无线的“安全设置”，如果需要做MAC地址绑定的安全管控，需要勾选mac地址“启用”：设置“允许”，将允许上网的计算机mac地址添加到mac地址列表；设置“禁用”，将不允许上网的计算机mac地址添加到mac地址列表。设置加密类型为常用的“WPA2-PSK”，并设置密码 7.“上网行为管理”设置，设置允许或者不允许上网的时间段；如果需要管理QQ等常用聊天软件，可以在聊天软件高级设置里进行启用，将允许使用QQ等聊天软件的账号添加到例外列表。 8.网络安全中设置内外网的“攻击防御”和“MAC地址绑定”（勾选“禁止未绑定IP/MAC的主机通过”，前面已经说过，不再赘述） 9.“端口映射”和“域名转发”，大多在系统集成中会用到，特别是监控设备想要远程访问，需要将设备的通讯端口等进行路由转发，此处需要注意的是，如果跨多层路由的话，每一层路由都是需要转发的。 10.修改路由器的登录密码。 [4]netsh网络配置命令netsh是Network Shell的缩写，是windows为我们提供的功能强大的网络配置命令行工具。下面用几个常用的“netsh interface ip show”小命令介绍netsh的用法。 1.netsh interface ip show address:显示本机IP地址配置，包括以太网的ip和本地回环ip地址，以太网ip地址就是我们常说的为本机网卡分配的一个地址，这个容易理解；本地还有ip地址，是一种叫做本地回环接口虚接口，在windows系统中都会采用如下图所示的127.0.0.1这个地址，用以提高网络的健壮性。 2.如果在上一步的基础上想要显示更多信息，可以用命令：netsh interface ip show config。 3.netsh interface ip show dns:显示本机使用的DNS服务器，同样包括以太网和本地回环接口的DNS信息。 4.netsh interface ip show ipnet:显示本IP地址所在的网络到媒体的映射，我们同时可以看到映射类型和所用接口等信息。 5.netsh interface ip show wins:如果设置了wins服务器，可以用此命令查看wins服务器的地址。 6.还有一个我喜欢用的不属于“netsh interface ip”这一系列的小命令，netsh firewall show state:查看本机防火墙的状态，每当我们公司某一台办公电脑在连接公司的某个系统连接不上的时候，我会用以查看防火墙状态，我们可以看到启用或禁用的功能模块，以及启用情况。 [5]安装失败（未签名）在我们安装驱动的时候，特别是用驱动精灵等驱动软件安装的时候，会出现“安装失败（未签名）”的情况，如何解决？ 方法/步骤 1.单击开始菜单里的“运行”，或者通过“windows键+R”打开“运行”，在输入框中输入“sigverif”回车 2.在打开的文件签名验证里点击“高级”按钮 3.如下图所示找到下载的驱动（如果未解压，需要先解压），然后点击“确认”按钮 4.切换到“正在记录”选项，选中如下图所示选项，点击“确定”按钮 5.回到第二步时候的界面，点击“开始”按钮，我们可以看到下图所示列表界面，点击“关闭”即可 6.从设备管理器安装驱动，右键单击我的电脑（xp）/计算机（win7）/这台电脑（win8），点击“管理”，在“计算机管理”中右侧边栏中单击“设备管理器”，找到我们要安装驱动的这个硬件，右键单击，选择“更新驱动程序” 7.勾选“从列表或指定位置安装”，点击“下一步”按钮 8.选择驱动程序解压后的文件夹，点击“下一步”按钮 9.到安装界面，用户需等待，知道出现安装成功的界面，点击“完成”按钮即可 10.返回到设备管理器，我们可以看到，此驱动已经安装完成 [6]管理用户网络应用现在各种网络应用程序纷繁复杂，而p2p软件又是其中最为流行的一种，而且提供了多样化得登陆方式，在此，我们以最常用的QQ为例。 我们大家都知道，QQ本身支持UDP、HTTP和HTTPS三种登陆方式，而且可以使用代理，意思是说，只要你允许了HTTP协议，QQ就可以登陆。 现在我们以封锁QQ为例，介绍一下，如何利用路由级的网络防火墙管理用户网络应用。 1.QQ登陆原理 QQ登录登陆的过程，由向服务器群的8000端口发送UDP数据包，从服务器群的回复中选择一个最快的作为登陆服务器。 如果没有服务器回复UDP数据包，则使用TCP80/443端口来进行连接。 QQ服务器： UDP8000端口类18个 TCPHTTP连接服务器5个 会员VIP服务器使用HTTPS443连接 2.如何封锁1.上面我们知道，QQ可以使用HTTP直接连接，一般不能封锁HTTP协议，所以最好的办法就是封锁它的服务器IP地址，但是QQ还可以使用代理登陆，这种情况我们就得在路由级防火墙中的HTTP检查机制中设置禁止QQ的HTTP连接。2.首先，配置用户访问规则，使用计算机集定义目的网络。也就是做好禁止内部客户访问QQ服务器的访问策略。 3.其次，配置HTTP策略，理由路由器的HTTP深层检查机制，禁止QQ使用HTTP代理。在允许ＱＱ使用HTTP代理的策略上点击右键，选中“配置HTTP” 4.在弹出的“为规则配置HTTP策略”对话框中，点击“签名”，然后点击“添加”，在弹出的“签名”对话框中，输入名称为“QQ”，指定签名搜索条件为在“请求URL”中搜索“tencent.com”，找到则阻止这个连接 5.最后，在防火墙策略选项中，点击“应用”来保存修改和更新防火墙策略，此时，QQ已经不能通过代理服务器登录了 [7]映射网络驱动器映射网络驱动器” 的意思是将局域网中的某个目录（一般是共享的文件夹之类的）映射成本地驱动器号，就是说把网络上其他机器的共享的文件夹映射自己机器上的一个磁盘，这样可以提高访问时间，相当于一个打开共享的快捷方式。 1.首先，找到这个共享文件夹，我们可以在网络里找到这台设备，或者打开开始菜单的“运行”，输入：“\这台设备的IP地址”，比如此例中的“\192.168.1.52” 2.在打开的共享界面，找到并右键单击要映射驱动器的文件件，选择“映射网络驱动器” 3.在映射驱动器的界面，选择好驱动器盘符，点击“完成”即可完成设置 4.打开资源管理器，我们可以看到，已经有了该驱动器，日常使用过程中直接点击打开即可 [8]网络适配器的原理网络适配器，也就是我们说的网卡，有些维修人员也叫网络接口卡，是计算机和网络电缆之间的物理接口，下面我们根据网络适配器需要完成的任务介绍一下它的工作原理。 1.为在计算机使用的数据（并行数据）和电缆上传输的电信号（串行数据）之间提供数据转换的功能。比如我们用的一个共享打印机，计算机直接连接打印机用的是并行数据，而如果我们通过网络连接别人共享的打印机，就是通过串行数据转换为并行数据来实现。2.判断从电缆接收的数据是否为传输给该计算机的数据。 3.在计算机和电缆之间控制数据流，每块网卡都有一个唯一的标识，我们一般叫做MAC地址，大部分网卡的MAC地址烧录在卡上的ROM芯片中，MAC地址有6段组成，通常表示为12个16进制数。我们可以通过命令提示符查看本机网卡的信息，操作步骤：1、单击开始菜单里的“运行”，在输入框中输入“cmd”，然后回车。2、在命令提示符界面输入“ipconfig /all”命令，回车，我们可以看到以下信息。如图所示的是本机无线网卡的信息，其中前3字节“A6-17-31”表示厂商代码，有IEEE负责分配；后3个字节“30-49-E2”表示网卡序号，由网卡厂商负责。 [9]交换机的分类交换机是网络连接的基础，有了交换机，就可以实现更多电脑的共享上网 1.广义上来讲，交换机分为两种：广域交换机和局域网交换机。广域网交换机主要用于电信领域，提供通信用的基础平台，我们平常接触很少；而局域网交换机是我们日常使用最多的，主要应用于日常的局域网络，连接计算机和网络打印机的终端设备 2.从传输介质和传输速度上可以分为以太网交换机、快速以太网交换机、千兆以太网交换机、FDDI交换机、ATM交换机和令牌交换机等 3.从规模应用上可以分为企业级、部门级和工作组交换机 [10]交换机的功能1.交换机功能学习功能，局域网内交换机会了解跟每一个插口相连接的MAC地址，并将地址同相应的端口映射起来存放在交换机缓存中的MAC地址表中 2.转发/过滤功能当一个数据帧的目的地址在MAC地址表中有映射时，它被转发到连接目的节点的端口而不是所有端口（如该数据帧为广播/组播帧则转发至所有端口） 3.消除回路功能当交换机包括一个冗余回路时，以太网交换机通过生成树协议避免回路的产生，同时允许存在后背路径 4.兼容功能交换机除了能连接两种同类型的网络之外，还可以在不同类型的网路（如以太网和快速以太网）之间起到互联作用。而且现在的交换机没有很严格的类型之分，百兆交换机一般也会加两个千兆口或光纤接入口 [11]交换机的接口种1.双绞线RJ-45接口-水晶头 2.光纤接口光纤需要熔接到带插头的尾纤，常见的尾纤插头有SC。 [12]路由器的工作原理路由器，大家都很熟悉了，办公室或者家里凡有两台以上的电脑需要上网的一般都安装了路由器，只有安装了路由器才能实现多台电脑同时上网。我们就了解下路由器的配置原理。 1.路由器的概念1.所谓“路由”，就是把数据从一个地方传送到另一个地方的行为和动作，路由器就是执行这个动作的机器，英文名Router 2.路由器能将不同网络或网段之间的数据信息进行“翻译”，以使他们能够相互“读”懂对方的数据，从而构建更大的网络。 2.路由器的典型功能 数据通道功能 包括转发决定、背板转发以及输出链路调度等，一般由特定的硬件来完成 控制功能 一般用软件来实现，包括与相邻路由器之间的信息交换、系统配置、系统管理等 3.路由器的主要功能 网络互连 路由器支持各种局域网和广域网接口，主要用于互连局域网和广域网，实现不同网络互相通信 数据处理 提供包括分组过滤、分组转发、优先级、复用、加密、压缩和防火墙等功能 网络管理 路由器提供包括配置管理、性能管理、容错管理和流量控制管理等功能 4.路由器的工作原理 接收来自它连接的某个网络的数据 将数据向上传递，并且（必要时）重新组合IP数据报 检查IP头部中的目的地址，如果目的地址位于发出数据的那个网络，那么路由器就放下被认为已经达到目的地的数据，因为数据是在目的计算机所在网络上传输 如果数据要送往另一个网络，那么路由器就查询路由表，以确定数据要转发到的目的地 路由器确定哪个适配器负责接收数据后，就通过相应的软件传递数据，以便通过网络来传送数据 [13]初识TCP/IP的分层大家可能经常使用TCP/IP协议，在进行网络配置或修改IP地址等操作的时候会用到该处，但很少有人去深入挖掘，在此我们简单的了解一下TCP/IP的分层。 1.TCP/IP协议 Internet采用了TCP/IP协议，但这并不是一个单一的协议，我们可能知道，TCP即传输控制协议，IP为网间协议，TCP/IP我们常常描述为互联网协议集。但可能很少人知道TCP/IP也是一种分层模型。它是基于硬件层次上的四个概念性层次构成，分别是网络接口层（数据链路层）、IP层（网络层）、传输层、应用层。 网络接口层:也称数据链路层，这是TCP/IP最底层。功能:负责接收IP数据报并发送至选定的网络。 IP层:IP层处理机器之间的通信。功能:它接收来自传输层的请求，将带有目的地址的分组发送出去。将分组封装到数据报中，填入数据报头，使用路由算法以决定是直接将数据报传送至目的主机还是传给路由器，然后把数据报送至相应的网络接口来传送。 传输层:是提供应用层之间的通信，即端到端的通信。功能:管理信息流，提供可靠的传输服务，以确保数据无差错的地按序到达。 2.TCP/IP模型的分界线协议地址分界线:以区分高层和低层的寻址，高层寻址使用IP地址，低层寻址使用物理地址。应用程序IP层之上的协议软件只使用IP地址，而网络接口层处理物理地址。 操作系统分界线:以区分系统与应用程序。在传输层和应用层之间。 3.复用与分解 发送报文时，发送方在报文中加和了报文类型、选用协议等附加信息。所有的报文以帧的形式在网络中复用传送，形成一个分组流。在接收方收到分组时，参考附加信息对接收到的分组进行分解。 参考网址：https://jingyan.baidu.com/season/38734 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/26/Network/]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Threejs中的各种光源（Threejs第三章）]]></title>
    <url>%2F2017%2F09%2F22%2FThreejs3%2F</url>
    <content type="text"><![CDATA[本章你将了解1、怎么使用光源2、以及各种光源的区别，这些区别会通过实例对比来给大家讲清楚。这种对比方式应该是讲解最好的思路。 2.6 环境光和方向光接下来，我们来看看多种光源同时存在于场景之中，对物体颜色的影响。 当环境光和方向光同时存在的时候，会出现怎么样的情况呢？可以把这种情况想成两种光源同时作用于物体，它产生的情况，和每种光源分别作用于物体，然后将两者的结果相加，是一样的效果。例如：0x00FF00 + 0xFF0000 = 0xFFFF00，oxFFFF00 就是黄色。 2.7 点光源点光源是理想化为质点的向四面八方发出光线的光源。点光源是抽象化了的物理概念，为了把物理问题的研究简单化。就像平时说的光滑平面，质点，无空气阻力一样，点光源在现实中也是不存在的，指的是从一个点向周围空间均匀发光的光源。 点光源的特点是发光部分为一个小圆面，近似一个点 下面的例子介绍了怎么使用点光源： light = new THREE.PointLight(0xFF0000); light.position.set(0, 0,50); scene.add(light); 效果如下图： 2.8 混合光源将方向光和点光源混合使用。 效果如图所示： 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/22/Threejs3/]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
        <tag>3D</tag>
        <tag>threejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Threejs中的各种光源（Threejs第三章）]]></title>
    <url>%2F2017%2F09%2F22%2FThreejs3(1)%2F</url>
    <content type="text"><![CDATA[本章你将了解1、怎么使用光源2、以及各种光源的区别，这些区别会通过实例对比来给大家讲清楚。这种对比方式应该是讲解最好的思路。 2.6 环境光和方向光接下来，我们来看看多种光源同时存在于场景之中，对物体颜色的影响。 当环境光和方向光同时存在的时候，会出现怎么样的情况呢？可以把这种情况想成两种光源同时作用于物体，它产生的情况，和每种光源分别作用于物体，然后将两者的结果相加，是一样的效果。例如：0x00FF00 + 0xFF0000 = 0xFFFF00，oxFFFF00 就是黄色。 2.7 点光源点光源是理想化为质点的向四面八方发出光线的光源。点光源是抽象化了的物理概念，为了把物理问题的研究简单化。就像平时说的光滑平面，质点，无空气阻力一样，点光源在现实中也是不存在的，指的是从一个点向周围空间均匀发光的光源。 点光源的特点是发光部分为一个小圆面，近似一个点 下面的例子介绍了怎么使用点光源： light = new THREE.PointLight(0xFF0000); light.position.set(0, 0,50); scene.add(light); 效果如下图： 2.8 混合光源将方向光和点光源混合使用。 效果如图所示： 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/22/Threejs3(1)/]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
        <tag>3D</tag>
        <tag>threejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Threejs中的各种光源（Threejs第二章）]]></title>
    <url>%2F2017%2F09%2F22%2FThreejs2(1)%2F</url>
    <content type="text"><![CDATA[作为3D技术的发展趋势，浏览器端3D技术越来越被一些技术公司重视。由此，Threejs非常注重3D渲染效果的真实性，对渲染真实性来说，使用光源是比不可少的技巧。Threejs，在光源方面提供了多种光源供选择。 第二章1.Threejs中的各种光源1.1光源基类在Threejs中，光源用Light表示，它是所有光源的基类。它的构造函数是：THREE.Light ( hex ) 它有一个参数hex，接受一个16进制的颜色值。例如要定义一种红色的光源，我们可以这样来定义： Var redLight = new THREE.Light(0xFF0000); 1.2由基类派生出来的其他种类光源THREE.Light只是其他所有光源的基类，要让光源除了具有颜色的特性之外，我们需要其他光源。看看，下面的类图，是目前光源的继承结构。 环境光是经过多次反射而来的光称为环境光，无法确定其最初的方向。环境光是一种无处不在的光。环境光源放出的光线被认为来自任何方向。因此，当你仅为场景指定环境光时，所有的物体无论法向量如何，都将表现为同样的明暗程度。 （这是因为，反射光可以从各个方向进入您的眼睛） 1.2.1 环境光用THREE.AmbientLight来表示，它的构造函数如下所示： THREE.AmbientLight( hex ) 它仍然接受一个16进制的颜色值，作为光源的颜色。环境光将照射场景中的所有物体，让物体显示出某种颜色。环境光的使用例子如下所示： var light = new THREE.AmbientLight( 0xff0000 ); scene.add( light ); 只需要将光源加入场景，场景就能够通过光源渲染出好的效果来了。 1.2.2点光源由这种光源放出的光线来自同一点，且方向辐射自四面八方。例如蜡烛放出的光，萤火虫放出的光。 点光源用PointLight来表示，它的构造函数如下所示： PointLight( color, intensity, distance ) 这个类的参数稍微复杂一些，我们花点时间来解释一下： Color：光的颜色 Intensity：光的强度，默认是1.0,就是说是100%强度的灯光， distance：光的距离，从光源所在的位置，经过distance这段距离之后，光的强度将从Intensity衰减为0。 默认情况下，这个值为0.0，表示光源强度不衰减。 #####1.2.3聚光灯这种光源的光线从一个锥体中射出，在被照射的物体上产生聚光的效果。使用这种光源需要指定光的射出方向以及锥体的顶角α。聚光灯示例如图所示： 聚光灯的构造函数是：THREE.SpotLight( hex, intensity, distance, angle, exponent ) 函数的参数如下所示： Hex：聚光灯发出的颜色，如0xFFFFFF Intensity：光源的强度，默认是1.0，如果为0.5，则强度是一半，意思是颜色会淡一些。和上面点光源一样。 Distance：光线的强度，从最大值衰减到0，需要的距离。 默认为0，表示光不衰减，如果非0，则表示从光源的位置到Distance的距离，光都在线性衰减。到离光源距离Distance时，光源强度为0. Angle：聚光灯着色的角度，用弧度作为单位，这个角度是和光源的方向形成的角度。 exponent：光源模型中，衰减的一个参数，越大衰减约快。 2.材质与光源的关系材质与光源有什么关系？什么是材质？ 2.1 材质的真相 材质就是物体的质地。材质就是材料和质感的完美结合。 在渲染程序中，它是表面各可视属性的结合，这些可视属性是指表面的色彩、纹理、光滑度、透明度、反射率、折射率、发光度等。正是有了这些属性，才能让我们识别三维中的模型是什么做成的，也正是有了这些属性，我们计算机三维的虚拟世界才会和真实世界一样缤纷多彩。 这就是材质的真相吗？答案是否定的。不要奇怪，我们必须仔细分析产生不同材质的原因，才能让我们更好的把握质感。那么，材质的真相到底是什么呢？仍然是光，离开光材质是无法体现的。 首先，我们来看一些例子。这些例子是一系类的，掌握一个，我们就印下了一个脚印. 2.2 脚印一：不带任何光源的物体我们首先在屏幕上画一个物体，不带任何的光源，定义物体的颜色为黑色，其值为0x000000，定义材质如下： var material = new THREE.MeshLambertMaterial( { color:0x000000} ); // 这是兰伯特材质，材质中的一种 先看看最终的运行截图，如下所示： 由这幅图得出结论，当没有任何光源的时候，最终的颜色将是材质的颜色。但是这个结论目前来说，并没有依据。结论：当没有任何光源的时候，最终的颜色将是黑色，无论材质是什么颜色。 2.3 脚印二：兰伯特材质与光源最常见的材质之一就是Lambert材质，这是在灰暗的或不光滑的表面产生均匀散射而形成的材质类型。比如一张纸就是Lambert表面。 首先它粗糙不均匀，不会产生镜面效果。我们在阅读书籍的时候，没有发现书上一处亮，一处不亮吧，它非常均匀，这就是兰伯特材质。 有的朋友觉得纸不粗糙啊，你怎么说它粗糙吗？人的肉眼是不好分辨出来，它粗不粗糙的。 Lambert材质表面会在所有方向上均匀地散射灯光，这就会使颜色看上去比较均匀。想想一张纸，无论什么颜色，是不是纸的各个部分颜色都比较均匀呢。 Lambert材质的图例如下所示：Lambert材质会受环境光的影响，呈现环境光的颜色，与材质本身颜色关系不大。 我们现在来做一个例子 例子：红色环境光照射下的长方体，它用的是淡红色(0x880000)的兰伯特材质。效果如下图： 最后整个效果中，长方体呈现的是红色。我们要说的是，长方体显示红色，是因为长方体反射了红色的光，长方体本身的颜色是0x880000，光源的颜色是0xFF0000，红色的光照在物体上，物体反射了红色的光，所以呈现红色。我们现在一直在使用环境光，从环境光的构造函数来看，它只有颜色，其位置对场景中的物体并没有影响，因为他是均匀的反射到物体的表面的。 2.4 脚印三：环境光对物体的影响环境光就是在场景中无处不在的光，它对物体的影响是均匀的，也就是无论你从物体的那个角度观察，物体的颜色都是一样的，这就是伟大的环境光。 你可以把环境光放在任何一个位置，它的光线是不会衰减的，是永恒的某个强度的一种光源。 2.5脚印四：方向光（平行光）平行光又称为方向光（Directional Light），是一组没有衰减的平行的光线，类似太阳光的效果。 方向光的模型如图：方向光的构造函数如下所示： THREE.DirectionalLight = function ( hex, intensity ) 其参数如下： Hex：关系的颜色，用16进制表示 Intensity：光线的强度，默认为1。因为RGB的三个值均在0~255之间，不能反映出光照的强度变化，光照越强，物体表面就更明亮。它的取值范围是0到1。如果为0，表示光线基本没什么作用，那么物体就会显示为黑色。呆会你可以尝试来更改这个参数，看看实际的效果 我们来看一个方向光的例子： 一个红色的方向光，把它放在（0,0,1）的位置，密度为1，照射在一个长方体中。效果如下图所示： 平行光有一个方向，它的方向是如何决定的呢？方向由位置和原点（0,0,0）来决定，方向光只与方向有关，与离物体的远近无关。分别将平行光放到（0,0,100），（0,0,50），（0,0,25），（0,0,1），渲染的结果还是红色和黑色，见下图，颜色的深浅不与离物体的距离相关。 但是它与方向有关，如果，我们灯光的位置改为（1,0,0.5），那么效果如图所示： 未完待续 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/22/Threejs2(1)/]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
        <tag>3D</tag>
        <tag>threejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Threejs中的各种光源（Threejs第二章）]]></title>
    <url>%2F2017%2F09%2F22%2FThreejs2%2F</url>
    <content type="text"><![CDATA[作为3D技术的发展趋势，浏览器端3D技术越来越被一些技术公司重视。由此，Threejs非常注重3D渲染效果的真实性，对渲染真实性来说，使用光源是比不可少的技巧。Threejs，在光源方面提供了多种光源供选择。 第二章1.Threejs中的各种光源1.1光源基类在Threejs中，光源用Light表示，它是所有光源的基类。它的构造函数是：THREE.Light ( hex ) 它有一个参数hex，接受一个16进制的颜色值。例如要定义一种红色的光源，我们可以这样来定义： Var redLight = new THREE.Light(0xFF0000); 1.2由基类派生出来的其他种类光源THREE.Light只是其他所有光源的基类，要让光源除了具有颜色的特性之外，我们需要其他光源。看看，下面的类图，是目前光源的继承结构。 环境光是经过多次反射而来的光称为环境光，无法确定其最初的方向。环境光是一种无处不在的光。环境光源放出的光线被认为来自任何方向。因此，当你仅为场景指定环境光时，所有的物体无论法向量如何，都将表现为同样的明暗程度。 （这是因为，反射光可以从各个方向进入您的眼睛） 1.2.1 环境光用THREE.AmbientLight来表示，它的构造函数如下所示： THREE.AmbientLight( hex ) 它仍然接受一个16进制的颜色值，作为光源的颜色。环境光将照射场景中的所有物体，让物体显示出某种颜色。环境光的使用例子如下所示： var light = new THREE.AmbientLight( 0xff0000 ); scene.add( light ); 只需要将光源加入场景，场景就能够通过光源渲染出好的效果来了。 1.2.2点光源由这种光源放出的光线来自同一点，且方向辐射自四面八方。例如蜡烛放出的光，萤火虫放出的光。 点光源用PointLight来表示，它的构造函数如下所示： PointLight( color, intensity, distance ) 这个类的参数稍微复杂一些，我们花点时间来解释一下： Color：光的颜色 Intensity：光的强度，默认是1.0,就是说是100%强度的灯光， distance：光的距离，从光源所在的位置，经过distance这段距离之后，光的强度将从Intensity衰减为0。 默认情况下，这个值为0.0，表示光源强度不衰减。 #####1.2.3聚光灯这种光源的光线从一个锥体中射出，在被照射的物体上产生聚光的效果。使用这种光源需要指定光的射出方向以及锥体的顶角α。聚光灯示例如图所示： 聚光灯的构造函数是：THREE.SpotLight( hex, intensity, distance, angle, exponent ) 函数的参数如下所示： Hex：聚光灯发出的颜色，如0xFFFFFF Intensity：光源的强度，默认是1.0，如果为0.5，则强度是一半，意思是颜色会淡一些。和上面点光源一样。 Distance：光线的强度，从最大值衰减到0，需要的距离。 默认为0，表示光不衰减，如果非0，则表示从光源的位置到Distance的距离，光都在线性衰减。到离光源距离Distance时，光源强度为0. Angle：聚光灯着色的角度，用弧度作为单位，这个角度是和光源的方向形成的角度。 exponent：光源模型中，衰减的一个参数，越大衰减约快。 2.材质与光源的关系材质与光源有什么关系？什么是材质？ 2.1 材质的真相 材质就是物体的质地。材质就是材料和质感的完美结合。 在渲染程序中，它是表面各可视属性的结合，这些可视属性是指表面的色彩、纹理、光滑度、透明度、反射率、折射率、发光度等。正是有了这些属性，才能让我们识别三维中的模型是什么做成的，也正是有了这些属性，我们计算机三维的虚拟世界才会和真实世界一样缤纷多彩。 这就是材质的真相吗？答案是否定的。不要奇怪，我们必须仔细分析产生不同材质的原因，才能让我们更好的把握质感。那么，材质的真相到底是什么呢？仍然是光，离开光材质是无法体现的。 首先，我们来看一些例子。这些例子是一系类的，掌握一个，我们就印下了一个脚印. 2.2 脚印一：不带任何光源的物体我们首先在屏幕上画一个物体，不带任何的光源，定义物体的颜色为黑色，其值为0x000000，定义材质如下： var material = new THREE.MeshLambertMaterial( { color:0x000000} ); // 这是兰伯特材质，材质中的一种 先看看最终的运行截图，如下所示： 由这幅图得出结论，当没有任何光源的时候，最终的颜色将是材质的颜色。但是这个结论目前来说，并没有依据。结论：当没有任何光源的时候，最终的颜色将是黑色，无论材质是什么颜色。 2.3 脚印二：兰伯特材质与光源最常见的材质之一就是Lambert材质，这是在灰暗的或不光滑的表面产生均匀散射而形成的材质类型。比如一张纸就是Lambert表面。 首先它粗糙不均匀，不会产生镜面效果。我们在阅读书籍的时候，没有发现书上一处亮，一处不亮吧，它非常均匀，这就是兰伯特材质。 有的朋友觉得纸不粗糙啊，你怎么说它粗糙吗？人的肉眼是不好分辨出来，它粗不粗糙的。 Lambert材质表面会在所有方向上均匀地散射灯光，这就会使颜色看上去比较均匀。想想一张纸，无论什么颜色，是不是纸的各个部分颜色都比较均匀呢。 Lambert材质的图例如下所示：Lambert材质会受环境光的影响，呈现环境光的颜色，与材质本身颜色关系不大。 我们现在来做一个例子 例子：红色环境光照射下的长方体，它用的是淡红色(0x880000)的兰伯特材质。效果如下图： 最后整个效果中，长方体呈现的是红色。我们要说的是，长方体显示红色，是因为长方体反射了红色的光，长方体本身的颜色是0x880000，光源的颜色是0xFF0000，红色的光照在物体上，物体反射了红色的光，所以呈现红色。我们现在一直在使用环境光，从环境光的构造函数来看，它只有颜色，其位置对场景中的物体并没有影响，因为他是均匀的反射到物体的表面的。 2.4 脚印三：环境光对物体的影响环境光就是在场景中无处不在的光，它对物体的影响是均匀的，也就是无论你从物体的那个角度观察，物体的颜色都是一样的，这就是伟大的环境光。 你可以把环境光放在任何一个位置，它的光线是不会衰减的，是永恒的某个强度的一种光源。 2.5脚印四：方向光（平行光）平行光又称为方向光（Directional Light），是一组没有衰减的平行的光线，类似太阳光的效果。 方向光的模型如图：方向光的构造函数如下所示： THREE.DirectionalLight = function ( hex, intensity ) 其参数如下： Hex：关系的颜色，用16进制表示 Intensity：光线的强度，默认为1。因为RGB的三个值均在0~255之间，不能反映出光照的强度变化，光照越强，物体表面就更明亮。它的取值范围是0到1。如果为0，表示光线基本没什么作用，那么物体就会显示为黑色。呆会你可以尝试来更改这个参数，看看实际的效果 我们来看一个方向光的例子： 一个红色的方向光，把它放在（0,0,1）的位置，密度为1，照射在一个长方体中。效果如下图所示： 平行光有一个方向，它的方向是如何决定的呢？方向由位置和原点（0,0,0）来决定，方向光只与方向有关，与离物体的远近无关。分别将平行光放到（0,0,100），（0,0,50），（0,0,25），（0,0,1），渲染的结果还是红色和黑色，见下图，颜色的深浅不与离物体的距离相关。 但是它与方向有关，如果，我们灯光的位置改为（1,0,0.5），那么效果如图所示： 未完待续 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/22/Threejs2/]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
        <tag>3D</tag>
        <tag>threejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue进阶之路——过渡效果]]></title>
    <url>%2F2017%2F09%2F21%2FVue%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。 概述Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。包括以下工具： 在 CSS 过渡和动画中自动应用 class 可以配合使用第三方 CSS 动画库，如 Animate.css 在过渡钩子函数中使用 JavaScript 直接操作 DOM 可以配合使用第三方 JavaScript 动画库，如 Velocity.js 单元素/组件的过渡Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡 条件渲染 （使用 v-if） 条件展示 （使用 v-show） 动态组件 组件根节点这里是一个典型的例子：HTMl:12345678&lt;div id=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;show = !show&quot;&gt; Toggle &lt;/button&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; JS:123456new Vue(&#123; el: &apos;#demo&apos;, data: &#123; show: true &#125;&#125;) CSS:123456.fade-enter-active, .fade-leave-active &#123; transition: opacity .5s&#125;.fade-enter, .fade-leave-to /* .fade-leave-active in &lt;2.1.8 */ &#123; opacity: 0&#125; 当插入或删除包含在 transition 组件中的元素时，Vue 将会做以下处理： 自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。 如果过渡组件提供了JavaScript 钩子函数，这些钩子函数将在恰当的时机被调用。 如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，和Vue的 nextTick概念不同) 过渡的-CSS-类名 会有 6 个(CSS)类名在 enter/leave 的过渡中切换: v-enter v-enter-active v-enter-to v-leave v-leave-active v-leave-to 对于这些在 enter/leave 过渡中切换的类名，v- 是这些类名的前缀。使用 &lt;transition name=&quot;my-transition&quot;&gt; 可以重置前缀，比如 v-enter替换为 my-transition-enter。 CSS 过渡CSS 动画用法同 CSS 过渡，区别是在动画中 v-enter类名在节点插入 DOM 后不会立即删除，而是在animationend 事件触发时删除。 示例： (省略了兼容性前缀)123456&lt;div id=&quot;example-2&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle show&lt;/button&gt; &lt;transition name=&quot;bounce&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;Look at me!&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: &apos;#example-2&apos;, data: &#123; show: true &#125;&#125;) 12345678910111213141516171819202122232425262728.bounce-enter-active &#123; animation: bounce-in .5s;&#125;.bounce-leave-active &#123; animation: bounce-out .5s;&#125;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125;@keyframes bounce-out &#123; 0% &#123; transform: scale(1); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(0); &#125;&#125; 自定义过渡类名我们可以通过以下特性来自定义过渡类名： enter-class enter-active-class leave-class leave-active-class 他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用。示例：12345678910111213&lt;link href=&quot;https://unpkg.com/animate.css@3.5.1/animate.min.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;&lt;div id=&quot;example-3&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt; Toggle render &lt;/button&gt; &lt;transition name=&quot;custom-classes-transition&quot; enter-active-class=&quot;animated tada&quot; leave-active-class=&quot;animated bounceOutRight&quot; &gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 同时使用 Transitions 和 AnimationsVue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 transitionend或 animationend ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。 JavaScript 钩子123456789101112&lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:after-enter=&quot;afterEnter&quot; v-on:enter-cancelled=&quot;enterCancelled&quot; v-on:before-leave=&quot;beforeLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 12345678910111213141516171819202122232425262728293031323334353637383940// ...methods: &#123; // -------- // 进入中 // -------- beforeEnter: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // 离开时 // -------- beforeLeave: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) &#123; // ... &#125;&#125; 这些钩子函数可以结合 CSS transitions/animations使用，也可以单独使用。 当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。 否则，它们会被同步调用，过渡会立即完成。 推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。 初始渲染的过渡可以通过appear 特性设置节点的在初始渲染的过渡123&lt;transition appear&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 这里默认和进入和离开过渡一样，同样也可以自定义 CSS 类名。 1234567&lt;transition appear appear-class=&quot;custom-appear-class&quot; appear-active-class=&quot;custom-appear-active-class&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 自定义 JavaScript 钩子：12345678&lt;transition appear v-on:before-appear=&quot;customBeforeAppearHook&quot; v-on:appear=&quot;customAppearHook&quot; v-on:after-appear=&quot;customAfterAppearHook&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 多个元素的过渡 对于原生标签可以使用 v-if/v-else 。最常见的多标签过渡是一个列表和描述这个列表为空消息的元素：123456&lt;transition&gt; &lt;table v-if=&quot;items.length &gt; 0&quot;&gt;&lt;!-- ... --&gt; &lt;/table&gt; &lt;p v-else&gt;Sorry, no items found.&lt;/p&gt;&lt;/transition&gt; 当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，给在 &lt;transition组件中的多个元素设置 key 是一个更好的实践。12345678&lt;transition&gt; &lt;button v-if=&quot;isEditing&quot; key=&quot;save&quot;&gt; Save &lt;/button&gt; &lt;button v-else key=&quot;edit&quot;&gt; Edit &lt;/button&gt;&lt;/transition&gt; 过渡模式 in-out: 新元素先进行过渡，完成之后当前元素过渡离开。 out-in: 当前元素先进行过渡，完成之后新元素过渡进入。 多个组件的过渡多个组件的过渡简单很多 - 我们不需要使用 key 特性。相反，我们只需要使用动态组件: 列表过渡怎么同时渲染整个列表，比如使用v-for？在这种场景中，使用 &lt;transition-group&gt;组件。在我们深入例子之前，先了解关于这个组件的几个特点： 不同于 &lt;transition&gt;， 它会以一个真实元素呈现：默认为一个 &lt;span&gt;。你也可以通过 tag 特性更换为其他元素。 内部元素 总是需要 提供唯一的 key 属性值 列表的位移过渡&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move特性，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过 name 属性来自定义前缀，也可以通过 move-class 属性手动设置。v-move 对于设置过渡的切换时机和过渡曲线非常有用，你会看到如下的例子： (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/21/Vue进阶之路——过渡效果/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
        <tag>Vue</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue进阶之路——深入响应式原理]]></title>
    <url>%2F2017%2F09%2F21%2FVue%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Vue 最显著的特性之一便是不太引人注意的响应式系统 Vue 最显著的特性之一便是不太引人注意的响应式系统(reactivity system)。模型层(model)只是普通 JavaScript 对象，修改它则更新视图(view)。 如何追踪变化把一个普通 JavaScript 对象传给 Vue 实例的 data选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为getter/setter。 每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。 变化检测问题受现代 JavaScript 的限制,Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。例如：12345678var vm = new Vue(&#123; data:&#123; a:1 &#125;&#125;)// `vm.a` 是响应的vm.b = 2// `vm.b` 是非响应的 Vue 不允许在已经创建的实例上动态添加新的根级响应式属性(root-level reactive property)。然而它可以使用 Vue.set(object, key, value)方法将响应属性添加到嵌套的对象上： 1Vue.set(vm.someObject, &apos;b&apos;, 2) 您还可以使用vm.$set实例方法，这也是全局 Vue.set 方法的别名： 有时你想向已有对象上添加一些属性，例如使用 Object.assign()或 _.extend() 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：12// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;) 声明响应式属性由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值: 123456789var vm = new Vue(&#123; data: &#123; // 声明 message 为一个空值字符串 message: &apos;&apos; &#125;, template: &apos;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&apos;&#125;)// 之后设置 `message` vm.message = &apos;Hello!&apos; 如果你在 data 选项中未声明 message，Vue 将警告你渲染函数在试图访问的属性不存在。 data对象就像组件状态的概要，提前声明所有的响应式属性，可以让组件代码在以后重新阅读或其他开发人员阅读时更易于被理解。 异步更新队列可能你还没有注意到，Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会一次推入到队列中。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际（已去重的）工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和MutationObserver，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。 例如，当你设置 vm.someData = &#39;new value&#39;，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数在 DOM 更新完成后就会调用。例如：1&lt;div id=&quot;example&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; 1234567891011var vm = new Vue(&#123; el: &apos;#example&apos;, data: &#123; message: &apos;123&apos; &#125;&#125;)vm.message = &apos;new message&apos; // 更改数据vm.$el.textContent === &apos;new message&apos; // falseVue.nextTick(function () &#123; vm.$el.textContent === &apos;new message&apos; // true&#125;) 在组件内使用 vm.$nextTick() 实例方法特别方便，因为它不需要全局Vue，并且回调函数中的 this 将自动绑定到当前的 Vue 实例上：1234567891011121314151617Vue.component(&apos;example&apos;, &#123; template: &apos;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&apos;, data: function () &#123; return &#123; message: &apos;没有更新&apos; &#125; &#125;, methods: &#123; updateMessage: function () &#123; this.message = &apos;更新完成&apos; console.log(this.$el.textContent) // =&gt; &apos;没有更新&apos; this.$nextTick(function () &#123; console.log(this.$el.textContent) // =&gt; &apos;更新完成&apos; &#125;) &#125; &#125;&#125;) (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/21/Vue进阶之路——深入响应式原理/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
        <tag>Vue</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue进阶之路——过渡效果]]></title>
    <url>%2F2017%2F09%2F21%2FVue%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C(1)%2F</url>
    <content type="text"><![CDATA[Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。 概述Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。包括以下工具： 在 CSS 过渡和动画中自动应用 class 可以配合使用第三方 CSS 动画库，如 Animate.css 在过渡钩子函数中使用 JavaScript 直接操作 DOM 可以配合使用第三方 JavaScript 动画库，如 Velocity.js 单元素/组件的过渡Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡 条件渲染 （使用 v-if） 条件展示 （使用 v-show） 动态组件 组件根节点这里是一个典型的例子：HTMl:12345678&lt;div id=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;show = !show&quot;&gt; Toggle &lt;/button&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; JS:123456new Vue(&#123; el: &apos;#demo&apos;, data: &#123; show: true &#125;&#125;) CSS:123456.fade-enter-active, .fade-leave-active &#123; transition: opacity .5s&#125;.fade-enter, .fade-leave-to /* .fade-leave-active in &lt;2.1.8 */ &#123; opacity: 0&#125; 当插入或删除包含在 transition 组件中的元素时，Vue 将会做以下处理： 自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。 如果过渡组件提供了JavaScript 钩子函数，这些钩子函数将在恰当的时机被调用。 如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，和Vue的 nextTick概念不同) 过渡的-CSS-类名 会有 6 个(CSS)类名在 enter/leave 的过渡中切换: v-enter v-enter-active v-enter-to v-leave v-leave-active v-leave-to 对于这些在 enter/leave 过渡中切换的类名，v- 是这些类名的前缀。使用 &lt;transition name=&quot;my-transition&quot;&gt; 可以重置前缀，比如 v-enter替换为 my-transition-enter。 CSS 过渡CSS 动画用法同 CSS 过渡，区别是在动画中 v-enter类名在节点插入 DOM 后不会立即删除，而是在animationend 事件触发时删除。 示例： (省略了兼容性前缀)123456&lt;div id=&quot;example-2&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle show&lt;/button&gt; &lt;transition name=&quot;bounce&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;Look at me!&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: &apos;#example-2&apos;, data: &#123; show: true &#125;&#125;) 12345678910111213141516171819202122232425262728.bounce-enter-active &#123; animation: bounce-in .5s;&#125;.bounce-leave-active &#123; animation: bounce-out .5s;&#125;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125;@keyframes bounce-out &#123; 0% &#123; transform: scale(1); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(0); &#125;&#125; 自定义过渡类名我们可以通过以下特性来自定义过渡类名： enter-class enter-active-class leave-class leave-active-class 他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用。示例：12345678910111213&lt;link href=&quot;https://unpkg.com/animate.css@3.5.1/animate.min.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;&lt;div id=&quot;example-3&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt; Toggle render &lt;/button&gt; &lt;transition name=&quot;custom-classes-transition&quot; enter-active-class=&quot;animated tada&quot; leave-active-class=&quot;animated bounceOutRight&quot; &gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 同时使用 Transitions 和 AnimationsVue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 transitionend或 animationend ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。 JavaScript 钩子123456789101112&lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:after-enter=&quot;afterEnter&quot; v-on:enter-cancelled=&quot;enterCancelled&quot; v-on:before-leave=&quot;beforeLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 12345678910111213141516171819202122232425262728293031323334353637383940// ...methods: &#123; // -------- // 进入中 // -------- beforeEnter: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // 离开时 // -------- beforeLeave: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) &#123; // ... &#125;&#125; 这些钩子函数可以结合 CSS transitions/animations使用，也可以单独使用。 当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。 否则，它们会被同步调用，过渡会立即完成。 推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。 初始渲染的过渡可以通过appear 特性设置节点的在初始渲染的过渡123&lt;transition appear&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 这里默认和进入和离开过渡一样，同样也可以自定义 CSS 类名。 1234567&lt;transition appear appear-class=&quot;custom-appear-class&quot; appear-active-class=&quot;custom-appear-active-class&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 自定义 JavaScript 钩子：12345678&lt;transition appear v-on:before-appear=&quot;customBeforeAppearHook&quot; v-on:appear=&quot;customAppearHook&quot; v-on:after-appear=&quot;customAfterAppearHook&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 多个元素的过渡 对于原生标签可以使用 v-if/v-else 。最常见的多标签过渡是一个列表和描述这个列表为空消息的元素：123456&lt;transition&gt; &lt;table v-if=&quot;items.length &gt; 0&quot;&gt;&lt;!-- ... --&gt; &lt;/table&gt; &lt;p v-else&gt;Sorry, no items found.&lt;/p&gt;&lt;/transition&gt; 当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，给在 &lt;transition组件中的多个元素设置 key 是一个更好的实践。12345678&lt;transition&gt; &lt;button v-if=&quot;isEditing&quot; key=&quot;save&quot;&gt; Save &lt;/button&gt; &lt;button v-else key=&quot;edit&quot;&gt; Edit &lt;/button&gt;&lt;/transition&gt; 过渡模式 in-out: 新元素先进行过渡，完成之后当前元素过渡离开。 out-in: 当前元素先进行过渡，完成之后新元素过渡进入。 多个组件的过渡多个组件的过渡简单很多 - 我们不需要使用 key 特性。相反，我们只需要使用动态组件: 列表过渡怎么同时渲染整个列表，比如使用v-for？在这种场景中，使用 &lt;transition-group&gt;组件。在我们深入例子之前，先了解关于这个组件的几个特点： 不同于 &lt;transition&gt;， 它会以一个真实元素呈现：默认为一个 &lt;span&gt;。你也可以通过 tag 特性更换为其他元素。 内部元素 总是需要 提供唯一的 key 属性值 列表的位移过渡&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move特性，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过 name 属性来自定义前缀，也可以通过 move-class 属性手动设置。v-move 对于设置过渡的切换时机和过渡曲线非常有用，你会看到如下的例子： (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/21/Vue进阶之路——过渡效果(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
        <tag>Vue</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue进阶之路——深入响应式原理]]></title>
    <url>%2F2017%2F09%2F21%2FVue%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86(1)%2F</url>
    <content type="text"><![CDATA[Vue 最显著的特性之一便是不太引人注意的响应式系统 Vue 最显著的特性之一便是不太引人注意的响应式系统(reactivity system)。模型层(model)只是普通 JavaScript 对象，修改它则更新视图(view)。 如何追踪变化把一个普通 JavaScript 对象传给 Vue 实例的 data选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为getter/setter。 每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。 变化检测问题受现代 JavaScript 的限制,Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。例如：12345678var vm = new Vue(&#123; data:&#123; a:1 &#125;&#125;)// `vm.a` 是响应的vm.b = 2// `vm.b` 是非响应的 Vue 不允许在已经创建的实例上动态添加新的根级响应式属性(root-level reactive property)。然而它可以使用 Vue.set(object, key, value)方法将响应属性添加到嵌套的对象上： 1Vue.set(vm.someObject, &apos;b&apos;, 2) 您还可以使用vm.$set实例方法，这也是全局 Vue.set 方法的别名： 有时你想向已有对象上添加一些属性，例如使用 Object.assign()或 _.extend() 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：12// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;) 声明响应式属性由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值: 123456789var vm = new Vue(&#123; data: &#123; // 声明 message 为一个空值字符串 message: &apos;&apos; &#125;, template: &apos;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&apos;&#125;)// 之后设置 `message` vm.message = &apos;Hello!&apos; 如果你在 data 选项中未声明 message，Vue 将警告你渲染函数在试图访问的属性不存在。 data对象就像组件状态的概要，提前声明所有的响应式属性，可以让组件代码在以后重新阅读或其他开发人员阅读时更易于被理解。 异步更新队列可能你还没有注意到，Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会一次推入到队列中。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际（已去重的）工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和MutationObserver，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。 例如，当你设置 vm.someData = &#39;new value&#39;，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数在 DOM 更新完成后就会调用。例如：1&lt;div id=&quot;example&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; 1234567891011var vm = new Vue(&#123; el: &apos;#example&apos;, data: &#123; message: &apos;123&apos; &#125;&#125;)vm.message = &apos;new message&apos; // 更改数据vm.$el.textContent === &apos;new message&apos; // falseVue.nextTick(function () &#123; vm.$el.textContent === &apos;new message&apos; // true&#125;) 在组件内使用 vm.$nextTick() 实例方法特别方便，因为它不需要全局Vue，并且回调函数中的 this 将自动绑定到当前的 Vue 实例上：1234567891011121314151617Vue.component(&apos;example&apos;, &#123; template: &apos;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&apos;, data: function () &#123; return &#123; message: &apos;没有更新&apos; &#125; &#125;, methods: &#123; updateMessage: function () &#123; this.message = &apos;更新完成&apos; console.log(this.$el.textContent) // =&gt; &apos;没有更新&apos; this.$nextTick(function () &#123; console.log(this.$el.textContent) // =&gt; &apos;更新完成&apos; &#125;) &#125; &#125;&#125;) (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/21/Vue进阶之路——深入响应式原理(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
        <tag>Vue</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Threejs]]></title>
    <url>%2F2017%2F09%2F21%2FThreejs%2F</url>
    <content type="text"><![CDATA[一门3D技术语言。什么是threejs，很简单，你将它理解成three + js就可以了。three表示3D的意思，js表示javascript的意思。那么合起来，three.js就是使用javascript 来写3D程序的意思。Javascript是运行在网页端的脚本语言，那么毫无疑问Three.js也是运行在浏览器上的。 ##第一章来学习three.js之前最好了解一下WebGL。什么是WebGL? WebGL是在浏览器中实现三维效果的一套规范。 使用WebGL原生的API来写3D程序是一件非常痛苦的事情，幸好，有很多同行花业余时间写了一些WebGL开源框架，其中three.js就是非常优秀的一个，它掩 盖了很多麻烦的细节，那么，就让我们一起来看看，什么是three.js吧 1. 启程：实际上，我们要使用 Three.js 展示一些画面到浏览器上, 我们需要下面这三样东西:一个场景(scene)， 一个摄像头(camera) , 和一个渲染器(renderer)， 所以我们使用一个相机渲染一个场景. var scene = new THREE.Scene(); // 场景 var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);// 透视相机 var renderer = new THREE.WebGLRenderer(); // 渲染器 renderer.setSize(window.innerWidth, window.innerHeight); // 设置渲染器的大小为窗口的内宽度，也就是内容区的宽度 document.body.appendChild(renderer.domElement); 场景是所有物体的容器，如果要显示一个苹果，就需要将苹果对象加入场景中。 另一个组件是相机，相机决定了场景中那个角度的景色会显示出来。相机就像人的眼睛一样，人站在不同位置，抬头或者低头都能够看到不同的景色。 场景只有一种，但是相机却又很多种。和现实中一样，不同的相机确定了呈相的各个方面。比如有的相机适合人像，有的相机适合风景，专业的摄影师根据实际用途不一样，选择不同的相机。对程序员来说，只要设置不同的相机参数，就能够让相机产生不一样的效果。 2. 三维空间两种基本的相机 透视相机 正投影相机 2.1. 单反、双反都是相机2.1.1 认识相机在Threejs中相机的表示是THREE.Camera，它是相机的抽象基类，其子类有两种相机，分别是正投影相机THREE.OrthographicCamera和透视投影相机THREE.PerspectiveCamera。类图如下所示： 正投影相机有时候也叫正交投影摄像机，下图显示了正交摄像机投影和透视投影之间的差别。 2.1.2 两者的区别 正投影和透视投影的区别是：透视投影有一个基本点，就是远处的物体比近处的物体小。 在工程建筑领域，正投影的例子很多，例如下面就是一个正投影的例子：其特点是，远近高低比例都相同。 2.2 正投影相机下面我们来介绍正投影相机，正投影的构造函数如下所示： OrthographicCamera( left, right, top, bottom, near, far ) 结合下面一个图，我们来看看，各个参数的意思。 1、 left参数 left：左平面距离相机中心点的垂直距离。从图中可以看出，左平面是屏幕里面的那个平面。 2、 right参数 right：右平面距离相机中心点的垂直距离。从图中可以看出，右平面是屏幕稍微外面一点的那个平面。 3、 top参数 top：顶平面距离相机中心点的垂直距离。上图中的顶平面，是长方体头朝天的平面。 4、 bottom参数 bottom：底平面距离相机中心点的垂直距离。底平面是头朝地的平面。 5、near参数 near：近平面距离相机中心点的垂直距离。近平面是左边竖着的那个平面。 6、far参数 far：远平面距离相机中心点的垂直距离。远平面是右边竖着的那个平面。 有了这些参数和相机中心点，我们这里将相机的中心点又定义为相机的位置。通过这些参数，我们就能够在三维空间中唯一的确定上图的一个长方体。这个长方体也叫做视景体。 投影变换的目的就是定义一个视景体，使得视景体外多余的部分裁剪掉，最终图像只是视景体内的有关部分。 好了，看一个简单的例子： var camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 ); scene.add( camera ); 这个例子将浏览器窗口的宽度和高度作为了视景体的高度和宽度，相机正好在窗口的中心点上。这也是我们一般的设置方法，基本上为了方便，我们不会设置其他的值。 2.3 透视投影相机透视投影相机的构造函数如下所示： PerspectiveCamera( fov, aspect, near, far ) 我们来欣赏一幅图来看看这个函数的各个参数的意思： 先来明确这个图里涉及的概念。1、视角fov：这个最难理解,我的理解是,眼睛睁开的角度,即,视角的大小,如果设置为0,相当你闭上眼睛了,所以什么也看不到,如果为180,那么可以认为你的视界很广阔,但是在180度的时候，往往物体很小，因为他在你的整个可视区域中的比例变小了。 2、近平面near：这个呢，表示你近处的裁面的距离。补充一下，也可以认为是眼睛距离近处的距离，假设为10米远，请不要设置为负值，Three.js就傻了,不知道怎么算了, 3、远平面far：这个呢，表示你远处的裁面, 4、纵横比aspect：实际窗口的纵横比，即宽度除以高度。这个值越大，说明你宽度越大 好了，看看下面一个简单的例子： var camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 ); scene.add( camera ); 未完待续。。。 (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/21/Threejs/]]></content>
      <categories>
        <category>JS</category>
        <category>3D</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
        <tag>可视化</tag>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Threejs]]></title>
    <url>%2F2017%2F09%2F21%2FThreejs(1)%2F</url>
    <content type="text"><![CDATA[一门3D技术语言。什么是threejs，很简单，你将它理解成three + js就可以了。three表示3D的意思，js表示javascript的意思。那么合起来，three.js就是使用javascript 来写3D程序的意思。Javascript是运行在网页端的脚本语言，那么毫无疑问Three.js也是运行在浏览器上的。 ##第一章来学习three.js之前最好了解一下WebGL。什么是WebGL? WebGL是在浏览器中实现三维效果的一套规范。 使用WebGL原生的API来写3D程序是一件非常痛苦的事情，幸好，有很多同行花业余时间写了一些WebGL开源框架，其中three.js就是非常优秀的一个，它掩 盖了很多麻烦的细节，那么，就让我们一起来看看，什么是three.js吧 1. 启程：实际上，我们要使用 Three.js 展示一些画面到浏览器上, 我们需要下面这三样东西:一个场景(scene)， 一个摄像头(camera) , 和一个渲染器(renderer)， 所以我们使用一个相机渲染一个场景. var scene = new THREE.Scene(); // 场景 var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);// 透视相机 var renderer = new THREE.WebGLRenderer(); // 渲染器 renderer.setSize(window.innerWidth, window.innerHeight); // 设置渲染器的大小为窗口的内宽度，也就是内容区的宽度 document.body.appendChild(renderer.domElement); 场景是所有物体的容器，如果要显示一个苹果，就需要将苹果对象加入场景中。 另一个组件是相机，相机决定了场景中那个角度的景色会显示出来。相机就像人的眼睛一样，人站在不同位置，抬头或者低头都能够看到不同的景色。 场景只有一种，但是相机却又很多种。和现实中一样，不同的相机确定了呈相的各个方面。比如有的相机适合人像，有的相机适合风景，专业的摄影师根据实际用途不一样，选择不同的相机。对程序员来说，只要设置不同的相机参数，就能够让相机产生不一样的效果。 2. 三维空间两种基本的相机 透视相机 正投影相机 2.1. 单反、双反都是相机2.1.1 认识相机在Threejs中相机的表示是THREE.Camera，它是相机的抽象基类，其子类有两种相机，分别是正投影相机THREE.OrthographicCamera和透视投影相机THREE.PerspectiveCamera。类图如下所示： 正投影相机有时候也叫正交投影摄像机，下图显示了正交摄像机投影和透视投影之间的差别。 2.1.2 两者的区别 正投影和透视投影的区别是：透视投影有一个基本点，就是远处的物体比近处的物体小。 在工程建筑领域，正投影的例子很多，例如下面就是一个正投影的例子：其特点是，远近高低比例都相同。 2.2 正投影相机下面我们来介绍正投影相机，正投影的构造函数如下所示： OrthographicCamera( left, right, top, bottom, near, far ) 结合下面一个图，我们来看看，各个参数的意思。 1、 left参数 left：左平面距离相机中心点的垂直距离。从图中可以看出，左平面是屏幕里面的那个平面。 2、 right参数 right：右平面距离相机中心点的垂直距离。从图中可以看出，右平面是屏幕稍微外面一点的那个平面。 3、 top参数 top：顶平面距离相机中心点的垂直距离。上图中的顶平面，是长方体头朝天的平面。 4、 bottom参数 bottom：底平面距离相机中心点的垂直距离。底平面是头朝地的平面。 5、near参数 near：近平面距离相机中心点的垂直距离。近平面是左边竖着的那个平面。 6、far参数 far：远平面距离相机中心点的垂直距离。远平面是右边竖着的那个平面。 有了这些参数和相机中心点，我们这里将相机的中心点又定义为相机的位置。通过这些参数，我们就能够在三维空间中唯一的确定上图的一个长方体。这个长方体也叫做视景体。 投影变换的目的就是定义一个视景体，使得视景体外多余的部分裁剪掉，最终图像只是视景体内的有关部分。 好了，看一个简单的例子： var camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 ); scene.add( camera ); 这个例子将浏览器窗口的宽度和高度作为了视景体的高度和宽度，相机正好在窗口的中心点上。这也是我们一般的设置方法，基本上为了方便，我们不会设置其他的值。 2.3 透视投影相机透视投影相机的构造函数如下所示： PerspectiveCamera( fov, aspect, near, far ) 我们来欣赏一幅图来看看这个函数的各个参数的意思： 先来明确这个图里涉及的概念。1、视角fov：这个最难理解,我的理解是,眼睛睁开的角度,即,视角的大小,如果设置为0,相当你闭上眼睛了,所以什么也看不到,如果为180,那么可以认为你的视界很广阔,但是在180度的时候，往往物体很小，因为他在你的整个可视区域中的比例变小了。 2、近平面near：这个呢，表示你近处的裁面的距离。补充一下，也可以认为是眼睛距离近处的距离，假设为10米远，请不要设置为负值，Three.js就傻了,不知道怎么算了, 3、远平面far：这个呢，表示你远处的裁面, 4、纵横比aspect：实际窗口的纵横比，即宽度除以高度。这个值越大，说明你宽度越大 好了，看看下面一个简单的例子： var camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 ); scene.add( camera ); 未完待续。。。 (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/21/Threejs(1)/]]></content>
      <categories>
        <category>JS</category>
        <category>3D</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
        <tag>可视化</tag>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mock.js]]></title>
    <url>%2F2017%2F09%2F21%2FMock%2F</url>
    <content type="text"><![CDATA[Mock.js 是一款模拟数据生成器，旨在帮助前端攻城师独立于后端进行开发，帮助编写单元测试 Mock.js 是一款模拟数据生成器，旨在帮助前端攻城师独立于后端进行开发，帮助编写单元测试。提供了以下模拟功能： 根据数据模板生成模拟数据 模拟 Ajax 请求，生成并返回模拟数据 基于 HTML 模板生成模拟数据 语法规范Mock.js 的语法规范包括两部分： 数据模板定义规范（Data Template Definition，DTD） 数据占位符定义规范（Data Placeholder Definition，DPD） 数据模板定义规范 DTD数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值： // 属性名 name // 生成规则 rule // 属性值 value &apos;name|rule&apos;: value 注意： 属性名 和 生成规则 之间用竖线 | 分隔。 生成规则 是可选的。 生成规则 有 7 种格式： ‘name|min-max’: value ‘name|count’: value ‘name|min-max.dmin-dmax’: value ‘name|min-max.dcount’: value ‘name|count.dmin-dmax’: value ‘name|count.dcount’: value ‘name|+step’: value 生成规则 的 含义 需要依赖 属性值的类型 才能确定。 属性值 中可以含有 @占位符。 属性值 还指定了最终值的初始值和类型。生成规则和示例：1. 属性值是字符串 String ‘name|min-max’: string通过重复 string 生成一个字符串，重复次数大于等于 min，小于等于 max。 ‘name|count’: string通过重复 string 生成一个字符串，重复次数等于 count。2. 属性值是数字 Number ‘name|+1’: number 属性值自动加 1，初始值为 number。 ‘name|min-max’: number生成一个大于等于 min、小于等于 max 的整数，属性值 number 只是用来确定类型。 ‘name|min-max.dmin-dmax’: number生成一个浮点数，整数部分大于等于 min、小于等于 max，小数部分保留 dmin 到 dmax 位。 3.属性值是布尔型 Boolean 4. 属性值是对象 Object 5. 属性值是数组 Array 6. 属性值是函数 Function ‘name’: function 执行函数 function，取其返回值作为最终的属性值，函数的上下文为属性 ‘name’ 所在的对象。 7. 属性值是正则表达式 RegExp ‘name’: regexp 根据正则表达式regexp 反向生成可以匹配它的字符串。用于生成自定义格式的字符串。 数据占位符定义规范 DPD占位符 只是在属性值字符串中占个位置，并不出现在最终的属性值中。 占位符 的格式为： @占位符 @占位符(参数 [, 参数]) 注意： 用 @ 来标识其后的字符串是 占位符。 占位符 引用的是 Mock.Random 中的方法。 通过Mock.Random.extend() 来扩展自定义占位符。 占位符 也可以引用 数据模板 中的属性。 占位符 会优先引用 数据模板 中的属性。 占位符 支持 相对路径 和 绝对路径。 Mock.mockMock.mock( rurl?, rtype?, template|function(options) )根据数据模板生成模拟数据。 ock.mock( template )根据数据模板生成模拟数据。 Mock.mock( rurl, template )记录数据模板。当拦截到匹配 rurl 的 Ajax 请求时，将根据数据模板 template 生成模拟数据，并作为响应数据返回。 Mock.mock( rurl, function(options) )记录用于生成响应数据的函数。当拦截到匹配 rurl 的 Ajax 请求时，函数 function(options) 将被执行，并把执行结果作为响应数据返回。 Mock.mock( rurl, rtype, template )记录数据模板。当拦截到匹配 rurl 和 rtype 的 Ajax 请求时，将根据数据模板 template 生成模拟数据，并作为响应数据返回。 Mock.mock( rurl, rtype, function(options) )记录用于生成响应数据的函数。当拦截到匹配 rurl 和 rtype 的 Ajax 请求时，函数 function(options) 将被执行，并把执行结果作为响应数据返回。 参数的含义和默认值如下所示： 参数 rurl：可选。表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。例如 /\/domain\/list.json/、’/domian/list.json’。 参数 rtype：可选。表示需要拦截的 Ajax 请求类型。例如 GET、POST、PUT、DELETE 等。 参数 template：可选。表示数据模板，可以是对象或字符串。例如 { ‘data|1-10’:[{}] }、‘@EMAIL’。 参数 function(options)：可选。表示用于生成响应数据的函数。 参数 options：指向本次请求的 Ajax 选项集。 从 1.0 开始，Mock.js 通过覆盖和模拟原生 XMLHttpRequest 的行为来拦截 Ajax 请求，不再依赖于第三方 Ajax 工具库（例如 jQuery、Zepto 等）。 Mock.mockjax(library)Mock.setup()Mock.setup( settings )配置拦截 Ajax 请求时的行为。支持的配置项有：timeout。 timeout指定被拦截的 Ajax 请求的响应时间，单位是毫秒。值可以是正整数，例如 400，表示 400 毫秒 后才会返回响应内容；也可以是横杠 ‘-‘ 风格的字符串，例如 ‘200-600’，表示响应时间介于 200 和 600 毫秒之间。默认值是’10-100’。 目前，接口 Mock.setup( settings ) 仅用于配置 Ajax 请求，将来可能用于配置 Mock 的其他行为。 (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/21/Mock/]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mock.js]]></title>
    <url>%2F2017%2F09%2F21%2FMock(1)%2F</url>
    <content type="text"><![CDATA[Mock.js 是一款模拟数据生成器，旨在帮助前端攻城师独立于后端进行开发，帮助编写单元测试 Mock.js 是一款模拟数据生成器，旨在帮助前端攻城师独立于后端进行开发，帮助编写单元测试。提供了以下模拟功能： 根据数据模板生成模拟数据 模拟 Ajax 请求，生成并返回模拟数据 基于 HTML 模板生成模拟数据 语法规范Mock.js 的语法规范包括两部分： 数据模板定义规范（Data Template Definition，DTD） 数据占位符定义规范（Data Placeholder Definition，DPD） 数据模板定义规范 DTD数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值： // 属性名 name // 生成规则 rule // 属性值 value &apos;name|rule&apos;: value 注意： 属性名 和 生成规则 之间用竖线 | 分隔。 生成规则 是可选的。 生成规则 有 7 种格式： ‘name|min-max’: value ‘name|count’: value ‘name|min-max.dmin-dmax’: value ‘name|min-max.dcount’: value ‘name|count.dmin-dmax’: value ‘name|count.dcount’: value ‘name|+step’: value 生成规则 的 含义 需要依赖 属性值的类型 才能确定。 属性值 中可以含有 @占位符。 属性值 还指定了最终值的初始值和类型。生成规则和示例：1. 属性值是字符串 String ‘name|min-max’: string通过重复 string 生成一个字符串，重复次数大于等于 min，小于等于 max。 ‘name|count’: string通过重复 string 生成一个字符串，重复次数等于 count。2. 属性值是数字 Number ‘name|+1’: number 属性值自动加 1，初始值为 number。 ‘name|min-max’: number生成一个大于等于 min、小于等于 max 的整数，属性值 number 只是用来确定类型。 ‘name|min-max.dmin-dmax’: number生成一个浮点数，整数部分大于等于 min、小于等于 max，小数部分保留 dmin 到 dmax 位。 3.属性值是布尔型 Boolean 4. 属性值是对象 Object 5. 属性值是数组 Array 6. 属性值是函数 Function ‘name’: function 执行函数 function，取其返回值作为最终的属性值，函数的上下文为属性 ‘name’ 所在的对象。 7. 属性值是正则表达式 RegExp ‘name’: regexp 根据正则表达式regexp 反向生成可以匹配它的字符串。用于生成自定义格式的字符串。 数据占位符定义规范 DPD占位符 只是在属性值字符串中占个位置，并不出现在最终的属性值中。 占位符 的格式为： @占位符 @占位符(参数 [, 参数]) 注意： 用 @ 来标识其后的字符串是 占位符。 占位符 引用的是 Mock.Random 中的方法。 通过Mock.Random.extend() 来扩展自定义占位符。 占位符 也可以引用 数据模板 中的属性。 占位符 会优先引用 数据模板 中的属性。 占位符 支持 相对路径 和 绝对路径。 Mock.mockMock.mock( rurl?, rtype?, template|function(options) )根据数据模板生成模拟数据。 ock.mock( template )根据数据模板生成模拟数据。 Mock.mock( rurl, template )记录数据模板。当拦截到匹配 rurl 的 Ajax 请求时，将根据数据模板 template 生成模拟数据，并作为响应数据返回。 Mock.mock( rurl, function(options) )记录用于生成响应数据的函数。当拦截到匹配 rurl 的 Ajax 请求时，函数 function(options) 将被执行，并把执行结果作为响应数据返回。 Mock.mock( rurl, rtype, template )记录数据模板。当拦截到匹配 rurl 和 rtype 的 Ajax 请求时，将根据数据模板 template 生成模拟数据，并作为响应数据返回。 Mock.mock( rurl, rtype, function(options) )记录用于生成响应数据的函数。当拦截到匹配 rurl 和 rtype 的 Ajax 请求时，函数 function(options) 将被执行，并把执行结果作为响应数据返回。 参数的含义和默认值如下所示： 参数 rurl：可选。表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。例如 /\/domain\/list.json/、’/domian/list.json’。 参数 rtype：可选。表示需要拦截的 Ajax 请求类型。例如 GET、POST、PUT、DELETE 等。 参数 template：可选。表示数据模板，可以是对象或字符串。例如 { ‘data|1-10’:[{}] }、‘@EMAIL’。 参数 function(options)：可选。表示用于生成响应数据的函数。 参数 options：指向本次请求的 Ajax 选项集。 从 1.0 开始，Mock.js 通过覆盖和模拟原生 XMLHttpRequest 的行为来拦截 Ajax 请求，不再依赖于第三方 Ajax 工具库（例如 jQuery、Zepto 等）。 Mock.mockjax(library)Mock.setup()Mock.setup( settings )配置拦截 Ajax 请求时的行为。支持的配置项有：timeout。 timeout指定被拦截的 Ajax 请求的响应时间，单位是毫秒。值可以是正整数，例如 400，表示 400 毫秒 后才会返回响应内容；也可以是横杠 ‘-‘ 风格的字符串，例如 ‘200-600’，表示响应时间介于 200 和 600 毫秒之间。默认值是’10-100’。 目前，接口 Mock.setup( settings ) 仅用于配置 Ajax 请求，将来可能用于配置 Mock 的其他行为。 (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/21/Mock(1)/]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R笔记]]></title>
    <url>%2F2017%2F09%2F20%2FR%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一门可视化语言。http://bayes.math.montana.edu/Rweb/Rnotes/R.html 前言：关于R在R的官方教程里是这么给R下注解的:一个数据分析和图形显示的程序设计环境(A system for data analysis and visualization which is built based on S language.)。R的源起R是S语言的一种实现。S语言是由 AT&amp;T贝尔实验室开发的一种用来进行数据探索、统计分析、作图的解释型语言。最初S语言的实现版本主要是S-PLUS。S-PLUS是一个商业 软件，它基于S语言，并由MathSoft公司的统计科学部进一步完善。后来Auckland大学的Robert Gentleman 和 Ross Ihaka 及其他志愿人员开发了一个R系统。R的使用与S-PLUS有很多类似之处，两个软件有一定的兼容性。R is freeR是用于统计分析、绘图的语言和操作环境。R是属于GNU系统的一个自由、免费、源代码开放的软件，它是一个用于统计计算和统计制图的优秀工具。R是一套完整的数据处理、计算和制图软件系统。其功能包括：数据存储和处理系统；数组运算工具（其向量、矩阵运算方面功能尤其强大）；完整连贯的统计分析工具；优秀的统计制图功能；简便而强大的编程语言：可操纵数据的输入和输入，可实现分支、循环，用户可自定义功能。R是一个免费的自由软件，它有UNIX、LINUX、MacOS和WINDOWS版本，都是可以免费下载和使用的,在那儿可以下载到R的安装程序、各种外挂程序和文档。在R的安装程序中只包含了8个基础模块，其他外在模块可以通过CRAN获得。R的特点(1) 有效的数据处理和保存机制。(2) 拥有一整套数组和矩阵的操作运算符。(3) 一系列连贯而又完整的数据分析中间工具。(4) 图形统计可以对数据直接进行分析和显示，可用于多种图形设备。(5) 一种相当完善、简洁和高效的程序设计语言。它包括条件语句、循环语句、用户自定义的递归函数以及输入输出接口。(6) R语言是彻底面向对象的统计编程语言。(7) R语言和其它编程语言、数据库之间有很好的接口。(8) R语言是自由软件，可以放心大胆地使用，但其功能却不比任何其它同类软件差。(9) R语言具有丰富的网上资源一 入门训练 获取帮助 help.start() 开启帮助文档help(solve) 显示某命令的帮助信息，或者?solve 对于由特殊字符指定的功能，这些参数必须用单引号或双引号括起来，使之成为一个“字符串”,如help(“[[“) 与某个主题相关的例子通常可以用下面的命令得到example(topic) 命令简介 R对大小写是敏感的；名称不能以数字开始； 基本的命令由表达式或者赋值语句组成。如果一个表达式被作为一条命令给出，它将被求值、打印而表达式的值并不被保存。一个赋值语句同样对表达式求值之后把表达式的值传给一个变量，不过并不会自动的被打印出来； 命令由分号(;)来分隔，或者另起新行； 基本命令可以由花括号(f和g)合并为一组复合表达式； 注释几乎可以被放在任何地方，只要是以井号( # )开始，到行末结束； 如果一个命令在行莫仍没有结束，R将会给出一个不同的提示符，默认的是‘+’。 命令文件的执行和输出转向到文件如果命令存储于一个外部文件中，比如工作目录work中的commands.R，他们可以随时在R的任务中被执行 source(“commands.R”)在Windows中Source也可以由File菜单执行。函数sink，sink(“record.lis”)将把所有后续的输出由终端转向一个外部文件，record.lis。命令sink() 将把信息重新恢复到终端上。 数据的保持与对象的清除R所创建、操作的实体是对象。对象可以是变量、数组、字符串、函数以及由这些元素组成的其它结构； objects() 用来显示目前存储在R中的对象的名字。而当前存储的所有对象的组合被称为workspace；清除对象可以使用rm命令：rm(x, y, z, ink, junk, temp, foo, bar)所有在一个R任务中被创建的对象都可以在文件中被永久保存，并在其它的R任务中被使用。在每个R任务结束时用户都有机会保存当前有效的所有对象。如果用户这样做的话，对象将被写入当前目录一个名为.RData。当R被再次启动时R会从这个文件中再载入workspace。同时相关的命令记录也被载入。所以，推荐大家在用R进行不同的分析时分别使用不同的工作目录。 基本数据结构 数值型(numeric）1,1.2,3.1415926复数型(complex)1+2i字符型(character)‘A’/ “hello world!”逻辑型(logical)TRUE / FALSE 基本数据对象 向量(vector), 见下节矩阵(matrix)：更一般的说数组是向量在多维情况下的一般形式。事实上它们是可以被两个或更多的指标索引的向量，并且以特定的方式被打印出来。因子(factors) 提供了一种处理分类数据的更简介的方式。列表(list)：是向量的一种一般形式，并不需要保证其中的元素都是相同的类型，而且其中的元素经常是向量和列表本身。数据框(data frame)：是一种与矩阵相似的结构，其中的列可以是不同的数据类型。可以把数据框看作一种数据”矩阵”，它的每行是一个观测单位，而且(可能)同时包含数值型和分类的变量。函数( function)：能够在R的workspace中存储的对象。我们可以通过函数来扩展R的功能。二 简单操作，数值与向量2.1 向量与赋值R对命名了的数据结构进行操作。最简单的数据结构是数字向量；如， x &lt;- c(10.4, 5.6, 3.1, 6.4, 21.7) c()是创建函数，赋值运算符是’&lt;-‘，与函数assign()等价assign(“x”, c(10.4, 5.6, 3.1, 6.4, 21.7)) 也可以写成：c(10.4, 5.6, 3.1, 6.4, 21.7) -&gt; x如果一个表达式被当作一个完整的命令，它的值将被打印到终端但不被储存。单独输入x则会将值打印出来。也可以打印倒数：1/xy &lt;- c(x, 0, x) 也可以将向量作为元素。2.2 向量运算 操作是按照向量中的元素一个一个进行的。同一个表达式中的向量并不需要具有相同的长度。如果它们的长度不同,表达式的结果是一个与表达式中最长向量有相同长度的向量。表达式中较短的向量会根据它的长度被重复使用若干次(不一定是整数次)，直到与长度最长的向量相匹配。而常数很明显的将被不断重复。如，v &lt;- 2x + y + 1常用运算有：+，-，，/，^（次方）；log, exp, sin, cos, tan,sqrt等；max和min的作用是选出所给向量中最大的或最小的元素；range函数的值是一个长度为2的向量，即c(min(x),max(x))length(x)返回了向量x中元素的个数，也就是x的长度。sum(x)给出了x中所有元素的总和；prod(x)给出x中所有元素的乘积；mean(x)和var(x)，分别计算样本均值和样本方差，这两个函数分别相当于sum(x)/length(x)，sum((x-mean(x)) ^2)/(length(x) -1)。如果var()的参数是一个np的矩阵，那么函数的值是一个pp的样本协方差矩阵，认为每行是一个p变量的样本向量。sort(x)返回一个与x具有相同长度的向量，其中的元素按招升序排列。还有其他更灵活的排序功能(参见order()和sort.list())。pmax和pmin将返回一个与最长的向量长度相等的向量，向量中的元素由参数中所有向量在相应位置的最大值(最小值)组成；如果要使用复数，需要直接给出一个复数部分。因此sqrt(-17)将会返回NaN(无效数值)和一个警告，而sqrt(-17+0i)将按照复数进行运算。2.3 生成序列最简单的方法是用冒号‘：’，冒号具有最高运算优先级。例如1:30就是向量c(1,2,. . .,29,30)。30:1构造一个递减序列。利用seq()函数构造序列：有五个参数，from, to, by, length, along from, to可以不写参数名，seq(2,10)就相当于2:10。 by指定步长，默认为1，如seq(-5, 5, by=.2)即为c(-5.0, -4.8, -4.6, …, 4.6, 4.8, 5.0) length指定序列长度，如seq(length=51, from=-5, by=.2)，等同于seq(-5, 5, by=.2) along=vector只能单独使用，产生一个“1:length(vector)”序列。类似的函数是rep(),这个函数可以用多种复杂的方法来 复制一个对象。最简单的形式是&gt; s5 &lt;- rep(x, times=5)2.4 逻辑向量 TRUE, FALSE, 和NA(not available), 前两个可以简写为T和F，但T/F并不是系统保留字，可以被用户覆盖，所以最好还是不要简写。逻辑向量是由条件给出的，如下列语句令temp成为一个与x长度相同，相应位置根据是否与条件相符而由TRUE或FALSE组成的向量： temp 13逻辑操作符包括&lt;, &lt;=, &gt;, &gt;=,完全相等==和不等于!=，与或非分别为&amp;, |, !。在普通运算中，FALSE当做0而TRUE当做1。2.5 缺失值NA(not available): 一般来讲一个NA的任何操作都将返回NA。 is.na(x)返回一个与x等长的逻辑向量，并且由相应位置的元素是否是NA来决定这个逻辑向量相应位置的元素是TRUE还是FALSE。 x==NA是一个与x具有相同长度而其所有元素都是NA的向量。NaN(Not a Number): 由数值运算产生，如0/0, Inf-Inf. is.na(x)对于NA和NaN值都返回TRUE， is.nan(x)只对NaN值返回TRUE。2.6 字符向量 字符串在输入时可以使用单引号(‘)或双以号(“); 在打印时用双引号(有时不用引号)。R使用与C语言风格基本相同的转义符, 所以输入\打印的也是\, 输入” 打印引号”, n: 换行, t: tab, b: 回格。字符向量可以通过函数c()连接；paste()可以接受任意个参数，并从它们中逐个取出字符并连成字符串，形成的字符串的个数与参数中最长字符串的长度相同。如果参数中包含数字的话，数字将被强制转化为字符串。在默认情况下，参数中的各字符串是被一个空格分隔的，不过通过参数sep=string 用户可以把它更改为其他字符串，包括空字符串。例如： labs &lt;- paste(c(“X”,”Y”), 1:10, sep=””) 使变量labs成为字符变量c(“X1”, “Y2”, “X3”, “Y4”, “X5”, “Y6”, “X7”, “Y8”, “X9”, “Y10”)2.7 index vector—数据集子集的选择与修改 任何结果为一个向量的表达式都可以通过追加索引向量(index vector)来选择其中的子集。1 逻辑的向量。 y 0] -&gt; z 表示创建一个对象z，其中的元素由向量x+1中与x中的非缺失值和正数对应的向量组成。 正整数的向量x[6] 是x的第六个元素x[1:10] 选取了x的前10个元素(假设x的长度不小于10)。c(“x”,”y”)[rep(c(1,2,2,1), times=4)] 产生了一个字符向量，长度为16，由”x”, “y”, “y”, “x”重复4次而组成。 负整数的向量y &lt;- x[-(1:5)] 表示向量y取向量x前5个元素以外的元素。 字符串的向量只存在于拥有names属性并由它来区分向量中元素的向量。这种情况下一个由名称组成的子向量起到了和正整数的索引向量相同的效果。fruit &lt;- c(5, 10, 1, 20)names(fruit) &lt;- c(“orange”, “banana”, “apple”, “peach”)lunch &lt;- fruit[c(“apple”,”orange”)]子集的修改x[is.na(x)] &lt;- 0 表示将向量x中所以NA元素用0来代替y[y &lt; 0] &lt;- -y[y &lt; 0] 表示将向量(-y)中 与向量y的负元素对应位置的元素 赋值给 向量y中 与向量y负元素对应的元素。作用相当于：y &lt;- abs(y)三 对象，模式和属性3.1 固有属性：模式和长度对象是R所进行操作的实体，对象可以是向量、列表等，详见1.6.对象的模式包括numeri，ccomplex，character，logical，list，function，expression等。可以用mode(object)查看。对象的长度是对象的另一固有属性。可以用length(object)查看。attribute(object)可以查看更深入的属性。模式的转换在允许的情况下(大多数情况都是允许的)，R可以完成各种模式的转换。例如：d&lt;-as.character(z)，将数值向量z&lt;-(0:9)转化为字符向量c(“0”, “1”, “2”, …, “9”)。as.integer(d)将d转化为数值向量。R中很多形式为as.something()的函数，可以完成从一个模式向另一个模式的转化，或者是令对象取得它当前模式不具有的某些属性。3.2 改变对象的长度e &lt;- numeric() 产生一个numeric型的空向量e。character()等类似。此时长度为对象0。此时新添加一个元素会使e的长度自动调整。e[3] &lt;- 17 令e为一个长度为3的向量（此时，该向量的前两个元素都是NA）缩短（截断）一个对象的长度，只需要一个赋值命令。因此，若alpha是一个长度为10的对象，下面的命令alpha &lt;- alpha[2 * 1:5]3.3 属性的获取和设置 函数attributes(object)将给出当前对象所具有的所有非基本属性（长度和模式属于基本属性）的一个列表。函数attr(object,name)可以被用来选取一个指定的属性。除了为某些特殊的目的创建新属性这样特殊的环境下，这些函数很少被用到。当函数attr()用在赋值语句左侧时，既可以是将对象与一种新的属性关联，也可以是对原有属性的更改。例如 attr(z,”dim”) &lt;- c(10,10) 另R将z作为一个10X10的矩阵看待。3.4 对象的类别对象的一个特别属性，类别，被用来指定对象在R编程中的风格。比如：如果对象类别”data.frame”则会以特定方式处理。unclass()可以去除对象的类别。summary()可以查看对象的基本信息（min, max, mean, etc.）四 有序因子和无序因子 因子是一种向量对象，它给自己的组件指定了一个离散的分类（分组），它的组件由其他等长的向量组成。R提供了有序因子和无序因子。通俗点说，因子就是将对象的值分成不同的组（levels）。用函数factor()创建一个因子，levels按序排列(字母序或数值序)。例如province&lt;-c(“四川”,”湖南”,”江苏”,”四川”,”四川”,”四川”,”湖南”,”江苏”,”湖南”,”江苏”)，为province创建因子： pf&lt;-factor(province) 创建province的因子pfpf 打印出来 [1] 四川 湖南 江苏 四川 四川 四川 湖南 江苏 湖南 江苏Levels: 湖南 江苏 四川函数levels()可以用来观察因子中有多少不同的levels。假如我们拥有这些省份考生的分数：score&lt;-c(95,86,84,92,84,79,86,99,85,90)函数tappley()可以用来计算各省的平均分数，函数tapply()的作用是对它第一个参数的组件中所包含的每个组应用一个参数三指定的函数。smeans&lt;-tapply(score,pf,mean)smeans 湖南 江苏 四川85.66667 91.00000 87.50000再例如，下面命令会给出各组的lengthtapply(score,pf,length)湖南 江苏 四川 3 3 4 函数ordered()可以创建有序因子 ordered(province) [1] 四川 湖南 江苏 四川 四川 四川 湖南 江苏 湖南 江苏Levels: 湖南 &lt; 江苏 &lt; 四川 五 数组和矩阵5.1 数组数组可以看成一个由递增下标表示的数据项的集合，例如数值。数组的生成如果一个向量需要在R中以数组的方式被处理，则必须含有一个维数向量作为它的dim属性。维度向量由dim()指定，例如，z是一个由1500个元素组成的向量。下面的赋值语句 dim(z) &lt;- c(3,5,100) 使它具有dim属性，并且将被当作一个3X5X100的数组进行处理。 c(3,5,100) 就是他的维度向量。还可以用到像matrix()和array()这样的函数来赋值。比如array(1:20, dim=c(4,5))matrix(1:24, 3,4)数据向量中的值被赋给数组中的值时，将遵循与FORTRAN相同的原则”主列顺序”，即第一个下标变化的最快，最后的下标变化最慢。数组的运算数组可以在算数表达式中使用，结果也是一个数组，这个数组由数据向量逐个元素的运算后组成，通常参与运算的对象应当具有相同的dim属性。5.2 数组的索引和数组的子块 数组中的单个元素可以通过下标来指定，下标由逗号分隔，写在括号内。我们可以通过在下标的位置给出一个索引向量来指定一个数组的子块，不过如果在任何一个索引位置上给出空的索引向量，则相当于选取了这个下标的全部范围。如a[2,,]，a[,3,]等5.3 索引数组除了索引向量，还可以使用索引数组来指定数组的某些元素。例如：有4X5的数组a，若要得到a中的a[1,3], a[2,2] 和a[3,1]这三个元素，可以生成索引向量i，然后用a[i]得到它们。 a &lt;- array(1:20,dim=c(4,5)) # Generate a 4 by 5 array.i &lt;- array(c(1:3,3:1),dim=c(3,2))i[,1] [,2][1,] 1 3[2,] 2 2[3,] 3 1a[i][1] 9 6 3a[i] &lt;- 0 # 将这三个元素用0替换。5.4 向量，数组的混合运算表达式从左到右被扫描；参与运算的任意对象如果大小不足，都将被重复使用直到与其他参与运算的对象等长；当较短的向量和数组在运算中相遇时，所有的数组必须具有相同的dim属性，否则返回一个错误；如果有任意参与运算的向量比参与运算的矩阵或数组长，将会产生错误；如果数组结构正常声称，并且没有错误或者强制转换被应用于向量上，那么得到的结果与参与运算的数组具有相同的dim属性。5.5 矩阵的运算构建分区矩阵：cbind()和rbind()，cbind()按照水平方向，或者说按列的方式将矩阵连接到一起。rbind()按照垂直的方向，或者说按行的方式将矩阵连接到一起。 外积：操作符是%o%: ab &lt;- a %o% b 或者ab &lt;- outer(a, b, ““)其中的乘法操作可以由任意一个双变量的函数替代。广义转置：函数t(A)，或aperm(A, c(2,1))；获取行数/列数：nrow(A)和ncol(A)分别返回矩阵A的行数和列数。矩阵乘法：操作符为%%；交叉乘积（cross product）：crossprod(X，Y)等同于t(X) %*% y，crossprod(X)等价于crossprod(X, X)；diag(v)：如果v是向量，diag(v)返回一个由v的元素为对角元素的对角矩阵。 如果v为矩阵，diag(v)返回一个由v主对角元素组成的向量。 如果v只是一个数值，那么diag(v)是一个vXv的单位矩阵。 特征值和特征向量：eigen(Sm)。这个函数的结果是由名为values和vectors的两部分组成的列表。如果只是需要特征值：eigen(Sm)$values最小二乘拟合即QR分解：lsfit(), qr()。强制转换为向量：as.vector()，或者直接c().解线性方程和求矩阵的逆，奇异值分解与行列式见；六 列表和数据帧6.1 列表列表是由称作组件的有序对象集合构成的对象。组件的模式或类型不一定相同。形如Lst &lt;- list(name_1=object_1, . . ., name_m=object_m)的赋值将创建一个包含m个组件的列表，并根据参数中指定的名称为其命名。（其名称可以自由选取）。如果它们的名称被省略，组件将只是被编号。例如： Lst &lt;- list(name=”Fred”, wife=”Mary”, no.children=3,child.ages=c(4,7,9))所使用的组件是被复制到新的列表中的，对原始对象没有影响。组件总是被编号的，并且可以通过编号指定。Lst[[1]] 即为”Fred”，也可以用 Lst$name，Lst[[“name”]]指定。如果Lst[[4]]是一个有下标的数组，Lst[[4]][1]就是它的第一项。区分Lst[[1]]和Lst[1]，’[[…]]’是选择单个元素时使用的操作符，而’[…]’是一个一般的下标操作符。因此，前者代表列表Lst中的第一个对象；后者是列表Lst的子列表，仅包含列表的第一项。组件的名称可以缩写，可缩写的程度是只要能令组件被唯一的识别就可以了。如：Lst$na等价于Lst$name， Lst$w等价于Lst$wife。扩展列表可以通过指定额外组件的方式。例如Lst[5] &lt;- list(matrix=Mat)连接列表当连接函数c()的参数为列表时，其结果也是一个模式为列表的对象。由参数中的列表作为组件依次连接而成。list.ABC &lt;- c(list.A, list.B, list.C)6.2 数据帧 数据帧是类别为”data.frame”的列表；数据帧会被当作各列具有不同模式和属性的矩阵。数据帧按照矩阵的方式显示，选取的行或列也按照矩阵的方式来索引。创建数据帧直接创建：那些满足对数据帧的列（组件）限制的对象可以通过函数data.frame来构建成为一个数据帧 t &lt;- data.frame(home=statef, loot=income, shot=incomef)强制转换：如果一个列表的组件与数据帧的限制一致，这个列表就可以通过函数as.data.frame()强制转化为一个数据帧。外部文件：创建数据帧最简单的方法应当是使用read.table()函数从外部文件中读取整个数据帧。数据帧和列表的限制1 组件必须是向量（数值型，字符形，逻辑型），因子，数值矩阵，列表，或其他数据帧；2 矩阵，列表，数据帧向新数据帧提供的变量数分别等于它们的列数，元素数和变量数；3 数值向量，逻辑值和因子在数据帧中保持不变，字符向量将被强制转化为因子，其水平是字符向量中所出现的值；4 数据帧中作为变量的向量结构必须具有相同的长度，而矩阵结构应当具有相同的行大小。 挂接和卸载数据帧当觉得使用’$’引用数据帧元素(如’t$home’)麻烦时，可以进行数据帧挂接 attach(t) 这样可以直接引用数据帧内的元素，而无需’$’，前提是数据帧外没有同名的变量(如name)。挂接后若要对数据帧元素进行赋值操作，仍需用’$’，否则视为赋值给数据帧外的元素。赋值后必须要先卸载(detach)再重新挂接后，新值才可见。detach(t) attach()是具有一般性的函数，即它不仅能够将目录和数据帧挂接在搜索路径上，还能挂接其他类别的对象。特别是模式为”list”的对象可以通过相同的方式挂接： attach(any.old.list)任何被挂接的对象都可以用detach来卸载，通过指定位置编号或者指定名称这样的方式.搜索路径函数search()将显示目前的搜索路径，可以用来查看数据帧/列表的挂接状态。ls()（或objects()）命令可以用来检查搜索路径任意位置上的内容。如：ls(), ls(2), ls(t)R可以在搜索路径中包含至多20个项目,列表和数据帧只能在位置2或更靠后的位置上挂接。 数据帧使用惯例 1 将每个独立的，适当定义的问题所包含的所有变量收入同一个数据帧中，并赋予合适的、易理解、易辨识的名称；2 处理问题时，当相应的数据帧挂接于位置2，同时在第1层工作目录下存放操作的数值和临时变量；3 在结束一次工作之前，将你认为对将来有参考价值的变量通过$标记的形式添加到数据帧里面，然后detach()；4 最后，将工作目录下所有不需要的变量剔除，并且尽量将剩下多余的临时变量都清除干净。这样我们可以很简单的在同一个目录下处理多个问题，而且对每个问题都可以使用x,y,z这样的变量名。七 从文件中读取数据7.1 函数read.table()该函数可以直接将文件中完整的数据帧读入。此时文件要符合特定的格式：1 第一行应当提供数据帧中每个变量的名称；2 每一行(除变量名称行)应包含一个行标号和各变量的值。3 若没有表头(变量名称行)，也没有行标号，只有变量值，则默认变量名称为”v1”,”v2”…4 若有表头，但没有行标号，则可以指定参数header=TRUE.7.2 函数scan()该函数从键盘或文件中读取数据，并存入向量或列表中。 inp &lt;- scan(file, what)第一个参数是文件名,如“test.txt”，若为“”或空，则从键盘读入数据；第二个参数用于确定读入数据的模式。 如：list(“”,0,0) 指定读入到列表中，列表有三项，且列表第一项是字符型，第二三项是数值型。若为0，则指定读入到一个数值向量中，若为“”则指定读入到字符向量中。7.3 内置数据集的读取 R本身提供超过50个数据集，同时在功能包（包括标准功能包）中附带更多的数据集。与S-Plus不同，这些数据即必须通过data函数载入。 data() #获得基本系统提供的数据集列表，然后通过形如data(infert) #来载入名为infert的数据集从其他package中载入数据集data(package=”nls”) #查看nls中数据集data(Puromycin, package=”nls”) #读取nls中Puromycin数据集。用library()挂接package后，它的数据集也自动包含到搜索路径中了。library(nls) #载入package nlsdata() #查看数据集date(Puromycin) #载入Puromycin数据集 7.4 编辑数据在使用一个数据帧或矩阵时，edit提供一个独立的工作表式编辑环境。 xnew &lt;- edit(xold) #对数据集xold进行编辑。并在完成时将改动后的对象赋值给xnewxnew &lt;- edit(data.frame()) #可以通过工作表界面录入新数据。fix()函数用于直接修改已有的对象，等价于 x&lt;-edit(x).八 概率分布8.1 R是一个统计表集合(略读) R提供了一套完整的统计表集合。函数可以对累积分布函数P(X&lt;=x)，概率密度函数，分位函数（对给定的q，求满足P(X&lt;=x) &gt; q的最小x）求值，并根据分布进行模拟。 对于所给的名称，加前缀’d’代表密度(density)，’p’代表CDF，’q’代表分位函数，’r’代表模拟（随即散布）。这几类函数的第一个参数是有规律的，形为dxxx的函数为x，pxxx的函数为q，qxxx的函数为p，rxxx的函数为n（rhyper和rwilcox是特例，他们的第一个参数为nn）。目前为止，非中心参数(non-centrality parameter)仅对CDF和少数几个其他函数有效，细节请参考在线帮助。所有pxxx和qxxx的函数都具有逻辑参数lower.tail和log.p，而所有的dxxx函数都有参数log，这个是我们可以直接通过 pxxx(t, …, lower.tail = FALSE, log.p = TRUE)获取，比如说，累积失效函数（cumulative/integrated hazard function），H(t) =-log(1-F(t))，以及更精确的对数似然（通过dxxx(…, log = TRUE)）。此外，对于来自正态分布，具有学生化样本区间的分布还有ptukey和qtukey这样的函数。下面是一些例子 2-tailed p-value for t distribution2*pt(-2.43, df = 13) upper 1% point for an F(2, 7) distributionqf(0.99, 2, 7)8.2 检测数据集的分布 函数summary和fivenum这两个函数可以给出摘要，后者只给出数值；函数stem可以将数值统计结果以类似直方图的方式显示出来；函数hist()可以绘制直方图；函数density和line可以获得更漂亮的密度图；功能包fun中的ecdf函数能绘制经验累积分布函数；还可以进行拟合正态分布，覆盖拟合CDF；还可以绘制Quantile-quantile (Q-Q)图有助于我们更细致的检测其分布形态；8.3 单样本和两样本检验（略读）九 语句组、循环和条件操作 R是一种表达式语言，也就是说其命令类型只有函数或表达式，并由它们返回一个结果。语句组由花括号‘{ }’确定，此时结果是该组中最后一个能返回值的语句的结果。条件语句 if (expr_1) expr_2 else expr_3其中条件表达式expr1必须返回一个逻辑值，操作符&amp;&amp;和||经常被用于条件部分。&amp;和|与&amp;&amp;，||的区别在于，&amp;和|按照逐个元素的方式进行计算，&amp;&amp;和||对向量的第一个元素进行运算，只有在必需的时候才对第二个参数求值。if/else结构的向量版本是函数ifelse，其形式为ifelse (condition,a,b)，产生函数结果的规则是：如果condition[i]为真，对应a[i]元素；反之对应的是b[i]元素。根据这个原则函数返回一个由a,b中相应元素组成的向量，向量长度与其最长的参数等长。循环语句for (name in expr_1) expr_2其中name是循环变量，expr1是一个向量表达式（通常是1:20这样的序列），而expr2经常是一个表达式语句组，expr2随着name依次取expr1结果向量的值而被多次重复运行。repeat(expr)while(condition) expr break语句可以用来中断任何循环，可能是非正常的中断。而且这是中止repeat循环的唯一方式。next语句可以中止一个特定的循环，跳至下一个.十 编写自己的函数10.1 函数的定义 name &lt;- function(arg_1, arg_2, …) expressionexpression是一个R表达式（通常是表达式语句组），并使用参数arg_i来计算出一个数值，表达式的值就是函数的返回值。函数调用的形式通常都是name(expr1,expr2,…)10.2 定义新的二元操作符可以将函数定义为新的二元操作符：“%!%” &lt;- function(X, y) { … }正如矩阵乘法运算符，%*%，和矩阵外积运算符%o%10.3 指定参数和默认值 如果被调用函数的参数按照”name = obj”的形式给出，那么参数的次序可以是任意的。而且，参数序列可以在开始依次序给出，而将指定名称的参数置于后面。因此，如果由一个函数fun1被定义为 fun1 &lt;- function(data, data.frame, graph, limit) {[function body omitted]}那么函数可以有多种等价的使用方法，例如ans &lt;- fun1(d, df, TRUE, 20)ans &lt;- fun1(d, df, graph=TRUE, limit=20)ans &lt;- fun1(data=d, limit=20, graph=TRUE, data.frame=df)默认值 ：在很多情况下，参数都会被赋予一个普遍适用的默认值。fun1 &lt;- function(data, data.frame, graph=TRUE, limit=20) { … }则函数可以这样被调用ans &lt;- fun1(d, df)此时与上面三种情况等价，也可以这样调用ans &lt;- fun1(d, df, limit=10)此时改变了一个默认值。NOTE：参数可以是任意表达式，甚至可以是包含其他参数的表达式；10.4 额外参数“…” 当需要将一个函数的参数传递给另一个函数时，可以通过包含一个额外的参数”…”实现。fun1 &lt;- function(data, data.frame, graph=TRUE, limit=20, …) {[omitted statements]if (graph)par(pch=”*”, …)[more omissions]}10.5 全局变量和局部变量函数内的赋值都是局部变量，退出函数就丢失了。如果要在函数内进行永久赋值（定义全局变量），需要用到“超赋值”操作符, &lt;&lt;-或者函数assign()。10.6 一些高级示例区组设计的效率因子 (E±ciency factors)删除打印数组中的所有名称递归的数值积分10.7 范畴（Scope） 函数主体内出现的标识(symbol)可以被分为3类；正式参数、局部变量和自由变量。正式参数就是出现在函数参数列表中的参数，他们的值由实际的函数参数与正式参数的绑定（binding）过程决定。局部变量是在参数主体中，由表达式求值过程决定的变量。自由变量为既不是正式参数又不是局部变量的变量。赋值之后自由变量成为局部变量。 在R中，自由变量的值由函数被创建的环境中与其同名的第一个变量值决定（我理解为最近的同名变量），这种方式被称为词汇式范畴(lexical scope)。而在S中，该值由同名的全局变量决定。例如下面的函数cube，在R中cube（2）=8，在S中报错为sq()找不到n。cube &lt;- function(n) {sq &lt;- function() nnnsq()}一个银行账户的例子，详见《R语言笔记》。10.8 定制环境详见《R语言笔记》。10.9 类别，通用函数和对象定位 一个对象的类别(class)决定了他会如何被通用函数(generic function)处理。如果参数本身没有任何类别属性，或者其类别在特定问题中并不满足通用函数的要求，通常会有一个默认的动作被执行。类别机制使用户可以为特定的目的设计和编写通用函数。使用&gt; methods(class=”data.frame”)可以查看数据帧的通用函数。使用&gt; methods(plot)可以查看plot函数能处理的类别。十一 R的统计模型待阅。 十二 图形过程在Windows下用window()命令可以打开图形窗口。12.1 高级绘图命令 高级绘图函数，由函数参数提供数据生成一幅完整的图形。其中适当的坐标轴，标签和标题都自动生成了（除非你另外指定了）。高级绘图命令每次都生成一幅新的图形，清除当前的图形（如果需要的话）。 1 plot()函数 这是一个通用函数：生成图形的类型取决于第一个参数的类型或类别(class)。plot(x,y) plot(xy)：如果x，y是向量，plot(x,y)生成一幅y对x的散点图。用包含两个元素x，y的一个列表或一个两列的矩阵作为一个参数（第二种形式那样的）也能达成相同的效果。plot(x)：如果x是一个时间序列，这个命令生成一个时间序列图，如果x是一个数值型向量，则生成一个向量值对它们向量索引的土，而如果x是一个复向量，则生成一个向量中元素的虚部对实部的图。plot(f) plot(f,y)：f是一个因子对象，y是一个数值型向量。第一种形式生成一个f的条形图；第二种形式生成y对应于f各个水平的箱线图。plot(df) plot( expr) plot(y expr)：df是一个数据帧，y是任意对象，expr是由对象名称组成的列表，分隔符’+’(例如，a + b + c)。前两种形式生成分布式的图形，第一种是数据帧中的变量，第二种是一系列被命名的对象。第三种形式生成y对expr中每个对象的图。2 显示多元数据 如果X是一个数值矩阵或数据帧，下面的命令 pairs(X)生成一个配对的散点图矩阵，矩阵由X中的每列的列变量对其他各列列变量的散点图组成，得到的矩阵中每个散点图行、列长度都是固定的。 当问题涉及到三、四个变量时，使用coplot更好些。如果a和b是数值向量，c是数值向量或因子对象（全都是相同长度的），下面的命令 coplot(a ~ b | c)对应c的某些给定值生成数个a对b的散点图。当c是一个因子时，这个命令也就是对c的每个水平生成a对b的散点图。当c是数值向量的时候，这个数值向量被分为一系列的条件区间（conditioning intervals），对应c的每个区间生成一个a对b的散点图。区间的数量和位置可以通过coplot()的参数given.values来控制，函数co.intervals()也可以用来选择区间。我们也可以使用两个给定变量通过命令coplot(a ~ b | c+d)对c和d的每个联合条件区间生成a对b的散点图。 函数coplot()和pairs()都可以使用参数panel=，这个参数可以用来定制我们得到的图形类型。默认的是points()函数，生成一个散点图，不过通过在参数panel=中提供某些其它的低级图形函数，我们可以生成需要的各种图形。一个很有用的函数例子是panel.smooth()。3 显示图形 qqnorm(x) qqline(x) qqplot(x,y)分布比较图。第一种形式生成向量x对期望正态分数（一个正态记分图），第二个在上面的图上添加一条穿过分布分位点和数据分位点的直线。第三个命令生成x的分位点对y分位点图，用于分别比较它们的分布。hist(x) hist(x,nclass=n) hist(x,breaks=b, . . . )生成数值变量x的直方图。通常会自动选定一个合理的类别数，不过可以通过nclass=参数来指定一个推荐值。或者通过参数breaks=来指定分界点。如果给定了probability=TRUE参数，那么条形图代表相对频数而不是累计数。dotchart(x, . . . )创建一个x中数据的点图(dotchart)。点图中y轴给出x中数据的标签，x轴给出它们的值。它允许对落入某一特定区间的所有数据项方便的进行可视化选择。image(x,y,z, . . . ) contour(x,y,z, . . . ) persp(x,y,z, . . . )生成三个变量的图。函数image是用不同的颜色绘制一些矩形方格来展示z的值，函数contour通过绘制等高线来展示z的值，函数persp绘制一个3D面。4 参数配置 add=TRUE 强制函数按照低级图形函数的方式操作，将图形置于当前图形上（仅对某些函数有效）。axes=FALSE 暂时禁止坐标轴的生成|以便使用axis()函数添加你自己定制的坐标轴。默认情况是axes=TRUE，即包含坐标轴。log=”x” log=”y” log=”xy” 令x,y或者两者全都对数化。这个参数对许多函数都有效，不过不是全部。type= 参数type=控制所生成图形的类型： type=”p” 绘制单独的点（默认值） type=”l” 绘制线 type=”b” 绘制由线连接的点（both） type=”o” 将点绘在线上 type=”h” 绘制从点到零轴的垂线（high-density） type=”s” 阶梯式图。第一种形式中，点由垂线的顶部定义；第二种形式里用底部定义。 type=”n” 不绘制。不过坐标轴是绘出的（默认情况）而且要根据数据绘出坐标系统。用来给后续的低级图形函数创建图形作基础。xlab=string ylab=string x轴或y轴的标签。使用这些参数来改变默认的标签，通常的默认值是调用高级绘图函数时所使用对象的名称。main=string 图表标题，位于图形的顶部，大字体显示。sub=string 子标题，位于x轴下面，用较小的字体显示。12.2 低级绘图命令 有些时候高级绘图函数并不能很精确的生成我们想要的图形。这种情况下，我们可以通过低级绘图命令在当前图形上添加信息（例如，点、线或文本）。points(x,y) lines(x,y)在当前图形上添加点或线。函数plot()的参数type=也可以用于这些函数（默认的是”p”代表points()和”l”代表lines()）。text(x,y,labels, . . . )给定点坐标x,y，在该点添加文本。通常labels是一个整数或字符向量，其中labels[i]出现在点(x[i],y[i])。默认值是1:length(x)。Note： 这个函数通常用于这样的序列中 plot(x, y, type=”n”); text(x, y, names)图形参数type=”n”阻止了点的生成，但是建立了坐标轴，由函数text()提供字符向量names所指定的特定字符。 abline(a, b) abline(h=y) abline(v=x) abline(lm.obj)在当前图上添加一条斜率为b，截距为a的直线。h=y在图形指定的高度上绘制一条贯穿图形的水平线，同样的，v=x在x轴的指定位置绘制一条贯穿的垂线。而lm.obj是一个包含coefficients组件的列表，该组件的长度为2，分别当作截距和斜率。polygon(x, y, . . . )绘制一个多边形，其顶点由(x,y)指定。同时还（可选的）可以加上阴影线，如果图形设备允许的话还可以将多边形填充。legend(x, y, legend, . . . )这当前图形的指定位置添加图例。绘制的字符，线条类型，颜色等等由字符向量legend指定。除此之外至少还要给出一个参数v，与绘图单元的相应值，分别有：legend( , fill=v)填充方框的颜色legend( , col=v)绘制点线的颜色legend( , lty=v)线条类型legend( , lwd=v)线条宽度legend( , pch=v)绘制字符(字符向量) title(main,sub)在当前图形的顶部用大字题添加一个标题main，在底部用较小的字体添加子标题sub。axis(side, . . . )在当前图形的指定边上添加坐标，在哪个边上由第一个参数指定（1到4，从底部按照顺时针顺序）。其他参数控制坐标的位置|在图形内或图形外，以及标记的位置和标签。适合在调用参数为axes=FALSE的函数plot()后添加定制的坐标轴。低级绘图函数通常都需要一些位置信息（例如，x,y坐标）来决定在哪里添加新的元素。坐标以用户坐标(user coordinates)的形式给出，这个坐标系是根据所提供的数据由之前的高级绘图语句定义的。需要x,y参数的地方还可以选用一个单独的参数，即一个由名为x,y的元素组成的列表。相似的，一个两列的矩阵也可以。像locator()（后面会提到）这样的函数也可以按照这种方式交互的指定图形中的位置。添加数学注释某些情况下需要在图形中加入数学符号或公式。在R中可以通过在text, mtext,axis或title中指定一个表达式来实现。例如，下面的代码绘制了二项概率函数的公式： text(x, y, expression_r(paste(bgroup(“(“, atop(n, x), “)”),p^x, q^{n-x})))更多的信息，包括其特性的一个完整列表可以在R中通过下面的命令得到：help(plotmath)example(plotmath)添加Hershey矢量字体help(Hershey)example(Hershey)12.3 图形的交互R提供了函数，使用户可以通过鼠标从图形中释放信息或添加信息。 locator(n,type)等待用户使用鼠标左键在当前图形上选择位置。直到n(默认是512)个点都选完或者点击了鼠标另一个键（Unix,Windows)，在Mac下用鼠标点击图形窗口外的部分也可以结束。参数type的效果和在高级绘图函数中使用时是一样的，即在选择的点绘制指定的图形。默认情况是不绘制图形。函数locator()将所选点的坐标返回到一个列表中，列表包含x,y两个组件。通常locator()在调用的时候并不带参数。这个功能在为图例或标签这样的图形元素选择位置时比较有用，尤其是这些位置不好通过计算得到的时候。举个例子，如果要在一个野点附近添加一些信息，可以使用下面的命令 text(locator(1), “Outlier”, adj=0) identify(x, y, labels)允许用户在x,y（使用鼠标左键）定义的点附近绘制相应的labels的组件（如果没有给出labels就给出该点的序号），突显该点。当鼠标的另一个键被点击时（Unix,Windows）返回被选点的序号，在Mac下通过点击图形窗口外来实现这个效果。有时我们更想确定图形中的点，而非它们的位置。例如，我们可能希望从图示中选出某些感兴趣的观测点，然后进行某些操作。通过两个数值向量x,y给定一系列坐标(x; y)，我们可以使用identify()函数： plot(x,y) &gt; identify(x,y)函数identify()本身不绘图，但是允许用户移动鼠标，在某点附近点击左键。离鼠标指针最近的点将被突显，并标出其序号（也就是它在向量x/y中的位置）。或者使用identify()的labels参数，把某些信息（例如案例名称）作为突显的标志；或者通过plot=FALSE参数取消所有突显标志。当选点的过程结束后，identify()返回所选点的序号；用户可以使用这些序号从x和y中释放所选的点。12.4 使用图形参数 通过图形参数可以定制图形显示的几乎所有方面。R包含大量的图形参数，可以控制的包括线条类型，颜色，图标排列，文本对齐等等。1 持续性变更 (Permanent changes): par()函数 通过par()函数设定图形参数的值会持续性的更改参数的值，也就是说这之后（在当前设备上）所有对图形函数的调用都受到新值的影响。函数par()用于存取和修改当前图形设备的图形参数列表。par()不带任何参数，返回当前设备所有图形参数和它们的值的列表。par(c(“col”,”lty”))参数为一个字符向量，仅返回参数中指定的图形参数（也是作为一个列表）。par(col=4, lty=2)带指定参数（或一个列表型参数），设定指定图形参数的值，并将参数的原始值作为一个列表返回。所以如果想设定参数绘制一些图形后再恢复成原来的设定，可以这么做： oldpar &lt;- par(col=4, lty=2). . . plotting commands . . .par(oldpar)2 临时性变更：图形函数的参数 图形参数也可以作为（几乎）所有图形函数的命名参数。这种方式的效果和用于par()函数的效果是一样的，只不过这种改变只在函数调用的区间内有效。比如： plot(x, y, pch=”+”)生成一个以加号作为绘图符号的散点图，而不改变后续图形的默认的绘图符号。3 图形参数列表A 图形元素R图表由点、线、文本和多边形（填充区）组成。下面的图形参数控制了图形元素的绘制：pch=”+” 用来绘点的字符。这个默认值随不同的图形驱动是不同的，不过通常都是’±’。除非使用”.”作为绘图字符，否则绘制的点都会比适当的位置高一点或者低一点，而不是恰好在指定位置。pch=4当给定一个0到18的整数时，会生成一个特殊的绘图符号。通过下面的命令可以看这些符号都有什么。legend(locator(1), as.character(0:18), pch=0:18)lty=2 线条类型。并不是所有图形设备都支持多种线条类型（在那些支持的设备上也不全一样），不过线条类型1始终是实线，2及以上的是点、划线或者它们的组合。lwd=2 线条宽度。所需的线条宽度，是”标准”线条宽度的倍数。对line()等函数绘制的线条和坐标轴都有效果。col=2 点、线、文本、填充区和图像使用的颜色。每种图形元素都有其可用的颜色列表，这个参数的值就是颜色在列表中的序号。显然，这个参数值对有限的一类设备有效。font=2 指定文本所使用字体的一个整数。如果可能的话，设备驱动会把1对应普通文本，2对应粗体，3对应斜体，4对应粗斜体。font.axis font.lab font.main font.sub 这几个参数分别指定坐标轴注释，x,y轴的标签，主、副标题所用的字体。adj=-0.1 文本对齐和绘图位置有关。0代表左对齐，1代表右对齐，0.5代表水平的中间位置。当前的值使会图位置到左端距离的比例，所以-0.1在文本和绘图位置之间留10%的空白。cex=1.5 字符缩放。这个值是所需文本字符（包括绘图字符）的大小，与默认文本大小相关。B 坐标轴和标记很多R的高级图形都有坐标轴，你可以使用低级图形函数axis()自己创建坐标轴。坐标轴包含三个主要组件：轴线axis line（线条类型由参数lty控制），标记tick mark（沿着轴线划分单元），标号tick label（用来标出这些单元）。这些组件可以用下面这些参数定制。lab=c(5,7,12)前两个数字分别是x和y轴上所要划分的区间数。第三个数字是坐标轴标签的长度，用字符数来衡量（包括小数点）。参数的值如果选得太小可能导致所有标号都聚在一起。las=1 坐标轴标签的方向。0代表总是和坐标轴平行，1代表总是水平的，2代表总是垂直于坐标轴。mgp=c(3,1,0)坐标轴组件的位置。第一个组件是坐标轴标签到坐标轴的距离，单位是文本行(text lines)。第二个组件是到标号的距离，最后一个是轴的巍直到轴线的距离（一般都是0）。正数代表绘图区域外，负数代表区域内。tck=0.01 标号的长度，绘图区域大小的一个分数作单位。当tck比较小时（小于0.5），就强制x和y轴上的标记为相同大小。tck=1就是生成网格线。取负值时标记画向绘图区域外。内部标记可以使用tck=0.01和mgp=c(1,-1.5,0)。xaxs=”s” yaxs=”d” 分别是x、y轴的类型。如果是s(standard)或e(extended)类型，那最大和最小的标记都始终在数据区域之外。如果有某个点离边界非常近，那么扩展型(extended)的轴会稍稍扩展一下。这种类型的轴有时会在边界附近留出大片空白。而i(internal)或r(默认值)类型的轴，标记始终在数据区域内，不过r类型会在边界留出少量空白。如果这个参数设为d，就锁定当前轴，对之后绘制的所有图形都用这个轴（直到参数被重新设定为其他的那几个值）。这个参数适用于生成一系列固定尺度的图。C 图边缘（Figure margins）在R中一个单独图形，图（figure），包含一个绘图区(plot region)，以及环绕着这个区域的边缘（其中可能含有坐标轴标签、标题等等），（通常）这两部分以轴为边界。一个典型的图是 控制图的样式的图形参数包括：mai=c(1,0.5,0.5,0)分别是底部，左侧，顶部，右侧的宽度，单位是英寸。mar=c(4,2,2,1)与mai相似，只是单位是文本行(text lines)。由于更改一个就会改变另一个的值，所以在这个意义上，mai和mar是等价的。这个参数的默认值通常都太大了；右侧边缘很少用到，如果没标题，顶部边缘也不需要，左侧和底部的边缘应当足够大，以容纳坐标轴和标号。此外，默认值并没有考虑到设备表面的大小：比如，使用postscript()驱动，height=4参数时，除非用mar，mai另外设定，否则图的边缘就要占上大约50%。使用多图环境时（后面会提到）。边缘会减少一半，不过这在多图共用一页的时候可能还不够。D 多图环境R允许在一页上创建一个n£m的图的阵列。每个图由自己的边缘，图的阵列还有一个可选的外部边缘，如下图所示。 与多图环境相关的图形参数有：mfcol=c(3, 2) mfrow=c(2, 4) 设定多图阵列的大小。第一个值是行数，第二个值是列数。这两个参数唯一的区别是mfcol把图按列排入，mfrow把图按行排入。上图所示的版式可用mfrow=c(3,2)创建；上图显示的是绘制四幅图后的情况。mfg=c(2, 2, 3, 2) 当前图在多图环境下的位置。前两个数字是当前图的行、列数；后两个是其在多图阵列中的行列数。这个参数用来在多图阵列中跳转。你甚至可以在后两个数中使用和真值(true value)不同的值，在同一页上得到大小不同的图。fig=c(4, 9, 1, 4)/10 当前图在页面的位置，取值分别是左下角到左边界，右边界，下、上边界的距离与对应边的百分比数。给出的例子是一个页面右下角的图。这个参数可以设定图在页面的绝对位置。oma=c(2, 0, 3, 0) omi=(0, 0, 0.8, 0) 外部边缘的大小。与mar和mai相似，第一个用文本行作单位，第二个以英寸作单位，从下方开始按照顺时针顺序指定。外部边缘对页标题这类东西很有用。文本可以通过带outer=TRUE参数的mtext()函数加入外部边缘。默认情况下是没有外部边缘的因此必须通过oma或omi指定。函数split.screen()和layout()可以对多个图形作更复杂的排列。12.6 设备驱动 R几乎可以在任何一种类型的显示器和打印设备上生成（不同质量的）图形。不过，在这之前，需要告诉R要处理的是哪一种设备。这通过启动一个设备驱动来完成。设备驱动通过调用设备驱动函数来启动。某些常用的设备驱动有：X11()[Unix] 使用X11视窗系统windows()[Windows] 使用 Windows 视窗系统postscript()在PostScript打印机上打印或者创建PostScript图形文件pictex()生成一个LATEX文件当一个设备使用完之后，可以通过下面的命令终止设备驱动 dev.off()这个命令可以确保设备已经结束；例如，在某些硬拷贝的设备中，这个命令可以保证每页都已经完成，并且都被传送到打印机了。PostScript文档通过给postscript()函数带上file参数，我们可以把图形以PostScript格式存储到文件中。如果没有给出horizontal=FALSE参数，图形是横向的，你可以通过width和height参数控制图形的大小（图形会自动适应）。例如，命令postscript(“file.ps”, horizontal=FALSE, height=5, pointsize=10)为一个五英寸的图生成一个包含PostScript代码的文件，可以放在文当中。如果命令中的指定的文件名已经存在，将会被覆盖。多重图形设备每个对设备驱动的新调用都会打开一个新的图形设备，在设备列表中加入新的一项。这个设备就成为当前设备，图形输出就传送到这个设备。dev.list() 返回所有活动中设备的序号和名称。在列表位置1的设备始终是空设备(null device)，这个设备不接收任何图形命令。dev.next() dev.prev() 分别返回当前设备的后一个和前一个设备的序号和名称。dev.set(which=k) 用来把当前设备更改为设备列表中位置k的那个。返回设备的序号和标签。dev.off(k) 终止图形列表位置k的那个图形设备。对于某些设备，比如postscript，这个命令会立刻打印文件或者正常结束文件，具体怎样处理取决于设备是怎样初始化的。dev.copy(device,. . . ,which=k) dev.print(device,. . . ,which=k)建立一个设备k的拷贝。其中device是一个设备函数，例如postscript，如果需要的话可以在’. . . ‘中指定其它的参数，dev.print效果相似，不过复制的设备会立刻关闭，所以打印硬拷贝这样的终止操作也会被立即执行。graphics.off() 终止列表中的所有图形设备，空设备除外。 (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/20/R笔记/]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>初级</tag>
        <tag>可视化</tag>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[REST]]></title>
    <url>%2F2017%2F09%2F20%2FREST(1)%2F</url>
    <content type="text"><![CDATA[REST是一种设计API的模式什么是Web API呢？ 如果我们想要获取某个电商网站的某个商品，输入http://localhost:3000/products/123，就可以看到id为123的商品页面，但这个结果是HTML页面，它同时混合包含了Product的数据和Product的展示两个部分。对于用户来说，阅读起来没有问题，但是，如果机器读取，就很难从HTML中解析出Product的数据。 如果一个URL返回的不是HTML，而是机器能直接解析的数据，这个URL就可以看成是一个Web API。比如，读取http://localhost:3000/api/products/123，如果能直接返回Product的数据，那么机器就可以直接读取。 REST就是一种设计API的模式。最常用的数据格式是JSON。由于JSON能直接被JavaScript读取，所以，以JSON格式编写的REST风格的API具有简单、易读、易用的特点。 编写API有什么好处呢？由于API就是把Web App的功能全部封装了，所以，通过API操作数据，可以极大地把前端和后端的代码隔离，使得后端代码易于测试，前端代码编写更简单。 此外，如果我们把前端页面看作是一种用于展示的客户端，那么API就是为客户端提供数据、操作数据的接口。这种设计可以获得极高的扩展性。例如，当用户需要在手机上购买商品时，只需要开发针对iOS和Android的两个客户端，通过客户端访问API，就可以完成通过浏览器页面提供的功能，而后端代码基本无需改动。 当一个Web应用以API的形式对外提供功能时，整个应用的结构就扩展为： 把网页视为一种客户端，是REST架构可扩展的一个关键。 (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/20/REST(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli 脚手架总结]]></title>
    <url>%2F2017%2F09%2F20%2Fvue-cli%20%E8%84%9A%E6%89%8B%E6%9E%B6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[工地上，脚手架是帮助工人作业搭建的架子。 vue-cli 可以帮助我们写好 vuejs 代码的工具 vue-cli 介绍工地上，脚手架是帮助工人作业搭建的架子。 vue-cli 可以帮助我们写好 vuejs 代码的工具，vue-cli 可以做什么： 1、目录结构2、本地调试3、代码部署4、热更新5、单元测试 （ESlint） vue-cli 的脚手架项目模板有browserify 和 webpack , 现在自己在用的是webpack , 官网给出了两个模板： webpack-simple 和 webpack 两种。两种的区别在于webpack-simple 没有包括Eslint 检查功能等等功能，普通项目基本用webpack-simple 就足够了. 搭建官方项目模板步骤： $ npm install -g vue-cli $ vue init （例如：$ vue init webpack my-project） 我们还需要把项目的依赖下载下来。使用命令: cd youdemoname 然后执行npm install 就可以了，这个时候你的项目中有多了一个node_modules 目录 使用”npm run dev“ 命令来运行项目 “npm-run-bulid“ 来执行发布，会自动生成dist文件 默认情况下，浏览器打开 http://localhost:8080，就可以看到脚手架项目初始化的效果了。 (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/20/vue-cli 脚手架总结/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
        <tag>Vue</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli 脚手架总结]]></title>
    <url>%2F2017%2F09%2F20%2Fvue-cli%20%E8%84%9A%E6%89%8B%E6%9E%B6%E6%80%BB%E7%BB%93(1)%2F</url>
    <content type="text"><![CDATA[工地上，脚手架是帮助工人作业搭建的架子。 vue-cli 可以帮助我们写好 vuejs 代码的工具 vue-cli 介绍工地上，脚手架是帮助工人作业搭建的架子。 vue-cli 可以帮助我们写好 vuejs 代码的工具，vue-cli 可以做什么： 1、目录结构2、本地调试3、代码部署4、热更新5、单元测试 （ESlint） vue-cli 的脚手架项目模板有browserify 和 webpack , 现在自己在用的是webpack , 官网给出了两个模板： webpack-simple 和 webpack 两种。两种的区别在于webpack-simple 没有包括Eslint 检查功能等等功能，普通项目基本用webpack-simple 就足够了. 搭建官方项目模板步骤： $ npm install -g vue-cli $ vue init （例如：$ vue init webpack my-project） 我们还需要把项目的依赖下载下来。使用命令: cd youdemoname 然后执行npm install 就可以了，这个时候你的项目中有多了一个node_modules 目录 使用”npm run dev“ 命令来运行项目 “npm-run-bulid“ 来执行发布，会自动生成dist文件 默认情况下，浏览器打开 http://localhost:8080，就可以看到脚手架项目初始化的效果了。 (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/20/vue-cli 脚手架总结(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
        <tag>Vue</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[J微信时代，博客阅读]]></title>
    <url>%2F2017%2F09%2F20%2F%E5%BE%AE%E4%BF%A1%E6%97%B6%E4%BB%A3%EF%BC%8C%E5%8D%9A%E5%AE%A2%E9%98%85%E8%AF%BB(1)%2F</url>
    <content type="text"><![CDATA[博客沒有消失，只是变成了知乎，微博了而已先来看一下博客的定义：博客，英文名为Blogger,为WebLog的混成词。它的正式名称为网络日记，是一种通常由个人管理、不定期张贴新的文章的网站。许多博客专注在特定的课题上提供评论或新闻，其他则被作为个人的日记。比较著名的有新浪、网易等博客。 随着互联网的发展，曾经的博客渐渐的变得无人问津。 博客是否会退出历史舞台？或者博客未来可能会变什么样? 很多人批评「碎片化阅读」，我却觉得碎片化阅读是社会的一个救星。微信的一个巨大功劳，是将阅读重新送回日常生活，提供了碎片化阅读的最好机会。因为人们此前根本连碎片化的阅读都逐渐失去了。我看到朋友圈所有人都在转各种文章，我的一些从不阅读的亲友，如今开始阅读一些短小的内容。这些阅读都是微信重新送回来的。 我们反对的是碎片化阅读，不是利用碎片化时间来阅读。利用零散时间阅读，这是一个可以充分利用时间的表现。我们反对的碎片化阅读指的是浮浅和无视语境的阅读。这和长短无关，和读者有没有整体性的视角有关。 而博客给了我们记录自己的生活，学习，常常都是很用心写出来的文章。是看了某部电影的感受，学习了某个小技术的总结或应用，是生活的记录，长长的文字，是我们的经历。 但我们过十年二十年以后，看看自己的博客（希望还在），毕竟是自己的故事，当时的所见所感，不论发自肺腑，大体是暗合心境的，我们的记录翻开的时候就是现在的我与过去的我的相遇，相视一笑。 随着微博，语音记录等新事物的出现，博客面临着巨大的挑战。据研究报告显示，现今博客用户数量大幅减少，但趋于平稳。也就是说有一批博客的忠实用户存在着。年轻人从16到20出头的年轻人几乎不使用博客。其主要用户是那些30岁左右至40岁左右的人。博客是否会消失主要取决于它自身如何演化。如果把知乎这样的算作博客的话，那这个演化其实已经开始了。博客不会消失，只是不知道变了身的博客对你来说是不是还叫博客而已。 所以博客沒有消失，只是变成了知乎，微博了而已。 (function(){ var appid = 'cysmzRdbl'; var conf = 'prod_7c789e58c2fd9306e64aff79a862b4df'; var width = window.innerWidth || document.documentElement.clientWidth; if (width < 960) { window.document.write(''); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/20/微信时代，博客阅读(1)/]]></content>
      <categories>
        <category>感想</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>感想</tag>
        <tag>写作</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R笔记]]></title>
    <url>%2F2017%2F09%2F20%2FR%E7%AC%94%E8%AE%B0(1)%2F</url>
    <content type="text"><![CDATA[一门可视化语言。http://bayes.math.montana.edu/Rweb/Rnotes/R.html 前言：关于R在R的官方教程里是这么给R下注解的:一个数据分析和图形显示的程序设计环境(A system for data analysis and visualization which is built based on S language.)。R的源起R是S语言的一种实现。S语言是由 AT&amp;T贝尔实验室开发的一种用来进行数据探索、统计分析、作图的解释型语言。最初S语言的实现版本主要是S-PLUS。S-PLUS是一个商业 软件，它基于S语言，并由MathSoft公司的统计科学部进一步完善。后来Auckland大学的Robert Gentleman 和 Ross Ihaka 及其他志愿人员开发了一个R系统。R的使用与S-PLUS有很多类似之处，两个软件有一定的兼容性。R is freeR是用于统计分析、绘图的语言和操作环境。R是属于GNU系统的一个自由、免费、源代码开放的软件，它是一个用于统计计算和统计制图的优秀工具。R是一套完整的数据处理、计算和制图软件系统。其功能包括：数据存储和处理系统；数组运算工具（其向量、矩阵运算方面功能尤其强大）；完整连贯的统计分析工具；优秀的统计制图功能；简便而强大的编程语言：可操纵数据的输入和输入，可实现分支、循环，用户可自定义功能。R是一个免费的自由软件，它有UNIX、LINUX、MacOS和WINDOWS版本，都是可以免费下载和使用的,在那儿可以下载到R的安装程序、各种外挂程序和文档。在R的安装程序中只包含了8个基础模块，其他外在模块可以通过CRAN获得。R的特点(1) 有效的数据处理和保存机制。(2) 拥有一整套数组和矩阵的操作运算符。(3) 一系列连贯而又完整的数据分析中间工具。(4) 图形统计可以对数据直接进行分析和显示，可用于多种图形设备。(5) 一种相当完善、简洁和高效的程序设计语言。它包括条件语句、循环语句、用户自定义的递归函数以及输入输出接口。(6) R语言是彻底面向对象的统计编程语言。(7) R语言和其它编程语言、数据库之间有很好的接口。(8) R语言是自由软件，可以放心大胆地使用，但其功能却不比任何其它同类软件差。(9) R语言具有丰富的网上资源一 入门训练 获取帮助 help.start() 开启帮助文档help(solve) 显示某命令的帮助信息，或者?solve 对于由特殊字符指定的功能，这些参数必须用单引号或双引号括起来，使之成为一个“字符串”,如help(“[[“) 与某个主题相关的例子通常可以用下面的命令得到example(topic) 命令简介 R对大小写是敏感的；名称不能以数字开始； 基本的命令由表达式或者赋值语句组成。如果一个表达式被作为一条命令给出，它将被求值、打印而表达式的值并不被保存。一个赋值语句同样对表达式求值之后把表达式的值传给一个变量，不过并不会自动的被打印出来； 命令由分号(;)来分隔，或者另起新行； 基本命令可以由花括号(f和g)合并为一组复合表达式； 注释几乎可以被放在任何地方，只要是以井号( # )开始，到行末结束； 如果一个命令在行莫仍没有结束，R将会给出一个不同的提示符，默认的是‘+’。 命令文件的执行和输出转向到文件如果命令存储于一个外部文件中，比如工作目录work中的commands.R，他们可以随时在R的任务中被执行 source(“commands.R”)在Windows中Source也可以由File菜单执行。函数sink，sink(“record.lis”)将把所有后续的输出由终端转向一个外部文件，record.lis。命令sink() 将把信息重新恢复到终端上。 数据的保持与对象的清除R所创建、操作的实体是对象。对象可以是变量、数组、字符串、函数以及由这些元素组成的其它结构； objects() 用来显示目前存储在R中的对象的名字。而当前存储的所有对象的组合被称为workspace；清除对象可以使用rm命令：rm(x, y, z, ink, junk, temp, foo, bar)所有在一个R任务中被创建的对象都可以在文件中被永久保存，并在其它的R任务中被使用。在每个R任务结束时用户都有机会保存当前有效的所有对象。如果用户这样做的话，对象将被写入当前目录一个名为.RData。当R被再次启动时R会从这个文件中再载入workspace。同时相关的命令记录也被载入。所以，推荐大家在用R进行不同的分析时分别使用不同的工作目录。 基本数据结构 数值型(numeric）1,1.2,3.1415926复数型(complex)1+2i字符型(character)‘A’/ “hello world!”逻辑型(logical)TRUE / FALSE 基本数据对象 向量(vector), 见下节矩阵(matrix)：更一般的说数组是向量在多维情况下的一般形式。事实上它们是可以被两个或更多的指标索引的向量，并且以特定的方式被打印出来。因子(factors) 提供了一种处理分类数据的更简介的方式。列表(list)：是向量的一种一般形式，并不需要保证其中的元素都是相同的类型，而且其中的元素经常是向量和列表本身。数据框(data frame)：是一种与矩阵相似的结构，其中的列可以是不同的数据类型。可以把数据框看作一种数据”矩阵”，它的每行是一个观测单位，而且(可能)同时包含数值型和分类的变量。函数( function)：能够在R的workspace中存储的对象。我们可以通过函数来扩展R的功能。二 简单操作，数值与向量2.1 向量与赋值R对命名了的数据结构进行操作。最简单的数据结构是数字向量；如， x &lt;- c(10.4, 5.6, 3.1, 6.4, 21.7) c()是创建函数，赋值运算符是’&lt;-‘，与函数assign()等价assign(“x”, c(10.4, 5.6, 3.1, 6.4, 21.7)) 也可以写成：c(10.4, 5.6, 3.1, 6.4, 21.7) -&gt; x如果一个表达式被当作一个完整的命令，它的值将被打印到终端但不被储存。单独输入x则会将值打印出来。也可以打印倒数：1/xy &lt;- c(x, 0, x) 也可以将向量作为元素。2.2 向量运算 操作是按照向量中的元素一个一个进行的。同一个表达式中的向量并不需要具有相同的长度。如果它们的长度不同,表达式的结果是一个与表达式中最长向量有相同长度的向量。表达式中较短的向量会根据它的长度被重复使用若干次(不一定是整数次)，直到与长度最长的向量相匹配。而常数很明显的将被不断重复。如，v &lt;- 2x + y + 1常用运算有：+，-，，/，^（次方）；log, exp, sin, cos, tan,sqrt等；max和min的作用是选出所给向量中最大的或最小的元素；range函数的值是一个长度为2的向量，即c(min(x),max(x))length(x)返回了向量x中元素的个数，也就是x的长度。sum(x)给出了x中所有元素的总和；prod(x)给出x中所有元素的乘积；mean(x)和var(x)，分别计算样本均值和样本方差，这两个函数分别相当于sum(x)/length(x)，sum((x-mean(x)) ^2)/(length(x) -1)。如果var()的参数是一个np的矩阵，那么函数的值是一个pp的样本协方差矩阵，认为每行是一个p变量的样本向量。sort(x)返回一个与x具有相同长度的向量，其中的元素按招升序排列。还有其他更灵活的排序功能(参见order()和sort.list())。pmax和pmin将返回一个与最长的向量长度相等的向量，向量中的元素由参数中所有向量在相应位置的最大值(最小值)组成；如果要使用复数，需要直接给出一个复数部分。因此sqrt(-17)将会返回NaN(无效数值)和一个警告，而sqrt(-17+0i)将按照复数进行运算。2.3 生成序列最简单的方法是用冒号‘：’，冒号具有最高运算优先级。例如1:30就是向量c(1,2,. . .,29,30)。30:1构造一个递减序列。利用seq()函数构造序列：有五个参数，from, to, by, length, along from, to可以不写参数名，seq(2,10)就相当于2:10。 by指定步长，默认为1，如seq(-5, 5, by=.2)即为c(-5.0, -4.8, -4.6, …, 4.6, 4.8, 5.0) length指定序列长度，如seq(length=51, from=-5, by=.2)，等同于seq(-5, 5, by=.2) along=vector只能单独使用，产生一个“1:length(vector)”序列。类似的函数是rep(),这个函数可以用多种复杂的方法来 复制一个对象。最简单的形式是&gt; s5 &lt;- rep(x, times=5)2.4 逻辑向量 TRUE, FALSE, 和NA(not available), 前两个可以简写为T和F，但T/F并不是系统保留字，可以被用户覆盖，所以最好还是不要简写。逻辑向量是由条件给出的，如下列语句令temp成为一个与x长度相同，相应位置根据是否与条件相符而由TRUE或FALSE组成的向量： temp 13逻辑操作符包括&lt;, &lt;=, &gt;, &gt;=,完全相等==和不等于!=，与或非分别为&amp;, |, !。在普通运算中，FALSE当做0而TRUE当做1。2.5 缺失值NA(not available): 一般来讲一个NA的任何操作都将返回NA。 is.na(x)返回一个与x等长的逻辑向量，并且由相应位置的元素是否是NA来决定这个逻辑向量相应位置的元素是TRUE还是FALSE。 x==NA是一个与x具有相同长度而其所有元素都是NA的向量。NaN(Not a Number): 由数值运算产生，如0/0, Inf-Inf. is.na(x)对于NA和NaN值都返回TRUE， is.nan(x)只对NaN值返回TRUE。2.6 字符向量 字符串在输入时可以使用单引号(‘)或双以号(“); 在打印时用双引号(有时不用引号)。R使用与C语言风格基本相同的转义符, 所以输入\打印的也是\, 输入” 打印引号”, n: 换行, t: tab, b: 回格。字符向量可以通过函数c()连接；paste()可以接受任意个参数，并从它们中逐个取出字符并连成字符串，形成的字符串的个数与参数中最长字符串的长度相同。如果参数中包含数字的话，数字将被强制转化为字符串。在默认情况下，参数中的各字符串是被一个空格分隔的，不过通过参数sep=string 用户可以把它更改为其他字符串，包括空字符串。例如： labs &lt;- paste(c(“X”,”Y”), 1:10, sep=””) 使变量labs成为字符变量c(“X1”, “Y2”, “X3”, “Y4”, “X5”, “Y6”, “X7”, “Y8”, “X9”, “Y10”)2.7 index vector—数据集子集的选择与修改 任何结果为一个向量的表达式都可以通过追加索引向量(index vector)来选择其中的子集。1 逻辑的向量。 y 0] -&gt; z 表示创建一个对象z，其中的元素由向量x+1中与x中的非缺失值和正数对应的向量组成。 正整数的向量x[6] 是x的第六个元素x[1:10] 选取了x的前10个元素(假设x的长度不小于10)。c(“x”,”y”)[rep(c(1,2,2,1), times=4)] 产生了一个字符向量，长度为16，由”x”, “y”, “y”, “x”重复4次而组成。 负整数的向量y &lt;- x[-(1:5)] 表示向量y取向量x前5个元素以外的元素。 字符串的向量只存在于拥有names属性并由它来区分向量中元素的向量。这种情况下一个由名称组成的子向量起到了和正整数的索引向量相同的效果。fruit &lt;- c(5, 10, 1, 20)names(fruit) &lt;- c(“orange”, “banana”, “apple”, “peach”)lunch &lt;- fruit[c(“apple”,”orange”)]子集的修改x[is.na(x)] &lt;- 0 表示将向量x中所以NA元素用0来代替y[y &lt; 0] &lt;- -y[y &lt; 0] 表示将向量(-y)中 与向量y的负元素对应位置的元素 赋值给 向量y中 与向量y负元素对应的元素。作用相当于：y &lt;- abs(y)三 对象，模式和属性3.1 固有属性：模式和长度对象是R所进行操作的实体，对象可以是向量、列表等，详见1.6.对象的模式包括numeri，ccomplex，character，logical，list，function，expression等。可以用mode(object)查看。对象的长度是对象的另一固有属性。可以用length(object)查看。attribute(object)可以查看更深入的属性。模式的转换在允许的情况下(大多数情况都是允许的)，R可以完成各种模式的转换。例如：d&lt;-as.character(z)，将数值向量z&lt;-(0:9)转化为字符向量c(“0”, “1”, “2”, …, “9”)。as.integer(d)将d转化为数值向量。R中很多形式为as.something()的函数，可以完成从一个模式向另一个模式的转化，或者是令对象取得它当前模式不具有的某些属性。3.2 改变对象的长度e &lt;- numeric() 产生一个numeric型的空向量e。character()等类似。此时长度为对象0。此时新添加一个元素会使e的长度自动调整。e[3] &lt;- 17 令e为一个长度为3的向量（此时，该向量的前两个元素都是NA）缩短（截断）一个对象的长度，只需要一个赋值命令。因此，若alpha是一个长度为10的对象，下面的命令alpha &lt;- alpha[2 * 1:5]3.3 属性的获取和设置 函数attributes(object)将给出当前对象所具有的所有非基本属性（长度和模式属于基本属性）的一个列表。函数attr(object,name)可以被用来选取一个指定的属性。除了为某些特殊的目的创建新属性这样特殊的环境下，这些函数很少被用到。当函数attr()用在赋值语句左侧时，既可以是将对象与一种新的属性关联，也可以是对原有属性的更改。例如 attr(z,”dim”) &lt;- c(10,10) 另R将z作为一个10X10的矩阵看待。3.4 对象的类别对象的一个特别属性，类别，被用来指定对象在R编程中的风格。比如：如果对象类别”data.frame”则会以特定方式处理。unclass()可以去除对象的类别。summary()可以查看对象的基本信息（min, max, mean, etc.）四 有序因子和无序因子 因子是一种向量对象，它给自己的组件指定了一个离散的分类（分组），它的组件由其他等长的向量组成。R提供了有序因子和无序因子。通俗点说，因子就是将对象的值分成不同的组（levels）。用函数factor()创建一个因子，levels按序排列(字母序或数值序)。例如province&lt;-c(“四川”,”湖南”,”江苏”,”四川”,”四川”,”四川”,”湖南”,”江苏”,”湖南”,”江苏”)，为province创建因子： pf&lt;-factor(province) 创建province的因子pfpf 打印出来 [1] 四川 湖南 江苏 四川 四川 四川 湖南 江苏 湖南 江苏Levels: 湖南 江苏 四川函数levels()可以用来观察因子中有多少不同的levels。假如我们拥有这些省份考生的分数：score&lt;-c(95,86,84,92,84,79,86,99,85,90)函数tappley()可以用来计算各省的平均分数，函数tapply()的作用是对它第一个参数的组件中所包含的每个组应用一个参数三指定的函数。smeans&lt;-tapply(score,pf,mean)smeans 湖南 江苏 四川85.66667 91.00000 87.50000再例如，下面命令会给出各组的lengthtapply(score,pf,length)湖南 江苏 四川 3 3 4 函数ordered()可以创建有序因子 ordered(province) [1] 四川 湖南 江苏 四川 四川 四川 湖南 江苏 湖南 江苏Levels: 湖南 &lt; 江苏 &lt; 四川 五 数组和矩阵5.1 数组数组可以看成一个由递增下标表示的数据项的集合，例如数值。数组的生成如果一个向量需要在R中以数组的方式被处理，则必须含有一个维数向量作为它的dim属性。维度向量由dim()指定，例如，z是一个由1500个元素组成的向量。下面的赋值语句 dim(z) &lt;- c(3,5,100) 使它具有dim属性，并且将被当作一个3X5X100的数组进行处理。 c(3,5,100) 就是他的维度向量。还可以用到像matrix()和array()这样的函数来赋值。比如array(1:20, dim=c(4,5))matrix(1:24, 3,4)数据向量中的值被赋给数组中的值时，将遵循与FORTRAN相同的原则”主列顺序”，即第一个下标变化的最快，最后的下标变化最慢。数组的运算数组可以在算数表达式中使用，结果也是一个数组，这个数组由数据向量逐个元素的运算后组成，通常参与运算的对象应当具有相同的dim属性。5.2 数组的索引和数组的子块 数组中的单个元素可以通过下标来指定，下标由逗号分隔，写在括号内。我们可以通过在下标的位置给出一个索引向量来指定一个数组的子块，不过如果在任何一个索引位置上给出空的索引向量，则相当于选取了这个下标的全部范围。如a[2,,]，a[,3,]等5.3 索引数组除了索引向量，还可以使用索引数组来指定数组的某些元素。例如：有4X5的数组a，若要得到a中的a[1,3], a[2,2] 和a[3,1]这三个元素，可以生成索引向量i，然后用a[i]得到它们。 a &lt;- array(1:20,dim=c(4,5)) # Generate a 4 by 5 array.i &lt;- array(c(1:3,3:1),dim=c(3,2))i[,1] [,2][1,] 1 3[2,] 2 2[3,] 3 1a[i][1] 9 6 3a[i] &lt;- 0 # 将这三个元素用0替换。5.4 向量，数组的混合运算表达式从左到右被扫描；参与运算的任意对象如果大小不足，都将被重复使用直到与其他参与运算的对象等长；当较短的向量和数组在运算中相遇时，所有的数组必须具有相同的dim属性，否则返回一个错误；如果有任意参与运算的向量比参与运算的矩阵或数组长，将会产生错误；如果数组结构正常声称，并且没有错误或者强制转换被应用于向量上，那么得到的结果与参与运算的数组具有相同的dim属性。5.5 矩阵的运算构建分区矩阵：cbind()和rbind()，cbind()按照水平方向，或者说按列的方式将矩阵连接到一起。rbind()按照垂直的方向，或者说按行的方式将矩阵连接到一起。 外积：操作符是%o%: ab &lt;- a %o% b 或者ab &lt;- outer(a, b, ““)其中的乘法操作可以由任意一个双变量的函数替代。广义转置：函数t(A)，或aperm(A, c(2,1))；获取行数/列数：nrow(A)和ncol(A)分别返回矩阵A的行数和列数。矩阵乘法：操作符为%%；交叉乘积（cross product）：crossprod(X，Y)等同于t(X) %*% y，crossprod(X)等价于crossprod(X, X)；diag(v)：如果v是向量，diag(v)返回一个由v的元素为对角元素的对角矩阵。 如果v为矩阵，diag(v)返回一个由v主对角元素组成的向量。 如果v只是一个数值，那么diag(v)是一个vXv的单位矩阵。 特征值和特征向量：eigen(Sm)。这个函数的结果是由名为values和vectors的两部分组成的列表。如果只是需要特征值：eigen(Sm)$values最小二乘拟合即QR分解：lsfit(), qr()。强制转换为向量：as.vector()，或者直接c().解线性方程和求矩阵的逆，奇异值分解与行列式见；六 列表和数据帧6.1 列表列表是由称作组件的有序对象集合构成的对象。组件的模式或类型不一定相同。形如Lst &lt;- list(name_1=object_1, . . ., name_m=object_m)的赋值将创建一个包含m个组件的列表，并根据参数中指定的名称为其命名。（其名称可以自由选取）。如果它们的名称被省略，组件将只是被编号。例如： Lst &lt;- list(name=”Fred”, wife=”Mary”, no.children=3,child.ages=c(4,7,9))所使用的组件是被复制到新的列表中的，对原始对象没有影响。组件总是被编号的，并且可以通过编号指定。Lst[[1]] 即为”Fred”，也可以用 Lst$name，Lst[[“name”]]指定。如果Lst[[4]]是一个有下标的数组，Lst[[4]][1]就是它的第一项。区分Lst[[1]]和Lst[1]，’[[…]]’是选择单个元素时使用的操作符，而’[…]’是一个一般的下标操作符。因此，前者代表列表Lst中的第一个对象；后者是列表Lst的子列表，仅包含列表的第一项。组件的名称可以缩写，可缩写的程度是只要能令组件被唯一的识别就可以了。如：Lst$na等价于Lst$name， Lst$w等价于Lst$wife。扩展列表可以通过指定额外组件的方式。例如Lst[5] &lt;- list(matrix=Mat)连接列表当连接函数c()的参数为列表时，其结果也是一个模式为列表的对象。由参数中的列表作为组件依次连接而成。list.ABC &lt;- c(list.A, list.B, list.C)6.2 数据帧 数据帧是类别为”data.frame”的列表；数据帧会被当作各列具有不同模式和属性的矩阵。数据帧按照矩阵的方式显示，选取的行或列也按照矩阵的方式来索引。创建数据帧直接创建：那些满足对数据帧的列（组件）限制的对象可以通过函数data.frame来构建成为一个数据帧 t &lt;- data.frame(home=statef, loot=income, shot=incomef)强制转换：如果一个列表的组件与数据帧的限制一致，这个列表就可以通过函数as.data.frame()强制转化为一个数据帧。外部文件：创建数据帧最简单的方法应当是使用read.table()函数从外部文件中读取整个数据帧。数据帧和列表的限制1 组件必须是向量（数值型，字符形，逻辑型），因子，数值矩阵，列表，或其他数据帧；2 矩阵，列表，数据帧向新数据帧提供的变量数分别等于它们的列数，元素数和变量数；3 数值向量，逻辑值和因子在数据帧中保持不变，字符向量将被强制转化为因子，其水平是字符向量中所出现的值；4 数据帧中作为变量的向量结构必须具有相同的长度，而矩阵结构应当具有相同的行大小。 挂接和卸载数据帧当觉得使用’$’引用数据帧元素(如’t$home’)麻烦时，可以进行数据帧挂接 attach(t) 这样可以直接引用数据帧内的元素，而无需’$’，前提是数据帧外没有同名的变量(如name)。挂接后若要对数据帧元素进行赋值操作，仍需用’$’，否则视为赋值给数据帧外的元素。赋值后必须要先卸载(detach)再重新挂接后，新值才可见。detach(t) attach()是具有一般性的函数，即它不仅能够将目录和数据帧挂接在搜索路径上，还能挂接其他类别的对象。特别是模式为”list”的对象可以通过相同的方式挂接： attach(any.old.list)任何被挂接的对象都可以用detach来卸载，通过指定位置编号或者指定名称这样的方式.搜索路径函数search()将显示目前的搜索路径，可以用来查看数据帧/列表的挂接状态。ls()（或objects()）命令可以用来检查搜索路径任意位置上的内容。如：ls(), ls(2), ls(t)R可以在搜索路径中包含至多20个项目,列表和数据帧只能在位置2或更靠后的位置上挂接。 数据帧使用惯例 1 将每个独立的，适当定义的问题所包含的所有变量收入同一个数据帧中，并赋予合适的、易理解、易辨识的名称；2 处理问题时，当相应的数据帧挂接于位置2，同时在第1层工作目录下存放操作的数值和临时变量；3 在结束一次工作之前，将你认为对将来有参考价值的变量通过$标记的形式添加到数据帧里面，然后detach()；4 最后，将工作目录下所有不需要的变量剔除，并且尽量将剩下多余的临时变量都清除干净。这样我们可以很简单的在同一个目录下处理多个问题，而且对每个问题都可以使用x,y,z这样的变量名。七 从文件中读取数据7.1 函数read.table()该函数可以直接将文件中完整的数据帧读入。此时文件要符合特定的格式：1 第一行应当提供数据帧中每个变量的名称；2 每一行(除变量名称行)应包含一个行标号和各变量的值。3 若没有表头(变量名称行)，也没有行标号，只有变量值，则默认变量名称为”v1”,”v2”…4 若有表头，但没有行标号，则可以指定参数header=TRUE.7.2 函数scan()该函数从键盘或文件中读取数据，并存入向量或列表中。 inp &lt;- scan(file, what)第一个参数是文件名,如“test.txt”，若为“”或空，则从键盘读入数据；第二个参数用于确定读入数据的模式。 如：list(“”,0,0) 指定读入到列表中，列表有三项，且列表第一项是字符型，第二三项是数值型。若为0，则指定读入到一个数值向量中，若为“”则指定读入到字符向量中。7.3 内置数据集的读取 R本身提供超过50个数据集，同时在功能包（包括标准功能包）中附带更多的数据集。与S-Plus不同，这些数据即必须通过data函数载入。 data() #获得基本系统提供的数据集列表，然后通过形如data(infert) #来载入名为infert的数据集从其他package中载入数据集data(package=”nls”) #查看nls中数据集data(Puromycin, package=”nls”) #读取nls中Puromycin数据集。用library()挂接package后，它的数据集也自动包含到搜索路径中了。library(nls) #载入package nlsdata() #查看数据集date(Puromycin) #载入Puromycin数据集 7.4 编辑数据在使用一个数据帧或矩阵时，edit提供一个独立的工作表式编辑环境。 xnew &lt;- edit(xold) #对数据集xold进行编辑。并在完成时将改动后的对象赋值给xnewxnew &lt;- edit(data.frame()) #可以通过工作表界面录入新数据。fix()函数用于直接修改已有的对象，等价于 x&lt;-edit(x).八 概率分布8.1 R是一个统计表集合(略读) R提供了一套完整的统计表集合。函数可以对累积分布函数P(X&lt;=x)，概率密度函数，分位函数（对给定的q，求满足P(X&lt;=x) &gt; q的最小x）求值，并根据分布进行模拟。 对于所给的名称，加前缀’d’代表密度(density)，’p’代表CDF，’q’代表分位函数，’r’代表模拟（随即散布）。这几类函数的第一个参数是有规律的，形为dxxx的函数为x，pxxx的函数为q，qxxx的函数为p，rxxx的函数为n（rhyper和rwilcox是特例，他们的第一个参数为nn）。目前为止，非中心参数(non-centrality parameter)仅对CDF和少数几个其他函数有效，细节请参考在线帮助。所有pxxx和qxxx的函数都具有逻辑参数lower.tail和log.p，而所有的dxxx函数都有参数log，这个是我们可以直接通过 pxxx(t, …, lower.tail = FALSE, log.p = TRUE)获取，比如说，累积失效函数（cumulative/integrated hazard function），H(t) =-log(1-F(t))，以及更精确的对数似然（通过dxxx(…, log = TRUE)）。此外，对于来自正态分布，具有学生化样本区间的分布还有ptukey和qtukey这样的函数。下面是一些例子 2-tailed p-value for t distribution2*pt(-2.43, df = 13) upper 1% point for an F(2, 7) distributionqf(0.99, 2, 7)8.2 检测数据集的分布 函数summary和fivenum这两个函数可以给出摘要，后者只给出数值；函数stem可以将数值统计结果以类似直方图的方式显示出来；函数hist()可以绘制直方图；函数density和line可以获得更漂亮的密度图；功能包fun中的ecdf函数能绘制经验累积分布函数；还可以进行拟合正态分布，覆盖拟合CDF；还可以绘制Quantile-quantile (Q-Q)图有助于我们更细致的检测其分布形态；8.3 单样本和两样本检验（略读）九 语句组、循环和条件操作 R是一种表达式语言，也就是说其命令类型只有函数或表达式，并由它们返回一个结果。语句组由花括号‘{ }’确定，此时结果是该组中最后一个能返回值的语句的结果。条件语句 if (expr_1) expr_2 else expr_3其中条件表达式expr1必须返回一个逻辑值，操作符&amp;&amp;和||经常被用于条件部分。&amp;和|与&amp;&amp;，||的区别在于，&amp;和|按照逐个元素的方式进行计算，&amp;&amp;和||对向量的第一个元素进行运算，只有在必需的时候才对第二个参数求值。if/else结构的向量版本是函数ifelse，其形式为ifelse (condition,a,b)，产生函数结果的规则是：如果condition[i]为真，对应a[i]元素；反之对应的是b[i]元素。根据这个原则函数返回一个由a,b中相应元素组成的向量，向量长度与其最长的参数等长。循环语句for (name in expr_1) expr_2其中name是循环变量，expr1是一个向量表达式（通常是1:20这样的序列），而expr2经常是一个表达式语句组，expr2随着name依次取expr1结果向量的值而被多次重复运行。repeat(expr)while(condition) expr break语句可以用来中断任何循环，可能是非正常的中断。而且这是中止repeat循环的唯一方式。next语句可以中止一个特定的循环，跳至下一个.十 编写自己的函数10.1 函数的定义 name &lt;- function(arg_1, arg_2, …) expressionexpression是一个R表达式（通常是表达式语句组），并使用参数arg_i来计算出一个数值，表达式的值就是函数的返回值。函数调用的形式通常都是name(expr1,expr2,…)10.2 定义新的二元操作符可以将函数定义为新的二元操作符：“%!%” &lt;- function(X, y) { … }正如矩阵乘法运算符，%*%，和矩阵外积运算符%o%10.3 指定参数和默认值 如果被调用函数的参数按照”name = obj”的形式给出，那么参数的次序可以是任意的。而且，参数序列可以在开始依次序给出，而将指定名称的参数置于后面。因此，如果由一个函数fun1被定义为 fun1 &lt;- function(data, data.frame, graph, limit) {[function body omitted]}那么函数可以有多种等价的使用方法，例如ans &lt;- fun1(d, df, TRUE, 20)ans &lt;- fun1(d, df, graph=TRUE, limit=20)ans &lt;- fun1(data=d, limit=20, graph=TRUE, data.frame=df)默认值 ：在很多情况下，参数都会被赋予一个普遍适用的默认值。fun1 &lt;- function(data, data.frame, graph=TRUE, limit=20) { … }则函数可以这样被调用ans &lt;- fun1(d, df)此时与上面三种情况等价，也可以这样调用ans &lt;- fun1(d, df, limit=10)此时改变了一个默认值。NOTE：参数可以是任意表达式，甚至可以是包含其他参数的表达式；10.4 额外参数“…” 当需要将一个函数的参数传递给另一个函数时，可以通过包含一个额外的参数”…”实现。fun1 &lt;- function(data, data.frame, graph=TRUE, limit=20, …) {[omitted statements]if (graph)par(pch=”*”, …)[more omissions]}10.5 全局变量和局部变量函数内的赋值都是局部变量，退出函数就丢失了。如果要在函数内进行永久赋值（定义全局变量），需要用到“超赋值”操作符, &lt;&lt;-或者函数assign()。10.6 一些高级示例区组设计的效率因子 (E±ciency factors)删除打印数组中的所有名称递归的数值积分10.7 范畴（Scope） 函数主体内出现的标识(symbol)可以被分为3类；正式参数、局部变量和自由变量。正式参数就是出现在函数参数列表中的参数，他们的值由实际的函数参数与正式参数的绑定（binding）过程决定。局部变量是在参数主体中，由表达式求值过程决定的变量。自由变量为既不是正式参数又不是局部变量的变量。赋值之后自由变量成为局部变量。 在R中，自由变量的值由函数被创建的环境中与其同名的第一个变量值决定（我理解为最近的同名变量），这种方式被称为词汇式范畴(lexical scope)。而在S中，该值由同名的全局变量决定。例如下面的函数cube，在R中cube（2）=8，在S中报错为sq()找不到n。cube &lt;- function(n) {sq &lt;- function() nnnsq()}一个银行账户的例子，详见《R语言笔记》。10.8 定制环境详见《R语言笔记》。10.9 类别，通用函数和对象定位 一个对象的类别(class)决定了他会如何被通用函数(generic function)处理。如果参数本身没有任何类别属性，或者其类别在特定问题中并不满足通用函数的要求，通常会有一个默认的动作被执行。类别机制使用户可以为特定的目的设计和编写通用函数。使用&gt; methods(class=”data.frame”)可以查看数据帧的通用函数。使用&gt; methods(plot)可以查看plot函数能处理的类别。十一 R的统计模型待阅。 十二 图形过程在Windows下用window()命令可以打开图形窗口。12.1 高级绘图命令 高级绘图函数，由函数参数提供数据生成一幅完整的图形。其中适当的坐标轴，标签和标题都自动生成了（除非你另外指定了）。高级绘图命令每次都生成一幅新的图形，清除当前的图形（如果需要的话）。 1 plot()函数 这是一个通用函数：生成图形的类型取决于第一个参数的类型或类别(class)。plot(x,y) plot(xy)：如果x，y是向量，plot(x,y)生成一幅y对x的散点图。用包含两个元素x，y的一个列表或一个两列的矩阵作为一个参数（第二种形式那样的）也能达成相同的效果。plot(x)：如果x是一个时间序列，这个命令生成一个时间序列图，如果x是一个数值型向量，则生成一个向量值对它们向量索引的土，而如果x是一个复向量，则生成一个向量中元素的虚部对实部的图。plot(f) plot(f,y)：f是一个因子对象，y是一个数值型向量。第一种形式生成一个f的条形图；第二种形式生成y对应于f各个水平的箱线图。plot(df) plot( expr) plot(y expr)：df是一个数据帧，y是任意对象，expr是由对象名称组成的列表，分隔符’+’(例如，a + b + c)。前两种形式生成分布式的图形，第一种是数据帧中的变量，第二种是一系列被命名的对象。第三种形式生成y对expr中每个对象的图。2 显示多元数据 如果X是一个数值矩阵或数据帧，下面的命令 pairs(X)生成一个配对的散点图矩阵，矩阵由X中的每列的列变量对其他各列列变量的散点图组成，得到的矩阵中每个散点图行、列长度都是固定的。 当问题涉及到三、四个变量时，使用coplot更好些。如果a和b是数值向量，c是数值向量或因子对象（全都是相同长度的），下面的命令 coplot(a ~ b | c)对应c的某些给定值生成数个a对b的散点图。当c是一个因子时，这个命令也就是对c的每个水平生成a对b的散点图。当c是数值向量的时候，这个数值向量被分为一系列的条件区间（conditioning intervals），对应c的每个区间生成一个a对b的散点图。区间的数量和位置可以通过coplot()的参数given.values来控制，函数co.intervals()也可以用来选择区间。我们也可以使用两个给定变量通过命令coplot(a ~ b | c+d)对c和d的每个联合条件区间生成a对b的散点图。 函数coplot()和pairs()都可以使用参数panel=，这个参数可以用来定制我们得到的图形类型。默认的是points()函数，生成一个散点图，不过通过在参数panel=中提供某些其它的低级图形函数，我们可以生成需要的各种图形。一个很有用的函数例子是panel.smooth()。3 显示图形 qqnorm(x) qqline(x) qqplot(x,y)分布比较图。第一种形式生成向量x对期望正态分数（一个正态记分图），第二个在上面的图上添加一条穿过分布分位点和数据分位点的直线。第三个命令生成x的分位点对y分位点图，用于分别比较它们的分布。hist(x) hist(x,nclass=n) hist(x,breaks=b, . . . )生成数值变量x的直方图。通常会自动选定一个合理的类别数，不过可以通过nclass=参数来指定一个推荐值。或者通过参数breaks=来指定分界点。如果给定了probability=TRUE参数，那么条形图代表相对频数而不是累计数。dotchart(x, . . . )创建一个x中数据的点图(dotchart)。点图中y轴给出x中数据的标签，x轴给出它们的值。它允许对落入某一特定区间的所有数据项方便的进行可视化选择。image(x,y,z, . . . ) contour(x,y,z, . . . ) persp(x,y,z, . . . )生成三个变量的图。函数image是用不同的颜色绘制一些矩形方格来展示z的值，函数contour通过绘制等高线来展示z的值，函数persp绘制一个3D面。4 参数配置 add=TRUE 强制函数按照低级图形函数的方式操作，将图形置于当前图形上（仅对某些函数有效）。axes=FALSE 暂时禁止坐标轴的生成|以便使用axis()函数添加你自己定制的坐标轴。默认情况是axes=TRUE，即包含坐标轴。log=”x” log=”y” log=”xy” 令x,y或者两者全都对数化。这个参数对许多函数都有效，不过不是全部。type= 参数type=控制所生成图形的类型： type=”p” 绘制单独的点（默认值） type=”l” 绘制线 type=”b” 绘制由线连接的点（both） type=”o” 将点绘在线上 type=”h” 绘制从点到零轴的垂线（high-density） type=”s” 阶梯式图。第一种形式中，点由垂线的顶部定义；第二种形式里用底部定义。 type=”n” 不绘制。不过坐标轴是绘出的（默认情况）而且要根据数据绘出坐标系统。用来给后续的低级图形函数创建图形作基础。xlab=string ylab=string x轴或y轴的标签。使用这些参数来改变默认的标签，通常的默认值是调用高级绘图函数时所使用对象的名称。main=string 图表标题，位于图形的顶部，大字体显示。sub=string 子标题，位于x轴下面，用较小的字体显示。12.2 低级绘图命令 有些时候高级绘图函数并不能很精确的生成我们想要的图形。这种情况下，我们可以通过低级绘图命令在当前图形上添加信息（例如，点、线或文本）。points(x,y) lines(x,y)在当前图形上添加点或线。函数plot()的参数type=也可以用于这些函数（默认的是”p”代表points()和”l”代表lines()）。text(x,y,labels, . . . )给定点坐标x,y，在该点添加文本。通常labels是一个整数或字符向量，其中labels[i]出现在点(x[i],y[i])。默认值是1:length(x)。Note： 这个函数通常用于这样的序列中 plot(x, y, type=”n”); text(x, y, names)图形参数type=”n”阻止了点的生成，但是建立了坐标轴，由函数text()提供字符向量names所指定的特定字符。 abline(a, b) abline(h=y) abline(v=x) abline(lm.obj)在当前图上添加一条斜率为b，截距为a的直线。h=y在图形指定的高度上绘制一条贯穿图形的水平线，同样的，v=x在x轴的指定位置绘制一条贯穿的垂线。而lm.obj是一个包含coefficients组件的列表，该组件的长度为2，分别当作截距和斜率。polygon(x, y, . . . )绘制一个多边形，其顶点由(x,y)指定。同时还（可选的）可以加上阴影线，如果图形设备允许的话还可以将多边形填充。legend(x, y, legend, . . . )这当前图形的指定位置添加图例。绘制的字符，线条类型，颜色等等由字符向量legend指定。除此之外至少还要给出一个参数v，与绘图单元的相应值，分别有：legend( , fill=v)填充方框的颜色legend( , col=v)绘制点线的颜色legend( , lty=v)线条类型legend( , lwd=v)线条宽度legend( , pch=v)绘制字符(字符向量) title(main,sub)在当前图形的顶部用大字题添加一个标题main，在底部用较小的字体添加子标题sub。axis(side, . . . )在当前图形的指定边上添加坐标，在哪个边上由第一个参数指定（1到4，从底部按照顺时针顺序）。其他参数控制坐标的位置|在图形内或图形外，以及标记的位置和标签。适合在调用参数为axes=FALSE的函数plot()后添加定制的坐标轴。低级绘图函数通常都需要一些位置信息（例如，x,y坐标）来决定在哪里添加新的元素。坐标以用户坐标(user coordinates)的形式给出，这个坐标系是根据所提供的数据由之前的高级绘图语句定义的。需要x,y参数的地方还可以选用一个单独的参数，即一个由名为x,y的元素组成的列表。相似的，一个两列的矩阵也可以。像locator()（后面会提到）这样的函数也可以按照这种方式交互的指定图形中的位置。添加数学注释某些情况下需要在图形中加入数学符号或公式。在R中可以通过在text, mtext,axis或title中指定一个表达式来实现。例如，下面的代码绘制了二项概率函数的公式： text(x, y, expression_r(paste(bgroup(“(“, atop(n, x), “)”),p^x, q^{n-x})))更多的信息，包括其特性的一个完整列表可以在R中通过下面的命令得到：help(plotmath)example(plotmath)添加Hershey矢量字体help(Hershey)example(Hershey)12.3 图形的交互R提供了函数，使用户可以通过鼠标从图形中释放信息或添加信息。 locator(n,type)等待用户使用鼠标左键在当前图形上选择位置。直到n(默认是512)个点都选完或者点击了鼠标另一个键（Unix,Windows)，在Mac下用鼠标点击图形窗口外的部分也可以结束。参数type的效果和在高级绘图函数中使用时是一样的，即在选择的点绘制指定的图形。默认情况是不绘制图形。函数locator()将所选点的坐标返回到一个列表中，列表包含x,y两个组件。通常locator()在调用的时候并不带参数。这个功能在为图例或标签这样的图形元素选择位置时比较有用，尤其是这些位置不好通过计算得到的时候。举个例子，如果要在一个野点附近添加一些信息，可以使用下面的命令 text(locator(1), “Outlier”, adj=0) identify(x, y, labels)允许用户在x,y（使用鼠标左键）定义的点附近绘制相应的labels的组件（如果没有给出labels就给出该点的序号），突显该点。当鼠标的另一个键被点击时（Unix,Windows）返回被选点的序号，在Mac下通过点击图形窗口外来实现这个效果。有时我们更想确定图形中的点，而非它们的位置。例如，我们可能希望从图示中选出某些感兴趣的观测点，然后进行某些操作。通过两个数值向量x,y给定一系列坐标(x; y)，我们可以使用identify()函数： plot(x,y) &gt; identify(x,y)函数identify()本身不绘图，但是允许用户移动鼠标，在某点附近点击左键。离鼠标指针最近的点将被突显，并标出其序号（也就是它在向量x/y中的位置）。或者使用identify()的labels参数，把某些信息（例如案例名称）作为突显的标志；或者通过plot=FALSE参数取消所有突显标志。当选点的过程结束后，identify()返回所选点的序号；用户可以使用这些序号从x和y中释放所选的点。12.4 使用图形参数 通过图形参数可以定制图形显示的几乎所有方面。R包含大量的图形参数，可以控制的包括线条类型，颜色，图标排列，文本对齐等等。1 持续性变更 (Permanent changes): par()函数 通过par()函数设定图形参数的值会持续性的更改参数的值，也就是说这之后（在当前设备上）所有对图形函数的调用都受到新值的影响。函数par()用于存取和修改当前图形设备的图形参数列表。par()不带任何参数，返回当前设备所有图形参数和它们的值的列表。par(c(“col”,”lty”))参数为一个字符向量，仅返回参数中指定的图形参数（也是作为一个列表）。par(col=4, lty=2)带指定参数（或一个列表型参数），设定指定图形参数的值，并将参数的原始值作为一个列表返回。所以如果想设定参数绘制一些图形后再恢复成原来的设定，可以这么做： oldpar &lt;- par(col=4, lty=2). . . plotting commands . . .par(oldpar)2 临时性变更：图形函数的参数 图形参数也可以作为（几乎）所有图形函数的命名参数。这种方式的效果和用于par()函数的效果是一样的，只不过这种改变只在函数调用的区间内有效。比如： plot(x, y, pch=”+”)生成一个以加号作为绘图符号的散点图，而不改变后续图形的默认的绘图符号。3 图形参数列表A 图形元素R图表由点、线、文本和多边形（填充区）组成。下面的图形参数控制了图形元素的绘制：pch=”+” 用来绘点的字符。这个默认值随不同的图形驱动是不同的，不过通常都是’±’。除非使用”.”作为绘图字符，否则绘制的点都会比适当的位置高一点或者低一点，而不是恰好在指定位置。pch=4当给定一个0到18的整数时，会生成一个特殊的绘图符号。通过下面的命令可以看这些符号都有什么。legend(locator(1), as.character(0:18), pch=0:18)lty=2 线条类型。并不是所有图形设备都支持多种线条类型（在那些支持的设备上也不全一样），不过线条类型1始终是实线，2及以上的是点、划线或者它们的组合。lwd=2 线条宽度。所需的线条宽度，是”标准”线条宽度的倍数。对line()等函数绘制的线条和坐标轴都有效果。col=2 点、线、文本、填充区和图像使用的颜色。每种图形元素都有其可用的颜色列表，这个参数的值就是颜色在列表中的序号。显然，这个参数值对有限的一类设备有效。font=2 指定文本所使用字体的一个整数。如果可能的话，设备驱动会把1对应普通文本，2对应粗体，3对应斜体，4对应粗斜体。font.axis font.lab font.main font.sub 这几个参数分别指定坐标轴注释，x,y轴的标签，主、副标题所用的字体。adj=-0.1 文本对齐和绘图位置有关。0代表左对齐，1代表右对齐，0.5代表水平的中间位置。当前的值使会图位置到左端距离的比例，所以-0.1在文本和绘图位置之间留10%的空白。cex=1.5 字符缩放。这个值是所需文本字符（包括绘图字符）的大小，与默认文本大小相关。B 坐标轴和标记很多R的高级图形都有坐标轴，你可以使用低级图形函数axis()自己创建坐标轴。坐标轴包含三个主要组件：轴线axis line（线条类型由参数lty控制），标记tick mark（沿着轴线划分单元），标号tick label（用来标出这些单元）。这些组件可以用下面这些参数定制。lab=c(5,7,12)前两个数字分别是x和y轴上所要划分的区间数。第三个数字是坐标轴标签的长度，用字符数来衡量（包括小数点）。参数的值如果选得太小可能导致所有标号都聚在一起。las=1 坐标轴标签的方向。0代表总是和坐标轴平行，1代表总是水平的，2代表总是垂直于坐标轴。mgp=c(3,1,0)坐标轴组件的位置。第一个组件是坐标轴标签到坐标轴的距离，单位是文本行(text lines)。第二个组件是到标号的距离，最后一个是轴的巍直到轴线的距离（一般都是0）。正数代表绘图区域外，负数代表区域内。tck=0.01 标号的长度，绘图区域大小的一个分数作单位。当tck比较小时（小于0.5），就强制x和y轴上的标记为相同大小。tck=1就是生成网格线。取负值时标记画向绘图区域外。内部标记可以使用tck=0.01和mgp=c(1,-1.5,0)。xaxs=”s” yaxs=”d” 分别是x、y轴的类型。如果是s(standard)或e(extended)类型，那最大和最小的标记都始终在数据区域之外。如果有某个点离边界非常近，那么扩展型(extended)的轴会稍稍扩展一下。这种类型的轴有时会在边界附近留出大片空白。而i(internal)或r(默认值)类型的轴，标记始终在数据区域内，不过r类型会在边界留出少量空白。如果这个参数设为d，就锁定当前轴，对之后绘制的所有图形都用这个轴（直到参数被重新设定为其他的那几个值）。这个参数适用于生成一系列固定尺度的图。C 图边缘（Figure margins）在R中一个单独图形，图（figure），包含一个绘图区(plot region)，以及环绕着这个区域的边缘（其中可能含有坐标轴标签、标题等等），（通常）这两部分以轴为边界。一个典型的图是 控制图的样式的图形参数包括：mai=c(1,0.5,0.5,0)分别是底部，左侧，顶部，右侧的宽度，单位是英寸。mar=c(4,2,2,1)与mai相似，只是单位是文本行(text lines)。由于更改一个就会改变另一个的值，所以在这个意义上，mai和mar是等价的。这个参数的默认值通常都太大了；右侧边缘很少用到，如果没标题，顶部边缘也不需要，左侧和底部的边缘应当足够大，以容纳坐标轴和标号。此外，默认值并没有考虑到设备表面的大小：比如，使用postscript()驱动，height=4参数时，除非用mar，mai另外设定，否则图的边缘就要占上大约50%。使用多图环境时（后面会提到）。边缘会减少一半，不过这在多图共用一页的时候可能还不够。D 多图环境R允许在一页上创建一个n£m的图的阵列。每个图由自己的边缘，图的阵列还有一个可选的外部边缘，如下图所示。 与多图环境相关的图形参数有：mfcol=c(3, 2) mfrow=c(2, 4) 设定多图阵列的大小。第一个值是行数，第二个值是列数。这两个参数唯一的区别是mfcol把图按列排入，mfrow把图按行排入。上图所示的版式可用mfrow=c(3,2)创建；上图显示的是绘制四幅图后的情况。mfg=c(2, 2, 3, 2) 当前图在多图环境下的位置。前两个数字是当前图的行、列数；后两个是其在多图阵列中的行列数。这个参数用来在多图阵列中跳转。你甚至可以在后两个数中使用和真值(true value)不同的值，在同一页上得到大小不同的图。fig=c(4, 9, 1, 4)/10 当前图在页面的位置，取值分别是左下角到左边界，右边界，下、上边界的距离与对应边的百分比数。给出的例子是一个页面右下角的图。这个参数可以设定图在页面的绝对位置。oma=c(2, 0, 3, 0) omi=(0, 0, 0.8, 0) 外部边缘的大小。与mar和mai相似，第一个用文本行作单位，第二个以英寸作单位，从下方开始按照顺时针顺序指定。外部边缘对页标题这类东西很有用。文本可以通过带outer=TRUE参数的mtext()函数加入外部边缘。默认情况下是没有外部边缘的因此必须通过oma或omi指定。函数split.screen()和layout()可以对多个图形作更复杂的排列。12.6 设备驱动 R几乎可以在任何一种类型的显示器和打印设备上生成（不同质量的）图形。不过，在这之前，需要告诉R要处理的是哪一种设备。这通过启动一个设备驱动来完成。设备驱动通过调用设备驱动函数来启动。某些常用的设备驱动有：X11()[Unix] 使用X11视窗系统windows()[Windows] 使用 Windows 视窗系统postscript()在PostScript打印机上打印或者创建PostScript图形文件pictex()生成一个LATEX文件当一个设备使用完之后，可以通过下面的命令终止设备驱动 dev.off()这个命令可以确保设备已经结束；例如，在某些硬拷贝的设备中，这个命令可以保证每页都已经完成，并且都被传送到打印机了。PostScript文档通过给postscript()函数带上file参数，我们可以把图形以PostScript格式存储到文件中。如果没有给出horizontal=FALSE参数，图形是横向的，你可以通过width和height参数控制图形的大小（图形会自动适应）。例如，命令postscript(“file.ps”, horizontal=FALSE, height=5, pointsize=10)为一个五英寸的图生成一个包含PostScript代码的文件，可以放在文当中。如果命令中的指定的文件名已经存在，将会被覆盖。多重图形设备每个对设备驱动的新调用都会打开一个新的图形设备，在设备列表中加入新的一项。这个设备就成为当前设备，图形输出就传送到这个设备。dev.list() 返回所有活动中设备的序号和名称。在列表位置1的设备始终是空设备(null device)，这个设备不接收任何图形命令。dev.next() dev.prev() 分别返回当前设备的后一个和前一个设备的序号和名称。dev.set(which=k) 用来把当前设备更改为设备列表中位置k的那个。返回设备的序号和标签。dev.off(k) 终止图形列表位置k的那个图形设备。对于某些设备，比如postscript，这个命令会立刻打印文件或者正常结束文件，具体怎样处理取决于设备是怎样初始化的。dev.copy(device,. . . ,which=k) dev.print(device,. . . ,which=k)建立一个设备k的拷贝。其中device是一个设备函数，例如postscript，如果需要的话可以在’. . . ‘中指定其它的参数，dev.print效果相似，不过复制的设备会立刻关闭，所以打印硬拷贝这样的终止操作也会被立即执行。graphics.off() 终止列表中的所有图形设备，空设备除外。 (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/20/R笔记(1)/]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>初级</tag>
        <tag>可视化</tag>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[J微信时代，博客阅读]]></title>
    <url>%2F2017%2F09%2F20%2F%E5%BE%AE%E4%BF%A1%E6%97%B6%E4%BB%A3%EF%BC%8C%E5%8D%9A%E5%AE%A2%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[博客沒有消失，只是变成了知乎，微博了而已先来看一下博客的定义：博客，英文名为Blogger,为WebLog的混成词。它的正式名称为网络日记，是一种通常由个人管理、不定期张贴新的文章的网站。许多博客专注在特定的课题上提供评论或新闻，其他则被作为个人的日记。比较著名的有新浪、网易等博客。 随着互联网的发展，曾经的博客渐渐的变得无人问津。 博客是否会退出历史舞台？或者博客未来可能会变什么样? 很多人批评「碎片化阅读」，我却觉得碎片化阅读是社会的一个救星。微信的一个巨大功劳，是将阅读重新送回日常生活，提供了碎片化阅读的最好机会。因为人们此前根本连碎片化的阅读都逐渐失去了。我看到朋友圈所有人都在转各种文章，我的一些从不阅读的亲友，如今开始阅读一些短小的内容。这些阅读都是微信重新送回来的。 我们反对的是碎片化阅读，不是利用碎片化时间来阅读。利用零散时间阅读，这是一个可以充分利用时间的表现。我们反对的碎片化阅读指的是浮浅和无视语境的阅读。这和长短无关，和读者有没有整体性的视角有关。 而博客给了我们记录自己的生活，学习，常常都是很用心写出来的文章。是看了某部电影的感受，学习了某个小技术的总结或应用，是生活的记录，长长的文字，是我们的经历。 但我们过十年二十年以后，看看自己的博客（希望还在），毕竟是自己的故事，当时的所见所感，不论发自肺腑，大体是暗合心境的，我们的记录翻开的时候就是现在的我与过去的我的相遇，相视一笑。 随着微博，语音记录等新事物的出现，博客面临着巨大的挑战。据研究报告显示，现今博客用户数量大幅减少，但趋于平稳。也就是说有一批博客的忠实用户存在着。年轻人从16到20出头的年轻人几乎不使用博客。其主要用户是那些30岁左右至40岁左右的人。博客是否会消失主要取决于它自身如何演化。如果把知乎这样的算作博客的话，那这个演化其实已经开始了。博客不会消失，只是不知道变了身的博客对你来说是不是还叫博客而已。 所以博客沒有消失，只是变成了知乎，微博了而已。 (function(){ var appid = 'cysmzRdbl'; var conf = 'prod_7c789e58c2fd9306e64aff79a862b4df'; var width = window.innerWidth || document.documentElement.clientWidth; if (width < 960) { window.document.write(''); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/20/微信时代，博客阅读/]]></content>
      <categories>
        <category>感想</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>感想</tag>
        <tag>写作</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[REST]]></title>
    <url>%2F2017%2F09%2F20%2FREST%2F</url>
    <content type="text"><![CDATA[REST是一种设计API的模式什么是Web API呢？ 如果我们想要获取某个电商网站的某个商品，输入http://localhost:3000/products/123，就可以看到id为123的商品页面，但这个结果是HTML页面，它同时混合包含了Product的数据和Product的展示两个部分。对于用户来说，阅读起来没有问题，但是，如果机器读取，就很难从HTML中解析出Product的数据。 如果一个URL返回的不是HTML，而是机器能直接解析的数据，这个URL就可以看成是一个Web API。比如，读取http://localhost:3000/api/products/123，如果能直接返回Product的数据，那么机器就可以直接读取。 REST就是一种设计API的模式。最常用的数据格式是JSON。由于JSON能直接被JavaScript读取，所以，以JSON格式编写的REST风格的API具有简单、易读、易用的特点。 编写API有什么好处呢？由于API就是把Web App的功能全部封装了，所以，通过API操作数据，可以极大地把前端和后端的代码隔离，使得后端代码易于测试，前端代码编写更简单。 此外，如果我们把前端页面看作是一种用于展示的客户端，那么API就是为客户端提供数据、操作数据的接口。这种设计可以获得极高的扩展性。例如，当用户需要在手机上购买商品时，只需要开发针对iOS和Android的两个客户端，通过客户端访问API，就可以完成通过浏览器页面提供的功能，而后端代码基本无需改动。 当一个Web应用以API的形式对外提供功能时，整个应用的结构就扩展为： 把网页视为一种客户端，是REST架构可扩展的一个关键。 (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/20/REST/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Websocket协议入门]]></title>
    <url>%2F2017%2F06%2F29%2FWebsocket%2F</url>
    <content type="text"><![CDATA[WebSocket WebSocket是HTML5新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。 WebSocket协议WebSocket并不是全新的协议，而是利用了HTTP协议来建立连接。我们来看看WebSocket连接是如何创建的。 首先，WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求，格式如下：1234567GET ws://localhost:3000/ws/chat HTTP/1.1Host: localhostUpgrade: websocketConnection: UpgradeOrigin: http://localhost:3000Sec-WebSocket-Key: client-random-stringSec-WebSocket-Version: 13 该请求和普通的HTTP请求有几点不同： GET请求的地址不是类似/path/，而是以ws://开头的地址；请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接；Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据；Sec-WebSocket-Version指定了WebSocket的协议版本。 随后，服务器如果接受该请求，就会返回如下响应：1234HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: server-random-string 该响应代码101表示本次连接的HTTP协议即将被更改，更改后的协议就是Upgrade: websocket指定的WebSocket协议。 版本号和子协议规定了双方能理解的数据格式，以及是否支持压缩等等。如果仅使用WebSocket的API，就不需要关心这些。 为什么WebSocket连接可以实现全双工通信而HTTP连接不行呢？实际上HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但是HTTP协议的请求－应答机制限制了全双工通信。 安全的WebSocket连接机制和HTTPS类似。首先，浏览器用wss://xxx创建WebSocket连接时，会先通过HTTPS创建安全的连接，然后，该HTTPS连接升级为WebSocket连接，底层通信走的仍然是安全的SSL/TLS协议。 浏览器很显然，要支持WebSocket通信，浏览器得支持这个协议，这样才能发出ws://xxx的请求。目前，支持WebSocket的主流浏览器如下： Chrome Firefox IE &gt;= 10 Sarafi &gt;= 6 Android &gt;= 4.4 iOS &gt;= 8 服务器由于WebSocket是一个协议，服务器具体怎么实现，取决于所用编程语言和框架本身。Node.js本身支持的协议包括TCP协议和HTTP协议，要支持WebSocket协议，需要对Node.js提供的HTTPServer做额外的开发。已经有若干基于Node.js的稳定可靠的WebSocket实现，我们直接用npm安装使用即可。 使用wsws模块在Node.js中，使用最广泛的WebSocket模块是ws，我们创建一个hello-ws的文件夹，然后在package.json(自己创建）中添加ws的依赖：123&quot;dependencies&quot;: &#123; &quot;ws&quot;: &quot;1.1.1&quot;&#125; package.json文件完整内容：12345678910111213141516171819202122&#123; &quot;name&quot;: &quot;hello-ws&quot;, &quot;version&quot;: &quot;3.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;app.js&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node app.js&quot; &#125;, &quot;keywords&quot;: [ &quot;koa&quot;, &quot;async&quot; ], &quot;author&quot;: &quot;Michael Liao&quot;, &quot;license&quot;: &quot;Apache-2.0&quot;, &quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://github.com/michaelliao/learn-javascript.git&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;ws&quot;: &quot;1.1.1&quot; &#125;&#125; 整个工程结构如下： 1234567hello-ws/|+- app.js &lt;-- 启动js文件|+- package.json &lt;-- 项目描述文件|+- node_modules/ &lt;-- npm安装的所有依赖包 运行npm install后，我们就可以在app.js中编写WebSocket的服务器端代码。 创建一个WebSocket的服务器实例非常容易：123456789101112131415161718192021// 导入WebSocket模块:const WebSocket = require(&apos;ws&apos;);// 引用Server类:const WebSocketServer = WebSocket.Server;// 实例化:const wss = new WebSocketServer(&#123; port: 3000&#125;);wss.on(&apos;connection&apos;, function (ws) &#123; console.log(`[SERVER] connection()`); ws.on(&apos;message&apos;, function (message) &#123; console.log(`[SERVER] Received: $&#123;message&#125;`); ws.send(`ECHO: $&#123;message&#125;`, (err) =&gt; &#123; if (err) &#123; console.log(`[SERVER] error: $&#123;err&#125;`); &#125; &#125;); &#125;)&#125;); 如果有WebSocket请求接入，wss对象可以响应connection事件来处理这个WebSocket. 在connection事件中，回调函数会传入一个WebSocket的实例，表示这个WebSocket连接。对于每个WebSocket连接，我们都要对它绑定某些事件方法来处理不同的事件。这里，我们通过响应message事件，在收到消息后再返回一个ECHO: xxx的消息给客户端。 创建WebSocket连接现在，这个简单的服务器端WebSocket程序就编写好了。如何真正创建WebSocket并且给服务器发消息呢？方法是在浏览器中写JavaScript代码。 在命令行用npm start或node app.js执行。然后，打开可以执行JavaScript代码的浏览器Console，依次输入代码：1234567// 打开一个WebSocket:var ws = new WebSocket(&apos;ws://localhost:3000/test&apos;);// 响应onmessage事件:ws.onmessage = function(msg) &#123; console.log(msg); &#125;;// 给服务器发送一个字符串:ws.send(&apos;Hello!&apos;); 一切正常的话，可以看到Console的输出如下：1MessageEvent &#123;isTrusted: true, data: &quot;ECHO: Hello!&quot;, origin: &quot;ws://localhost:3000&quot;, lastEventId: &quot;&quot;, source: null…&#125; 这样，我们就在浏览器中成功地收到了服务器发送的消息！ 如果嫌在浏览器中输入JavaScript代码比较麻烦，我们还可以直接用ws模块提供的WebSocket来充当客户端。换句话说，ws模块既包含了服务器端，又包含了客户端。 ws的WebSocket就表示客户端，它其实就是WebSocketServer响应connection事件时回调函数传入的变量ws的类型。 客户端的写法如下：123456789101112let ws = new WebSocket(&apos;ws://localhost:3000/test&apos;);// 打开WebSocket连接后立刻发送一条消息:ws.on(&apos;open&apos;, function () &#123; console.log(`[CLIENT] open()`); ws.send(&apos;Hello!&apos;);&#125;);// 响应收到的消息:ws.on(&apos;message&apos;, function (message) &#123; console.log(`[CLIENT] Received: $&#123;message&#125;`);&#125; 在Node环境下，ws模块的客户端可以用于测试服务器端代码，否则，每次都必须在浏览器执行JavaScript代码。 同源策略从上面的测试可以看出，WebSocket协议本身不要求同源策略（Same-origin Policy），也就是某个地址为http://a.com的网页可以通过WebSocket连接到ws://b.com。但是，浏览器会发送Origin的HTTP头给服务器，服务器可以根据Origin拒绝这个WebSocket请求。所以，是否要求同源要看服务器端如何检查。 路由还需要注意到服务器在响应connection事件时并未检查请求的路径，因此，在客户端打开ws://localhost:3000/any/path可以写任意的路径。 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/29/Websocket/]]></content>
      <categories>
        <category>Node</category>
        <category>WebSocket</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>http</tag>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Websocket协议入门]]></title>
    <url>%2F2017%2F06%2F29%2FWebsocket(1)%2F</url>
    <content type="text"><![CDATA[WebSocket WebSocket是HTML5新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。 WebSocket协议WebSocket并不是全新的协议，而是利用了HTTP协议来建立连接。我们来看看WebSocket连接是如何创建的。 首先，WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求，格式如下：1234567GET ws://localhost:3000/ws/chat HTTP/1.1Host: localhostUpgrade: websocketConnection: UpgradeOrigin: http://localhost:3000Sec-WebSocket-Key: client-random-stringSec-WebSocket-Version: 13 该请求和普通的HTTP请求有几点不同： GET请求的地址不是类似/path/，而是以ws://开头的地址；请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接；Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据；Sec-WebSocket-Version指定了WebSocket的协议版本。 随后，服务器如果接受该请求，就会返回如下响应：1234HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: server-random-string 该响应代码101表示本次连接的HTTP协议即将被更改，更改后的协议就是Upgrade: websocket指定的WebSocket协议。 版本号和子协议规定了双方能理解的数据格式，以及是否支持压缩等等。如果仅使用WebSocket的API，就不需要关心这些。 为什么WebSocket连接可以实现全双工通信而HTTP连接不行呢？实际上HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但是HTTP协议的请求－应答机制限制了全双工通信。 安全的WebSocket连接机制和HTTPS类似。首先，浏览器用wss://xxx创建WebSocket连接时，会先通过HTTPS创建安全的连接，然后，该HTTPS连接升级为WebSocket连接，底层通信走的仍然是安全的SSL/TLS协议。 浏览器很显然，要支持WebSocket通信，浏览器得支持这个协议，这样才能发出ws://xxx的请求。目前，支持WebSocket的主流浏览器如下： Chrome Firefox IE &gt;= 10 Sarafi &gt;= 6 Android &gt;= 4.4 iOS &gt;= 8 服务器由于WebSocket是一个协议，服务器具体怎么实现，取决于所用编程语言和框架本身。Node.js本身支持的协议包括TCP协议和HTTP协议，要支持WebSocket协议，需要对Node.js提供的HTTPServer做额外的开发。已经有若干基于Node.js的稳定可靠的WebSocket实现，我们直接用npm安装使用即可。 使用wsws模块在Node.js中，使用最广泛的WebSocket模块是ws，我们创建一个hello-ws的文件夹，然后在package.json(自己创建）中添加ws的依赖：123&quot;dependencies&quot;: &#123; &quot;ws&quot;: &quot;1.1.1&quot;&#125; package.json文件完整内容：12345678910111213141516171819202122&#123; &quot;name&quot;: &quot;hello-ws&quot;, &quot;version&quot;: &quot;3.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;app.js&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node app.js&quot; &#125;, &quot;keywords&quot;: [ &quot;koa&quot;, &quot;async&quot; ], &quot;author&quot;: &quot;Michael Liao&quot;, &quot;license&quot;: &quot;Apache-2.0&quot;, &quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://github.com/michaelliao/learn-javascript.git&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;ws&quot;: &quot;1.1.1&quot; &#125;&#125; 整个工程结构如下： 1234567hello-ws/|+- app.js &lt;-- 启动js文件|+- package.json &lt;-- 项目描述文件|+- node_modules/ &lt;-- npm安装的所有依赖包 运行npm install后，我们就可以在app.js中编写WebSocket的服务器端代码。 创建一个WebSocket的服务器实例非常容易：123456789101112131415161718192021// 导入WebSocket模块:const WebSocket = require(&apos;ws&apos;);// 引用Server类:const WebSocketServer = WebSocket.Server;// 实例化:const wss = new WebSocketServer(&#123; port: 3000&#125;);wss.on(&apos;connection&apos;, function (ws) &#123; console.log(`[SERVER] connection()`); ws.on(&apos;message&apos;, function (message) &#123; console.log(`[SERVER] Received: $&#123;message&#125;`); ws.send(`ECHO: $&#123;message&#125;`, (err) =&gt; &#123; if (err) &#123; console.log(`[SERVER] error: $&#123;err&#125;`); &#125; &#125;); &#125;)&#125;); 如果有WebSocket请求接入，wss对象可以响应connection事件来处理这个WebSocket. 在connection事件中，回调函数会传入一个WebSocket的实例，表示这个WebSocket连接。对于每个WebSocket连接，我们都要对它绑定某些事件方法来处理不同的事件。这里，我们通过响应message事件，在收到消息后再返回一个ECHO: xxx的消息给客户端。 创建WebSocket连接现在，这个简单的服务器端WebSocket程序就编写好了。如何真正创建WebSocket并且给服务器发消息呢？方法是在浏览器中写JavaScript代码。 在命令行用npm start或node app.js执行。然后，打开可以执行JavaScript代码的浏览器Console，依次输入代码：1234567// 打开一个WebSocket:var ws = new WebSocket(&apos;ws://localhost:3000/test&apos;);// 响应onmessage事件:ws.onmessage = function(msg) &#123; console.log(msg); &#125;;// 给服务器发送一个字符串:ws.send(&apos;Hello!&apos;); 一切正常的话，可以看到Console的输出如下：1MessageEvent &#123;isTrusted: true, data: &quot;ECHO: Hello!&quot;, origin: &quot;ws://localhost:3000&quot;, lastEventId: &quot;&quot;, source: null…&#125; 这样，我们就在浏览器中成功地收到了服务器发送的消息！ 如果嫌在浏览器中输入JavaScript代码比较麻烦，我们还可以直接用ws模块提供的WebSocket来充当客户端。换句话说，ws模块既包含了服务器端，又包含了客户端。 ws的WebSocket就表示客户端，它其实就是WebSocketServer响应connection事件时回调函数传入的变量ws的类型。 客户端的写法如下：123456789101112let ws = new WebSocket(&apos;ws://localhost:3000/test&apos;);// 打开WebSocket连接后立刻发送一条消息:ws.on(&apos;open&apos;, function () &#123; console.log(`[CLIENT] open()`); ws.send(&apos;Hello!&apos;);&#125;);// 响应收到的消息:ws.on(&apos;message&apos;, function (message) &#123; console.log(`[CLIENT] Received: $&#123;message&#125;`);&#125; 在Node环境下，ws模块的客户端可以用于测试服务器端代码，否则，每次都必须在浏览器执行JavaScript代码。 同源策略从上面的测试可以看出，WebSocket协议本身不要求同源策略（Same-origin Policy），也就是某个地址为http://a.com的网页可以通过WebSocket连接到ws://b.com。但是，浏览器会发送Origin的HTTP头给服务器，服务器可以根据Origin拒绝这个WebSocket请求。所以，是否要求同源要看服务器端如何检查。 路由还需要注意到服务器在响应connection事件时并未检查请求的路径，因此，在客户端打开ws://localhost:3000/any/path可以写任意的路径。 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/29/Websocket(1)/]]></content>
      <categories>
        <category>Node</category>
        <category>WebSocket</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>http</tag>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js复习]]></title>
    <url>%2F2017%2F06%2F29%2Fnode-document%2F</url>
    <content type="text"><![CDATA[前阵子学习了Node，已经了解了Node的基本知识，并安装了node，npm，了解了怎么去运行，现在这篇是复习一下node。 Node(复习） Node.js:基于JavaScript语言和V8引擎的开源Web服务器项目 在Node上运行的JavaScript相比其他后端开发语言有何优势？ 最大的优势是借助JavaScript天生的事件驱动机制加V8高性能引擎，使编写高性能Web服务轻而易举。其次，JavaScript语言本身是完善的函数式语言,在Node环境下，通过模块化的JavaScript代码，加上函数式编程，并且无需考虑浏览器兼容性问题，直接使用最新的ECMAScript 6标准，可以完全满足工程上的需求。 io.js，这又是什么鬼？ io.js是“尝鲜版”，而Node.js是线上稳定版，相当于Fedora Linux和RHEL的关系。 #npm npm其实是Node.js的包管理工具（package manager）。 为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。 更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。 第一个Node程序选择一个目录，例如F:\Node，把文件保存为hello.js，就可以打开命令行窗口，把当前目录切换到hello.js所在目录，然后输入以下命令运行这个程序了：12F:\Node&gt;node hello.jsHello, world. 也可以保存为别的名字，比如first.js，但是必须要以.js结尾。此外，文件名只能是英文字母、数字和下划线的组合。 命令行模式和Node交互模式 请注意区分命令行模式和Node交互模式。 看到类似C:>是在Windows提供的命令行模式： 看到&gt;是在Node交互式环境下： 在Node交互式环境下，我们可以输入JavaScript代码并立刻执行。 使用严格模式如果在JavaScript文件开头写上&#39;use strict&#39;;，那么Node在执行该JavaScript时将使用严格模式。但是，在服务器环境下，如果有很多JavaScript文件，每个文件都写上’use strict’;很麻烦。我们可以给Nodejs传递一个参数，让Node直接为所有js文件开启严格模式： 1node --use_strict 给指定文件开启严格模式：1node --use_strict 文件名(例如:hello.js) 模块 在Node环境中，一个.js文件就称之为一个模块（module）。 使用模块有什么好处？ 最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。 使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。 比如，我们编写了一个hello.js文件，这个hello.js文件就是一个模块，模块的名字就是文件名（去掉.js后缀），所以hello.js文件就是名为hello的模块。 123456789&apos;use strict&apos;;var s = &apos;Hello&apos;;function greet(name) &#123; console.log(s + &apos;, &apos; + name + &apos;!&apos;);&#125;module.exports = greet; 函数greet()是我们在hello模块中定义的，你可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数greet作为模块的输出暴露出去，这样其他模块就可以使用greet函数了。 问题是其他模块怎么使用hello模块的这个greet函数呢？我们再编写一个main.js文件，调用hello模块的greet函数：12345678&apos;use strict&apos;;// 引入hello模块:var greet = require(&apos;./hello&apos;);var s = &apos;Michael&apos;;greet(s); // Hello, Michael! 注意到引入hello模块用Node提供的require函数：1var greet = require(&apos;./hello&apos;); 引入的模块作为变量保存在greet变量中，那greet变量到底是什么东西？其实变量greet就是在hello.js中我们用module.exports = greet;输出的greet函数。所以，main.js就成功地引用了hello.js模块中定义的greet()函数，接下来就可以直接使用它了。 在使用require()引入模块的时候，请注意模块的相对路径。因为main.js和hello.js位于同一个目录，所以我们用了当前目录.：1var greet = require(&apos;./hello&apos;); // 不要忘了写相对目录! 如果只写模块名：1var greet = require(&apos;hello&apos;); 则Node会依次在内置模块、全局模块和当前模块下查找hello.js，你很可能会得到一个错误： module.js throw err; ^ Error: Cannot find module &apos;hello&apos; at Function.Module._resolveFilename at Function.Module._load ... at Function.Module._load at Function.Module.runMain 遇到这个错误，你要检查： 模块名是否写对了； 模块文件是否存在； 相对路径是否写对了。 CommonJS规范这种模块加载机制被称为CommonJS规范。在这个规范下，每个.js文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突，例如，hello.js和main.js都申明了全局变量var s = ‘xxx’，但互不影响。 小结：要在模块中对外输出变量，用 module.exports = variable; 输出的变量可以是任意对象、函数、数组等等。 要引入其他模块输出的对象，用： var foo = require(&apos;other_module&apos;); 深入了解模块原理 JavaScript语言本身并没有一种模块机制来保证不同模块可以使用相同的变量名。 其实要实现“模块”这个功能，并不需要语法层面的支持。Node.js也并不会增加任何JavaScript语法。实现“模块”功能的奥妙就在于JavaScript是一种函数式编程语言，它支持闭包。如果我们把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。 请注意我们编写的hello.js代码是这样的： var s = &apos;Hello&apos;; var name = &apos;world&apos;; console.log(s + &apos; &apos; + name + &apos;!&apos;); Node.js加载了hello.js后，它可以把代码包装一下，变成这样执行： (function () { // 读取的hello.js代码: var s = &apos;Hello&apos;; var name = &apos;world&apos;; console.log(s + &apos; &apos; + name + &apos;!&apos;); // hello.js代码结束 })(); 所以，Node利用JavaScript的函数式编程的特性，轻而易举地实现了模块的隔离。 但是，模块的输出module.exports怎么实现？ 这个也很容易实现，Node可以先准备一个对象module： // 准备module对象: var module = { id: &apos;hello&apos;, exports: {} }; var load = function (module) { // 读取的hello.js代码: function greet(name) { console.log(&apos;Hello, &apos; + name + &apos;!&apos;); } module.exports = greet; // hello.js代码结束 return module.exports; }; var exported = load(module); // 保存module: save(module, exported); 可见，变量module是Node在加载js文件前准备的一个变量，并将其传入加载函数，我们在hello.js中可以直接使用变量module原因就在于它实际上是函数的一个参数： module.exports = greet; 通过把参数module传递给load()函数，hello.js就顺利地把一个变量传递给了Node执行环境，Node会把module变量保存到某个地方。 由于Node保存了所有导入的module，当我们用require()获取module时，Node找到对应的module，把这个module的exports变量返回，这样，另一个模块就顺利拿到了模块的输出： var greet = require(&apos;./hello&apos;); 以上是Node实现JavaScript模块的一个简单的原理介绍。 module.exports vs exports很多时候，你会看到，在Node环境中，有两种方法可以在一个模块中输出变量： 方法一：对module.exports赋值： // hello.js function hello() { console.log(&apos;Hello, world!&apos;); } function greet(name) { console.log(&apos;Hello, &apos; + name + &apos;!&apos;); } module.exports = { hello: hello, greet: greet }; 方法二：直接使用exports： // hello.js function hello() { console.log(&apos;Hello, world!&apos;); } function greet(name) { console.log(&apos;Hello, &apos; + name + &apos;!&apos;); } function hello() { console.log(&apos;Hello, world!&apos;); } exports.hello = hello; exports.greet = greet; 但是你不可以直接对exports赋值： // 代码可以执行，但是模块并没有输出任何变量: exports = { hello: hello, greet: greet }; 结论:如果要输出一个函数或数组，必须直接对module.exports对象赋值。 直接对module.exports赋值，可以应对任何情况 module.exports = { foo: function () { return &apos;foo&apos;; } }; 或者： module.exports = function () { return &apos;foo&apos;; }; 基本模块因为Node.js是运行在服务区端的JavaScript环境，服务器程序和浏览器程序相比，最大的特点是没有浏览器的安全限制了，而且，服务器程序必须能接收网络请求，读写文件，处理二进制内容，所以，Node.js内置的常用模块就是为了实现基本的服务器功能。这些模块在浏览器环境中是无法被执行的，因为它们的底层代码是用C/C++在Node.js运行环境中实现的。 global在前面的JavaScript课程中，我们已经知道，JavaScript有且仅有一个全局对象，在浏览器中，叫window对象。而在Node.js环境中，也有唯一的全局对象，但不叫window，而叫global，这个对象的属性和方法也和浏览器环境的window不同。进入Node.js交互环境，可以直接输入： E:\Node&gt;node &gt; global.console Console { log: [Function: bound ], info: [Function: bound ], warn: [Function: bound ], error: [Function: bound ], dir: [Function: bound ], time: [Function: bound ], timeEnd: [Function: bound ], trace: [Function: bound trace], assert: [Function: bound ], Console: [Function: Console] } &gt; process·process·也是Node.js提供的一个对象，它代表当前Node.js进程。通过process对象可以拿到许多有用信息： &gt; process==global.process true &gt; process.version &apos;v4.6.0&apos; &gt; process.platform &apos;win32&apos; &gt; process.arch &apos;x64&apos; &gt; &gt; process.cwd() &apos;E:\\Node&apos; JavaScript程序是由事件驱动执行的单线程模型，Node.js也不例外。Node.js不断执行响应事件的JavaScript函数，直到没有任何响应事件的函数可以执行时，Node.js就退出了。 如果我们想要在下一次事件响应中执行代码，可以调用process.nextTick()： // test.js // process.nextTick()将在下一轮事件循环中调用: process.nextTick(function () { console.log(&apos;nextTick callback!&apos;); }); console.log(&apos;nextTick was set!&apos;); 用Node执行上面的代码node test.js，你会看到，打印输出是：12nextTick was set!nextTick callback! 这说明传入process.nextTick()的函数不是立刻执行，而是要等到下一次事件循环。 Node.js进程本身的事件就由process对象来处理。如果我们响应exit事件，就可以在程序即将退出时执行某个回调函数：1234// 程序即将退出时的回调函数:process.on(&apos;exit&apos;, function (code) &#123; console.log(&apos;about to exit with code: &apos; + code);&#125;); 判断JavaScript执行环境有很多JavaScript代码既能在浏览器中执行，也能在Node环境执行，但有些时候，程序本身需要判断自己到底是在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断：12345if (typeof(window) === &apos;undefined&apos;) &#123; console.log(&apos;node.js&apos;);&#125; else &#123; console.log(&apos;browser&apos;);&#125; fsNode.js内置的fs模块就是 文件系统模块 ，负责读写文件。 和所有其它JavaScript模块不同的是，fs模块同时提供了异步和同步的方法。 回顾一下什么是异步方法。因为JavaScript的单线程模型，执行IO操作时，JavaScript代码无需等待，而是传入回调函数后，继续执行后续JavaScript代码。比如jQuery提供的getJSON()操作：1234$.getJSON(&apos;http://example.com/ajax&apos;, function (data) &#123; console.log(&apos;IO结果返回后执行...&apos;);&#125;);console.log(&apos;不等待IO结果直接执行后续代码...&apos;); 而同步的IO操作则需要等待函数返回：12// 根据网络耗时，函数将执行几十毫秒~几秒不等:var data = getJSONSync(&apos;http://example.com/ajax&apos;); 同步操作的好处是代码简单，缺点是程序将等待IO操作，在等待时间内，无法响应其它任何事件。而异步读取不用等待IO操作，但代码较麻烦。 异步读文件按照JavaScript的标准，异步读取一个文本文件的代码如下： 1234567891011&apos;use strict&apos;;var fs = require(&apos;fs&apos;);fs.readFile(&apos;sample.txt&apos;, &apos;utf-8&apos;, function (err, data) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); &#125;&#125;); 请注意，sample.txt文件必须在当前目录下，且文件编码为utf-8。 异步读取时，传入的回调函数接收两个参数，当正常读取时，err参数为null，data参数为读取到的String。当读取发生错误时，err参数代表一个错误对象，data为undefined。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。后面我们还会经常编写这种回调函数。 由于err是否为null就是判断是否出错的标志，所以通常的判断逻辑总是：12345if (err) &#123; // 出错了&#125; else &#123; // 正常&#125; 如果我们要读取的文件不是文本文件，而是二进制文件，怎么办？ 下面的例子演示了如何读取一个图片文件： 123456789101112&apos;use strict&apos;;var fs = require(&apos;fs&apos;);fs.readFile(&apos;sample.png&apos;, function (err, data) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); console.log(data.length + &apos; bytes&apos;); &#125;&#125;); 当读取二进制文件时，不传入文件编码时，回调函数的data参数将返回一个Buffer对象。在Node.js中，Buffer对象就是一个包含零个或任意个字节的数组（注意和Array不同）。 Buffer对象可以和String作转换，例如，把一个Buffer对象转换成String：123// Buffer -&gt; Stringvar text = data.toString(&apos;utf-8&apos;);console.log(text); 或者把一个String转换成Buffer：123// String -&gt; Buffervar buf = new Buffer(text, &apos;utf-8&apos;);console.log(buf); 同步读文件 除了标准的异步读取模式外，fs也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个Sync后缀，并且不接收回调函数，函数直接返回结果。 用fs模块同步读取一个文本文件的代码如下： 123456&apos;use strict&apos;;var fs = require(&apos;fs&apos;);var data = fs.readFileSync(&apos;sample.txt&apos;, &apos;utf-8&apos;);console.log(data); 可见，原异步调用的回调函数的data被函数直接返回，函数名需要改为readFileSync，其它参数不变。 如果同步读取文件发生错误，则需要用try…catch捕获该错误：123456try &#123; var data = fs.readFileSync(&apos;sample.txt&apos;, &apos;utf-8&apos;); console.log(data);&#125; catch (err) &#123; // 出错了&#125; 写文件 将数据写入文件是通过fs.writeFile()实现的： 123456789101112&apos;use strict&apos;;var fs = require(&apos;fs&apos;);var data = &apos;Hello, Node.js&apos;;fs.writeFile(&apos;output.txt&apos;, data, function (err) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(&apos;ok.&apos;); &#125;&#125;); writeFile()的参数依次为文件名、数据和回调函数。如果传入的数据是String，默认按UTF-8编码写入文本文件，如果传入的参数是Buffer，则写入的是二进制文件。回调函数由于只关心成功与否，因此只需要一个err参数。 和readFile()类似，writeFile()也有一个同步方法，叫writeFileSync()：123456&apos;use strict&apos;;var fs = require(&apos;fs&apos;);var data = &apos;Hello, Node.js&apos;;fs.writeFileSync(&apos;output.txt&apos;, data); stat如果我们要获取文件大小，创建时间等信息，可以使用fs.stat()，它返回一个Stat对象，能告诉我们文件或目录的详细信息：12345678910111213141516171819202122&apos;use strict&apos;;var fs = require(&apos;fs&apos;);fs.stat(&apos;sample.txt&apos;, function (err, stat) &#123; if (err) &#123; console.log(err); &#125; else &#123; // 是否是文件: console.log(&apos;isFile: &apos; + stat.isFile()); // 是否是目录: console.log(&apos;isDirectory: &apos; + stat.isDirectory()); if (stat.isFile()) &#123; // 文件大小: console.log(&apos;size: &apos; + stat.size); // 创建时间, Date对象: console.log(&apos;birth time: &apos; + stat.birthtime); // 修改时间, Date对象: console.log(&apos;modified time: &apos; + stat.mtime); &#125; &#125;&#125;); 运行结果如下：12345isFile: trueisDirectory: falsesize: 181birth time: Fri Dec 11 2015 09:43:41 GMT+0800 (CST)modified time: Fri Dec 11 2015 12:09:00 GMT+0800 (CST) stat()也有一个对应的同步函数statSync() 异步还是同步 在fs模块中，提供同步方法是为了方便使用。那我们到底是应该用异步方法还是同步方法呢？ 由于Node环境执行的JavaScript代码是服务器端代码，所以，绝大部分需要在服务器运行期反复执行业务逻辑的代码，必须使用异步代码，否则，同步代码在执行时期，服务器将停止响应，因为JavaScript只有一个执行线程。 服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次，不影响服务器正常运行时的异步执行。 streamstream是Node.js提供的又一个仅在服务区端可用的模块，目的是支持“流”这种数据结构。 什么是流？流是一种抽象的数据结构。流的特点是数据是有序的，而且必须依次读取，或者依次写入，不能像Array那样随机定位。 在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：data事件表示流的数据已经可以读取了，end事件表示这个流已经到末尾了，没有数据可以读取了，error事件表示出错了。 下面是一个从文件流读取文本内容的示例：12345678910111213141516171819&apos;use strict&apos;;var fs = require(&apos;fs&apos;);// 打开一个流:var rs = fs.createReadStream(&apos;sample.txt&apos;, &apos;utf-8&apos;);rs.on(&apos;data&apos;, function (chunk) &#123; console.log(&apos;DATA:&apos;) console.log(chunk);&#125;);rs.on(&apos;end&apos;, function () &#123; console.log(&apos;END&apos;);&#125;);rs.on(&apos;error&apos;, function (err) &#123; console.log(&apos;ERROR: &apos; + err);&#125;); 要注意，data事件可能会有多次，每次传递的chunk是流的一部分数据。 要以流的形式写入文件，只需要不断调用write()方法，最后以end()结束：12345678910111213&apos;use strict&apos;;var fs = require(&apos;fs&apos;);var ws1 = fs.createWriteStream(&apos;output1.txt&apos;, &apos;utf-8&apos;);ws1.write(&apos;使用Stream写入文本数据...\n&apos;);ws1.write(&apos;END.&apos;);ws1.end();var ws2 = fs.createWriteStream(&apos;output2.txt&apos;);ws2.write(new Buffer(&apos;使用Stream写入二进制数据...\n&apos;, &apos;utf-8&apos;));ws2.write(new Buffer(&apos;END.&apos;, &apos;utf-8&apos;));ws2.end(); 所有可以读取数据的流都继承自stream.Readable，所有可以写入的流都继承自stream.Writable。 pipe就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个Readable流和一个Writable流串起来后，所有的数据自动从Readable流进入Writable流，这种操作叫pipe。 在Node.js中，Readable流有一个pipe()方法，就是用来干这件事的。 让我们用pipe()把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序：12345678&apos;use strict&apos;;var fs = require(&apos;fs&apos;);var rs = fs.createReadStream(&apos;sample.txt&apos;);var ws = fs.createWriteStream(&apos;copied.txt&apos;);rs.pipe(ws); 默认情况下，当Readable流的数据读取完毕，end事件触发后，将自动关闭Writable流。如果我们不希望自动关闭Writable流，需要传入参数： 1readable.pipe(writable, &#123; end: false &#125;); httpHTTP协议要理解Web服务器程序的工作原理，首先，我们要对HTTP协议有基本的了解。 HTTP服务器要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的http模块完成了。应用程序并不直接和HTTP协议打交道，而是操作http模块提供的request和response对象。 request对象封装了HTTP请求，我们调用request对象的属性和方法就可以拿到所有HTTP请求的信息； response对象封装了HTTP响应，我们操作response对象的方法，就可以把HTTP响应返回给浏览器。 用Node.js实现一个HTTP服务器程序非常简单。我们来实现一个最简单的Web程序hello.js，它对于所有请求，都返回Hello world!：123456789101112131415161718192021&apos;use strict&apos;;// 导入http模块:var http = require(&apos;http&apos;);// 创建http server，并传入回调函数:var server = http.createServer(function (request, response) &#123; // 回调函数接收request和response对象, // 获得HTTP请求的method和url: console.log(request.method + &apos;: &apos; + request.url); // 将HTTP响应200写入response, 同时设置Content-Type: text/html: response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/html&apos;&#125;); // 将HTTP响应的HTML内容写入response: response.end(&apos;&lt;h1&gt;Hello world!&lt;/h1&gt;&apos;);&#125;);// 让服务器监听8080端口:server.listen(8080);console.log(&apos;Server is running at http://127.0.0.1:8080/&apos;); 在命令提示符下运行该程序，可以看到以下输出：12$ node hello.js Server is running at http://127.0.0.1:8080/ 不要关闭命令提示符，直接打开浏览器输入http://localhost:8080，即可看到服务器响应的内容。同时，在命令提示符窗口，可以看到程序打印的请求信息： 12GET: /GET: /favicon.ico 文件服务器让我们继续扩展一下上面的Web程序。我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析request.url中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。 解析URL需要用到Node.js提供的url模块，它使用起来非常简单，通过parse()将一个字符串解析为一个Url对象： 12345&apos;use strict&apos;;var url = require(&apos;url&apos;);console.log(url.parse(&apos;http://user:pass@host.com:8080/path/to/file?query=string#hash&apos;)); 结果如下：12345678910111213Url &#123; protocol: &apos;http:&apos;, slashes: true, auth: &apos;user:pass&apos;, host: &apos;host.com:8080&apos;, port: &apos;8080&apos;, hostname: &apos;host.com&apos;, hash: &apos;#hash&apos;, search: &apos;?query=string&apos;, query: &apos;query=string&apos;, pathname: &apos;/path/to/file&apos;, path: &apos;/path/to/file?query=string&apos;, href: &apos;http://user:pass@host.com:8080/path/to/file?query=string#hash&apos; &#125; 处理本地文件目录需要使用Node.js提供的path模块，它可以方便地构造目录：12345678910&apos;use strict&apos;;var path = require(&apos;path&apos;);// 解析当前目录:var workDir = path.resolve(&apos;.&apos;); //F:\Node// 组合完整的文件路径:当前目录+&apos;pub&apos;+&apos;index.html&apos;:var filePath = path.join(workDir, &apos;pub&apos;, &apos;index.html&apos;);// &apos;F:\Node\pub\index.html&apos; 最后，我们实现一个文件服务器file_server.js：1234567891011121314151617181920212223242526272829303132333435363738394041&apos;use strict&apos;;var fs = require(&apos;fs&apos;), url = require(&apos;url&apos;), path = require(&apos;path&apos;), http = require(&apos;http&apos;);// 从命令行参数获取root目录，默认是当前目录:var root = path.resolve(process.argv[2] || &apos;.&apos;);console.log(&apos;Static root dir: &apos; + root);// 创建服务器:var server = http.createServer(function (request, response) &#123; // 获得URL的path，类似 &apos;/css/bootstrap.css&apos;: var pathname = url.parse(request.url).pathname; // 获得对应的本地文件路径，类似 &apos;/srv/www/css/bootstrap.css&apos;: var filepath = path.join(root, pathname); // 获取文件状态: fs.stat(filepath, function (err, stats) &#123; if (!err &amp;&amp; stats.isFile()) &#123; // 没有出错并且文件存在: console.log(&apos;200 &apos; + request.url); // 发送200响应: response.writeHead(200); // 将文件流导向response: fs.createReadStream(filepath).pipe(response); &#125; else &#123; // 出错了或者文件不存在: console.log(&apos;404 &apos; + request.url); // 发送404响应: response.writeHead(404); response.end(&apos;404 Not Found&apos;); &#125; &#125;);&#125;);server.listen(8080);console.log(&apos;Server is running at http://127.0.0.1:8080/&apos;); 没有必要手动读取文件内容。由于response对象本身是一个Writable Stream，直接用pipe()方法就实现了自动读取文件内容并输出到HTTP响应。 在命令行运行node file_server.js ./path/to/dir，把/path/to/dir改成你本地的file_server.js路径下一个有效的目录，然后在浏览器中输入http://localhost:8080/index.html： 只要当前目录下存在文件index.html，服务器就可以把文件内容发送给浏览器。观察控制台输出：1234F:\Node&gt;node demo2.js ./path/to/dirStatic root dir: F:\Node\path\to\dirServer is running at http://127.0.0.1:8080/200 /index.html 第一个请求是浏览器请求index.html页面，后续请求是浏览器解析HTML后发送的其它资源请求。 cryptocrypto模块的目的是为了提供通用的加密和哈希算法。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。Nodejs用C/C++实现这些算法后，通过cypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。 MD5和SHA1 MD5是一种常用的哈希算法，用于给任意数据一个“签名”。这个签名通常用一个十六进制的字符串表示：123456789const crypto = require(&apos;crypto&apos;);const hash = crypto.createHash(&apos;md5&apos;);// 可任意多次调用update():hash.update(&apos;Hello, world!&apos;);hash.update(&apos;Hello, nodejs!&apos;);console.log(hash.digest(&apos;hex&apos;)); // 7e1977739c748beac0c0fd14fd26a544 update()方法默认字符串编码为UTF-8，也可以传入Buffer。 如果要计算SHA1，只需要把&#39;md5&#39;改成&#39;sha1&#39;，就可以得到SHA1的结果1f32b9c9932c02227819a4151feed43e131aca40。 还可以使用更安全的sha256和sha512。 HmacHmac算法也是一种哈希算法，它可以利用MD5或SHA1等哈希算法。不同的是，Hmac还需要一个密钥：12345678const crypto = require(&apos;crypto&apos;);const hmac = crypto.createHmac(&apos;sha256&apos;, &apos;secret-key&apos;);hmac.update(&apos;Hello, world!&apos;);hmac.update(&apos;Hello, nodejs!&apos;);console.log(hmac.digest(&apos;hex&apos;)); // 80f7e22570. 只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，因此，可以把Hmac理解为用随机数“增强”的哈希算法。 AES AES是一种常用的对称加密算法，加解密都用同一个密钥。crypto模块提供了AES支持，但是需要自己封装好函数，便于使用：123456789101112131415161718192021222324const crypto = require(&apos;crypto&apos;);function aesEncrypt(data, key) &#123; const cipher = crypto.createCipher(&apos;aes192&apos;, key); var crypted = cipher.update(data, &apos;utf8&apos;, &apos;hex&apos;); crypted += cipher.final(&apos;hex&apos;); return crypted;&#125;function aesDecrypt(encrypted, key) &#123; const decipher = crypto.createDecipher(&apos;aes192&apos;, key); var decrypted = decipher.update(encrypted, &apos;hex&apos;, &apos;utf8&apos;); decrypted += decipher.final(&apos;utf8&apos;); return decrypted;&#125;var data = &apos;Hello, this is a secret message!&apos;;var key = &apos;Password!&apos;;var encrypted = aesEncrypt(data, key);var decrypted = aesDecrypt(encrypted, key);console.log(&apos;Plain text: &apos; + data);console.log(&apos;Encrypted text: &apos; + encrypted);console.log(&apos;Decrypted text: &apos; + decrypted); 运行结果如下：123Plain text: Hello, this is a secret message!Encrypted text: 8a944d97bdabc157a5b7a40cb180e7...Decrypted text: Hello, this is a secret message! 可以看出，加密后的字符串通过解密又得到了原始内容。 注意到AES有很多不同的算法，如aes192，aes-128-ecb，aes-256-cbc等，AES除了密钥外还可以指定IV（Initial Vector），不同的系统只要IV不同，用相同的密钥加密相同的数据得到的加密结果也是不同的。加密结果通常有两种表示方法：hex和base64，这些功能Nodejs全部都支持，但是在应用中要注意，如果加解密双方一方用Nodejs，另一方用Java、PHP等其它语言，需要仔细测试。如果无法正确解密，要确认双方是否遵循同样的AES算法，字符串密钥和IV是否相同，加密后的数据是否统一为hex或base64格式。 Diffie-Hellman DH算法是一种密钥交换协议，它可以让双方在不泄漏密钥的情况下协商出一个密钥来。DH算法基于数学原理，比如小明和小红想要协商一个密钥，可以这么做： 小明先选一个素数和一个底数，例如，素数p=23，底数g=5（底数可以任选），再选择一个秘密整数a=6，计算A=g^a mod p=8，然后大声告诉小红：p=23，g=5，A=8； 小红收到小明发来的p，g，A后，也选一个秘密整数b=15，然后计算B=g^b mod p=19，并大声告诉小明：B=19； 小明自己计算出s=B^a mod p=2，小红也自己计算出s=A^b mod p=2，因此，最终协商的密钥s为2。 在这个过程中，密钥2并不是小明告诉小红的，也不是小红告诉小明的，而是双方协商计算出来的。第三方只能知道p=23，g=5，A=8，B=19，由于不知道双方选的秘密整数a=6和b=15，因此无法计算出密钥2。 用crypto模块实现DH算法如下：1234567891011121314151617181920212223const crypto = require(&apos;crypto&apos;);// xiaoming&apos;s keys:var ming = crypto.createDiffieHellman(512);var ming_keys = ming.generateKeys();var prime = ming.getPrime();var generator = ming.getGenerator();console.log(&apos;Prime: &apos; + prime.toString(&apos;hex&apos;));console.log(&apos;Generator: &apos; + generator.toString(&apos;hex&apos;));// xiaohong&apos;s keys:var hong = crypto.createDiffieHellman(prime, generator);var hong_keys = hong.generateKeys();// exchange and generate secret:var ming_secret = ming.computeSecret(hong_keys);var hong_secret = hong.computeSecret(ming_keys);// print secret:console.log(&apos;Secret of Xiao Ming: &apos; + ming_secret.toString(&apos;hex&apos;));console.log(&apos;Secret of Xiao Hong: &apos; + hong_secret.toString(&apos;hex&apos;)); 运行后，可以得到如下输出：12345$ node dh.js Prime: a8224c...deead3Generator: 02Secret of Xiao Ming: 695308...d519beSecret of Xiao Hong: 695308...d519be 注意每次输出都不一样，因为素数的选择是随机的。 证书crypto模块也可以处理数字证书。数字证书通常用在SSL连接，也就是Web的https连接。一般情况下，https连接只需要处理服务器端的单向认证，如无特殊需求（例如自己作为Root给客户发认证证书），建议用反向代理服务器如Nginx等Web服务器去处理证书。 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/29/node-document/]]></content>
      <categories>
        <category>JS</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Node</tag>
        <tag>模块</tag>
        <tag>npm</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js复习]]></title>
    <url>%2F2017%2F06%2F29%2Fnode-document(1)%2F</url>
    <content type="text"><![CDATA[前阵子学习了Node，已经了解了Node的基本知识，并安装了node，npm，了解了怎么去运行，现在这篇是复习一下node。 Node(复习） Node.js:基于JavaScript语言和V8引擎的开源Web服务器项目 在Node上运行的JavaScript相比其他后端开发语言有何优势？ 最大的优势是借助JavaScript天生的事件驱动机制加V8高性能引擎，使编写高性能Web服务轻而易举。其次，JavaScript语言本身是完善的函数式语言,在Node环境下，通过模块化的JavaScript代码，加上函数式编程，并且无需考虑浏览器兼容性问题，直接使用最新的ECMAScript 6标准，可以完全满足工程上的需求。 io.js，这又是什么鬼？ io.js是“尝鲜版”，而Node.js是线上稳定版，相当于Fedora Linux和RHEL的关系。 #npm npm其实是Node.js的包管理工具（package manager）。 为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。 更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。 第一个Node程序选择一个目录，例如F:\Node，把文件保存为hello.js，就可以打开命令行窗口，把当前目录切换到hello.js所在目录，然后输入以下命令运行这个程序了：12F:\Node&gt;node hello.jsHello, world. 也可以保存为别的名字，比如first.js，但是必须要以.js结尾。此外，文件名只能是英文字母、数字和下划线的组合。 命令行模式和Node交互模式 请注意区分命令行模式和Node交互模式。 看到类似C:>是在Windows提供的命令行模式： 看到&gt;是在Node交互式环境下： 在Node交互式环境下，我们可以输入JavaScript代码并立刻执行。 使用严格模式如果在JavaScript文件开头写上&#39;use strict&#39;;，那么Node在执行该JavaScript时将使用严格模式。但是，在服务器环境下，如果有很多JavaScript文件，每个文件都写上’use strict’;很麻烦。我们可以给Nodejs传递一个参数，让Node直接为所有js文件开启严格模式： 1node --use_strict 给指定文件开启严格模式：1node --use_strict 文件名(例如:hello.js) 模块 在Node环境中，一个.js文件就称之为一个模块（module）。 使用模块有什么好处？ 最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。 使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。 比如，我们编写了一个hello.js文件，这个hello.js文件就是一个模块，模块的名字就是文件名（去掉.js后缀），所以hello.js文件就是名为hello的模块。 123456789&apos;use strict&apos;;var s = &apos;Hello&apos;;function greet(name) &#123; console.log(s + &apos;, &apos; + name + &apos;!&apos;);&#125;module.exports = greet; 函数greet()是我们在hello模块中定义的，你可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数greet作为模块的输出暴露出去，这样其他模块就可以使用greet函数了。 问题是其他模块怎么使用hello模块的这个greet函数呢？我们再编写一个main.js文件，调用hello模块的greet函数：12345678&apos;use strict&apos;;// 引入hello模块:var greet = require(&apos;./hello&apos;);var s = &apos;Michael&apos;;greet(s); // Hello, Michael! 注意到引入hello模块用Node提供的require函数：1var greet = require(&apos;./hello&apos;); 引入的模块作为变量保存在greet变量中，那greet变量到底是什么东西？其实变量greet就是在hello.js中我们用module.exports = greet;输出的greet函数。所以，main.js就成功地引用了hello.js模块中定义的greet()函数，接下来就可以直接使用它了。 在使用require()引入模块的时候，请注意模块的相对路径。因为main.js和hello.js位于同一个目录，所以我们用了当前目录.：1var greet = require(&apos;./hello&apos;); // 不要忘了写相对目录! 如果只写模块名：1var greet = require(&apos;hello&apos;); 则Node会依次在内置模块、全局模块和当前模块下查找hello.js，你很可能会得到一个错误： module.js throw err; ^ Error: Cannot find module &apos;hello&apos; at Function.Module._resolveFilename at Function.Module._load ... at Function.Module._load at Function.Module.runMain 遇到这个错误，你要检查： 模块名是否写对了； 模块文件是否存在； 相对路径是否写对了。 CommonJS规范这种模块加载机制被称为CommonJS规范。在这个规范下，每个.js文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突，例如，hello.js和main.js都申明了全局变量var s = ‘xxx’，但互不影响。 小结：要在模块中对外输出变量，用 module.exports = variable; 输出的变量可以是任意对象、函数、数组等等。 要引入其他模块输出的对象，用： var foo = require(&apos;other_module&apos;); 深入了解模块原理 JavaScript语言本身并没有一种模块机制来保证不同模块可以使用相同的变量名。 其实要实现“模块”这个功能，并不需要语法层面的支持。Node.js也并不会增加任何JavaScript语法。实现“模块”功能的奥妙就在于JavaScript是一种函数式编程语言，它支持闭包。如果我们把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。 请注意我们编写的hello.js代码是这样的： var s = &apos;Hello&apos;; var name = &apos;world&apos;; console.log(s + &apos; &apos; + name + &apos;!&apos;); Node.js加载了hello.js后，它可以把代码包装一下，变成这样执行： (function () { // 读取的hello.js代码: var s = &apos;Hello&apos;; var name = &apos;world&apos;; console.log(s + &apos; &apos; + name + &apos;!&apos;); // hello.js代码结束 })(); 所以，Node利用JavaScript的函数式编程的特性，轻而易举地实现了模块的隔离。 但是，模块的输出module.exports怎么实现？ 这个也很容易实现，Node可以先准备一个对象module： // 准备module对象: var module = { id: &apos;hello&apos;, exports: {} }; var load = function (module) { // 读取的hello.js代码: function greet(name) { console.log(&apos;Hello, &apos; + name + &apos;!&apos;); } module.exports = greet; // hello.js代码结束 return module.exports; }; var exported = load(module); // 保存module: save(module, exported); 可见，变量module是Node在加载js文件前准备的一个变量，并将其传入加载函数，我们在hello.js中可以直接使用变量module原因就在于它实际上是函数的一个参数： module.exports = greet; 通过把参数module传递给load()函数，hello.js就顺利地把一个变量传递给了Node执行环境，Node会把module变量保存到某个地方。 由于Node保存了所有导入的module，当我们用require()获取module时，Node找到对应的module，把这个module的exports变量返回，这样，另一个模块就顺利拿到了模块的输出： var greet = require(&apos;./hello&apos;); 以上是Node实现JavaScript模块的一个简单的原理介绍。 module.exports vs exports很多时候，你会看到，在Node环境中，有两种方法可以在一个模块中输出变量： 方法一：对module.exports赋值： // hello.js function hello() { console.log(&apos;Hello, world!&apos;); } function greet(name) { console.log(&apos;Hello, &apos; + name + &apos;!&apos;); } module.exports = { hello: hello, greet: greet }; 方法二：直接使用exports： // hello.js function hello() { console.log(&apos;Hello, world!&apos;); } function greet(name) { console.log(&apos;Hello, &apos; + name + &apos;!&apos;); } function hello() { console.log(&apos;Hello, world!&apos;); } exports.hello = hello; exports.greet = greet; 但是你不可以直接对exports赋值： // 代码可以执行，但是模块并没有输出任何变量: exports = { hello: hello, greet: greet }; 结论:如果要输出一个函数或数组，必须直接对module.exports对象赋值。 直接对module.exports赋值，可以应对任何情况 module.exports = { foo: function () { return &apos;foo&apos;; } }; 或者： module.exports = function () { return &apos;foo&apos;; }; 基本模块因为Node.js是运行在服务区端的JavaScript环境，服务器程序和浏览器程序相比，最大的特点是没有浏览器的安全限制了，而且，服务器程序必须能接收网络请求，读写文件，处理二进制内容，所以，Node.js内置的常用模块就是为了实现基本的服务器功能。这些模块在浏览器环境中是无法被执行的，因为它们的底层代码是用C/C++在Node.js运行环境中实现的。 global在前面的JavaScript课程中，我们已经知道，JavaScript有且仅有一个全局对象，在浏览器中，叫window对象。而在Node.js环境中，也有唯一的全局对象，但不叫window，而叫global，这个对象的属性和方法也和浏览器环境的window不同。进入Node.js交互环境，可以直接输入： E:\Node&gt;node &gt; global.console Console { log: [Function: bound ], info: [Function: bound ], warn: [Function: bound ], error: [Function: bound ], dir: [Function: bound ], time: [Function: bound ], timeEnd: [Function: bound ], trace: [Function: bound trace], assert: [Function: bound ], Console: [Function: Console] } &gt; process·process·也是Node.js提供的一个对象，它代表当前Node.js进程。通过process对象可以拿到许多有用信息： &gt; process==global.process true &gt; process.version &apos;v4.6.0&apos; &gt; process.platform &apos;win32&apos; &gt; process.arch &apos;x64&apos; &gt; &gt; process.cwd() &apos;E:\\Node&apos; JavaScript程序是由事件驱动执行的单线程模型，Node.js也不例外。Node.js不断执行响应事件的JavaScript函数，直到没有任何响应事件的函数可以执行时，Node.js就退出了。 如果我们想要在下一次事件响应中执行代码，可以调用process.nextTick()： // test.js // process.nextTick()将在下一轮事件循环中调用: process.nextTick(function () { console.log(&apos;nextTick callback!&apos;); }); console.log(&apos;nextTick was set!&apos;); 用Node执行上面的代码node test.js，你会看到，打印输出是：12nextTick was set!nextTick callback! 这说明传入process.nextTick()的函数不是立刻执行，而是要等到下一次事件循环。 Node.js进程本身的事件就由process对象来处理。如果我们响应exit事件，就可以在程序即将退出时执行某个回调函数：1234// 程序即将退出时的回调函数:process.on(&apos;exit&apos;, function (code) &#123; console.log(&apos;about to exit with code: &apos; + code);&#125;); 判断JavaScript执行环境有很多JavaScript代码既能在浏览器中执行，也能在Node环境执行，但有些时候，程序本身需要判断自己到底是在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断：12345if (typeof(window) === &apos;undefined&apos;) &#123; console.log(&apos;node.js&apos;);&#125; else &#123; console.log(&apos;browser&apos;);&#125; fsNode.js内置的fs模块就是 文件系统模块 ，负责读写文件。 和所有其它JavaScript模块不同的是，fs模块同时提供了异步和同步的方法。 回顾一下什么是异步方法。因为JavaScript的单线程模型，执行IO操作时，JavaScript代码无需等待，而是传入回调函数后，继续执行后续JavaScript代码。比如jQuery提供的getJSON()操作：1234$.getJSON(&apos;http://example.com/ajax&apos;, function (data) &#123; console.log(&apos;IO结果返回后执行...&apos;);&#125;);console.log(&apos;不等待IO结果直接执行后续代码...&apos;); 而同步的IO操作则需要等待函数返回：12// 根据网络耗时，函数将执行几十毫秒~几秒不等:var data = getJSONSync(&apos;http://example.com/ajax&apos;); 同步操作的好处是代码简单，缺点是程序将等待IO操作，在等待时间内，无法响应其它任何事件。而异步读取不用等待IO操作，但代码较麻烦。 异步读文件按照JavaScript的标准，异步读取一个文本文件的代码如下： 1234567891011&apos;use strict&apos;;var fs = require(&apos;fs&apos;);fs.readFile(&apos;sample.txt&apos;, &apos;utf-8&apos;, function (err, data) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); &#125;&#125;); 请注意，sample.txt文件必须在当前目录下，且文件编码为utf-8。 异步读取时，传入的回调函数接收两个参数，当正常读取时，err参数为null，data参数为读取到的String。当读取发生错误时，err参数代表一个错误对象，data为undefined。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。后面我们还会经常编写这种回调函数。 由于err是否为null就是判断是否出错的标志，所以通常的判断逻辑总是：12345if (err) &#123; // 出错了&#125; else &#123; // 正常&#125; 如果我们要读取的文件不是文本文件，而是二进制文件，怎么办？ 下面的例子演示了如何读取一个图片文件： 123456789101112&apos;use strict&apos;;var fs = require(&apos;fs&apos;);fs.readFile(&apos;sample.png&apos;, function (err, data) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); console.log(data.length + &apos; bytes&apos;); &#125;&#125;); 当读取二进制文件时，不传入文件编码时，回调函数的data参数将返回一个Buffer对象。在Node.js中，Buffer对象就是一个包含零个或任意个字节的数组（注意和Array不同）。 Buffer对象可以和String作转换，例如，把一个Buffer对象转换成String：123// Buffer -&gt; Stringvar text = data.toString(&apos;utf-8&apos;);console.log(text); 或者把一个String转换成Buffer：123// String -&gt; Buffervar buf = new Buffer(text, &apos;utf-8&apos;);console.log(buf); 同步读文件 除了标准的异步读取模式外，fs也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个Sync后缀，并且不接收回调函数，函数直接返回结果。 用fs模块同步读取一个文本文件的代码如下： 123456&apos;use strict&apos;;var fs = require(&apos;fs&apos;);var data = fs.readFileSync(&apos;sample.txt&apos;, &apos;utf-8&apos;);console.log(data); 可见，原异步调用的回调函数的data被函数直接返回，函数名需要改为readFileSync，其它参数不变。 如果同步读取文件发生错误，则需要用try…catch捕获该错误：123456try &#123; var data = fs.readFileSync(&apos;sample.txt&apos;, &apos;utf-8&apos;); console.log(data);&#125; catch (err) &#123; // 出错了&#125; 写文件 将数据写入文件是通过fs.writeFile()实现的： 123456789101112&apos;use strict&apos;;var fs = require(&apos;fs&apos;);var data = &apos;Hello, Node.js&apos;;fs.writeFile(&apos;output.txt&apos;, data, function (err) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(&apos;ok.&apos;); &#125;&#125;); writeFile()的参数依次为文件名、数据和回调函数。如果传入的数据是String，默认按UTF-8编码写入文本文件，如果传入的参数是Buffer，则写入的是二进制文件。回调函数由于只关心成功与否，因此只需要一个err参数。 和readFile()类似，writeFile()也有一个同步方法，叫writeFileSync()：123456&apos;use strict&apos;;var fs = require(&apos;fs&apos;);var data = &apos;Hello, Node.js&apos;;fs.writeFileSync(&apos;output.txt&apos;, data); stat如果我们要获取文件大小，创建时间等信息，可以使用fs.stat()，它返回一个Stat对象，能告诉我们文件或目录的详细信息：12345678910111213141516171819202122&apos;use strict&apos;;var fs = require(&apos;fs&apos;);fs.stat(&apos;sample.txt&apos;, function (err, stat) &#123; if (err) &#123; console.log(err); &#125; else &#123; // 是否是文件: console.log(&apos;isFile: &apos; + stat.isFile()); // 是否是目录: console.log(&apos;isDirectory: &apos; + stat.isDirectory()); if (stat.isFile()) &#123; // 文件大小: console.log(&apos;size: &apos; + stat.size); // 创建时间, Date对象: console.log(&apos;birth time: &apos; + stat.birthtime); // 修改时间, Date对象: console.log(&apos;modified time: &apos; + stat.mtime); &#125; &#125;&#125;); 运行结果如下：12345isFile: trueisDirectory: falsesize: 181birth time: Fri Dec 11 2015 09:43:41 GMT+0800 (CST)modified time: Fri Dec 11 2015 12:09:00 GMT+0800 (CST) stat()也有一个对应的同步函数statSync() 异步还是同步 在fs模块中，提供同步方法是为了方便使用。那我们到底是应该用异步方法还是同步方法呢？ 由于Node环境执行的JavaScript代码是服务器端代码，所以，绝大部分需要在服务器运行期反复执行业务逻辑的代码，必须使用异步代码，否则，同步代码在执行时期，服务器将停止响应，因为JavaScript只有一个执行线程。 服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次，不影响服务器正常运行时的异步执行。 streamstream是Node.js提供的又一个仅在服务区端可用的模块，目的是支持“流”这种数据结构。 什么是流？流是一种抽象的数据结构。流的特点是数据是有序的，而且必须依次读取，或者依次写入，不能像Array那样随机定位。 在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：data事件表示流的数据已经可以读取了，end事件表示这个流已经到末尾了，没有数据可以读取了，error事件表示出错了。 下面是一个从文件流读取文本内容的示例：12345678910111213141516171819&apos;use strict&apos;;var fs = require(&apos;fs&apos;);// 打开一个流:var rs = fs.createReadStream(&apos;sample.txt&apos;, &apos;utf-8&apos;);rs.on(&apos;data&apos;, function (chunk) &#123; console.log(&apos;DATA:&apos;) console.log(chunk);&#125;);rs.on(&apos;end&apos;, function () &#123; console.log(&apos;END&apos;);&#125;);rs.on(&apos;error&apos;, function (err) &#123; console.log(&apos;ERROR: &apos; + err);&#125;); 要注意，data事件可能会有多次，每次传递的chunk是流的一部分数据。 要以流的形式写入文件，只需要不断调用write()方法，最后以end()结束：12345678910111213&apos;use strict&apos;;var fs = require(&apos;fs&apos;);var ws1 = fs.createWriteStream(&apos;output1.txt&apos;, &apos;utf-8&apos;);ws1.write(&apos;使用Stream写入文本数据...\n&apos;);ws1.write(&apos;END.&apos;);ws1.end();var ws2 = fs.createWriteStream(&apos;output2.txt&apos;);ws2.write(new Buffer(&apos;使用Stream写入二进制数据...\n&apos;, &apos;utf-8&apos;));ws2.write(new Buffer(&apos;END.&apos;, &apos;utf-8&apos;));ws2.end(); 所有可以读取数据的流都继承自stream.Readable，所有可以写入的流都继承自stream.Writable。 pipe就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个Readable流和一个Writable流串起来后，所有的数据自动从Readable流进入Writable流，这种操作叫pipe。 在Node.js中，Readable流有一个pipe()方法，就是用来干这件事的。 让我们用pipe()把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序：12345678&apos;use strict&apos;;var fs = require(&apos;fs&apos;);var rs = fs.createReadStream(&apos;sample.txt&apos;);var ws = fs.createWriteStream(&apos;copied.txt&apos;);rs.pipe(ws); 默认情况下，当Readable流的数据读取完毕，end事件触发后，将自动关闭Writable流。如果我们不希望自动关闭Writable流，需要传入参数： 1readable.pipe(writable, &#123; end: false &#125;); httpHTTP协议要理解Web服务器程序的工作原理，首先，我们要对HTTP协议有基本的了解。 HTTP服务器要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的http模块完成了。应用程序并不直接和HTTP协议打交道，而是操作http模块提供的request和response对象。 request对象封装了HTTP请求，我们调用request对象的属性和方法就可以拿到所有HTTP请求的信息； response对象封装了HTTP响应，我们操作response对象的方法，就可以把HTTP响应返回给浏览器。 用Node.js实现一个HTTP服务器程序非常简单。我们来实现一个最简单的Web程序hello.js，它对于所有请求，都返回Hello world!：123456789101112131415161718192021&apos;use strict&apos;;// 导入http模块:var http = require(&apos;http&apos;);// 创建http server，并传入回调函数:var server = http.createServer(function (request, response) &#123; // 回调函数接收request和response对象, // 获得HTTP请求的method和url: console.log(request.method + &apos;: &apos; + request.url); // 将HTTP响应200写入response, 同时设置Content-Type: text/html: response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/html&apos;&#125;); // 将HTTP响应的HTML内容写入response: response.end(&apos;&lt;h1&gt;Hello world!&lt;/h1&gt;&apos;);&#125;);// 让服务器监听8080端口:server.listen(8080);console.log(&apos;Server is running at http://127.0.0.1:8080/&apos;); 在命令提示符下运行该程序，可以看到以下输出：12$ node hello.js Server is running at http://127.0.0.1:8080/ 不要关闭命令提示符，直接打开浏览器输入http://localhost:8080，即可看到服务器响应的内容。同时，在命令提示符窗口，可以看到程序打印的请求信息： 12GET: /GET: /favicon.ico 文件服务器让我们继续扩展一下上面的Web程序。我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析request.url中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。 解析URL需要用到Node.js提供的url模块，它使用起来非常简单，通过parse()将一个字符串解析为一个Url对象： 12345&apos;use strict&apos;;var url = require(&apos;url&apos;);console.log(url.parse(&apos;http://user:pass@host.com:8080/path/to/file?query=string#hash&apos;)); 结果如下：12345678910111213Url &#123; protocol: &apos;http:&apos;, slashes: true, auth: &apos;user:pass&apos;, host: &apos;host.com:8080&apos;, port: &apos;8080&apos;, hostname: &apos;host.com&apos;, hash: &apos;#hash&apos;, search: &apos;?query=string&apos;, query: &apos;query=string&apos;, pathname: &apos;/path/to/file&apos;, path: &apos;/path/to/file?query=string&apos;, href: &apos;http://user:pass@host.com:8080/path/to/file?query=string#hash&apos; &#125; 处理本地文件目录需要使用Node.js提供的path模块，它可以方便地构造目录：12345678910&apos;use strict&apos;;var path = require(&apos;path&apos;);// 解析当前目录:var workDir = path.resolve(&apos;.&apos;); //F:\Node// 组合完整的文件路径:当前目录+&apos;pub&apos;+&apos;index.html&apos;:var filePath = path.join(workDir, &apos;pub&apos;, &apos;index.html&apos;);// &apos;F:\Node\pub\index.html&apos; 最后，我们实现一个文件服务器file_server.js：1234567891011121314151617181920212223242526272829303132333435363738394041&apos;use strict&apos;;var fs = require(&apos;fs&apos;), url = require(&apos;url&apos;), path = require(&apos;path&apos;), http = require(&apos;http&apos;);// 从命令行参数获取root目录，默认是当前目录:var root = path.resolve(process.argv[2] || &apos;.&apos;);console.log(&apos;Static root dir: &apos; + root);// 创建服务器:var server = http.createServer(function (request, response) &#123; // 获得URL的path，类似 &apos;/css/bootstrap.css&apos;: var pathname = url.parse(request.url).pathname; // 获得对应的本地文件路径，类似 &apos;/srv/www/css/bootstrap.css&apos;: var filepath = path.join(root, pathname); // 获取文件状态: fs.stat(filepath, function (err, stats) &#123; if (!err &amp;&amp; stats.isFile()) &#123; // 没有出错并且文件存在: console.log(&apos;200 &apos; + request.url); // 发送200响应: response.writeHead(200); // 将文件流导向response: fs.createReadStream(filepath).pipe(response); &#125; else &#123; // 出错了或者文件不存在: console.log(&apos;404 &apos; + request.url); // 发送404响应: response.writeHead(404); response.end(&apos;404 Not Found&apos;); &#125; &#125;);&#125;);server.listen(8080);console.log(&apos;Server is running at http://127.0.0.1:8080/&apos;); 没有必要手动读取文件内容。由于response对象本身是一个Writable Stream，直接用pipe()方法就实现了自动读取文件内容并输出到HTTP响应。 在命令行运行node file_server.js ./path/to/dir，把/path/to/dir改成你本地的file_server.js路径下一个有效的目录，然后在浏览器中输入http://localhost:8080/index.html： 只要当前目录下存在文件index.html，服务器就可以把文件内容发送给浏览器。观察控制台输出：1234F:\Node&gt;node demo2.js ./path/to/dirStatic root dir: F:\Node\path\to\dirServer is running at http://127.0.0.1:8080/200 /index.html 第一个请求是浏览器请求index.html页面，后续请求是浏览器解析HTML后发送的其它资源请求。 cryptocrypto模块的目的是为了提供通用的加密和哈希算法。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。Nodejs用C/C++实现这些算法后，通过cypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。 MD5和SHA1 MD5是一种常用的哈希算法，用于给任意数据一个“签名”。这个签名通常用一个十六进制的字符串表示：123456789const crypto = require(&apos;crypto&apos;);const hash = crypto.createHash(&apos;md5&apos;);// 可任意多次调用update():hash.update(&apos;Hello, world!&apos;);hash.update(&apos;Hello, nodejs!&apos;);console.log(hash.digest(&apos;hex&apos;)); // 7e1977739c748beac0c0fd14fd26a544 update()方法默认字符串编码为UTF-8，也可以传入Buffer。 如果要计算SHA1，只需要把&#39;md5&#39;改成&#39;sha1&#39;，就可以得到SHA1的结果1f32b9c9932c02227819a4151feed43e131aca40。 还可以使用更安全的sha256和sha512。 HmacHmac算法也是一种哈希算法，它可以利用MD5或SHA1等哈希算法。不同的是，Hmac还需要一个密钥：12345678const crypto = require(&apos;crypto&apos;);const hmac = crypto.createHmac(&apos;sha256&apos;, &apos;secret-key&apos;);hmac.update(&apos;Hello, world!&apos;);hmac.update(&apos;Hello, nodejs!&apos;);console.log(hmac.digest(&apos;hex&apos;)); // 80f7e22570. 只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，因此，可以把Hmac理解为用随机数“增强”的哈希算法。 AES AES是一种常用的对称加密算法，加解密都用同一个密钥。crypto模块提供了AES支持，但是需要自己封装好函数，便于使用：123456789101112131415161718192021222324const crypto = require(&apos;crypto&apos;);function aesEncrypt(data, key) &#123; const cipher = crypto.createCipher(&apos;aes192&apos;, key); var crypted = cipher.update(data, &apos;utf8&apos;, &apos;hex&apos;); crypted += cipher.final(&apos;hex&apos;); return crypted;&#125;function aesDecrypt(encrypted, key) &#123; const decipher = crypto.createDecipher(&apos;aes192&apos;, key); var decrypted = decipher.update(encrypted, &apos;hex&apos;, &apos;utf8&apos;); decrypted += decipher.final(&apos;utf8&apos;); return decrypted;&#125;var data = &apos;Hello, this is a secret message!&apos;;var key = &apos;Password!&apos;;var encrypted = aesEncrypt(data, key);var decrypted = aesDecrypt(encrypted, key);console.log(&apos;Plain text: &apos; + data);console.log(&apos;Encrypted text: &apos; + encrypted);console.log(&apos;Decrypted text: &apos; + decrypted); 运行结果如下：123Plain text: Hello, this is a secret message!Encrypted text: 8a944d97bdabc157a5b7a40cb180e7...Decrypted text: Hello, this is a secret message! 可以看出，加密后的字符串通过解密又得到了原始内容。 注意到AES有很多不同的算法，如aes192，aes-128-ecb，aes-256-cbc等，AES除了密钥外还可以指定IV（Initial Vector），不同的系统只要IV不同，用相同的密钥加密相同的数据得到的加密结果也是不同的。加密结果通常有两种表示方法：hex和base64，这些功能Nodejs全部都支持，但是在应用中要注意，如果加解密双方一方用Nodejs，另一方用Java、PHP等其它语言，需要仔细测试。如果无法正确解密，要确认双方是否遵循同样的AES算法，字符串密钥和IV是否相同，加密后的数据是否统一为hex或base64格式。 Diffie-Hellman DH算法是一种密钥交换协议，它可以让双方在不泄漏密钥的情况下协商出一个密钥来。DH算法基于数学原理，比如小明和小红想要协商一个密钥，可以这么做： 小明先选一个素数和一个底数，例如，素数p=23，底数g=5（底数可以任选），再选择一个秘密整数a=6，计算A=g^a mod p=8，然后大声告诉小红：p=23，g=5，A=8； 小红收到小明发来的p，g，A后，也选一个秘密整数b=15，然后计算B=g^b mod p=19，并大声告诉小明：B=19； 小明自己计算出s=B^a mod p=2，小红也自己计算出s=A^b mod p=2，因此，最终协商的密钥s为2。 在这个过程中，密钥2并不是小明告诉小红的，也不是小红告诉小明的，而是双方协商计算出来的。第三方只能知道p=23，g=5，A=8，B=19，由于不知道双方选的秘密整数a=6和b=15，因此无法计算出密钥2。 用crypto模块实现DH算法如下：1234567891011121314151617181920212223const crypto = require(&apos;crypto&apos;);// xiaoming&apos;s keys:var ming = crypto.createDiffieHellman(512);var ming_keys = ming.generateKeys();var prime = ming.getPrime();var generator = ming.getGenerator();console.log(&apos;Prime: &apos; + prime.toString(&apos;hex&apos;));console.log(&apos;Generator: &apos; + generator.toString(&apos;hex&apos;));// xiaohong&apos;s keys:var hong = crypto.createDiffieHellman(prime, generator);var hong_keys = hong.generateKeys();// exchange and generate secret:var ming_secret = ming.computeSecret(hong_keys);var hong_secret = hong.computeSecret(ming_keys);// print secret:console.log(&apos;Secret of Xiao Ming: &apos; + ming_secret.toString(&apos;hex&apos;));console.log(&apos;Secret of Xiao Hong: &apos; + hong_secret.toString(&apos;hex&apos;)); 运行后，可以得到如下输出：12345$ node dh.js Prime: a8224c...deead3Generator: 02Secret of Xiao Ming: 695308...d519beSecret of Xiao Hong: 695308...d519be 注意每次输出都不一样，因为素数的选择是随机的。 证书crypto模块也可以处理数字证书。数字证书通常用在SSL连接，也就是Web的https连接。一般情况下，https连接只需要处理服务器端的单向认证，如无特殊需求（例如自己作为Root给客户发认证证书），建议用反向代理服务器如Nginx等Web服务器去处理证书。 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/29/node-document(1)/]]></content>
      <categories>
        <category>JS</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Node</tag>
        <tag>模块</tag>
        <tag>npm</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS构造函数及new运算符]]></title>
    <url>%2F2017%2F06%2F24%2Fcontructor-new(1)%2F</url>
    <content type="text"><![CDATA[JS中的函数即可以是构造函数又可以当作普通函数来调用，当使用new来创建对象时，对应的函数就是构造函数，通过对象来调用时就是普通函数。 普通函数的创建有：显式声明、匿名定义、new Function() 等三种方式。 当通过new来创建一个新对象时，JS底层将新对象的原型链指向了构造函数的原型对象，于是就在新对象和函数对象之间建立了一条原型链，通过新对象可以访问到函数对象原型prototype中的方法和属性。 和其他高级语言一样 Javascript 中也有构造函数和 new 运算符，我们知道 new 是用来实例化一个类，从而在内存中分配一个实例对象。 但在 Javascript 中，万物皆对象，为什么还要通过 new 来产生对象？ 本文将带你一起来探索 Javascript 中 new 的奥秘… 1、认识new运算符 1234567891011121314151617181920function Animal(name)&#123;this.name = name;&#125; Animal.color = &quot;black&quot;; Animal.prototype.say = function()&#123;console.log(&quot;I&apos;m &quot; + this.name); &#125;; var cat = new Animal(&quot;cat&quot;); console.log( cat.name, //cat cat.color //undefined ); cat.say(); //I&apos;m cat console.log( Animal.name, //Animal Animal.color //back ); Animal.say(); //Animal.say is not a function 2、代码解读 1-3行创建了一个函数Animal,并在其this上定义了属性:name,name的值是函数被执行时的形参。 第4行在Animal对象（Animal本身是一个函数对象）上定义了一个静态属性:color,并赋值“black” 5-7行在Animal函数的原型对象prototype上定义了一个say()方法，say方法输出了this的name值。 第8行通过new关键字创建了一个新对象cat 10-14行cat对象尝试访问name和color属性，并调用say方法。 16-20行Animal对象尝试访问name和color属性，并调用say方法。 3、重点解析 第8行代码是关键： var cat = new Animal(&quot;cat&quot;); Animal 本身是一个普通函数，但当通过new来创建对象时，Animal就是构造函数。JS引擎执行这句代码时，在内部做了很多工作，用伪代码模拟其工作流程如下： new Animal(&quot;cat&quot;) = { var obj = {}; obj.__proto__ = Animal.prototype; var result = Animal.call(obj,&quot;cat&quot;); return typeof result === &apos;object&apos;? result : obj; } （1）创建一个空对象obj; （2）把obj的__proto__指向构造函数Animal的原型对象prototype，此时便建立了obj对象的原型链：obj-&gt;Animal.prototype-&gt;Object.prototype-&gt;null （3）在obj对象的执行环境调用Animal 函数并传递参数“cat”。 相当于var result = obj.Animal(“cat”)。 （4）考察第3步返回的返回值，如果无返回值或者返回一个非对象值，则将obj返回作为新对象；否则会将返回值作为新对象返回。 理解了其运行机制以后，我们知道cat其实就是过程（4）的返回值，因此我们对cat对象的认知就多了一些： cat的原型链是：cat-&gt;Animal.prototype-&gt;Object.prototype-&gt;null cat上新增了一个属性：name 分析完了cat的产生过程，我们再看看输出结果： cat.name -&gt; 在过程（3）中，obj对象就产生了name属性。因此cat.name就是这里的obj.name cat.color -&gt; cat会先查找自身的color，没有找到便会沿着原型链查找，在上述例子中，我们仅在Animal对象上定义了color,并没有在其原型链上定义，因此找不到。 cat.say -&gt; cat会先查找自身的say方法，没有找到便会沿着原型链查找，在上述例子中，我们在Animal的prototype上定义了say,因此在原型链上找到了say方法。 另外，在say方法中还访问this.name，这里的this指的是其调用者obj,因此输出的是obj.name的值。 对于Animal来说，它本身也是一个对象，因此，它在访问属性和方法时也遵守上述查找规则，所以： Animal.color -&gt; “black” Animal.name -&gt; “Animal” , Animal先查找自身的name,找到了name, 但这个name不是我们定义的name,而是函数对象内置的属性。 一般情况下，函数对象在产生时会内置name属性并将函数名作为赋值（仅函数对象）。 Animal.say -&gt; Animal在自身没有找到say方法，也会沿着其原型链查找，话说Animal的原型链是什么呢？ 从测试结果看：Animal的原型链是这样的：Animal-&gt;Function.prototype-&gt;Object.prototype-&gt;null 因此Animal的原型链上没有定义say方法！ 4、new存在的意义认识了new运算符之后，我们再回到开篇提到的问题：JS中万物皆对象，为什么还要通过new来产生对象？ 要弄明白这个问题，我们首先要搞清楚cat和Animal的关系： 通过上面的分析，我们发现cat继承了Animal中的部分属性，因此我们可以简单的理解：Animal和cat是继承关系。 另一方面，cat是通过new产生的对象，那么cat到底是不是Animal的实例对象？ 我们先来了解一下JS是如何来定义“实例对象”的？ A instanceof B 如果上述表达式为true,JS认为A是B的实例对象，我们用这个方法来判断一下cat和Animal cat instanceof Animal; //true 从执行结果看：cat确实是Animal实例，要想证实这个结果，我们再来了解一下JS中instanceof的判断规则： var L = A.__proto__; var R = B.prototype; if(L === R) return true; 如果A的proto 等价于 B的prototype，就返回true 在new的执行过程（2）中，cat的proto指向了Animal的prototype，所以cat和Animal符合instanceof的判断结果。 因此，我们认为：cat 是Animal的实例对象。 5、总结在Javascript中, 通过new可以产生原对象的一个实例对象，而这个实例对象继承了原对象的属性和方法。因此，new存在的意义在于它实现了Javascript中的继承，而不仅仅是实例化了一个对象！ 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/24/contructor-new(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS构造函数及new运算符]]></title>
    <url>%2F2017%2F06%2F24%2Fcontructor-new%2F</url>
    <content type="text"><![CDATA[JS中的函数即可以是构造函数又可以当作普通函数来调用，当使用new来创建对象时，对应的函数就是构造函数，通过对象来调用时就是普通函数。 普通函数的创建有：显式声明、匿名定义、new Function() 等三种方式。 当通过new来创建一个新对象时，JS底层将新对象的原型链指向了构造函数的原型对象，于是就在新对象和函数对象之间建立了一条原型链，通过新对象可以访问到函数对象原型prototype中的方法和属性。 和其他高级语言一样 Javascript 中也有构造函数和 new 运算符，我们知道 new 是用来实例化一个类，从而在内存中分配一个实例对象。 但在 Javascript 中，万物皆对象，为什么还要通过 new 来产生对象？ 本文将带你一起来探索 Javascript 中 new 的奥秘… 1、认识new运算符 1234567891011121314151617181920function Animal(name)&#123;this.name = name;&#125; Animal.color = &quot;black&quot;; Animal.prototype.say = function()&#123;console.log(&quot;I&apos;m &quot; + this.name); &#125;; var cat = new Animal(&quot;cat&quot;); console.log( cat.name, //cat cat.color //undefined ); cat.say(); //I&apos;m cat console.log( Animal.name, //Animal Animal.color //back ); Animal.say(); //Animal.say is not a function 2、代码解读 1-3行创建了一个函数Animal,并在其this上定义了属性:name,name的值是函数被执行时的形参。 第4行在Animal对象（Animal本身是一个函数对象）上定义了一个静态属性:color,并赋值“black” 5-7行在Animal函数的原型对象prototype上定义了一个say()方法，say方法输出了this的name值。 第8行通过new关键字创建了一个新对象cat 10-14行cat对象尝试访问name和color属性，并调用say方法。 16-20行Animal对象尝试访问name和color属性，并调用say方法。 3、重点解析 第8行代码是关键： var cat = new Animal(&quot;cat&quot;); Animal 本身是一个普通函数，但当通过new来创建对象时，Animal就是构造函数。JS引擎执行这句代码时，在内部做了很多工作，用伪代码模拟其工作流程如下： new Animal(&quot;cat&quot;) = { var obj = {}; obj.__proto__ = Animal.prototype; var result = Animal.call(obj,&quot;cat&quot;); return typeof result === &apos;object&apos;? result : obj; } （1）创建一个空对象obj; （2）把obj的__proto__指向构造函数Animal的原型对象prototype，此时便建立了obj对象的原型链：obj-&gt;Animal.prototype-&gt;Object.prototype-&gt;null （3）在obj对象的执行环境调用Animal 函数并传递参数“cat”。 相当于var result = obj.Animal(“cat”)。 （4）考察第3步返回的返回值，如果无返回值或者返回一个非对象值，则将obj返回作为新对象；否则会将返回值作为新对象返回。 理解了其运行机制以后，我们知道cat其实就是过程（4）的返回值，因此我们对cat对象的认知就多了一些： cat的原型链是：cat-&gt;Animal.prototype-&gt;Object.prototype-&gt;null cat上新增了一个属性：name 分析完了cat的产生过程，我们再看看输出结果： cat.name -&gt; 在过程（3）中，obj对象就产生了name属性。因此cat.name就是这里的obj.name cat.color -&gt; cat会先查找自身的color，没有找到便会沿着原型链查找，在上述例子中，我们仅在Animal对象上定义了color,并没有在其原型链上定义，因此找不到。 cat.say -&gt; cat会先查找自身的say方法，没有找到便会沿着原型链查找，在上述例子中，我们在Animal的prototype上定义了say,因此在原型链上找到了say方法。 另外，在say方法中还访问this.name，这里的this指的是其调用者obj,因此输出的是obj.name的值。 对于Animal来说，它本身也是一个对象，因此，它在访问属性和方法时也遵守上述查找规则，所以： Animal.color -&gt; “black” Animal.name -&gt; “Animal” , Animal先查找自身的name,找到了name, 但这个name不是我们定义的name,而是函数对象内置的属性。 一般情况下，函数对象在产生时会内置name属性并将函数名作为赋值（仅函数对象）。 Animal.say -&gt; Animal在自身没有找到say方法，也会沿着其原型链查找，话说Animal的原型链是什么呢？ 从测试结果看：Animal的原型链是这样的：Animal-&gt;Function.prototype-&gt;Object.prototype-&gt;null 因此Animal的原型链上没有定义say方法！ 4、new存在的意义认识了new运算符之后，我们再回到开篇提到的问题：JS中万物皆对象，为什么还要通过new来产生对象？ 要弄明白这个问题，我们首先要搞清楚cat和Animal的关系： 通过上面的分析，我们发现cat继承了Animal中的部分属性，因此我们可以简单的理解：Animal和cat是继承关系。 另一方面，cat是通过new产生的对象，那么cat到底是不是Animal的实例对象？ 我们先来了解一下JS是如何来定义“实例对象”的？ A instanceof B 如果上述表达式为true,JS认为A是B的实例对象，我们用这个方法来判断一下cat和Animal cat instanceof Animal; //true 从执行结果看：cat确实是Animal实例，要想证实这个结果，我们再来了解一下JS中instanceof的判断规则： var L = A.__proto__; var R = B.prototype; if(L === R) return true; 如果A的proto 等价于 B的prototype，就返回true 在new的执行过程（2）中，cat的proto指向了Animal的prototype，所以cat和Animal符合instanceof的判断结果。 因此，我们认为：cat 是Animal的实例对象。 5、总结在Javascript中, 通过new可以产生原对象的一个实例对象，而这个实例对象继承了原对象的属性和方法。因此，new存在的意义在于它实现了Javascript中的继承，而不仅仅是实例化了一个对象！ 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/24/contructor-new/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JS执行细节]]></title>
    <url>%2F2017%2F06%2F24%2FGlobal-object-window%2F</url>
    <content type="text"><![CDATA[在JS中，当一段JS代码在浏览器中被加载执行，JS引擎会在内存中构建一个全局执行环境，执行环境的作用是保证所有的函数能按照正确的顺序被执行，而window对象则是这个执行环境中的一个全局对象，window对象中内置了很多操作api和对象，document对象就是其中一个 深入理解JS执行细节Javascript从定义到执行，JS引擎在实现层做了很多初始化工作，因此在学习JS引擎工作机制之前，我们需要引入几个相关的概念：执行环境栈、全局对象、执行环境、变量对象、活动对象、作用域和作用域链等，这些概念正是JS引擎工作的核心组件。这篇文章的目的不是孤立的为你讲解每一个概念，而是通过一个简单的DEMO来展开分析，全局讲解JS引擎从定义到执行的每一个细节，以及这些概念在其中所扮演的角色。 12345678910var x = 1; //定义一个全局变量 xfunction A(y)&#123; var x = 2; //定义一个局部变量 x function B(z)&#123; //定义一个内部函数 B console.log(x+y+z); &#125; return B; //返回函数B的引用&#125;var C = A(1); //执行A,返回BC(1); //执行函数B，输出 4 下面我们将分全局初始化、执行函数A、执行函数B 三个阶段来分析JS引擎的工作机制： 1、全局初始化JS引擎在进入一段可执行的代码时，需要完成以下三个初始化工作： 首先，创建一个全局对象(Global Object) ， 这个对象全局只存在一份，它的属性在任何地方都可以访问，它的存在伴随着应用程序的整个生命周期。全局对象在创建时，将Math,String,Date,document 等常用的JS对象作为其属性。由于这个全局对象不能通过名字直接访问，因此还有另外一个属性window,并将window指向了自身，这样就可以通过window访问这个全局对象了。用伪代码模拟全局对象的大体结构如下： 123456789//创建一个全局对象var globalObject = &#123; Math:&#123;&#125;, String:&#123;&#125;, Date:&#123;&#125;, document:&#123;&#125;, //DOM操作 ... window:this //让window属性指向了自身&#125; 然后，JS引擎需要构建一个执行环境栈( Execution Context Stack) ，与此同时，也要创建一个全局执行环境（Execution Context）EC ，并将这个全局执行环境EC压入执行环境栈中。执行环境栈的作用是为了保证程序能够按照正确的顺序被执行。在javascript中，每个函数都有自己的执行环境，当执行一个函数时，该函数的执行环境就会被推入执行环境栈的顶部并获取执行权。当这个函数执行完毕，它的执行环境又从这个栈的顶部被删除，并把执行权并还给之前执行环境。我们用伪代码来模拟执行环境栈和EC的关系： 12345678910ECStack = [ //执行环境栈 EC(G) = &#123; //全局执行环境 VO(G):&#123; //定义全局变量对象 ... //包含全局对象原有的属性 x = 1; //定义变量x A = function()&#123;...&#125;; //定义函数A A[[scope]] = this; //定义A的scope，并赋值为VO本身 &#125; &#125;]; 2、 执行函数A当执行进入A(1) 时，JS引擎需要完成以下工作： 首先，JS引擎会创建函数A的执行环境EC，然后EC推入执行环境栈的顶部并获取执行权。此时执行环境栈中有两个执行环境，分别是全局执行环境**和函数A执行环境，A的执行环境在栈顶，全局执行环境在栈的底部。然后，创建函数A的作用域链(Scope Chain) ，在javascript中，每个执行环境都有自己的作用域链，用于标识符解析，当执行环境被创建时，它的作用域链就初始化为当前运行函数的scope所包含的对象。 ** 接着，JS引擎会创建一个当前函数的活动对象(Activation Object) AO，这里的活动对象扮演着变量对象的角色，只是在函数中的叫法不同而已（你可以认为变量对象是一个总的概念，而活动对象是它的一个分支）， AO中包含了函数的形参、arguments对象、this对象、以及局部变量和内部函数的定义，然后AO会被推入作用域链的顶端。需要注意的是，在定义函数B的时候，JS引擎同样也会为B添加了一个scope属性,并将scope指向了定义函数B时所在的环境，定义函数B的环境就是A的活动对象AO， 而AO位于链表的前端，由于链表具有首尾相连的特点，因此函数B的scope指向了A的整个作用域链。 我们再看看此时的ECStack结构： 12345678910111213141516171819202122ECStack = [ //执行环境栈 EC(A) = &#123; //A的执行环境 [scope]:VO(G), //VO是全局变量对象 AO(A) : &#123; //创建函数A的活动对象 y:1, x:2, //定义局部变量x B:function()&#123;...&#125;, //定义函数B B[[scope]] = this; //this指代AO本身，而AO位于scopeChain的顶端，因此B[[scope]]指向整个作用域链 arguments:[],//平时我们在函数中访问的arguments就是AO中的arguments this:window //函数中的this指向调用者window对象 &#125;, scopeChain:&lt;AO(A),A[[scope]]&gt; //链表初始化为A[[scope]],然后再把AO加入该作用域链的顶端,此时A的作用域链：AO(A)-&gt;VO(G) &#125;, EC(G) = &#123; //全局执行环境 VO(G):&#123; //创建全局变量对象 ... //包含全局对象原有的属性 x = 1; //定义变量x A = function()&#123;...&#125;; //定义函数A A[[scope]] = this; //定义A的scope，A[[scope]] == VO(G) &#125; &#125;]; 3、 执行函数B函数A被执行以后，返回了B的引用，并赋值给了变量C，执行 C(1) 就相当于执行B(1)，JS引擎需要完成以下工作： 首先，还和上面一样，创建函数B的执行环境EC，然后EC推入执行环境栈的顶部并获取执行权。 此时执行环境栈中有两个执行环境，分别是全局执行环境和函数B的执行环境，B的执行环境在栈顶，全局执行环境在栈的底部。（注意：当函数A返回后，A的执行环境就会从栈中被删除，只留下全局执行环境）然后，创建函数B的作用域链，并初始化为函数B的scope所包含的对象，即包含了A的作用域链。最后，创建函数B的活动对象AO,并将B的形参z, arguments对象 和 this对象作为AO的属性。此时ECStack将会变成这样：1234567891011121314151617181920ECStack = [ //执行环境栈 EC(B) = &#123; //创建B的执行环境,并处于作用域链的顶端 [scope]:AO(A), //指向函数A的作用域链,AO(A)-&gt;VO(G) var AO(B) = &#123; //创建函数B的活动对象 z:1, arguments:[], this:window &#125; scopeChain:&lt;AO(B),B[[scope]]&gt; //链表初始化为B[[scope]],再将AO(B)加入链表表头，此时B的作用域链：AO(B)-&gt;AO(A)-VO(G) &#125;, EC(A), //A的执行环境已经从栈顶被删除, EC(G) = &#123; //全局执行环境 VO:&#123; //定义全局变量对象 ... //包含全局对象原有的属性 x = 1; //定义变量x A = function()&#123;...&#125;; //定义函数A A[[scope]] = this; //定义A的scope，A[[scope]] == VO(G) &#125; &#125;]; 当函数B执行“x+y+z”时，需要对x、y、z 三个标识符进行一一解析，解析过程遵守变量查找规则：先查找自己的活动对象中是否存在该属性，如果存在，则停止查找并返回；如果不存在，继续沿着其作用域链从顶端依次查找，直到找到为止，如果整个作用域链上都未找到该变量，则返回“undefined”。从上面的分析可以看出函数B的作用域链是这样的：1AO(B)-&gt;AO(A)-&gt;VO(G) 因此，变量x会在AO(A)中被找到，而不会查找VO(G)中的x，变量y也会在AO(A)中被找到，变量z 在自身的AO(B)中就找到了。所以执行结果：2+1+1=4 ps:var C = A(1); // 使y=1;C(1); //使z=1 4、总结了解了JS引擎的工作机制之后，我们不能只停留在理解概念的层面，而要将其作为基础工具，用以优化和改善我们在实际工作中的代码，提高执行效率，产生实际价值才是我们的真正目的。就拿变量查找机制来说，如果你的代码嵌套很深，每引用一次全局变量，JS引擎就要查找整个作用域链，比如处于作用域链的最底端window和document对象就存在这个问题，因此我们围绕这个问题可以做很多性能优化的工作，当然还有其他方面的优化，此处不再赘述，本文仅当作抛砖引玉吧！ 来源：一像素 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/24/Global-object-window/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS引擎</tag>
        <tag>作用域</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JS执行细节]]></title>
    <url>%2F2017%2F06%2F24%2FGlobal-object-window(1)%2F</url>
    <content type="text"><![CDATA[在JS中，当一段JS代码在浏览器中被加载执行，JS引擎会在内存中构建一个全局执行环境，执行环境的作用是保证所有的函数能按照正确的顺序被执行，而window对象则是这个执行环境中的一个全局对象，window对象中内置了很多操作api和对象，document对象就是其中一个 深入理解JS执行细节Javascript从定义到执行，JS引擎在实现层做了很多初始化工作，因此在学习JS引擎工作机制之前，我们需要引入几个相关的概念：执行环境栈、全局对象、执行环境、变量对象、活动对象、作用域和作用域链等，这些概念正是JS引擎工作的核心组件。这篇文章的目的不是孤立的为你讲解每一个概念，而是通过一个简单的DEMO来展开分析，全局讲解JS引擎从定义到执行的每一个细节，以及这些概念在其中所扮演的角色。 12345678910var x = 1; //定义一个全局变量 xfunction A(y)&#123; var x = 2; //定义一个局部变量 x function B(z)&#123; //定义一个内部函数 B console.log(x+y+z); &#125; return B; //返回函数B的引用&#125;var C = A(1); //执行A,返回BC(1); //执行函数B，输出 4 下面我们将分全局初始化、执行函数A、执行函数B 三个阶段来分析JS引擎的工作机制： 1、全局初始化JS引擎在进入一段可执行的代码时，需要完成以下三个初始化工作： 首先，创建一个全局对象(Global Object) ， 这个对象全局只存在一份，它的属性在任何地方都可以访问，它的存在伴随着应用程序的整个生命周期。全局对象在创建时，将Math,String,Date,document 等常用的JS对象作为其属性。由于这个全局对象不能通过名字直接访问，因此还有另外一个属性window,并将window指向了自身，这样就可以通过window访问这个全局对象了。用伪代码模拟全局对象的大体结构如下： 123456789//创建一个全局对象var globalObject = &#123; Math:&#123;&#125;, String:&#123;&#125;, Date:&#123;&#125;, document:&#123;&#125;, //DOM操作 ... window:this //让window属性指向了自身&#125; 然后，JS引擎需要构建一个执行环境栈( Execution Context Stack) ，与此同时，也要创建一个全局执行环境（Execution Context）EC ，并将这个全局执行环境EC压入执行环境栈中。执行环境栈的作用是为了保证程序能够按照正确的顺序被执行。在javascript中，每个函数都有自己的执行环境，当执行一个函数时，该函数的执行环境就会被推入执行环境栈的顶部并获取执行权。当这个函数执行完毕，它的执行环境又从这个栈的顶部被删除，并把执行权并还给之前执行环境。我们用伪代码来模拟执行环境栈和EC的关系： 12345678910ECStack = [ //执行环境栈 EC(G) = &#123; //全局执行环境 VO(G):&#123; //定义全局变量对象 ... //包含全局对象原有的属性 x = 1; //定义变量x A = function()&#123;...&#125;; //定义函数A A[[scope]] = this; //定义A的scope，并赋值为VO本身 &#125; &#125;]; 2、 执行函数A当执行进入A(1) 时，JS引擎需要完成以下工作： 首先，JS引擎会创建函数A的执行环境EC，然后EC推入执行环境栈的顶部并获取执行权。此时执行环境栈中有两个执行环境，分别是全局执行环境**和函数A执行环境，A的执行环境在栈顶，全局执行环境在栈的底部。然后，创建函数A的作用域链(Scope Chain) ，在javascript中，每个执行环境都有自己的作用域链，用于标识符解析，当执行环境被创建时，它的作用域链就初始化为当前运行函数的scope所包含的对象。 ** 接着，JS引擎会创建一个当前函数的活动对象(Activation Object) AO，这里的活动对象扮演着变量对象的角色，只是在函数中的叫法不同而已（你可以认为变量对象是一个总的概念，而活动对象是它的一个分支）， AO中包含了函数的形参、arguments对象、this对象、以及局部变量和内部函数的定义，然后AO会被推入作用域链的顶端。需要注意的是，在定义函数B的时候，JS引擎同样也会为B添加了一个scope属性,并将scope指向了定义函数B时所在的环境，定义函数B的环境就是A的活动对象AO， 而AO位于链表的前端，由于链表具有首尾相连的特点，因此函数B的scope指向了A的整个作用域链。 我们再看看此时的ECStack结构： 12345678910111213141516171819202122ECStack = [ //执行环境栈 EC(A) = &#123; //A的执行环境 [scope]:VO(G), //VO是全局变量对象 AO(A) : &#123; //创建函数A的活动对象 y:1, x:2, //定义局部变量x B:function()&#123;...&#125;, //定义函数B B[[scope]] = this; //this指代AO本身，而AO位于scopeChain的顶端，因此B[[scope]]指向整个作用域链 arguments:[],//平时我们在函数中访问的arguments就是AO中的arguments this:window //函数中的this指向调用者window对象 &#125;, scopeChain:&lt;AO(A),A[[scope]]&gt; //链表初始化为A[[scope]],然后再把AO加入该作用域链的顶端,此时A的作用域链：AO(A)-&gt;VO(G) &#125;, EC(G) = &#123; //全局执行环境 VO(G):&#123; //创建全局变量对象 ... //包含全局对象原有的属性 x = 1; //定义变量x A = function()&#123;...&#125;; //定义函数A A[[scope]] = this; //定义A的scope，A[[scope]] == VO(G) &#125; &#125;]; 3、 执行函数B函数A被执行以后，返回了B的引用，并赋值给了变量C，执行 C(1) 就相当于执行B(1)，JS引擎需要完成以下工作： 首先，还和上面一样，创建函数B的执行环境EC，然后EC推入执行环境栈的顶部并获取执行权。 此时执行环境栈中有两个执行环境，分别是全局执行环境和函数B的执行环境，B的执行环境在栈顶，全局执行环境在栈的底部。（注意：当函数A返回后，A的执行环境就会从栈中被删除，只留下全局执行环境）然后，创建函数B的作用域链，并初始化为函数B的scope所包含的对象，即包含了A的作用域链。最后，创建函数B的活动对象AO,并将B的形参z, arguments对象 和 this对象作为AO的属性。此时ECStack将会变成这样：1234567891011121314151617181920ECStack = [ //执行环境栈 EC(B) = &#123; //创建B的执行环境,并处于作用域链的顶端 [scope]:AO(A), //指向函数A的作用域链,AO(A)-&gt;VO(G) var AO(B) = &#123; //创建函数B的活动对象 z:1, arguments:[], this:window &#125; scopeChain:&lt;AO(B),B[[scope]]&gt; //链表初始化为B[[scope]],再将AO(B)加入链表表头，此时B的作用域链：AO(B)-&gt;AO(A)-VO(G) &#125;, EC(A), //A的执行环境已经从栈顶被删除, EC(G) = &#123; //全局执行环境 VO:&#123; //定义全局变量对象 ... //包含全局对象原有的属性 x = 1; //定义变量x A = function()&#123;...&#125;; //定义函数A A[[scope]] = this; //定义A的scope，A[[scope]] == VO(G) &#125; &#125;]; 当函数B执行“x+y+z”时，需要对x、y、z 三个标识符进行一一解析，解析过程遵守变量查找规则：先查找自己的活动对象中是否存在该属性，如果存在，则停止查找并返回；如果不存在，继续沿着其作用域链从顶端依次查找，直到找到为止，如果整个作用域链上都未找到该变量，则返回“undefined”。从上面的分析可以看出函数B的作用域链是这样的：1AO(B)-&gt;AO(A)-&gt;VO(G) 因此，变量x会在AO(A)中被找到，而不会查找VO(G)中的x，变量y也会在AO(A)中被找到，变量z 在自身的AO(B)中就找到了。所以执行结果：2+1+1=4 ps:var C = A(1); // 使y=1;C(1); //使z=1 4、总结了解了JS引擎的工作机制之后，我们不能只停留在理解概念的层面，而要将其作为基础工具，用以优化和改善我们在实际工作中的代码，提高执行效率，产生实际价值才是我们的真正目的。就拿变量查找机制来说，如果你的代码嵌套很深，每引用一次全局变量，JS引擎就要查找整个作用域链，比如处于作用域链的最底端window和document对象就存在这个问题，因此我们围绕这个问题可以做很多性能优化的工作，当然还有其他方面的优化，此处不再赘述，本文仅当作抛砖引玉吧！ 来源：一像素 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/24/Global-object-window(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS引擎</tag>
        <tag>作用域</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器同源政策及其规避方法]]></title>
    <url>%2F2017%2F06%2F24%2Fsame-origin-poolicy(1)%2F</url>
    <content type="text"><![CDATA[浏览器安全的基石是”同源政策”（same-origin policy）。很多开发者都知道这一点，但了解得不全面。本文详细介绍”同源政策”的各个方面，以及如何规避它。 一、概述1.1 含义1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”。所谓”同源”指的是”三个相同”。 协议相同 域名相同 端口相同 举例来说，http://www.example.com/dir/page.html这个网址，协议是http://，域名是www.example.com，端口是80（默认端口可以省略）。它的同源情况如下。 http://www.example.com/dir2/other.html：同源 http://example.com/dir/other.html：不同源（域名不同） http://v2.www.example.com/dir/other.html：不同源（域名不同） http://www.example.com:81/dir/other.html：不同源（端口不同） 1.2 目的同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。 1.3 限制范围随着互联网的发展，”同源政策”越来越严格。目前，如果非同源，共有三种行为受到限制。（1） Cookie、LocalStorage 和 IndexDB 无法读取。（2） DOM 无法获得。（3） AJAX 请求不能发送。 虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面，我将详细介绍，如何规避上面三种限制。 二、CookieCookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie。举例来说，A网页是http://w1.example.com/a.html，B网页是http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享Cookie。 1document.domain = &apos;example.com&apos;; 现在，A网页通过脚本设置一个 Cookie。1document.cookie = &quot;test1=hello&quot;; B网页就可以读到这个 Cookie。1var allCookie = document.cookie; 注意，这种方法只适用于Cookie 和iframe窗口，LocalStorage 和 IndexDB无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。 另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如.example.com。1Set-Cookie: key=value; domain=.example.com; path=/ 这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。 三、iframe如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。 比如，父窗口运行下面的命令，如果iframe窗口不是同源，就会报错。12document.getElementById(&quot;myIFrame&quot;).contentWindow.document// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame. 上面命令中，父窗口想获取子窗口的DOM，因为跨源导致报错。反之亦然，子窗口获取主窗口的DOM也会报错。12window.parent.document.body// 报错 如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的document.domain属性，就可以规避同源政策，拿到DOM。 对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。 片段识别符（fragment identifier） window.name 跨文档通信API（Cross-document messaging） 3.1 片段识别符片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。父窗口可以把信息，写入子窗口的片段标识符。 12var src = originURL + &apos;#&apos; + data;document.getElementById(&apos;myIFrame&apos;).src = src; 子窗口通过监听hashchange事件得到通知。123456window.onhashchange = checkMessage;function checkMessage() &#123; var message = window.location.hash; // ...&#125; 同样的，子窗口也可以改变父窗口的片段标识符。parent.location.href= target + &quot;#&quot; + hash; 3.2 window.name浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入window.name属性。1window.name = data; 接着，子窗口跳回一个与主窗口同域的网址。1location = &apos;http://parent.url.com/xxx.html&apos;; 然后，主窗口就可以读取子窗口的window.name了。1var data = document.getElementById(&apos;myFrame&apos;).contentWindow.name; 这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。 3.3 window.postMessage上面两种方法都属于破解，HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。举例来说，父窗口http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法就可以了。12var popup = window.open(&apos;http://bbb.com&apos;, &apos;title&apos;);popup.postMessage(&apos;Hello World!&apos;, &apos;http://bbb.com&apos;); postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即”协议 + 域名 + 端口”。也可以设为*，表示不限制域名，向所有窗口发送。子窗口向父窗口发送消息的写法类似。 1window.opener.postMessage(&apos;Nice to see you&apos;, &apos;http://aaa.com&apos;); 父窗口和子窗口都可以通过message事件，监听对方的消息。123window.addEventListener(&apos;message&apos;, function(e) &#123; console.log(e.data);&#125;,false); message事件的事件对象event，提供以下三个属性。 event.source：发送消息的窗口 event.origin: 消息发向的网址 event.data: 消息内容 下面的例子是，子窗口通过event.source属性引用父窗口，然后发送消息。1234window.addEventListener(&apos;message&apos;, receiveMessage);function receiveMessage(event) &#123; event.source.postMessage(&apos;Nice to see you!&apos;, &apos;*&apos;);&#125; event.origin属性可以过滤不是发给本窗口的消息。123456789window.addEventListener(&apos;message&apos;, receiveMessage);function receiveMessage(event) &#123; if (event.origin !== &apos;http://aaa.com&apos;) return; if (event.data === &apos;Hello World&apos;) &#123; event.source.postMessage(&apos;Hello&apos;, event.origin); &#125; else &#123; console.log(event.data); &#125;&#125; 3.4 LocalStorage通过window.postMessage，读写其他窗口的 LocalStorage也成为了可能。下面是一个例子，主窗口写入iframe子窗口的localStorage。1234567window.onmessage = function(e) &#123; if (e.origin !== &apos;http://bbb.com&apos;) &#123; return; &#125; var payload = JSON.parse(e.data); localStorage.setItem(payload.key, JSON.stringify(payload.data));&#125;; 上面代码中，子窗口将父窗口发来的消息，写入自己的LocalStorage。父窗口发送消息的代码如下。123var win = document.getElementsByTagName(&apos;iframe&apos;)[0].contentWindow;var obj = &#123; name: &apos;Jack&apos; &#125;;win.postMessage(JSON.stringify(&#123;key: &apos;storage&apos;, data: obj&#125;), &apos;http://bbb.com&apos;); 加强版的子窗口接收消息的代码如下。1234567891011121314151617window.onmessage = function(e) &#123; if (e.origin !== &apos;http://bbb.com&apos;) return; var payload = JSON.parse(e.data); switch (payload.method) &#123; case &apos;set&apos;: localStorage.setItem(payload.key, JSON.stringify(payload.data)); break; case &apos;get&apos;: var parent = window.parent; var data = localStorage.getItem(payload.key); parent.postMessage(data, &apos;http://aaa.com&apos;); break; case &apos;remove&apos;: localStorage.removeItem(payload.key); break; &#125;&#125;; 加强版的父窗口发送消息代码如下。1234567891011var win = document.getElementsByTagName(&apos;iframe&apos;)[0].contentWindow;var obj = &#123; name: &apos;Jack&apos; &#125;;// 存入对象win.postMessage(JSON.stringify(&#123;key: &apos;storage&apos;, method: &apos;set&apos;, data: obj&#125;), &apos;http://bbb.com&apos;);// 读取对象win.postMessage(JSON.stringify(&#123;key: &apos;storage&apos;, method: &quot;get&quot;&#125;), &quot;*&quot;);window.onmessage = function(e) &#123; if (e.origin != &apos;http://aaa.com&apos;) return; // &quot;Jack&quot; console.log(JSON.parse(e.data).name);&#125;; 四、AJAX同源政策规定，AJAX请求只能发给同源的网址，否则就报错。除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。 JSONP WebSocket CORS 4.1 JSONPJSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。它的基本思想是，网页通过添加一个&lt;script&gt;元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。 首先，网页动态插入&lt;script&gt;元素，由它向跨源网址发出请求。1234567891011121314function addScriptTag(src) &#123; var script = document.createElement(&apos;script&apos;); script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;); script.src = src; document.body.appendChild(script);&#125;window.onload = function () &#123; addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);&#125;function foo(data) &#123; console.log(&apos;Your public IP address is: &apos; + data.ip);&#125;; 上面代码通过动态添加&lt;script&gt;元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。 123foo(&#123; &quot;ip&quot;: &quot;8.8.8.8&quot;&#125;); 由于&lt;script&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 4.2 WebSocketWebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自维基百科）。12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat 4.3 CORSCORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。 详细CORS介绍的文章:如何通过CORS完成跨源AJAX请求 来源：阮一峰 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/24/same-origin-poolicy(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Jsonp</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器同源政策及其规避方法]]></title>
    <url>%2F2017%2F06%2F24%2Fsame-origin-poolicy%2F</url>
    <content type="text"><![CDATA[浏览器安全的基石是”同源政策”（same-origin policy）。很多开发者都知道这一点，但了解得不全面。本文详细介绍”同源政策”的各个方面，以及如何规避它。 一、概述1.1 含义1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”。所谓”同源”指的是”三个相同”。 协议相同 域名相同 端口相同 举例来说，http://www.example.com/dir/page.html这个网址，协议是http://，域名是www.example.com，端口是80（默认端口可以省略）。它的同源情况如下。 http://www.example.com/dir2/other.html：同源 http://example.com/dir/other.html：不同源（域名不同） http://v2.www.example.com/dir/other.html：不同源（域名不同） http://www.example.com:81/dir/other.html：不同源（端口不同） 1.2 目的同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。 1.3 限制范围随着互联网的发展，”同源政策”越来越严格。目前，如果非同源，共有三种行为受到限制。（1） Cookie、LocalStorage 和 IndexDB 无法读取。（2） DOM 无法获得。（3） AJAX 请求不能发送。 虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面，我将详细介绍，如何规避上面三种限制。 二、CookieCookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie。举例来说，A网页是http://w1.example.com/a.html，B网页是http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享Cookie。 1document.domain = &apos;example.com&apos;; 现在，A网页通过脚本设置一个 Cookie。1document.cookie = &quot;test1=hello&quot;; B网页就可以读到这个 Cookie。1var allCookie = document.cookie; 注意，这种方法只适用于Cookie 和iframe窗口，LocalStorage 和 IndexDB无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。 另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如.example.com。1Set-Cookie: key=value; domain=.example.com; path=/ 这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。 三、iframe如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。 比如，父窗口运行下面的命令，如果iframe窗口不是同源，就会报错。12document.getElementById(&quot;myIFrame&quot;).contentWindow.document// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame. 上面命令中，父窗口想获取子窗口的DOM，因为跨源导致报错。反之亦然，子窗口获取主窗口的DOM也会报错。12window.parent.document.body// 报错 如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的document.domain属性，就可以规避同源政策，拿到DOM。 对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。 片段识别符（fragment identifier） window.name 跨文档通信API（Cross-document messaging） 3.1 片段识别符片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。父窗口可以把信息，写入子窗口的片段标识符。 12var src = originURL + &apos;#&apos; + data;document.getElementById(&apos;myIFrame&apos;).src = src; 子窗口通过监听hashchange事件得到通知。123456window.onhashchange = checkMessage;function checkMessage() &#123; var message = window.location.hash; // ...&#125; 同样的，子窗口也可以改变父窗口的片段标识符。parent.location.href= target + &quot;#&quot; + hash; 3.2 window.name浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入window.name属性。1window.name = data; 接着，子窗口跳回一个与主窗口同域的网址。1location = &apos;http://parent.url.com/xxx.html&apos;; 然后，主窗口就可以读取子窗口的window.name了。1var data = document.getElementById(&apos;myFrame&apos;).contentWindow.name; 这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。 3.3 window.postMessage上面两种方法都属于破解，HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。举例来说，父窗口http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法就可以了。12var popup = window.open(&apos;http://bbb.com&apos;, &apos;title&apos;);popup.postMessage(&apos;Hello World!&apos;, &apos;http://bbb.com&apos;); postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即”协议 + 域名 + 端口”。也可以设为*，表示不限制域名，向所有窗口发送。子窗口向父窗口发送消息的写法类似。 1window.opener.postMessage(&apos;Nice to see you&apos;, &apos;http://aaa.com&apos;); 父窗口和子窗口都可以通过message事件，监听对方的消息。123window.addEventListener(&apos;message&apos;, function(e) &#123; console.log(e.data);&#125;,false); message事件的事件对象event，提供以下三个属性。 event.source：发送消息的窗口 event.origin: 消息发向的网址 event.data: 消息内容 下面的例子是，子窗口通过event.source属性引用父窗口，然后发送消息。1234window.addEventListener(&apos;message&apos;, receiveMessage);function receiveMessage(event) &#123; event.source.postMessage(&apos;Nice to see you!&apos;, &apos;*&apos;);&#125; event.origin属性可以过滤不是发给本窗口的消息。123456789window.addEventListener(&apos;message&apos;, receiveMessage);function receiveMessage(event) &#123; if (event.origin !== &apos;http://aaa.com&apos;) return; if (event.data === &apos;Hello World&apos;) &#123; event.source.postMessage(&apos;Hello&apos;, event.origin); &#125; else &#123; console.log(event.data); &#125;&#125; 3.4 LocalStorage通过window.postMessage，读写其他窗口的 LocalStorage也成为了可能。下面是一个例子，主窗口写入iframe子窗口的localStorage。1234567window.onmessage = function(e) &#123; if (e.origin !== &apos;http://bbb.com&apos;) &#123; return; &#125; var payload = JSON.parse(e.data); localStorage.setItem(payload.key, JSON.stringify(payload.data));&#125;; 上面代码中，子窗口将父窗口发来的消息，写入自己的LocalStorage。父窗口发送消息的代码如下。123var win = document.getElementsByTagName(&apos;iframe&apos;)[0].contentWindow;var obj = &#123; name: &apos;Jack&apos; &#125;;win.postMessage(JSON.stringify(&#123;key: &apos;storage&apos;, data: obj&#125;), &apos;http://bbb.com&apos;); 加强版的子窗口接收消息的代码如下。1234567891011121314151617window.onmessage = function(e) &#123; if (e.origin !== &apos;http://bbb.com&apos;) return; var payload = JSON.parse(e.data); switch (payload.method) &#123; case &apos;set&apos;: localStorage.setItem(payload.key, JSON.stringify(payload.data)); break; case &apos;get&apos;: var parent = window.parent; var data = localStorage.getItem(payload.key); parent.postMessage(data, &apos;http://aaa.com&apos;); break; case &apos;remove&apos;: localStorage.removeItem(payload.key); break; &#125;&#125;; 加强版的父窗口发送消息代码如下。1234567891011var win = document.getElementsByTagName(&apos;iframe&apos;)[0].contentWindow;var obj = &#123; name: &apos;Jack&apos; &#125;;// 存入对象win.postMessage(JSON.stringify(&#123;key: &apos;storage&apos;, method: &apos;set&apos;, data: obj&#125;), &apos;http://bbb.com&apos;);// 读取对象win.postMessage(JSON.stringify(&#123;key: &apos;storage&apos;, method: &quot;get&quot;&#125;), &quot;*&quot;);window.onmessage = function(e) &#123; if (e.origin != &apos;http://aaa.com&apos;) return; // &quot;Jack&quot; console.log(JSON.parse(e.data).name);&#125;; 四、AJAX同源政策规定，AJAX请求只能发给同源的网址，否则就报错。除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。 JSONP WebSocket CORS 4.1 JSONPJSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。它的基本思想是，网页通过添加一个&lt;script&gt;元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。 首先，网页动态插入&lt;script&gt;元素，由它向跨源网址发出请求。1234567891011121314function addScriptTag(src) &#123; var script = document.createElement(&apos;script&apos;); script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;); script.src = src; document.body.appendChild(script);&#125;window.onload = function () &#123; addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);&#125;function foo(data) &#123; console.log(&apos;Your public IP address is: &apos; + data.ip);&#125;; 上面代码通过动态添加&lt;script&gt;元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。 123foo(&#123; &quot;ip&quot;: &quot;8.8.8.8&quot;&#125;); 由于&lt;script&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 4.2 WebSocketWebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自维基百科）。12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat 4.3 CORSCORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。 详细CORS介绍的文章:如何通过CORS完成跨源AJAX请求 来源：阮一峰 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/24/same-origin-poolicy/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Jsonp</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域资源共享 CORS 详解]]></title>
    <url>%2F2017%2F06%2F24%2Fajax-1%2F</url>
    <content type="text"><![CDATA[Ajax是浏览器专门用来和服务器进行交互的异步通讯技术，其核心对象是XMLHttpRequest,通过该对象可以创建一个Ajax请求。 为了防止XSS攻击，浏览器对Ajax做了限制，不允许Ajax跨域请求服务器,就是只能访问当前域名下的url。 当然，如果确信你的站点不存在跨域的风险，可以在服务端主动开启跨域请求。 也可以直接通过CORS或JSONP来实现。 JSONP是利用脚本(script)跨域能力来模拟Ajax请求。 CORS是一个W3C标准，全称是”跨域资源共享“（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 本文详细介绍CORS的内部机制。一、简介CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 二、两种请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求。（1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。浏览器对这两种请求的处理，是不一样的。 三、简单请求3.1 基本流程对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。123456GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。 （1）Access-Control-Allow-Origin该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 （2）Access-Control-Allow-Credentials该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 （3）Access-Control-Expose-Headers该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。 3.2 withCredentials 属性上面说到，CORS请求默认不发送Cookie和HTTP认证信息。 如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。Access-Control-Allow-Credentials: true 另一方面，开发者必须在AJAX请求中打开withCredentials属性。12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。 xhr.withCredentials = false; 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 四、非简单请求4.1 预检请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。下面是一段浏览器的JavaScript脚本。12345var url = &apos;http://api.alice.com/cors&apos;;var xhr = new XMLHttpRequest();xhr.open(&apos;PUT&apos;, url, true);xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;);xhr.send(); 上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检“请求的HTTP头信息。12345678OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，”预检”请求的头信息包括两个特殊字段。 （1）Access-Control-Request-Method该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。（2）Access-Control-Request-Headers该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。 4.2 预检请求的回应服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 Access-Control-Allow-Origin: *如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。12XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他CORS相关字段如下。1234Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 （2）Access-Control-Allow-Headers如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 （3）Access-Control-Allow-Credentials该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 4.3 浏览器的正常请求和回应一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。下面是”预检”请求之后，浏览器的正常CORS请求。1234567PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面头信息的Origin字段是浏览器自动添加的。 下面是服务器正常的回应。12Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8 上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。 五、与JSONP的比较 CORS与JSONP的使用目的相同，但是比JSONP更强大。 JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 来源：阮一峰 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/24/ajax-1/]]></content>
      <categories>
        <category>JS</category>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Ajax</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域资源共享 CORS 详解]]></title>
    <url>%2F2017%2F06%2F24%2Fajax-1(1)%2F</url>
    <content type="text"><![CDATA[Ajax是浏览器专门用来和服务器进行交互的异步通讯技术，其核心对象是XMLHttpRequest,通过该对象可以创建一个Ajax请求。 为了防止XSS攻击，浏览器对Ajax做了限制，不允许Ajax跨域请求服务器,就是只能访问当前域名下的url。 当然，如果确信你的站点不存在跨域的风险，可以在服务端主动开启跨域请求。 也可以直接通过CORS或JSONP来实现。 JSONP是利用脚本(script)跨域能力来模拟Ajax请求。 CORS是一个W3C标准，全称是”跨域资源共享“（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 本文详细介绍CORS的内部机制。一、简介CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 二、两种请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求。（1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。浏览器对这两种请求的处理，是不一样的。 三、简单请求3.1 基本流程对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。123456GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。 （1）Access-Control-Allow-Origin该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 （2）Access-Control-Allow-Credentials该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 （3）Access-Control-Expose-Headers该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。 3.2 withCredentials 属性上面说到，CORS请求默认不发送Cookie和HTTP认证信息。 如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。Access-Control-Allow-Credentials: true 另一方面，开发者必须在AJAX请求中打开withCredentials属性。12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。 xhr.withCredentials = false; 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 四、非简单请求4.1 预检请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。下面是一段浏览器的JavaScript脚本。12345var url = &apos;http://api.alice.com/cors&apos;;var xhr = new XMLHttpRequest();xhr.open(&apos;PUT&apos;, url, true);xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;);xhr.send(); 上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检“请求的HTTP头信息。12345678OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，”预检”请求的头信息包括两个特殊字段。 （1）Access-Control-Request-Method该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。（2）Access-Control-Request-Headers该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。 4.2 预检请求的回应服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 Access-Control-Allow-Origin: *如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。12XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他CORS相关字段如下。1234Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 （2）Access-Control-Allow-Headers如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 （3）Access-Control-Allow-Credentials该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 4.3 浏览器的正常请求和回应一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。下面是”预检”请求之后，浏览器的正常CORS请求。1234567PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面头信息的Origin字段是浏览器自动添加的。 下面是服务器正常的回应。12Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8 上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。 五、与JSONP的比较 CORS与JSONP的使用目的相同，但是比JSONP更强大。 JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 来源：阮一峰 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/24/ajax-1(1)/]]></content>
      <categories>
        <category>JS</category>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Ajax</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2017%2F06%2F24%2FClosure%2F</url>
    <content type="text"><![CDATA[闭包其实是一个主动执行的代码块，这个代码块的特殊之处是可以永久保存局部变量，但又不污染全局变量，可以形成一个独立的执行过程，因此我们经常用闭包来定义组件。 让你分分钟学会JS闭包 闭包，是 Javascript 比较重要的一个概念，对于初学者来讲，闭包是一个特别抽象的概念，特别是ECMA规范给的定义，如果没有实战经验，很难从定义去理解它。因此，本文不会对闭包的概念进行大篇幅描述，直接上干货，让你分分钟学会闭包！ 1、闭包，一睹为快在接触一个新技术的时候，我首先会做的一件事就是找它的 demo。对于我们来说，看代码比自然语言更能理解一个事物的本质。其实，闭包无处不在，比如：jQuery、zepto的核心代码都包含在一个大的闭包中，所以下面我先写一个最简单最原始的闭包，以便让你在大脑里产生闭包的画面： 12345678function A()&#123; function B()&#123; console.log(&quot;Hello Closure!&quot;); &#125; return B;&#125;var C = A();C();//Hello Closure! 这是最简单的闭包。 有了初步认识后，我们简单分析一下它和普通函数有什么不同，上面代码翻译成自然语言如下： （1）定义普通函数 A （2）在 A 中定义普通函数 B （3）在 A 中返回 B （4）执行 A, 并把 A 的返回结果赋值给变量 C （5）执行 C 把这5步操作总结成一句话就是： 函数A的内部函数B被函数A外的一个变量 c 引用。 把这句话再加工一下就变成了闭包的定义：当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。 因此，当你执行上述5步操作时，就已经定义了一个闭包！ 这就是闭包。 2、 闭包的用途在了解闭包的作用之前，我们先了解一下 Javascript 中的GC机制: 在 Javascript 中，如果一个对象不再被引用，那么这个对象就会被 GC 回收，否则这个对象一直会保存在内存中。 在上述例子中，B 定义在 A 中，因此 B 依赖于 A ,而外部变量 C 又引用了 B , 所以A间接的被 C 引用。 也就是说，A 不会被 GC 回收，会一直保存在内存中。为了证明我们的推理，上面的例子稍作改进：123456789101112function A()&#123; var count = 0; function B()&#123; count ++; console.log(count); &#125; return B;&#125;var C = A();C();// 1C();// 2C();// 3 count 是函数A 中的一个变量，它的值在函数B 中被改变，函数B 每执行一次，count 的值就在原来的基础上累加 1 。因此，函数A中的 count 变量会一直保存在内存中。 当我们需要在模块中定义一些变量，并希望这些变量一直保存在内存中但又不会“污染”全局的变量时，就可以用闭包来定义这个模块。 3、 闭包的高级写法上面的写法其实是最原始的写法，而在实际应用中，会将闭包和匿名函数联系在一起使用。下面就是一个闭包常用的写法：123456789101112131415(function(document)&#123; var viewport; var obj = &#123; init:function(id)&#123; viewport = document.querySelector(&quot;#&quot;+id); &#125;, addChild:function(child)&#123; viewport.appendChild(child); &#125;, removeChild:function(child)&#123; viewport.removeChild(child); &#125; &#125; window.jView = obj;&#125;)(document); 这个组件的作用是：初始化一个容器，然后可以给这个容器添加子容器，也可以移除一个容器。 功能很简单，但这里涉及到了另外一个概念：立即执行函数。 简单了解一下就行，需要重点理解的是这种写法是如何实现闭包功能的。 可以将上面的代码拆分成两部分：(function(){}) 和() , 第1个() 是一个表达式，而这个表达式本身是一个匿名函数，所以在这个表达式后面加 () 就表示执行这个匿名函数。 因此这段代码执行执行过程可以分解如下：12345678910111213141516var f = function(document)&#123; var viewport; var obj = &#123; init:function(id)&#123; viewport = document.querySelector(&quot;#&quot;+id); &#125;, addChild:function(child)&#123; viewport.appendChild(child); &#125;, removeChild:function(child)&#123; viewport.removeChild(child); &#125; &#125; window.jView = obj;&#125;;f(document); 在这段代码中似乎看到了闭包的影子，但 f 中没有任何返回值，似乎不具备闭包的条件，注意这句代码：window.jView = obj; obj 是在函数 f 中定义的一个对象，这个对象中定义了一系列方法， 执行window.jView = obj 就是在 window 全局对象定义了一个变量 jView，并将这个变量指向 obj 对象，即全局变量 jView 引用了 obj . 而 obj 对象中的函数又引用了函数 f 中的变量 viewport ,因此函数 f 中的 viewport 不会被 GC 回收，viewport 会一直保存到内存中，所以这种写法满足了闭包的条件。 4、 总结语这是对闭包最简单的理解，当然闭包还有其更深层次的理解，这个就涉及的多了，你需要了解JS的执行环境(execution context)、活动对象(activation object)以及作用域(scope)和作用域链(scope chain)的运行机制。但作为初学者，暂时不必了解这些，有了简单的理解之后，一定要在实际项目中用起来，等你用的多了，对于闭包，你自然会有更深层次的理解！ 来源：一像素 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/24/Closure/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2017%2F06%2F24%2FClosure(1)%2F</url>
    <content type="text"><![CDATA[闭包其实是一个主动执行的代码块，这个代码块的特殊之处是可以永久保存局部变量，但又不污染全局变量，可以形成一个独立的执行过程，因此我们经常用闭包来定义组件。 让你分分钟学会JS闭包 闭包，是 Javascript 比较重要的一个概念，对于初学者来讲，闭包是一个特别抽象的概念，特别是ECMA规范给的定义，如果没有实战经验，很难从定义去理解它。因此，本文不会对闭包的概念进行大篇幅描述，直接上干货，让你分分钟学会闭包！ 1、闭包，一睹为快在接触一个新技术的时候，我首先会做的一件事就是找它的 demo。对于我们来说，看代码比自然语言更能理解一个事物的本质。其实，闭包无处不在，比如：jQuery、zepto的核心代码都包含在一个大的闭包中，所以下面我先写一个最简单最原始的闭包，以便让你在大脑里产生闭包的画面： 12345678function A()&#123; function B()&#123; console.log(&quot;Hello Closure!&quot;); &#125; return B;&#125;var C = A();C();//Hello Closure! 这是最简单的闭包。 有了初步认识后，我们简单分析一下它和普通函数有什么不同，上面代码翻译成自然语言如下： （1）定义普通函数 A （2）在 A 中定义普通函数 B （3）在 A 中返回 B （4）执行 A, 并把 A 的返回结果赋值给变量 C （5）执行 C 把这5步操作总结成一句话就是： 函数A的内部函数B被函数A外的一个变量 c 引用。 把这句话再加工一下就变成了闭包的定义：当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。 因此，当你执行上述5步操作时，就已经定义了一个闭包！ 这就是闭包。 2、 闭包的用途在了解闭包的作用之前，我们先了解一下 Javascript 中的GC机制: 在 Javascript 中，如果一个对象不再被引用，那么这个对象就会被 GC 回收，否则这个对象一直会保存在内存中。 在上述例子中，B 定义在 A 中，因此 B 依赖于 A ,而外部变量 C 又引用了 B , 所以A间接的被 C 引用。 也就是说，A 不会被 GC 回收，会一直保存在内存中。为了证明我们的推理，上面的例子稍作改进：123456789101112function A()&#123; var count = 0; function B()&#123; count ++; console.log(count); &#125; return B;&#125;var C = A();C();// 1C();// 2C();// 3 count 是函数A 中的一个变量，它的值在函数B 中被改变，函数B 每执行一次，count 的值就在原来的基础上累加 1 。因此，函数A中的 count 变量会一直保存在内存中。 当我们需要在模块中定义一些变量，并希望这些变量一直保存在内存中但又不会“污染”全局的变量时，就可以用闭包来定义这个模块。 3、 闭包的高级写法上面的写法其实是最原始的写法，而在实际应用中，会将闭包和匿名函数联系在一起使用。下面就是一个闭包常用的写法：123456789101112131415(function(document)&#123; var viewport; var obj = &#123; init:function(id)&#123; viewport = document.querySelector(&quot;#&quot;+id); &#125;, addChild:function(child)&#123; viewport.appendChild(child); &#125;, removeChild:function(child)&#123; viewport.removeChild(child); &#125; &#125; window.jView = obj;&#125;)(document); 这个组件的作用是：初始化一个容器，然后可以给这个容器添加子容器，也可以移除一个容器。 功能很简单，但这里涉及到了另外一个概念：立即执行函数。 简单了解一下就行，需要重点理解的是这种写法是如何实现闭包功能的。 可以将上面的代码拆分成两部分：(function(){}) 和() , 第1个() 是一个表达式，而这个表达式本身是一个匿名函数，所以在这个表达式后面加 () 就表示执行这个匿名函数。 因此这段代码执行执行过程可以分解如下：12345678910111213141516var f = function(document)&#123; var viewport; var obj = &#123; init:function(id)&#123; viewport = document.querySelector(&quot;#&quot;+id); &#125;, addChild:function(child)&#123; viewport.appendChild(child); &#125;, removeChild:function(child)&#123; viewport.removeChild(child); &#125; &#125; window.jView = obj;&#125;;f(document); 在这段代码中似乎看到了闭包的影子，但 f 中没有任何返回值，似乎不具备闭包的条件，注意这句代码：window.jView = obj; obj 是在函数 f 中定义的一个对象，这个对象中定义了一系列方法， 执行window.jView = obj 就是在 window 全局对象定义了一个变量 jView，并将这个变量指向 obj 对象，即全局变量 jView 引用了 obj . 而 obj 对象中的函数又引用了函数 f 中的变量 viewport ,因此函数 f 中的 viewport 不会被 GC 回收，viewport 会一直保存到内存中，所以这种写法满足了闭包的条件。 4、 总结语这是对闭包最简单的理解，当然闭包还有其更深层次的理解，这个就涉及的多了，你需要了解JS的执行环境(execution context)、活动对象(activation object)以及作用域(scope)和作用域链(scope chain)的运行机制。但作为初学者，暂时不必了解这些，有了简单的理解之后，一定要在实际项目中用起来，等你用的多了，对于闭包，你自然会有更深层次的理解！ 来源：一像素 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/24/Closure(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解JS的call,apply和bind]]></title>
    <url>%2F2017%2F06%2F20%2F%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88-this(1)%2F</url>
    <content type="text"><![CDATA[Function对象还提供了call、apply和bind等方法来改变函数的this指向，其中call和apply主动执行函数，bind一般在事件回调中使用，而call和apply的区别只是参数的传递方式不同 深入理解call,apply和bind在JavaScript 中，call、apply 和 bind 是 Function 对象自带的三个方法，这三个方法的主要作用是改变函数中的 this 指向，从而可以达到接花移木的效果。本文将对这三个方法进行详细的讲解，并列出几个经典应用场景。 1、call(thisArgs [,args…])该方法可以传递一个thisArgs参数和一个参数列表，thisArgs 指定了函数在运行期的调用者，也就是函数中的 this 对象，而参数列表会被传入调用函数中。thisArgs 的取值有以下4种情况：（1） 不传，或者传null,undefined， 函数中的 this 指向 window 对象 （2） 传递另一个函数的函数名，函数中的 this 指向这个函数的引用 （3） 传递字符串、数值或布尔类型等基础类型，函数中的 this 指向其对应的包装对象，如 String、Number、Boolean （4） 传递一个对象，函数中的 this 指向这个对象 function a(){ console.log(this); //输出函数a中的this对象 } function b(){} //定义函数b var obj = {name:&apos;onepixel&apos;}; //定义对象obj a.call(); //window a.call(null); //window a.call(undefined);//window a.call(1); //Number a.call(&apos;&apos;); //String a.call(true); //Boolean a.call(b);// function b(){} a.call(obj); //Object 这是call 的核心功能，它允许你在一个对象上调用该对象没有定义的方法，并且这个方法可以访问该对象中的属性，至于这样做有什么好处，我待会再讲，我们先看一个简单的例子： var a = { name:&apos;onepixel&apos;, //定义a的属性 say:function(){ //定义a的方法 console.log(&quot;Hi,I&apos;m function a!&quot;); } }; function b(name){ console.log(&quot;Post params: &quot;+ name); console.log(&quot;I&apos;m &quot;+ this.name); this.say(); } b.call(a,&apos;test&apos;); &gt;&gt; Post params: test I&apos;m onepixel I&apos;m function a! 当执行b.call 时，字符串test作为参数传递给了函数b,由于call的作用，函数b中的this指向了对象a, 因此相当于调用了对象a上的函数b,而实际上a中没有定义b 。 2、apply(thisArgs[,args[]])apply 和 call 的唯一区别是第二个参数的传递方式不同，apply 的第二个参数必须是一个数组，而 call 允许传递一个参数列表。值得你注意的是，虽然 apply 接收的是一个参数数组，但在传递给调用函数时，却是以参数列表的形式传递，我们看个简单的例子： function b(x,y,z){ console.log(x,y,z); } b.apply(null,[1,2,3]); // 1 2 3 apply 的这个特性很重要，我们会在下面的应用场景中提到这个特性。 3、bind(thisArgs [,args…])bind是ES5 新增的一个方法，它的传参和call类似，但又和 call/apply 有着显著的不同，即调用 call 或 apply 都会自动执行对应的函数，而 bind 不会执行对应的函数，只是返回了对函数的引用。粗略一看，bind 似乎比call/apply 要落后一些，那ES5为什么还要引入bind 呢？ 其实，ES5引入 bind 的真正目的是为了弥补 call/apply 的不足，由于 call/apply 会对目标函数自动执行，从而导致它无法在事件绑定函数中使用，因为事件绑定函数不需要我们手动执行，它是在事件被触发时由JS 内部自动执行的。而 bind 在实现改变函数 this 的同时又不会自动执行目标函数，因此可以完美的解决上述问题，看一个例子就能明白： var obj = {name:&apos;onepixel&apos;}; /** * 给document添加click事件监听，并绑定onClick函数 * 通过bind方法设置onClick的this为obj，并传递参数p1,p2 */ document.addEventListener(&apos;click&apos;,onClick.bind(obj,&apos;p1&apos;,&apos;p2&apos;),false); //当点击网页时触发并执行 function onClick(a,b){ console.log( this.name, //onepixel a, //p1 b //p2 ) } 当点击网页时，onClick 被触发执行，输出onepixel p1 p2, 说明 onClick 中的 this 被 bind 改变成了obj 对象，为了对 bind 进行深入的理解，我们来看一下 bind 的polyfill 实现： if (!Function.prototype.bind) { Function.prototype.bind = function (oThis) { var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, //this在这里指向的是目标函数 fBound = function () { return fToBind.apply( //如果外部执行var obj = new fBound(),则将obj作为最终的this，放弃使用oThis this instanceof fToBind ? this //此时的this就是new出的obj : oThis || this, //如果传递的oThis无效，就将fBound的调用者作为this //将通过bind传递的参数和调用时传递的参数进行合并，并作为最终的参数传递 aArgs.concat(Array.prototype.slice.call(arguments))); }; //将目标函数的原型对象拷贝到新函数中，因为目标函数有可能被当作构造函数使用 fBound.prototype = this.prototype; //返回fBond的引用，由外部按需调用 return fBound; }; } 一旦函数通过bind传递了有效的this对象，则该函数在运行期的this将指向这个对象，即使通过call或apply来试图改变this的指向也是徒劳的。 //实现数组的去重功能 Array.prototype.unique = function(fn) { var rst = []; var tmp = {}; this.forEach(function(val) { //使用call来改变fn的this指向，这里传window var key = &apos;uniq&apos; + (typeof fn === &apos;function&apos; ? fn.call(window, val) : val); if (!tmp.hasOwnProperty(key)) { rst.push(val); tmp[key] = null; } }, this); return rst; } //对象数组去重 var arr = [ { id: 2 }, { id: 4 }, { id: 3 }, { id: 3 }, { id: 4 }, { id: 6 } ] arr.unique(function(v) { console.log(this) //使用bind传递了Array,则this一定是Array,而不会是window return v.id }.bind(Array)); 4、应用场景一：继承大家知道，JavaScript中没有诸如Java、C# 等高级语言中的extend 关键字，因此JS 中没有继承的概念，如果一定要继承的话，call 和 apply 可以实现这个功能： function Animal(name,weight){ this.name = name; this.weight = weight; } function Cat(){ Animal.call(this,&apos;cat&apos;,&apos;50&apos;); //Animal.apply(this,[&apos;cat&apos;,&apos;50&apos;]); this.say = function(){ console.log(&quot;I am &quot; + this.name+&quot;,my weight is &quot; + this.weight); } } var cat = new Cat(); cat.say();//I am cat,my weight is 50 当通过new 运算符产生了cat 时，Cat中的 this 就指向了cat对象(关于new运算符的讲解，请参考JS构造函数和new运算符，而继承的关键是在于Cat中执行了Animal.call(this,’cat’,’50’) 这句话，在call中将this作为thisArgs参数传递，于是Animal 方法中的 this 就指向了Cat中的 this，而 cat 中的 this 指向的是 cat 对象，所以Animal 中的 this 指向的就是 cat 对象，在 Animal 中定义了name 和 weight 属性，就相当于在 cat 中定义了这些属性，因此 cat 对象便拥有了Animal 中定义的属性，从而达到了继承的目的。 5、应用场景二：移花接木在讲下面的内容之前，我们首先来认识一下JavaScript 中的一个非标准专业术语：ArrayLike (类数组/伪数组) ArrayLike 对象即拥有数组的一部分行为，在DOM 中早已表现出来，而jQuery 的崛起让ArrayLike 在JavaScript 中大放异彩。ArrayLike 对象的精妙在于它和JS 原生的 Array 类似，但是它是自由构建的，它来自开发者对JavaScript 对象的扩展，也就是说：对于它的原型(prototype)我们可以自由定义，而不会污染到JS原生的Array。 ArrayLike 对象在JS中被广泛使用，比如DOM 中的NodeList, 函数中的arguments 都是类数组对象，这些对象像数组一样存储着每一个元素，但它没有操作数组的方法，而我们可以通过call 将数组的某些方法移接到ArrayLike 对象，从而达到操作其元素的目的。比如我们可以这样遍历函数中的arguments: function test(){ //检测arguments是否为Array的实例 console.log( arguments instanceof Array, //false Array.isArray(arguments) //false ); //判断arguments是否有forEach方法 console.log(arguments.forEach); //undefined // 将数组中的forEach应用到arguments上 Array.prototype.forEach.call(arguments,function(item){ console.log(item); // 1 2 3 4 }); } test(1,2,3,4); 除此之外，对于apply 而言，我们上面提到了它独有的一个特性，即apply 接收的是数组，在传递给调用函数的时候是以参数列表传递的。 这个特性让apply 看起来比call 略胜一筹，比如有这样一个场景：给定一个数组[1,3,4,7]，然后求数组中的最大元素，而我们知道，数组中并没有获取最大值的方法，一般情况下，你需要通过编写代码来实现。而我们知道，Math 对象中有一个获取最大值的方法，即Math.max()， max方法需要传递一个参数列表，然后返回这些参数中的最大值。而apply 不仅可以将Math 对象的max 方法应用到其他对象上，还可以将一个数组转化为参数列表传递给max,看代码就能一目了然： var arr = [2,3,1,5,4]; Math.max.apply(null,arr); // 5 以上便是call 和apply 比较经典的几个应用场景，熟练掌握这些技巧，并把这些特性应用到你的实际项目中，会使你的代码看起来更加耐人寻味！ 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/20/函数指针-this(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>函数</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解JS的call,apply和bind]]></title>
    <url>%2F2017%2F06%2F20%2F%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88-this%2F</url>
    <content type="text"><![CDATA[Function对象还提供了call、apply和bind等方法来改变函数的this指向，其中call和apply主动执行函数，bind一般在事件回调中使用，而call和apply的区别只是参数的传递方式不同 深入理解call,apply和bind在JavaScript 中，call、apply 和 bind 是 Function 对象自带的三个方法，这三个方法的主要作用是改变函数中的 this 指向，从而可以达到接花移木的效果。本文将对这三个方法进行详细的讲解，并列出几个经典应用场景。 1、call(thisArgs [,args…])该方法可以传递一个thisArgs参数和一个参数列表，thisArgs 指定了函数在运行期的调用者，也就是函数中的 this 对象，而参数列表会被传入调用函数中。thisArgs 的取值有以下4种情况：（1） 不传，或者传null,undefined， 函数中的 this 指向 window 对象 （2） 传递另一个函数的函数名，函数中的 this 指向这个函数的引用 （3） 传递字符串、数值或布尔类型等基础类型，函数中的 this 指向其对应的包装对象，如 String、Number、Boolean （4） 传递一个对象，函数中的 this 指向这个对象 function a(){ console.log(this); //输出函数a中的this对象 } function b(){} //定义函数b var obj = {name:&apos;onepixel&apos;}; //定义对象obj a.call(); //window a.call(null); //window a.call(undefined);//window a.call(1); //Number a.call(&apos;&apos;); //String a.call(true); //Boolean a.call(b);// function b(){} a.call(obj); //Object 这是call 的核心功能，它允许你在一个对象上调用该对象没有定义的方法，并且这个方法可以访问该对象中的属性，至于这样做有什么好处，我待会再讲，我们先看一个简单的例子： var a = { name:&apos;onepixel&apos;, //定义a的属性 say:function(){ //定义a的方法 console.log(&quot;Hi,I&apos;m function a!&quot;); } }; function b(name){ console.log(&quot;Post params: &quot;+ name); console.log(&quot;I&apos;m &quot;+ this.name); this.say(); } b.call(a,&apos;test&apos;); &gt;&gt; Post params: test I&apos;m onepixel I&apos;m function a! 当执行b.call 时，字符串test作为参数传递给了函数b,由于call的作用，函数b中的this指向了对象a, 因此相当于调用了对象a上的函数b,而实际上a中没有定义b 。 2、apply(thisArgs[,args[]])apply 和 call 的唯一区别是第二个参数的传递方式不同，apply 的第二个参数必须是一个数组，而 call 允许传递一个参数列表。值得你注意的是，虽然 apply 接收的是一个参数数组，但在传递给调用函数时，却是以参数列表的形式传递，我们看个简单的例子： function b(x,y,z){ console.log(x,y,z); } b.apply(null,[1,2,3]); // 1 2 3 apply 的这个特性很重要，我们会在下面的应用场景中提到这个特性。 3、bind(thisArgs [,args…])bind是ES5 新增的一个方法，它的传参和call类似，但又和 call/apply 有着显著的不同，即调用 call 或 apply 都会自动执行对应的函数，而 bind 不会执行对应的函数，只是返回了对函数的引用。粗略一看，bind 似乎比call/apply 要落后一些，那ES5为什么还要引入bind 呢？ 其实，ES5引入 bind 的真正目的是为了弥补 call/apply 的不足，由于 call/apply 会对目标函数自动执行，从而导致它无法在事件绑定函数中使用，因为事件绑定函数不需要我们手动执行，它是在事件被触发时由JS 内部自动执行的。而 bind 在实现改变函数 this 的同时又不会自动执行目标函数，因此可以完美的解决上述问题，看一个例子就能明白： var obj = {name:&apos;onepixel&apos;}; /** * 给document添加click事件监听，并绑定onClick函数 * 通过bind方法设置onClick的this为obj，并传递参数p1,p2 */ document.addEventListener(&apos;click&apos;,onClick.bind(obj,&apos;p1&apos;,&apos;p2&apos;),false); //当点击网页时触发并执行 function onClick(a,b){ console.log( this.name, //onepixel a, //p1 b //p2 ) } 当点击网页时，onClick 被触发执行，输出onepixel p1 p2, 说明 onClick 中的 this 被 bind 改变成了obj 对象，为了对 bind 进行深入的理解，我们来看一下 bind 的polyfill 实现： if (!Function.prototype.bind) { Function.prototype.bind = function (oThis) { var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, //this在这里指向的是目标函数 fBound = function () { return fToBind.apply( //如果外部执行var obj = new fBound(),则将obj作为最终的this，放弃使用oThis this instanceof fToBind ? this //此时的this就是new出的obj : oThis || this, //如果传递的oThis无效，就将fBound的调用者作为this //将通过bind传递的参数和调用时传递的参数进行合并，并作为最终的参数传递 aArgs.concat(Array.prototype.slice.call(arguments))); }; //将目标函数的原型对象拷贝到新函数中，因为目标函数有可能被当作构造函数使用 fBound.prototype = this.prototype; //返回fBond的引用，由外部按需调用 return fBound; }; } 一旦函数通过bind传递了有效的this对象，则该函数在运行期的this将指向这个对象，即使通过call或apply来试图改变this的指向也是徒劳的。 //实现数组的去重功能 Array.prototype.unique = function(fn) { var rst = []; var tmp = {}; this.forEach(function(val) { //使用call来改变fn的this指向，这里传window var key = &apos;uniq&apos; + (typeof fn === &apos;function&apos; ? fn.call(window, val) : val); if (!tmp.hasOwnProperty(key)) { rst.push(val); tmp[key] = null; } }, this); return rst; } //对象数组去重 var arr = [ { id: 2 }, { id: 4 }, { id: 3 }, { id: 3 }, { id: 4 }, { id: 6 } ] arr.unique(function(v) { console.log(this) //使用bind传递了Array,则this一定是Array,而不会是window return v.id }.bind(Array)); 4、应用场景一：继承大家知道，JavaScript中没有诸如Java、C# 等高级语言中的extend 关键字，因此JS 中没有继承的概念，如果一定要继承的话，call 和 apply 可以实现这个功能： function Animal(name,weight){ this.name = name; this.weight = weight; } function Cat(){ Animal.call(this,&apos;cat&apos;,&apos;50&apos;); //Animal.apply(this,[&apos;cat&apos;,&apos;50&apos;]); this.say = function(){ console.log(&quot;I am &quot; + this.name+&quot;,my weight is &quot; + this.weight); } } var cat = new Cat(); cat.say();//I am cat,my weight is 50 当通过new 运算符产生了cat 时，Cat中的 this 就指向了cat对象(关于new运算符的讲解，请参考JS构造函数和new运算符，而继承的关键是在于Cat中执行了Animal.call(this,’cat’,’50’) 这句话，在call中将this作为thisArgs参数传递，于是Animal 方法中的 this 就指向了Cat中的 this，而 cat 中的 this 指向的是 cat 对象，所以Animal 中的 this 指向的就是 cat 对象，在 Animal 中定义了name 和 weight 属性，就相当于在 cat 中定义了这些属性，因此 cat 对象便拥有了Animal 中定义的属性，从而达到了继承的目的。 5、应用场景二：移花接木在讲下面的内容之前，我们首先来认识一下JavaScript 中的一个非标准专业术语：ArrayLike (类数组/伪数组) ArrayLike 对象即拥有数组的一部分行为，在DOM 中早已表现出来，而jQuery 的崛起让ArrayLike 在JavaScript 中大放异彩。ArrayLike 对象的精妙在于它和JS 原生的 Array 类似，但是它是自由构建的，它来自开发者对JavaScript 对象的扩展，也就是说：对于它的原型(prototype)我们可以自由定义，而不会污染到JS原生的Array。 ArrayLike 对象在JS中被广泛使用，比如DOM 中的NodeList, 函数中的arguments 都是类数组对象，这些对象像数组一样存储着每一个元素，但它没有操作数组的方法，而我们可以通过call 将数组的某些方法移接到ArrayLike 对象，从而达到操作其元素的目的。比如我们可以这样遍历函数中的arguments: function test(){ //检测arguments是否为Array的实例 console.log( arguments instanceof Array, //false Array.isArray(arguments) //false ); //判断arguments是否有forEach方法 console.log(arguments.forEach); //undefined // 将数组中的forEach应用到arguments上 Array.prototype.forEach.call(arguments,function(item){ console.log(item); // 1 2 3 4 }); } test(1,2,3,4); 除此之外，对于apply 而言，我们上面提到了它独有的一个特性，即apply 接收的是数组，在传递给调用函数的时候是以参数列表传递的。 这个特性让apply 看起来比call 略胜一筹，比如有这样一个场景：给定一个数组[1,3,4,7]，然后求数组中的最大元素，而我们知道，数组中并没有获取最大值的方法，一般情况下，你需要通过编写代码来实现。而我们知道，Math 对象中有一个获取最大值的方法，即Math.max()， max方法需要传递一个参数列表，然后返回这些参数中的最大值。而apply 不仅可以将Math 对象的max 方法应用到其他对象上，还可以将一个数组转化为参数列表传递给max,看代码就能一目了然： var arr = [2,3,1,5,4]; Math.max.apply(null,arr); // 5 以上便是call 和apply 比较经典的几个应用场景，熟练掌握这些技巧，并把这些特性应用到你的实际项目中，会使你的代码看起来更加耐人寻味！ 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/20/函数指针-this/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>函数</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 之函数原型链]]></title>
    <url>%2F2017%2F06%2F20%2FJS-%E4%B9%8B%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E9%93%BE(1)%2F</url>
    <content type="text"><![CDATA[在Javascript中，万物皆对象，但对象也有区别，大致可以分为两类，即：普通对象Object 和 函数对象Function。一般而言，通过new Function产生的对象是函数对象，其他对象都是普通对象。 JS原型对象和原型链 一般而言，通过new Function产生的对象是函数对象，其他对象都是普通对象。栗子： function f1(){ //todo } var f2 = function(){ //todo }; var f3 = new Function(&apos;x&apos;,&apos;console.log(x)&apos;); var o1 = {}; var o2 = new Object(); var o3 = new f1(); console.log( typeof f1,//function typeof f2,//function typeof f3,//function typeof o1,//object typeof o2,//object typeof o3 //object ); &gt;&gt; function function function object object object f1属于函数的声明，最常见的函数定义方式，f2实际上是一个匿名函数，把这个匿名函数赋值给了f2,属于函数表达式，f3不常见，但也是一种函数对象。f1属于函数的声明，最常见的函数定义方式，f2实际上是一个匿名函数，把这个匿名函数赋值给了f2,属于函数表达式，f3不常见，但也是一种函数对象。 Function是JS自带的对象，f1,f2在创建的时候，JS会自动通过new Function()的方式来构建这些对象，因此，这三个对象都是通过new Function()创建的。 在Javascript中创建对象有两种方式：对象字面量和使用new表达式，o1和o2的创建恰好对应了这两种方式，重点讲一下o3, 如果用Java和C#的思路来理解的话，o3是f1的实例对象，o3和f1是同一类型，至少我以前这么认为，其实不然… 那么怎么理解呢? 很简单，看o3是不是通过new Function产生的, 显然不是，既然不是函数对象，那就是普通对象 。 通过对函数对象和普通对象的简单理解之后，我们再来了解一下Javascript中的原型和原型链： 在JS中，每当创建一个函数对象f1 时，该对象中都会内置一些属性，其中包括prototype和__proto__, prototype即原型对象，它记录着f1的一些属性和方法。 需要注意的是，prototype 对f1是不可见的，也就是说，f1不会查找prototype中的属性和方法。 function f(){} f.prototype.foo = &quot;abc&quot;; console.log(f.foo); //undefined 那么，prototype有什么用呢？ 其实prototype的主要作用就是继承。 通俗一点讲，prototype中定义的属性和方法都是留给自己的“后代”用的，因此，子类完全可以访问prototype中的属性和方法。 想要知道f1是如何把prototype留给“后代”，我们需要了解一下JS中的原型链，此时，JS中的__proto__ 入场了，这哥们长的很奇特，隐藏的也很深，以致于你经常见不到它，但它在普通对象和函数对象中都存在， 它的作用就是保存父类的prototype对象，JS在通过new 表达式创建一个对象的时候，通常会把父类的prototype赋值给新对象的proto属性，这样，就形成了一代代传承… function f(){} f.prototype.foo = &quot;abc&quot;; var obj = new f(); console.log(obj.foo); //abc 现在我们知道，obj中proto保存的是f的prototype,那么f的prototype中的proto中保存的是什么呢? 看下图： 如图所示，f.prototype的proto中保存的是Object.prototype，Object.prototype对象中也有proto，而从输出结果看，Object.prototype.proto 是null，表示obj对象原型链的终结。如下图所示： obj对象拥有这样一个原型链以后，当obj.foo执行时，obj会先查找自身是否有该属性，但不会查找自己的prototype,当找不到foo时，obj就沿着原型链依次去查找… 在上面的例子中，我们在f的prototype上定义了foo属性，这时obj就会在原型链上找到这个属性并执行。 最后，用几句话总结一下本文中涉及到的重点： 原型链的形成真正是靠__proto__ 而非prototype 当JS引擎执行对象的方法时，先查找对象本身是否存在该方法，如果不存在，会在原型链上查找，但不会查找自身的prototype。一个对象的proto记录着自己的原型链，决定了自身的数据类型，改变proto就等于改变对象的数据类型。 函数的prototype不属于自身的原型链，它是子类创建的核心，决定了子类的数据类型，是连接子类原型链的桥梁。 在原型对象上定义方法和属性的目的是为了被子类继承和使用。 来源：@一像素 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/20/JS-之函数原型链(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>原型</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R入门]]></title>
    <url>%2F2017%2F06%2F20%2FR%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[一门可视化语言安装包（例如在RStudio中国安装caret包） install.packages(&quot;caret&quot;) 使用引入包 library(caret) 数据对象的5种基本类型：字符（character）、数值（numeric：real numbers）、整数（integer）、复数（complex）、逻辑（logical：True/False) x&lt;-1数值x&lt;-1L 整数（后面加L）逻辑（TRUE和FALSE要用大写） 数据结构：向量（Vector）：只能包含同一类型的对象矩阵（Matrix）：向量+维度属性数组（array）：相当于维度大于2的矩阵（矩阵的维度等于2）列表（list）：可以包含不同类型的对象因子(factor):分类数据/有序vs无序 整数向量+标签（label）（优于整数向量）缺失值（missing value):数据框（data frame）（表格）：数据框是R里面最重要的数据对象，日期与时间： par()——数据可视化的起点 (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/20/R入门/]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>初级</tag>
        <tag>可视化</tag>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 之函数原型链]]></title>
    <url>%2F2017%2F06%2F20%2FJS-%E4%B9%8B%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[在Javascript中，万物皆对象，但对象也有区别，大致可以分为两类，即：普通对象Object 和 函数对象Function。一般而言，通过new Function产生的对象是函数对象，其他对象都是普通对象。 JS原型对象和原型链 一般而言，通过new Function产生的对象是函数对象，其他对象都是普通对象。栗子： function f1(){ //todo } var f2 = function(){ //todo }; var f3 = new Function(&apos;x&apos;,&apos;console.log(x)&apos;); var o1 = {}; var o2 = new Object(); var o3 = new f1(); console.log( typeof f1,//function typeof f2,//function typeof f3,//function typeof o1,//object typeof o2,//object typeof o3 //object ); &gt;&gt; function function function object object object f1属于函数的声明，最常见的函数定义方式，f2实际上是一个匿名函数，把这个匿名函数赋值给了f2,属于函数表达式，f3不常见，但也是一种函数对象。f1属于函数的声明，最常见的函数定义方式，f2实际上是一个匿名函数，把这个匿名函数赋值给了f2,属于函数表达式，f3不常见，但也是一种函数对象。 Function是JS自带的对象，f1,f2在创建的时候，JS会自动通过new Function()的方式来构建这些对象，因此，这三个对象都是通过new Function()创建的。 在Javascript中创建对象有两种方式：对象字面量和使用new表达式，o1和o2的创建恰好对应了这两种方式，重点讲一下o3, 如果用Java和C#的思路来理解的话，o3是f1的实例对象，o3和f1是同一类型，至少我以前这么认为，其实不然… 那么怎么理解呢? 很简单，看o3是不是通过new Function产生的, 显然不是，既然不是函数对象，那就是普通对象 。 通过对函数对象和普通对象的简单理解之后，我们再来了解一下Javascript中的原型和原型链： 在JS中，每当创建一个函数对象f1 时，该对象中都会内置一些属性，其中包括prototype和__proto__, prototype即原型对象，它记录着f1的一些属性和方法。 需要注意的是，prototype 对f1是不可见的，也就是说，f1不会查找prototype中的属性和方法。 function f(){} f.prototype.foo = &quot;abc&quot;; console.log(f.foo); //undefined 那么，prototype有什么用呢？ 其实prototype的主要作用就是继承。 通俗一点讲，prototype中定义的属性和方法都是留给自己的“后代”用的，因此，子类完全可以访问prototype中的属性和方法。 想要知道f1是如何把prototype留给“后代”，我们需要了解一下JS中的原型链，此时，JS中的__proto__ 入场了，这哥们长的很奇特，隐藏的也很深，以致于你经常见不到它，但它在普通对象和函数对象中都存在， 它的作用就是保存父类的prototype对象，JS在通过new 表达式创建一个对象的时候，通常会把父类的prototype赋值给新对象的proto属性，这样，就形成了一代代传承… function f(){} f.prototype.foo = &quot;abc&quot;; var obj = new f(); console.log(obj.foo); //abc 现在我们知道，obj中proto保存的是f的prototype,那么f的prototype中的proto中保存的是什么呢? 看下图： 如图所示，f.prototype的proto中保存的是Object.prototype，Object.prototype对象中也有proto，而从输出结果看，Object.prototype.proto 是null，表示obj对象原型链的终结。如下图所示： obj对象拥有这样一个原型链以后，当obj.foo执行时，obj会先查找自身是否有该属性，但不会查找自己的prototype,当找不到foo时，obj就沿着原型链依次去查找… 在上面的例子中，我们在f的prototype上定义了foo属性，这时obj就会在原型链上找到这个属性并执行。 最后，用几句话总结一下本文中涉及到的重点： 原型链的形成真正是靠__proto__ 而非prototype 当JS引擎执行对象的方法时，先查找对象本身是否存在该方法，如果不存在，会在原型链上查找，但不会查找自身的prototype。一个对象的proto记录着自己的原型链，决定了自身的数据类型，改变proto就等于改变对象的数据类型。 函数的prototype不属于自身的原型链，它是子类创建的核心，决定了子类的数据类型，是连接子类原型链的桥梁。 在原型对象上定义方法和属性的目的是为了被子类继承和使用。 来源：@一像素 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/20/JS-之函数原型链/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>原型</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R入门]]></title>
    <url>%2F2017%2F06%2F20%2FR%E5%85%A5%E9%97%A8(1)%2F</url>
    <content type="text"><![CDATA[一门可视化语言安装包（例如在RStudio中国安装caret包） install.packages(&quot;caret&quot;) 使用引入包 library(caret) 数据对象的5种基本类型：字符（character）、数值（numeric：real numbers）、整数（integer）、复数（complex）、逻辑（logical：True/False) x&lt;-1数值x&lt;-1L 整数（后面加L）逻辑（TRUE和FALSE要用大写） 数据结构：向量（Vector）：只能包含同一类型的对象矩阵（Matrix）：向量+维度属性数组（array）：相当于维度大于2的矩阵（矩阵的维度等于2）列表（list）：可以包含不同类型的对象因子(factor):分类数据/有序vs无序 整数向量+标签（label）（优于整数向量）缺失值（missing value):数据框（data frame）（表格）：数据框是R里面最重要的数据对象，日期与时间： par()——数据可视化的起点 (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/20/R入门(1)/]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>初级</tag>
        <tag>可视化</tag>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之函数作用域]]></title>
    <url>%2F2017%2F06%2F20%2FJS%E4%B9%8B%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F(1)%2F</url>
    <content type="text"><![CDATA[所谓作用域就是：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。 函数作用域和作用域链 1、作用域所谓作用域就是：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。 function scope(){ var foo = &quot;global&quot;; if(window.getComputedStyle){ var a = &quot;I&apos;m if&quot;; console.log(&quot;if:&quot;+foo); //if:global } while(1){ var b = &quot;I&apos;m while&quot;; console.log(&quot;while:&quot;+foo);//while:global break; } !function (){ var c = &quot;I&apos;m function&quot;; console.log(&quot;function:&quot;+foo);//function:global }(); console.log( foo,//global a, // I&apos;m if b, // I&apos;m while c // c is not defined ); } scope(); （1）scope函数中定义的foo变量，除过自身可以访问以外，还可以在if语句、while语句和内嵌的匿名函数中访问。 因此，foo的作用域就是scope函数体。 （2）在javascript中，if、while、for 等代码块不能形成独立的作用域。因此，javascript中没有块级作用域，只有函数作用域。 但是，在JS中有一种特殊情况： 如果一个变量没有使用var声明，window便拥有了该属性，因此这个变量的作用域不属于某一个函数体,而是window对象。 function varscope(){ foo = &quot;I&apos;m in function&quot;; console.log(foo);//I&apos;m in function } varscope(); console.log(window.foo); //I&apos;m in function 2、作用域链所谓作用域链就是：一个函数体中嵌套了多层函数体，并在不同的函数体中定义了同一变量， 当其中一个函数访问这个变量时，便会形成一条作用域链。 foo = &quot;window&quot;; function first(){ var foo = &quot;first&quot;; function second(){ var foo = &quot;second&quot;; console.log(foo); } function third(){ console.log(foo); } second(); //second third(); //first } first(); 当执行second时，JS引擎会将second的作用域放置链表的头部，其次是first的作用域，最后是window对象，于是会形成如下作用域链： second-&gt;first-&gt;window, 此时，JS引擎沿着该作用域链查找变量foo, 查到的是 second 当执行third时，third形成的作用域链：third-&gt;first-&gt;window, 因此查到的是：frist 3、作用域的延长：with 和 catchwith和catch语句主要用来临时扩展作用域链， 将语句中传递的变量对象添加到作用域的头部。语句结束后，原作用域链恢复正常。 //with语句 foo = &quot;window&quot;; function first(){ var foo = &quot;first&quot;; function second(){ var foo = &quot;second&quot;; console.log(foo); } function third(obj){ console.log(foo); //first with (obj){ console.log(foo); //obj } console.log(foo); //first } var obj = {foo:&apos;obj&apos;}; third(obj); } first(); //catch语句 var e = new Error(&apos;a&apos;); try { throw new Error(&apos;b&apos;); } catch (e) { console.log(e.message); //b } 在执行third()时，传递了一个obj对象，obj 中有属性foo, 在执行with语句时，JS引擎将obj放置在了原链表的头部，于是形成的作用域链如下： obj-&gt;third-&gt;first-&gt;window, 此时查找到的foo就是obj中的foo,因此输出的是 obj 而在with之前和之后，都是沿着原来的链表进行查找，从而说明在with语句结束后，作用域链已恢复正常。 4、this 关键字 在一个函数中，this总是指向当前函数的所有者对象，this总是在运行时才能确定其具体的指向, 也才能知道它的调用对象。 window.name = &quot;window&quot;; function f(){ console.log(this.name); } f();//window var obj = {name:&apos;obj&apos;}; f.call(obj); //obj 在执行f()时，此时f()的调用者是window对象，因此输出 window f.call(obj) 是把f()放在obj对象上执行，相当于obj.f(),此时f 中的this就是obj,所以输出的是 obj 5、实战应用//demo1 var foo = &quot;window&quot;; var obj = { foo : &quot;obj&quot;, getFoo : function(){ return function(){ return this.foo; }; } }; var f = obj.getFoo(); f(); //window //demo2 var foo = &quot;window&quot;; var obj = { foo : &quot;obj&quot;, getFoo : function(){ var that = this; return function(){ return that.foo; }; } }; var f = obj.getFoo(); f(); //obj 6、demo解析//demo1: //执行var f = obj.getFoo()返回的是一个匿名函数，相当于: var f = function(){ return this.foo; } //f() 相当于window.f(), 因此f中的this指向的是window对象，this.foo相当于window.foo, 所以f()返回&quot;window&quot; //demo2: //执行var f = obj.getFoo() 同样返回匿名函数，即： var f = function(){ return that.foo; } //唯一不同的是f中的this变成了that, 要知道that是哪个对象之前，先确定f的作用域链：f-&gt;getFoo-&gt;window 并在该链条上查找that, //此时可以发现that指代的是getFoo中的this, getFoo中的this指向其运行时的调用者， //从var f = obj.getFoo() 可知此时this指向的是obj对象，因此that.foo 就相当于obj.foo,所以f()返回&quot;obj&quot; 所以： this是指向window, that就是执行obj.getFoo()时的this, 调用getFoo()的对象是obj,因此这里的this就指的是obj 来源：一像素 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/20/JS之函数作用域(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>作用域</tag>
        <tag>js</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之函数作用域]]></title>
    <url>%2F2017%2F06%2F20%2FJS%E4%B9%8B%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[所谓作用域就是：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。 函数作用域和作用域链 1、作用域所谓作用域就是：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。 function scope(){ var foo = &quot;global&quot;; if(window.getComputedStyle){ var a = &quot;I&apos;m if&quot;; console.log(&quot;if:&quot;+foo); //if:global } while(1){ var b = &quot;I&apos;m while&quot;; console.log(&quot;while:&quot;+foo);//while:global break; } !function (){ var c = &quot;I&apos;m function&quot;; console.log(&quot;function:&quot;+foo);//function:global }(); console.log( foo,//global a, // I&apos;m if b, // I&apos;m while c // c is not defined ); } scope(); （1）scope函数中定义的foo变量，除过自身可以访问以外，还可以在if语句、while语句和内嵌的匿名函数中访问。 因此，foo的作用域就是scope函数体。 （2）在javascript中，if、while、for 等代码块不能形成独立的作用域。因此，javascript中没有块级作用域，只有函数作用域。 但是，在JS中有一种特殊情况： 如果一个变量没有使用var声明，window便拥有了该属性，因此这个变量的作用域不属于某一个函数体,而是window对象。 function varscope(){ foo = &quot;I&apos;m in function&quot;; console.log(foo);//I&apos;m in function } varscope(); console.log(window.foo); //I&apos;m in function 2、作用域链所谓作用域链就是：一个函数体中嵌套了多层函数体，并在不同的函数体中定义了同一变量， 当其中一个函数访问这个变量时，便会形成一条作用域链。 foo = &quot;window&quot;; function first(){ var foo = &quot;first&quot;; function second(){ var foo = &quot;second&quot;; console.log(foo); } function third(){ console.log(foo); } second(); //second third(); //first } first(); 当执行second时，JS引擎会将second的作用域放置链表的头部，其次是first的作用域，最后是window对象，于是会形成如下作用域链： second-&gt;first-&gt;window, 此时，JS引擎沿着该作用域链查找变量foo, 查到的是 second 当执行third时，third形成的作用域链：third-&gt;first-&gt;window, 因此查到的是：frist 3、作用域的延长：with 和 catchwith和catch语句主要用来临时扩展作用域链， 将语句中传递的变量对象添加到作用域的头部。语句结束后，原作用域链恢复正常。 //with语句 foo = &quot;window&quot;; function first(){ var foo = &quot;first&quot;; function second(){ var foo = &quot;second&quot;; console.log(foo); } function third(obj){ console.log(foo); //first with (obj){ console.log(foo); //obj } console.log(foo); //first } var obj = {foo:&apos;obj&apos;}; third(obj); } first(); //catch语句 var e = new Error(&apos;a&apos;); try { throw new Error(&apos;b&apos;); } catch (e) { console.log(e.message); //b } 在执行third()时，传递了一个obj对象，obj 中有属性foo, 在执行with语句时，JS引擎将obj放置在了原链表的头部，于是形成的作用域链如下： obj-&gt;third-&gt;first-&gt;window, 此时查找到的foo就是obj中的foo,因此输出的是 obj 而在with之前和之后，都是沿着原来的链表进行查找，从而说明在with语句结束后，作用域链已恢复正常。 4、this 关键字 在一个函数中，this总是指向当前函数的所有者对象，this总是在运行时才能确定其具体的指向, 也才能知道它的调用对象。 window.name = &quot;window&quot;; function f(){ console.log(this.name); } f();//window var obj = {name:&apos;obj&apos;}; f.call(obj); //obj 在执行f()时，此时f()的调用者是window对象，因此输出 window f.call(obj) 是把f()放在obj对象上执行，相当于obj.f(),此时f 中的this就是obj,所以输出的是 obj 5、实战应用//demo1 var foo = &quot;window&quot;; var obj = { foo : &quot;obj&quot;, getFoo : function(){ return function(){ return this.foo; }; } }; var f = obj.getFoo(); f(); //window //demo2 var foo = &quot;window&quot;; var obj = { foo : &quot;obj&quot;, getFoo : function(){ var that = this; return function(){ return that.foo; }; } }; var f = obj.getFoo(); f(); //obj 6、demo解析//demo1: //执行var f = obj.getFoo()返回的是一个匿名函数，相当于: var f = function(){ return this.foo; } //f() 相当于window.f(), 因此f中的this指向的是window对象，this.foo相当于window.foo, 所以f()返回&quot;window&quot; //demo2: //执行var f = obj.getFoo() 同样返回匿名函数，即： var f = function(){ return that.foo; } //唯一不同的是f中的this变成了that, 要知道that是哪个对象之前，先确定f的作用域链：f-&gt;getFoo-&gt;window 并在该链条上查找that, //此时可以发现that指代的是getFoo中的this, getFoo中的this指向其运行时的调用者， //从var f = obj.getFoo() 可知此时this指向的是obj对象，因此that.foo 就相当于obj.foo,所以f()返回&quot;obj&quot; 所以： this是指向window, that就是执行obj.getFoo()时的this, 调用getFoo()的对象是obj,因此这里的this就指的是obj 来源：一像素 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/20/JS之函数作用域/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>作用域</tag>
        <tag>js</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断JS数据类型的四种方法]]></title>
    <url>%2F2017%2F06%2F20%2F%E5%88%A4%E6%96%ADJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Javascript可以通过typeof来判断基础数据类型，但不能够准确判断引用类型, 因此需要用到另外一个方法，那就是Object的toString 说到数据类型，我们先说一下JavaScript 中常见的几种数据类型： 基本类型：string,number,boolean 特殊类型：undefined,null 引用类型：Object,Function,Function,Array,RegExp,Date,… 很多时候我们都需要通过判断变量的数据类型来进行下一步操作，下面我们介绍常用的4种方法： 1、typeoftypeof 返回一个表示数据类型的字符串，返回结果包括：number、boolean、string、object、undefined、function等6种数据类型。 typeof &apos;&apos;; // string 有效 typeof 1; // number 有效 typeof true; //boolean 有效 typeof undefined; //undefined 有效 typeof null; //object 无效 typeof [] ; //object 无效 typeof new Function(); // function 有效 typeof new Date(); //object 无效 typeof new RegExp(); //object 无效 typeof 可以对JS基础数据类型做出准确的判断，而对于引用类型返回的基本上都是object,其实返回object也没有错，因为所有对象的原型链最终都指向了Object,Object是所有对象的祖宗。但当我们需要知道某个对象的具体类型时，typeof 就显得有些力不从心了 2、instanceofnstanceof 是用来判断 A 是否为 B 的实例对，表达式为：A instanceof B，如果A是B的实例，则返回true,否则返回false。 在这里需要特别注意的是：instanceof检测的是原型，我们用一段伪代码来模拟其内部执行过程： instanceof (A,B) = { var L = A.__proto__; var R = B.prototype; if(L === R) { //A的内部属性__proto__指向B的原型对象 return true; } return false; } 上述过程可以看出，当 A 的 proto 指向 B 的 prototype 时，就认为A就是B的实例，我们再来看几个例子： [] instanceof Array; //true {} instanceof Object;//true new Date() instanceof Date;//true function Person(){}; new Person() instanceof Person; [] instanceof Object; //true new Date() instanceof Object;//true new Person instanceof Object;//true 我们发现，虽然 instanceof 能够判断出 [] 是Array的实例，但它认为 [] 也是Object的实例，为什么呢？ 我们来分析一下[]、Array、Object 三者之间的关系: 从instanceof 能够判断出 [].proto 指向 Array.prototype， 而 Array.prototype.proto 又指向了Object.prototype，Object.prototype.proto 指向了null,标志着原型链的结束。因此，[]、Array、Object就形成了如下图所示的一条原型链：从原型链可以看出，[] 的 proto 直接指向Array.prototype, 间接指向Object.prototype, 所以按照 instanceof 的判断规则，[] 就是Object的实例。当然，类似的new Date()、new Person() 也会形成这样一条原型链，因此，instanceof 只能用来判断两个对象是否属于原型链的关系， 而不能获取对象的具体类型。 3、constructor当一个函数F被定义时，JS引擎会为F添加prototype原型，然后再在prototype上添加一个constructor属性，并让其指向F的引用。如下所示：当执行 var f = new F() 时，F被当成了构造函数，f是F的实例对象，此时F原型上的constructor传递到了f上，因此f.constructor == F可以看出，JS在函数F的原型上定义了constructor，当F被当作构造函数用来创建对象时，创建的新对象就被标记为了“F” 类型，使得新对象有名有姓，可以追溯。 同理,JS中的数据类型也遵守这个规则：注意： null和undefined是无效的对象，因此是不会有constructor存在的，这两种类型的数据需要通过typeof来判断。 JS对象的constructor是不稳定的，这个主要体现在自定义对象上，当开发者重写prototype后，原有的constructor会丢失，constructor会默认为Object 4、Object.prototype.toStringObject.prototype.toString.call(&apos;&apos;) ; // [object String] Object.prototype.toString.call(1) ; // [object Number] Object.prototype.toString.call(true) ; // [object Boolean] Object.prototype.toString.call(undefined) ; // [object Undefined] Object.prototype.toString.call(null) ; // [object Null] Object.prototype.toString.call(new Function()) ; // [object Function] Object.prototype.toString.call(new Date()) ; // [object Date] Object.prototype.toString.call([]) ; // [object Array] Object.prototype.toString.call(new RegExp()) ; // [object RegExp] Object.prototype.toString.call(new Error()) ; // [object Error] Object.prototype.toString.call(document) ; // [object HTMLDocument] Object.prototype.toString.call(window) ; //[object global] window是全局对象global的引用 需要注意的是，必须通过Object.prototype.toString.call来获取，而不能直接 newDate().toString(), 从原型链的角度讲，所有对象的原型链最终都指向了Object,按照JS变量查找规则，其他对象应该也可以直接访问到Object的toString方法，而事实上，大部分的对象都实现了自身的toString方法，这样就可能会导致Object的toString被终止查找，因此要用call来强制执行Object的toString方法。 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/20/判断JS数据类型的四种方法/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>原型</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断JS数据类型的四种方法]]></title>
    <url>%2F2017%2F06%2F20%2F%E5%88%A4%E6%96%ADJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95(1)%2F</url>
    <content type="text"><![CDATA[Javascript可以通过typeof来判断基础数据类型，但不能够准确判断引用类型, 因此需要用到另外一个方法，那就是Object的toString 说到数据类型，我们先说一下JavaScript 中常见的几种数据类型： 基本类型：string,number,boolean 特殊类型：undefined,null 引用类型：Object,Function,Function,Array,RegExp,Date,… 很多时候我们都需要通过判断变量的数据类型来进行下一步操作，下面我们介绍常用的4种方法： 1、typeoftypeof 返回一个表示数据类型的字符串，返回结果包括：number、boolean、string、object、undefined、function等6种数据类型。 typeof &apos;&apos;; // string 有效 typeof 1; // number 有效 typeof true; //boolean 有效 typeof undefined; //undefined 有效 typeof null; //object 无效 typeof [] ; //object 无效 typeof new Function(); // function 有效 typeof new Date(); //object 无效 typeof new RegExp(); //object 无效 typeof 可以对JS基础数据类型做出准确的判断，而对于引用类型返回的基本上都是object,其实返回object也没有错，因为所有对象的原型链最终都指向了Object,Object是所有对象的祖宗。但当我们需要知道某个对象的具体类型时，typeof 就显得有些力不从心了 2、instanceofnstanceof 是用来判断 A 是否为 B 的实例对，表达式为：A instanceof B，如果A是B的实例，则返回true,否则返回false。 在这里需要特别注意的是：instanceof检测的是原型，我们用一段伪代码来模拟其内部执行过程： instanceof (A,B) = { var L = A.__proto__; var R = B.prototype; if(L === R) { //A的内部属性__proto__指向B的原型对象 return true; } return false; } 上述过程可以看出，当 A 的 proto 指向 B 的 prototype 时，就认为A就是B的实例，我们再来看几个例子： [] instanceof Array; //true {} instanceof Object;//true new Date() instanceof Date;//true function Person(){}; new Person() instanceof Person; [] instanceof Object; //true new Date() instanceof Object;//true new Person instanceof Object;//true 我们发现，虽然 instanceof 能够判断出 [] 是Array的实例，但它认为 [] 也是Object的实例，为什么呢？ 我们来分析一下[]、Array、Object 三者之间的关系: 从instanceof 能够判断出 [].proto 指向 Array.prototype， 而 Array.prototype.proto 又指向了Object.prototype，Object.prototype.proto 指向了null,标志着原型链的结束。因此，[]、Array、Object就形成了如下图所示的一条原型链：从原型链可以看出，[] 的 proto 直接指向Array.prototype, 间接指向Object.prototype, 所以按照 instanceof 的判断规则，[] 就是Object的实例。当然，类似的new Date()、new Person() 也会形成这样一条原型链，因此，instanceof 只能用来判断两个对象是否属于原型链的关系， 而不能获取对象的具体类型。 3、constructor当一个函数F被定义时，JS引擎会为F添加prototype原型，然后再在prototype上添加一个constructor属性，并让其指向F的引用。如下所示：当执行 var f = new F() 时，F被当成了构造函数，f是F的实例对象，此时F原型上的constructor传递到了f上，因此f.constructor == F可以看出，JS在函数F的原型上定义了constructor，当F被当作构造函数用来创建对象时，创建的新对象就被标记为了“F” 类型，使得新对象有名有姓，可以追溯。 同理,JS中的数据类型也遵守这个规则：注意： null和undefined是无效的对象，因此是不会有constructor存在的，这两种类型的数据需要通过typeof来判断。 JS对象的constructor是不稳定的，这个主要体现在自定义对象上，当开发者重写prototype后，原有的constructor会丢失，constructor会默认为Object 4、Object.prototype.toStringObject.prototype.toString.call(&apos;&apos;) ; // [object String] Object.prototype.toString.call(1) ; // [object Number] Object.prototype.toString.call(true) ; // [object Boolean] Object.prototype.toString.call(undefined) ; // [object Undefined] Object.prototype.toString.call(null) ; // [object Null] Object.prototype.toString.call(new Function()) ; // [object Function] Object.prototype.toString.call(new Date()) ; // [object Date] Object.prototype.toString.call([]) ; // [object Array] Object.prototype.toString.call(new RegExp()) ; // [object RegExp] Object.prototype.toString.call(new Error()) ; // [object Error] Object.prototype.toString.call(document) ; // [object HTMLDocument] Object.prototype.toString.call(window) ; //[object global] window是全局对象global的引用 需要注意的是，必须通过Object.prototype.toString.call来获取，而不能直接 newDate().toString(), 从原型链的角度讲，所有对象的原型链最终都指向了Object,按照JS变量查找规则，其他对象应该也可以直接访问到Object的toString方法，而事实上，大部分的对象都实现了自身的toString方法，这样就可能会导致Object的toString被终止查找，因此要用call来强制执行Object的toString方法。 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/20/判断JS数据类型的四种方法(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>原型</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之数据类型详解]]></title>
    <url>%2F2017%2F06%2F20%2FJS%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3(1)%2F</url>
    <content type="text"><![CDATA[Javascript中的数据类型有以下几种情况：基本类型：string,number,boolean特殊类型：undefined,null引用类型：Object,Function,Date,Array,RegExp, … Javascript中的数据类型有以下几种情况： 基本类型：string,number,boolean 特殊类型：undefined,null 引用类型：Object,Function,Date,Array,RegExp, … 1、stringstring类型的数据是由16位Unicode字符组成的字符串，用typeof检测其数据类型如下： var str = &quot;Hi, Javascript&quot;; console.log(typeof str); // string 在Javascript中，除过undefined和null之外的其他的数据类型都有toString()方法，因此这些数据类型都可以通过toString方法转化为对应的string类型 123..toString(); // &quot;123&quot;,注意有两个.. true.toString(); // &quot;true&quot; new Object().toString(); // [object Object] &quot;Hello&quot;.toString(); // &quot;Hello&quot; undefined.toString(); // Error null.toString(); // Error 一般情况下，toString不需要传递参数，而将数值转化为字符串时，通过传递一个radix参数，可以将数值转化为对应的二进制、八进制和十六进制的字符串表示。 2、number在Javascript中，没有int和float数据类型，而是用number来表示整数和浮点数值，除此之外，number还有一个特殊的数值，即NaN (Not a Number)，NaN表示一个承诺返回数值类型数据但实际没有返回的情况. NaN有两个特点：一是任何涉及NaN的操作都会返回NaN，二是NaN不与任何数值相等，包括自己，但可以通过isNaN()方法来判断一个数值是否为NaN typeof 123; // &quot;number&quot; typeof 123.45 // &quot;number&quot; typeof NaN; // &quot;number&quot; NaN+1; // NaN NaN == false; // false NaN == NaN; //false isNaN(NaN+1); //true 3、booleanboolean类型只有两个字面值：true和false 。 但在Javascript中，所有类型的值都可以转化为与boolean等价的值，转化规则如下：（1）所有对象都被当作 true（2）当字符串为空时，该字符串被当作false（3）null 和 undefined 被当作 false（4）当数字为0时，该数字被当作 false typeof true; // &quot;boolean&quot; typeof false; // &quot;boolean&quot; Boolean(new Object()); //true Boolean(undefined); //false Boolean(null); //false Boolean(&apos;&apos;); //false Boolean(0); //false Boolean(100); // true 4、undefined该类型只有一个值，即 undefined。 undefined意为未定义，即当使用var声明了变量但未进行赋值时，这个变量的值就是undefined。undefined产生的原因有两种：（1）访问对象不存在的属性或方法 （2）声明了变量但从未赋值 var v1,obj = {}; console.log(v1); //undefined console.log(obj.get); //undefined typeof v1; // &quot;undefined&quot; typeof v2; // &quot;undefined&quot; typeof obj.get; // &quot;undefined&quot; 5、nullnull类型也只有一个值：null , 表示一个变量中没有包含有效数据。null在这里意为空值、空对象的意思，更确切的说，一个被赋值为null的变量没有保存有效的数值、字符串、布尔、数组或对象等，可以通过给一个变量赋值为null来清空变量中的内容。产生null的原因只有一个：即对一个变量显式的赋值为null 。 var p = null; console.log(p); //null typeof p ; // &quot;object&quot; typeof null; // &quot;object&quot; 另外，需要注意的是，typeof null 应该返回null，但实际上返回的是object，这是一个历史遗留问题，并没有其他原因。 6、Object,Function,Array,Date,RegExp这些对象在JS中都属于引用类型, 除Function之外，通过typeof检测其数据类型返回的都是object, 如果要判断对应的具体类型，则可以通过Object.prototype.toString来获取。 var a = {}; var b = new Function(); var c = []; var d = new Date(); var e = new RegExp(); typeof a; //object 有效 Object.prototype.toString.call(a); //[object Object] typeof b; //function 有效 Object.prototype.toString.call(b); //[object Object] typeof c; //object 无效 Object.prototype.toString.call(c);//[object Array] typeof d; //object 无效 Object.prototype.toString.call(d);//[object Date] typeof e; //object 无效 Object.prototype.toString.call(e);//[object RegExp] 另外，ES6中新增了symbol这个类型: typeof Symbol() 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/20/JS之数据类型详解(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之数据类型详解]]></title>
    <url>%2F2017%2F06%2F20%2FJS%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Javascript中的数据类型有以下几种情况：基本类型：string,number,boolean特殊类型：undefined,null引用类型：Object,Function,Date,Array,RegExp, … Javascript中的数据类型有以下几种情况： 基本类型：string,number,boolean 特殊类型：undefined,null 引用类型：Object,Function,Date,Array,RegExp, … 1、stringstring类型的数据是由16位Unicode字符组成的字符串，用typeof检测其数据类型如下： var str = &quot;Hi, Javascript&quot;; console.log(typeof str); // string 在Javascript中，除过undefined和null之外的其他的数据类型都有toString()方法，因此这些数据类型都可以通过toString方法转化为对应的string类型 123..toString(); // &quot;123&quot;,注意有两个.. true.toString(); // &quot;true&quot; new Object().toString(); // [object Object] &quot;Hello&quot;.toString(); // &quot;Hello&quot; undefined.toString(); // Error null.toString(); // Error 一般情况下，toString不需要传递参数，而将数值转化为字符串时，通过传递一个radix参数，可以将数值转化为对应的二进制、八进制和十六进制的字符串表示。 2、number在Javascript中，没有int和float数据类型，而是用number来表示整数和浮点数值，除此之外，number还有一个特殊的数值，即NaN (Not a Number)，NaN表示一个承诺返回数值类型数据但实际没有返回的情况. NaN有两个特点：一是任何涉及NaN的操作都会返回NaN，二是NaN不与任何数值相等，包括自己，但可以通过isNaN()方法来判断一个数值是否为NaN typeof 123; // &quot;number&quot; typeof 123.45 // &quot;number&quot; typeof NaN; // &quot;number&quot; NaN+1; // NaN NaN == false; // false NaN == NaN; //false isNaN(NaN+1); //true 3、booleanboolean类型只有两个字面值：true和false 。 但在Javascript中，所有类型的值都可以转化为与boolean等价的值，转化规则如下：（1）所有对象都被当作 true（2）当字符串为空时，该字符串被当作false（3）null 和 undefined 被当作 false（4）当数字为0时，该数字被当作 false typeof true; // &quot;boolean&quot; typeof false; // &quot;boolean&quot; Boolean(new Object()); //true Boolean(undefined); //false Boolean(null); //false Boolean(&apos;&apos;); //false Boolean(0); //false Boolean(100); // true 4、undefined该类型只有一个值，即 undefined。 undefined意为未定义，即当使用var声明了变量但未进行赋值时，这个变量的值就是undefined。undefined产生的原因有两种：（1）访问对象不存在的属性或方法 （2）声明了变量但从未赋值 var v1,obj = {}; console.log(v1); //undefined console.log(obj.get); //undefined typeof v1; // &quot;undefined&quot; typeof v2; // &quot;undefined&quot; typeof obj.get; // &quot;undefined&quot; 5、nullnull类型也只有一个值：null , 表示一个变量中没有包含有效数据。null在这里意为空值、空对象的意思，更确切的说，一个被赋值为null的变量没有保存有效的数值、字符串、布尔、数组或对象等，可以通过给一个变量赋值为null来清空变量中的内容。产生null的原因只有一个：即对一个变量显式的赋值为null 。 var p = null; console.log(p); //null typeof p ; // &quot;object&quot; typeof null; // &quot;object&quot; 另外，需要注意的是，typeof null 应该返回null，但实际上返回的是object，这是一个历史遗留问题，并没有其他原因。 6、Object,Function,Array,Date,RegExp这些对象在JS中都属于引用类型, 除Function之外，通过typeof检测其数据类型返回的都是object, 如果要判断对应的具体类型，则可以通过Object.prototype.toString来获取。 var a = {}; var b = new Function(); var c = []; var d = new Date(); var e = new RegExp(); typeof a; //object 有效 Object.prototype.toString.call(a); //[object Object] typeof b; //function 有效 Object.prototype.toString.call(b); //[object Object] typeof c; //object 无效 Object.prototype.toString.call(c);//[object Array] typeof d; //object 无效 Object.prototype.toString.call(d);//[object Date] typeof e; //object 无效 Object.prototype.toString.call(e);//[object RegExp] 另外，ES6中新增了symbol这个类型: typeof Symbol() 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/20/JS之数据类型详解/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery 效果 - 动画]]></title>
    <url>%2F2017%2F06%2F19%2FjQuery-%E6%95%88%E6%9E%9C-%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[基础要扎实。对于我来说，虽然学了好多好泛，但却没有学扎实，所以，这是一个复习JQuery动画的一篇文章，很基础。 jQuery 效果 - 隐藏和显示包括隐藏、显示、切换，滑动，淡入淡出，以及动画，哇哦 jQuery hide() $(“#hide”).click(function(){ $(&quot;p&quot;).hide(); }); 演示地址 show()与hide()类似$(“#show”).click(function(){$(“p”).show();}); 演示地址 语法： $(selector).hide(speed,callback); $(selector).show(speed,callback); 可选的 speed 参数规定隐藏/显示的速度，可以取以下值：”slow”、”fast” 或毫秒。 可选的 callback 参数是隐藏或显示完成后所执行的函数名称 jQuery toggle() 使用 toggle() 方法来切换 hide() 和 show() $(&quot;button&quot;).click(function(){ $(&quot;p&quot;).toggle(); }); 演示地址 jQuery 效果 - 淡入淡出 jQuery fadeIn() jQuery fadeOut() jQuery fadeToggle() jQuery fadeTo() jQuery fadeTo() 方法允许渐变为给定的不透明度（值介于 0 与 1 之间）语法： $(selector).fadeTo(speed,opacity,callback); jQuery 效果 - 滑动 slideDown() slideUp() slideToggle() slideToggle() 方法演示 jQuery animate()动画 Query animate() 方法用于创建自定义动画。 语法： $(selector).animate({params},speed,callback); 必需的 params 参数定义形成动画的 CSS 属性 下面的例子演示 animate() 方法的简单应用；它把 元素移动到左边，直到 left 属性等于 250 像素为止： $(&quot;button&quot;).click(function(){ $(&quot;div&quot;).animate({left:&apos;250px&apos;}); }); 演示地址ps：生成动画的过程中可同时使用多个属性 $(&quot;button&quot;).click(function(){ $(&quot;div&quot;).animate({ left:&apos;250px&apos;, opacity:&apos;0.5&apos;, height:&apos;150px&apos;, width:&apos;150px&apos; }); }); 可以用 animate() 方法来操作所有 CSS 属性吗？ 是的，几乎可以！不过，需要记住一件重要的事情：当使用 animate() 时，必须使用 Camel 标记法书写所有的属性名，比如，必须使用 paddingLeft 而不是 padding-left，使用 marginRight 而不是 margin-right，等等。 同时，色彩动画并不包含在核心 jQuery 库中。 如果需要生成颜色动画，您需要从 jQuery.com 下载 Color Animations 插件。 jQuery animate() - 使用预定义的值您甚至可以把属性的动画值设置为 “show”、”hide” 或 “toggle”： $(&quot;button&quot;).click(function(){ $(&quot;div&quot;).animate({ height:&apos;toggle&apos; }); }); jQuery animate() - 使用队列功能如果您希望在彼此之后执行不同的动画，那么我们要利用队列功能： $(&quot;button&quot;).click(function(){ var div=$(&quot;div&quot;); div.animate({height:&apos;300px&apos;,opacity:&apos;0.4&apos;},&quot;slow&quot;); div.animate({width:&apos;300px&apos;,opacity:&apos;0.8&apos;},&quot;slow&quot;); div.animate({height:&apos;100px&apos;,opacity:&apos;0.4&apos;},&quot;slow&quot;); div.animate({width:&apos;100px&apos;,opacity:&apos;0.8&apos;},&quot;slow&quot;); }); jQuery 停止动画jQuery stop() 方法用于在动画或效果完成前对它们进行停止。jQuery stop() 滑动语法： $(selector).stop(stopAll,goToEnd); 可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行。 可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。 因此，默认地，stop() 会清除在被选元素上指定的当前动画。 jQuery Callback 函数 Callback 函数在当前动画 100% 完成之后执行。 由于 JavaScript 语句（指令）是逐一执行的 - 按照次序，动画之后的语句可能会产生错误或页面冲突，因为动画还没有完成。 为了避免这个情况，您可以以参数的形式添加 Callback 函数。 典型的语法： $(selector).hide(speed,callback) 错误（没有 callback）: $(&quot;p&quot;).hide(1000); alert(&quot;The paragraph is now hidden&quot;); jQuery - Chaining 通过 jQuery，您可以把动作/方法链接起来。Chaining 允许我们在一条语句中允许多个 jQuery 方法（在相同的元素上）。 例子 1下面的例子把 css(), slideUp(), and slideDown() 链接在一起。”p1” 元素首先会变为红色，然后向上滑动，然后向下滑动： $(&quot;#p1&quot;).css(&quot;color&quot;,&quot;red&quot;).slideUp(2000).slideDown(2000); 这些是jquery的基础动画，jquery真的是一个经典的库！！！ 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/19/jQuery-效果-动画/]]></content>
      <tags>
        <tag>js</tag>
        <tag>jquery</tag>
        <tag>动画</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery 效果 - 动画]]></title>
    <url>%2F2017%2F06%2F19%2FjQuery-%E6%95%88%E6%9E%9C-%E5%8A%A8%E7%94%BB(1)%2F</url>
    <content type="text"><![CDATA[基础要扎实。对于我来说，虽然学了好多好泛，但却没有学扎实，所以，这是一个复习JQuery动画的一篇文章，很基础。 jQuery 效果 - 隐藏和显示包括隐藏、显示、切换，滑动，淡入淡出，以及动画，哇哦 jQuery hide() $(“#hide”).click(function(){ $(&quot;p&quot;).hide(); }); 演示地址 show()与hide()类似$(“#show”).click(function(){$(“p”).show();}); 演示地址 语法： $(selector).hide(speed,callback); $(selector).show(speed,callback); 可选的 speed 参数规定隐藏/显示的速度，可以取以下值：”slow”、”fast” 或毫秒。 可选的 callback 参数是隐藏或显示完成后所执行的函数名称 jQuery toggle() 使用 toggle() 方法来切换 hide() 和 show() $(&quot;button&quot;).click(function(){ $(&quot;p&quot;).toggle(); }); 演示地址 jQuery 效果 - 淡入淡出 jQuery fadeIn() jQuery fadeOut() jQuery fadeToggle() jQuery fadeTo() jQuery fadeTo() 方法允许渐变为给定的不透明度（值介于 0 与 1 之间）语法： $(selector).fadeTo(speed,opacity,callback); jQuery 效果 - 滑动 slideDown() slideUp() slideToggle() slideToggle() 方法演示 jQuery animate()动画 Query animate() 方法用于创建自定义动画。 语法： $(selector).animate({params},speed,callback); 必需的 params 参数定义形成动画的 CSS 属性 下面的例子演示 animate() 方法的简单应用；它把 元素移动到左边，直到 left 属性等于 250 像素为止： $(&quot;button&quot;).click(function(){ $(&quot;div&quot;).animate({left:&apos;250px&apos;}); }); 演示地址ps：生成动画的过程中可同时使用多个属性 $(&quot;button&quot;).click(function(){ $(&quot;div&quot;).animate({ left:&apos;250px&apos;, opacity:&apos;0.5&apos;, height:&apos;150px&apos;, width:&apos;150px&apos; }); }); 可以用 animate() 方法来操作所有 CSS 属性吗？ 是的，几乎可以！不过，需要记住一件重要的事情：当使用 animate() 时，必须使用 Camel 标记法书写所有的属性名，比如，必须使用 paddingLeft 而不是 padding-left，使用 marginRight 而不是 margin-right，等等。 同时，色彩动画并不包含在核心 jQuery 库中。 如果需要生成颜色动画，您需要从 jQuery.com 下载 Color Animations 插件。 jQuery animate() - 使用预定义的值您甚至可以把属性的动画值设置为 “show”、”hide” 或 “toggle”： $(&quot;button&quot;).click(function(){ $(&quot;div&quot;).animate({ height:&apos;toggle&apos; }); }); jQuery animate() - 使用队列功能如果您希望在彼此之后执行不同的动画，那么我们要利用队列功能： $(&quot;button&quot;).click(function(){ var div=$(&quot;div&quot;); div.animate({height:&apos;300px&apos;,opacity:&apos;0.4&apos;},&quot;slow&quot;); div.animate({width:&apos;300px&apos;,opacity:&apos;0.8&apos;},&quot;slow&quot;); div.animate({height:&apos;100px&apos;,opacity:&apos;0.4&apos;},&quot;slow&quot;); div.animate({width:&apos;100px&apos;,opacity:&apos;0.8&apos;},&quot;slow&quot;); }); jQuery 停止动画jQuery stop() 方法用于在动画或效果完成前对它们进行停止。jQuery stop() 滑动语法： $(selector).stop(stopAll,goToEnd); 可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行。 可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。 因此，默认地，stop() 会清除在被选元素上指定的当前动画。 jQuery Callback 函数 Callback 函数在当前动画 100% 完成之后执行。 由于 JavaScript 语句（指令）是逐一执行的 - 按照次序，动画之后的语句可能会产生错误或页面冲突，因为动画还没有完成。 为了避免这个情况，您可以以参数的形式添加 Callback 函数。 典型的语法： $(selector).hide(speed,callback) 错误（没有 callback）: $(&quot;p&quot;).hide(1000); alert(&quot;The paragraph is now hidden&quot;); jQuery - Chaining 通过 jQuery，您可以把动作/方法链接起来。Chaining 允许我们在一条语句中允许多个 jQuery 方法（在相同的元素上）。 例子 1下面的例子把 css(), slideUp(), and slideDown() 链接在一起。”p1” 元素首先会变为红色，然后向上滑动，然后向下滑动： $(&quot;#p1&quot;).css(&quot;color&quot;,&quot;red&quot;).slideUp(2000).slideDown(2000); 这些是jquery的基础动画，jquery真的是一个经典的库！！！ 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/19/jQuery-效果-动画(1)/]]></content>
      <tags>
        <tag>js</tag>
        <tag>jquery</tag>
        <tag>动画</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步coding教程]]></title>
    <url>%2F2017%2F06%2F19%2F%E5%90%8C%E6%AD%A5%E5%88%B0coding%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[coding是国内版的github，这篇文章默认是已经在github上布置好了，写的是现在在coding在布置教程 参考网址： hexo干货系列：（四）将hexo博客同时托管到github和coding Hexo搭建独立博客，托管到Github和Coding上教程 YAML 语言教程 - 阮一峰的网络日志步骤： 注册coding帐号访问官网注册并登录 创建仓库,点+创建项目,这里我创建为jaymo （仓库名称和用户名一样，推荐；ps：如果你的项目名称跟你coding的用户名一样，jaymo,博客项目名也叫jaymo那直接访问jaymo.coding.me就能访问博客，否则就要带上项目名:jaymo.coding.me/项目名 才能访问推荐项目名跟用户名一样，这样就可以省略项目名了） 配置SHH，配置shh key是让本地git项目与远程的github建立联系 ： 1cd ~/.ssh 输入cat命令，打开id_rsa.pub文件 1cat id_rsa.pub 复制ssh到Coding的SSH中（这里直接使用之前部署github时已经生成的公钥）4.打开Git Bash，然后输入 1ssh -T git@git.coding.net 输入密码后，如果显示以下内容，则说明coding中的ssh配置成功。 12Hi username! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 4.创建Coding Pages 服务 官网点击代码再点击Coding Pages 服务开启。分支和github分支写一样，填写master 打开根目录中的_config.yml文件，找到如下位置，填写 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:yourname/yourname.github.io.git,master coding: git@git.coding.net:yourname/yourname.git,master 5.在根目录中空白处右击打开Git Bash输入 123hexo s #启动服务，调试用hexo g #生成静态网页hexo d #开始部署 设置自动部署 找到项目设置那边的WebHook,然后点击新建 Hook 第一个输入框中是填你的博客域名，然后在后面加上 /_，比如我的http://jaymo.coding.me/_ 第二个输入框是输入一个token，我们直接填写就可以了。 未完！！！下一篇将结束自动部署。 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/19/同步到coding教程/]]></content>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步coding教程]]></title>
    <url>%2F2017%2F06%2F19%2F%E5%90%8C%E6%AD%A5%E5%88%B0coding%E6%95%99%E7%A8%8B(1)%2F</url>
    <content type="text"><![CDATA[coding是国内版的github，这篇文章默认是已经在github上布置好了，写的是现在在coding在布置教程 参考网址： hexo干货系列：（四）将hexo博客同时托管到github和coding Hexo搭建独立博客，托管到Github和Coding上教程 YAML 语言教程 - 阮一峰的网络日志步骤： 注册coding帐号访问官网注册并登录 创建仓库,点+创建项目,这里我创建为jaymo （仓库名称和用户名一样，推荐；ps：如果你的项目名称跟你coding的用户名一样，jaymo,博客项目名也叫jaymo那直接访问jaymo.coding.me就能访问博客，否则就要带上项目名:jaymo.coding.me/项目名 才能访问推荐项目名跟用户名一样，这样就可以省略项目名了） 配置SHH，配置shh key是让本地git项目与远程的github建立联系 ： 1cd ~/.ssh 输入cat命令，打开id_rsa.pub文件 1cat id_rsa.pub 复制ssh到Coding的SSH中（这里直接使用之前部署github时已经生成的公钥）4.打开Git Bash，然后输入 1ssh -T git@git.coding.net 输入密码后，如果显示以下内容，则说明coding中的ssh配置成功。 12Hi username! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 4.创建Coding Pages 服务 官网点击代码再点击Coding Pages 服务开启。分支和github分支写一样，填写master 打开根目录中的_config.yml文件，找到如下位置，填写 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:yourname/yourname.github.io.git,master coding: git@git.coding.net:yourname/yourname.git,master 5.在根目录中空白处右击打开Git Bash输入 123hexo s #启动服务，调试用hexo g #生成静态网页hexo d #开始部署 设置自动部署 找到项目设置那边的WebHook,然后点击新建 Hook 第一个输入框中是填你的博客域名，然后在后面加上 /_，比如我的http://jaymo.coding.me/_ 第二个输入框是输入一个token，我们直接填写就可以了。 未完！！！下一篇将结束自动部署。 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/19/同步到coding教程(1)/]]></content>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主题页面设置]]></title>
    <url>%2F2017%2F06%2F19%2F%E4%B8%BB%E9%A2%98%E9%A1%B5%E9%9D%A2%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[主题页面的简单设置 参考网站 NexT主题 下载主题 12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题：启用了Pisces - 双栏 Scheme，小家碧玉似的清新在\themes\next文件夹中找到站点配置文件_config.yml文件，选择 Scheme，去掉scheme前面注释#，如： 123#scheme: Muse#scheme: Mistscheme: Pisces 设置 语言编辑_config.yml，配置：1language: zh-Hans 设置 菜单1234567menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html 设置菜单项的显示文本在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的languages/{language}.yml （{language} 为你所使用的语言）。以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml，在menu 字段下添加一项： 123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 something: 有料 设定菜单项的图标对应的字段是 menu_icons。 此设定格式是item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。 123456789menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat 设置 头像放置在了 source/images/ 目录下 ,如下： 集成常用的第三方服务百度统计 登录 百度统计， 定位到站点的代码获取页面 复制 hm.js? 后面那串统计脚本 id 编辑 主题配置文件， 修改字段 baidu_analytics 字段，值设置成你的百度统计脚本 id。所以，页面已经设置了百度统计阅读次数统计以按照 为NexT主题添加文章阅读量统计功能，注册了https://leancloud.cn如图：创建了JayMo个人博客应用，创建了名称为Counter的Class,复制AppID以及AppKey并在NexT主题的_config.yml文件中我们相应的位置填入即可，正确配置之后文件内容像这个样子: 1234leancloud_visitors: enable: true app_id: joaeuuc4hsqudUUwx4gIvGF6-gzGzoHsz app_key: E9UJsJpw1omCHuS22PdSpKoh Web安全以设置只能通过：jaymo666.github.io/或jaymo.cf/来访问,确保数据调用的安全。 数据统计与分析配置了百度分享搜索服务Local Search添加百度/谷歌/本地 自定义站点内容搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 2.编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 评论服务注册了Disqus，配置了评论 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/19/主题页面设置/]]></content>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主题页面设置]]></title>
    <url>%2F2017%2F06%2F19%2F%E4%B8%BB%E9%A2%98%E9%A1%B5%E9%9D%A2%E8%AE%BE%E7%BD%AE(1)%2F</url>
    <content type="text"><![CDATA[主题页面的简单设置 参考网站 NexT主题 下载主题 12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题：启用了Pisces - 双栏 Scheme，小家碧玉似的清新在\themes\next文件夹中找到站点配置文件_config.yml文件，选择 Scheme，去掉scheme前面注释#，如： 123#scheme: Muse#scheme: Mistscheme: Pisces 设置 语言编辑_config.yml，配置：1language: zh-Hans 设置 菜单1234567menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html 设置菜单项的显示文本在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的languages/{language}.yml （{language} 为你所使用的语言）。以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml，在menu 字段下添加一项： 123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 something: 有料 设定菜单项的图标对应的字段是 menu_icons。 此设定格式是item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。 123456789menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat 设置 头像放置在了 source/images/ 目录下 ,如下： 集成常用的第三方服务百度统计 登录 百度统计， 定位到站点的代码获取页面 复制 hm.js? 后面那串统计脚本 id 编辑 主题配置文件， 修改字段 baidu_analytics 字段，值设置成你的百度统计脚本 id。所以，页面已经设置了百度统计阅读次数统计以按照 为NexT主题添加文章阅读量统计功能，注册了https://leancloud.cn如图：创建了JayMo个人博客应用，创建了名称为Counter的Class,复制AppID以及AppKey并在NexT主题的_config.yml文件中我们相应的位置填入即可，正确配置之后文件内容像这个样子: 1234leancloud_visitors: enable: true app_id: joaeuuc4hsqudUUwx4gIvGF6-gzGzoHsz app_key: E9UJsJpw1omCHuS22PdSpKoh Web安全以设置只能通过：jaymo666.github.io/或jaymo.cf/来访问,确保数据调用的安全。 数据统计与分析配置了百度分享搜索服务Local Search添加百度/谷歌/本地 自定义站点内容搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 2.编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 评论服务注册了Disqus，配置了评论 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/19/主题页面设置(1)/]]></content>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建及使用]]></title>
    <url>%2F2017%2F06%2F19%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8(1)%2F</url>
    <content type="text"><![CDATA[博客搭建及使用 参考网站 基于hexo+github搭建一个独立博客 主题：Anisina 中文使用教程 手把手教你用Hexo+Github 搭建属于自己的博客 用Hexo创建个人博客 用Hexo创建个人博客步骤 搭建环境准备（包括node.js和git环境，gitHub账户的配置） 安装Hexo 配置Hexo 怎样将Hexo与github page 联系起来 怎样发布文章 主题 推荐 主题Net的简单配置 添加sitemap和feed插件 添加404 公益页面 在搭建中我使用的不是推荐的Net主题，而是Anisina 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 比如我的电脑下的 F:\JayMo666 目录下的成为 站点配置文件，F:\JayMo66\themes\Anisina 目录下的成为主题配置文件。具体如何配置详细看上面的网站：主题：Anisina 中文使用教程 创建博客步骤：在1.Run server 1$ hexo server F:\JayMo666启动命令行执行下面命令：3.1hexo new post &quot;文章标题&quot; 这时候在我的 电脑的目录下 F:\JayMo666\source\ _posts 将会看到文章标题.md 文件 4.用MarDown编辑器打开就可以编辑文章了。文章编辑好之后，运行生成、部署命令： 1hexo d -g #在部署前先生成 其中g代表 generate（md文件生成html文件） d 代表deploy(配置) 这样个人博客基本就ok了，剩下的就是完善了 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/19/博客搭建及使用(1)/]]></content>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建及使用]]></title>
    <url>%2F2017%2F06%2F19%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[博客搭建及使用 参考网站 基于hexo+github搭建一个独立博客 主题：Anisina 中文使用教程 手把手教你用Hexo+Github 搭建属于自己的博客 用Hexo创建个人博客 用Hexo创建个人博客步骤 搭建环境准备（包括node.js和git环境，gitHub账户的配置） 安装Hexo 配置Hexo 怎样将Hexo与github page 联系起来 怎样发布文章 主题 推荐 主题Net的简单配置 添加sitemap和feed插件 添加404 公益页面 在搭建中我使用的不是推荐的Net主题，而是Anisina 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 比如我的电脑下的 F:\JayMo666 目录下的成为 站点配置文件，F:\JayMo66\themes\Anisina 目录下的成为主题配置文件。具体如何配置详细看上面的网站：主题：Anisina 中文使用教程 创建博客步骤：在1.Run server 1$ hexo server F:\JayMo666启动命令行执行下面命令：3.1hexo new post &quot;文章标题&quot; 这时候在我的 电脑的目录下 F:\JayMo666\source\ _posts 将会看到文章标题.md 文件 4.用MarDown编辑器打开就可以编辑文章了。文章编辑好之后，运行生成、部署命令： 1hexo d -g #在部署前先生成 其中g代表 generate（md文件生成html文件） d 代表deploy(配置) 这样个人博客基本就ok了，剩下的就是完善了 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/19/博客搭建及使用/]]></content>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next-主题配置教程]]></title>
    <url>%2F2017%2F06%2F19%2Fnext-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[next-主题页面设置。使用了next，next在众多主题中评分最高，使用了几个主题后，发现它确实好用，PS：hexo很方便更换主题，赞 参考网站 NexT主题 下载主题 12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题：启用了Pisces - 双栏 Scheme，小家碧玉似的清新在\themes\next文件夹中找到站点配置文件_config.yml文件，选择 Scheme，去掉scheme前面注释#，如： 123#scheme: Muse#scheme: Mistscheme: Pisces 设置 语言编辑_config.yml，配置：1language: zh-Hans 设置 菜单1234567menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html 设置菜单项的显示文本在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的languages/{language}.yml （{language} 为你所使用的语言）。以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml，在menu 字段下添加一项： 123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 something: 有料 设定菜单项的图标对应的字段是 menu_icons。 此设定格式是item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。 123456789menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat 设置 头像放置在了 source/images/ 目录下 ,如下： 集成常用的第三方服务百度统计 登录 百度统计， 定位到站点的代码获取页面 复制 hm.js? 后面那串统计脚本 id 编辑 主题配置文件， 修改字段 baidu_analytics 字段，值设置成你的百度统计脚本 id。所以，页面已经设置了百度统计阅读次数统计以按照 为NexT主题添加文章阅读量统计功能，注册了https://leancloud.cn如图：创建了JayMo个人博客应用，创建了名称为Counter的Class,复制AppID以及AppKey并在NexT主题的_config.yml文件中我们相应的位置填入即可，正确配置之后文件内容像这个样子: 1234leancloud_visitors: enable: true app_id: joaeuuc4hsqudUUwx4gIvGF6-gzGzoHsz app_key: E9UJsJpw1omCHuS22PdSpKoh Web安全以设置只能通过：jaymo666.github.io/或jaymo.cf/来访问,确保数据调用的安全。 数据统计与分析配置了百度分享搜索服务Local Search添加百度/谷歌/本地 自定义站点内容搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 2.编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 评论服务注册了Disqus，配置了评论 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/19/next-主题配置教程/]]></content>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next-主题配置教程]]></title>
    <url>%2F2017%2F06%2F19%2Fnext-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B(1)%2F</url>
    <content type="text"><![CDATA[next-主题页面设置。使用了next，next在众多主题中评分最高，使用了几个主题后，发现它确实好用，PS：hexo很方便更换主题，赞 参考网站 NexT主题 下载主题 12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题：启用了Pisces - 双栏 Scheme，小家碧玉似的清新在\themes\next文件夹中找到站点配置文件_config.yml文件，选择 Scheme，去掉scheme前面注释#，如： 123#scheme: Muse#scheme: Mistscheme: Pisces 设置 语言编辑_config.yml，配置：1language: zh-Hans 设置 菜单1234567menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html 设置菜单项的显示文本在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的languages/{language}.yml （{language} 为你所使用的语言）。以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml，在menu 字段下添加一项： 123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 something: 有料 设定菜单项的图标对应的字段是 menu_icons。 此设定格式是item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。 123456789menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat 设置 头像放置在了 source/images/ 目录下 ,如下： 集成常用的第三方服务百度统计 登录 百度统计， 定位到站点的代码获取页面 复制 hm.js? 后面那串统计脚本 id 编辑 主题配置文件， 修改字段 baidu_analytics 字段，值设置成你的百度统计脚本 id。所以，页面已经设置了百度统计阅读次数统计以按照 为NexT主题添加文章阅读量统计功能，注册了https://leancloud.cn如图：创建了JayMo个人博客应用，创建了名称为Counter的Class,复制AppID以及AppKey并在NexT主题的_config.yml文件中我们相应的位置填入即可，正确配置之后文件内容像这个样子: 1234leancloud_visitors: enable: true app_id: joaeuuc4hsqudUUwx4gIvGF6-gzGzoHsz app_key: E9UJsJpw1omCHuS22PdSpKoh Web安全以设置只能通过：jaymo666.github.io/或jaymo.cf/来访问,确保数据调用的安全。 数据统计与分析配置了百度分享搜索服务Local Search添加百度/谷歌/本地 自定义站点内容搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 2.编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 评论服务注册了Disqus，配置了评论 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/19/next-主题配置教程(1)/]]></content>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
