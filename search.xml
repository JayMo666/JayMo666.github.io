<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTTP协议缓存机制详解]]></title>
    <url>%2F2018%2F05%2F21%2FHTTP%E5%8D%8F%E8%AE%AE%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[浏览器 HTTP 协议缓存机制详解 ，包括缓存分类，HTTP协议定义的缓存机制 浏览器 HTTP 协议缓存机制详解缓存分为服务端侧（server side，比如 Nginx、Apache）和客户端侧（client side，比如 web browser) 服务端缓存又分为 代理服务器缓存 和 反向代理服务器缓存（也叫网关缓存，比如 Nginx反向代理、Squid等），其实广泛使用的 CDN 也是一种服务端缓存，目的都是让用户的请求走”捷径“，并且都是缓存图片、文件等静态资源。 客户端侧缓存一般指的是浏览器缓存，目的就是加速各种静态资源的访问，想想现在的大型网站，随便一个页面都是一两百个请求，每天 pv 都是亿级别，如果没有缓存，用户体验会急剧下降、同时服务器压力和网络带宽都面临严重的考验。 浏览器缓存机制详解浏览器缓存机制，其实主要就是HTTP协议定义的缓存机制（如： Expires； Cache-control等）。但是也有非HTTP协议定义的缓存机制，如使用HTML Meta 标签，Web开发者可以在HTML页面的节点中加入标签，代码如下1&lt;META HTTP-EQUIV=&quot;Pragma&quot; CONTENT=&quot;no-cache&quot;&gt; 上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。使用上很简单，但只有部分浏览器可以支持，而且所有缓存代理服务器都不支持，因为代理不解析HTML内容本身。而广泛应用的还是 HTTP头信息 来控制缓存，下面我主要介绍HTTP协议定义的缓存机制。 HTTP头信息控制缓存浏览器请求流程浏览器第一次请求流程图： 浏览器再次请求时： 几个重要概念解释 Expires策略：Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大（比如时钟不同步，或者跨时区），那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。 Cache-control策略（重点关注）：Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。 值可以是public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age各个消息中的指令含义如下： Public指示响应可被任何缓存区缓存。 Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允 许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。 no-cache指示请求或响应消息不能缓存，该选项并不是说可以设置”不缓存“，容易望文生义~ no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存，完全不存下來。 max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。 min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。 max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。 Last-Modified/If-Modified-Since：Last-Modified/If-Modified-Since要配合Cache-Control使用。 Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。 If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。 Etag/If-None-Match：Etag/If-None-Match也要配合Cache-Control使用。 Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。 既生Last-Modified何生Etag？你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题： Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形 Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag一起使用时，服务器会优先验证ETag。 yahoo的Yslow法则中则提示谨慎设置Etag：需要注意的是分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败，Yahoo建议分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样，因为除了 last-modified、inode 也很难保持一致)。 Pragma行是为了兼容HTTP1.0，作用与Cache-Control: no-cache是一样的。 最后总结下几种状态码的区别： 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2018/05/21/HTTP协议缓存机制详解/]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数组方法对比]]></title>
    <url>%2F2018%2F04%2F23%2FJavaScript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[JavaScript 提供了多种新增，移除，替换数组元素的方法，但是有些会影响原来的数组；有些则不会，它是新建了一个数组。 JavaScript数组方法对比 JavaScript 提供了多种新增，移除，替换数组元素的方法，但是有些会影响原来的数组；有些则不会，它是新建了一个数组。 新增：影响原数组使用 array.push() 和 array.ushift() 新增元素会影响原来的数组。12345let mutatingAdd = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];mutatingAdd.push(&apos;f&apos;); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;]mutatingAdd.unshift(&apos;z&apos;); // [&apos;z&apos;, &apos;a&apos;,&apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; &apos;f&apos;] 新增：不影响原数组两种方式新增元素不会影响原数组，第一种是 array.concat() 。12345const arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];const arr2 = arr1.concat(&apos;f&apos;); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;] console.log(arr1); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;] 第二种方法是使用 JavaScript 的展开（spread）操作符，展开操作符是三个点（…）12345const arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];const arr2 = [...arr1, &apos;f&apos;]; // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;] const arr3 = [&apos;z&apos;, ...arr1]; // [&apos;z&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;] 展开操作符会复制原来的数组，从原数组取出所有元素，然后存入新的环境。 移除：影响原数组使用 array.pop() 和 array.shift() 移除数组元素时，会影响原来的数组。12345let mutatingRemove = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]; mutatingRemove.pop(); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;] mutatingRemove.shift(); // [&apos;b&apos;, &apos;c&apos;, &apos;d&apos;] array.splice() 也可以删除数组的元素。123let mutatingRemove = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]; mutatingRemove.splice(0, 2); // [&apos;c&apos;, &apos;d&apos;, &apos;e&apos;] splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。 arrayObject.splice(index,howmany,item1,.....,itemX)参数| 描述—|—index |必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。howmany| 必需。要删除的项目数量。如果设置为 0，则不会删除项目。item1, …, itemX |可选。向数组添加的新项目。 移除：不影响原数组JavaScript 的 array.filter() 方法基于原数组创建一个新数组，新数组仅包含匹配特定条件的元素。12345678910const arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];const arr2 = arr1.filter(a =&gt; a !== &apos;e&apos;); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]// 或者const arr2 = arr1.filter(a =&gt; &#123; return a !== &apos;e&apos;;&#125;); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;] 以上代码的条件是“不等于 ‘e’ ”，因此新数组（arr2）里面没有包含 ‘e’。 另一种不影响原数组的方式是 array.slice()（不要与 array.splice() 混淆）。 12345const arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]; const arr2 = arr1.slice(1, 5) // [&apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;] const arr3 = arr1.slice(2) // [&apos;c&apos;, &apos;d&apos;, &apos;e&apos;] slice() 方法可从已有的数组中返回选定的元素。 语法arrayObject.slice(start,end)参数| 描述—|—start| 必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。end| 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 如果 end 未被规定，那么 slice() 方法会选取从 start 到数组结尾的所有元素。 替换：影响原数组可以使用 array.map() 创建一个新数组，并且可以检查每一个元素，根据特定的条件替换它们。 1234567891011const arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;] const arr2 = arr1.map(item =&gt; &#123; if(item === &apos;c&apos;) &#123; item = &apos;CAT&apos;; &#125; return item;&#125;); // [&apos;a&apos;, &apos;b&apos;, &apos;CAT&apos;, &apos;d&apos;, &apos;e&apos;] 使用 array.map() 转换数据array.map() 是个强力方法，可以用于转换数据，而不污染原先的数据源。12345const origArr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]; const transformedArr = origArr.map(n =&gt; n + &apos;Hi!&apos;); // [&apos;aHi!&apos;, &apos;bHi!&apos;, &apos;cHi!&apos;, &apos;dHi!&apos;, &apos;eHi!&apos;] console.log(origArr); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]; // 原数组毫发无损 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2018/04/23/JavaScript数组方法对比/]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典前端题1]]></title>
    <url>%2F2018%2F04%2F16%2F%E7%BB%8F%E5%85%B8%E5%89%8D%E7%AB%AF%E9%A2%981%2F</url>
    <content type="text"><![CDATA[经典前端题(1) 经典前端题(1)用typeof来判断对象的潜在陷阱问：使用 typeof bar === “object” 来确定 bar 是否是对象的潜在陷阱是什么？如何避免这个陷阱？ 尽管 typeof bar === “object” 是检查 bar 是否对象的可靠方法，令人惊讶的是在JavaScript中 null 也被认为是对象！ 因此，令大多数开发人员惊讶的是，下面的代码将输出 true 控制台：123var bar = null;console.log(typeof bar === &quot;object&quot;); // true! 只要清楚这一点，同时检查 bar 是否为 null，就可以很容易地避免问题：12345console.log( (bar !== null) &amp;&amp; (typeof bar === &quot;object&quot;)); 下面的代码将输出什么到控制台(是否加var)123456(function()&#123; var a = b = 3;&#125;)(); console.log(typeof a == &apos;undefined&apos;);console.log(typeof b == &apos;undefined&apos;); 部分开发者就会认为，变量a和b都是声明定义在匿名函数内部的，属于函数内的局部变量，如果要在函数外部进行打印调用，a和b则为undefined。所以最后两行代码打印的结果都是true。 然而结果并非如此，之所以这么理解的原因是，他们把1var a = b = 3; 这句代码错误地理解为等同于：12var b = 3;var a = b; 而事实上，它等同于：12b = 3;var a = b; 这个时候的变量b声明是不加关键字var的，也就是说变量b是全局变量（隐式全局变量）。 所以最后我们得到的结果分别是：true和false。 在严格模式下（使用 use strict），又会是什么结果？这里就要注意一点了，在严格模式下我们运行后得到的结果是：1报错:b is not undefined 这也正是因为严格模式的这个特点，可以避免很多不必要的bug（全局变量污染）。 关于this指向的常见面试题看下面的代码，你觉得输出的结果是什么？12345678910111213var myObject = &#123; foo: &quot;bar&quot;, func: function() &#123; var self = this; console.log(this.foo); console.log(self.foo); (function() &#123; console.log(this.foo); console.log(self.foo); &#125;()); &#125;&#125;;myObject.func(); 在外部函数中， this 和 self 两者都指向了 myObject ，因此两者都可以正确地引用和访问 foo 。 在内部函数中, this不再指向myObject.其结果可以console.log(this)打印出来，发现是：Windows对象。（在ECMA 5之前，在内部函数中的this 将指向全局的window对象；反之，因为作为ECMA 5，内部函数中的功能this 是未定义的。） 上面的代码将输出以下内容到控制台： 1234barbarundefinedbar use strict 有什么意义和好处？ use strict 是一种在JavaScript代码运行时自动实行更严格解析和错误处理的方法。 严格模式是ES5引入的，更好的将错误检测引入代码的方法.包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。 设立”严格模式”的目的，主要有以下几个： 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 1234567891011121314151617181920212223242526272829303132变量必须先声明，再使用function test()&#123; &quot;use strict&quot;; foo = &apos;bar&apos;; // Error&#125; 不能对变量执行delete操作var foo = &quot;test&quot;;function test()&#123;&#125; delete foo; // Errordelete test; // Error function test2(arg) &#123; delete arg; // Error&#125;对象的属性名不能重复&#123; foo: true, foo: false &#125; // Error 禁用eval() 函数的arguments参数setTimeout(function later()&#123; // do stuff... setTimeout( later, 1000 );&#125;, 1000 ); 禁用with()&#123;&#125; 不能修改arguments不能在函数内定义arguments变量不能使用arugment.caller和argument.callee。因此如果你要引用匿名函数，需要对匿名函数命名。 进入标志1&quot;use strict&quot;; 老版本的浏览器会把它当作一行普通字符串，加以忽略。 如何调用针对整个脚本文件将”use strict”放在脚本文件的第一行，则整个脚本都将以”严格模式”运行。如果这行语句不在第一行，则无效，整个脚本以”正常模式”运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。 (严格地说，只要前面不是产生实际运行结果的语句，”use strict”可以不在第一行，比如直接跟在一个空的分号后面。)1234567&lt;script&gt; &quot;use strict&quot;; console.log(&quot;这是严格模式。&quot;);&lt;/script&gt;&lt;script&gt; console.log(&quot;这是正常模式。&quot;);kly, it&apos;s almost 2 years ago now. I can admit it now - I run it on my school&apos;s network that has about 50 computers.&lt;/script&gt; 上面的代码表示，一个网页中依次有两段Javascript代码。前一个script标签是严格模式，后一个不是。 针对单个函数将”use strict”放在函数体的第一行，则整个函数以”严格模式”运行。1234567function strict()&#123; &quot;use strict&quot;; return &quot;这是严格模式。&quot;;&#125;function notStrict() &#123; return &quot;这是正常模式。&quot;;&#125; 脚本文件的变通写法因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。123456(function ()&#123; &quot;use strict&quot;; // some code here &#125;)(); 小心javascript自动插入分号机制在《JavaScript语言精粹》这本书里，这个“自动插入分号”机制被划入到了JavaScript的毒瘤里面，与之并列的前面的全局变量。 有些时候，不合时宜地插入分号，会导致严重的后果。 比如一个return语句要正确返回一个值，这个值的表达式的开始部分必须和return位于同一行。 今天，我们就来聊聊这个知识点，看下面的代码函数，它们会返回什么？1234567891011121314151617function foo1()&#123; return &#123; bar: &quot;hello&quot; &#125;;&#125; function foo2()&#123; return &#123; bar: &quot;hello&quot; &#125;;&#125;console.log(&quot;foo1 returns:&quot;);console.log(foo1());console.log(&quot;foo2 returns:&quot;);console.log(foo2()); 将产生：1234foo1 returns:Object &#123;bar: &quot;hello&quot;&#125;foo2 returns:undefined 这不仅是令人惊讶，而且特别让人困惑的是， foo2()返回的是undefined，也没有任何错误抛出。原因是这样的，当碰到 foo2()中包含return语句的代码行（代码行上没有其他任何代码），分号会立即自动插入到返回语句之后。请仔细留意上面两个函数中return的不同之处，foo2函数的return是单独一行的。 也不会抛出错误，因为代码的其余部分是完全有效的，即使它没有得到调用或做任何事情（相当于它就是是一个未使用的代码块，定义了等同于字符串 “hello”的属性 bar）。 所以，在使用return语句的时候，要留意javascript的这个特点，尽可能不要将return关键字写在独立的一行，避免不必造成不必要的错误。 NaN 是什么？如何测试一个值是否等于 NaN ？NaN 属性代表一个“不是数字”的值。这个特殊的值是因为运算不能执行而导致的，不能执行的原因要么是因为其中的运算对象之一非数字。例如： “abc” / 4。首先，虽然 NaN 意味着“不是数字”，但是它的类型，不管你信不信，是 Number：12console.log(typeof NaN === &quot;number&quot;); // logs &quot;true&quot; 此外， NaN 和任何东西比较，甚至是它自己本身，结果是false：12console.log(NaN === NaN); // logs &quot;false&quot; 一种半可靠的方法来测试一个数字是否等于 NaN，是使用内置函数 isNaN()，但即使使用 isNaN() 依然并非是一个完美的解决方案。 一个更好的解决办法是使用 value !== value，如果值等于NaN，只会产生true。因为只有NaN 这货，才会自己不等于自己。 另外，ES6提供了一个新的Number.isNaN() 函数，这是一个不同的函数，并且比老的全局 isNaN() 函数更可靠。 Number.isNaN()和全局函数isNaN() 相比，该方法不会强制将参数转换成数字，只有在参数是真正的数字类型，且值为 NaN 的时候才会返回 true。 123456789101112131415161718Number.isNaN(NaN); // trueNumber.isNaN(Number.NaN); // trueNumber.isNaN(0 / 0) // true// 下面这几个如果使用全局的 isNaN() 时，会返回 true。Number.isNaN(&quot;NaN&quot;); // false，字符串 &quot;NaN&quot; 不会被隐式转换成数字 NaN。Number.isNaN(undefined); // falseNumber.isNaN(&#123;&#125;); // falseNumber.isNaN(&quot;blabla&quot;); // false// 下面的都返回 falseNumber.isNaN(true);Number.isNaN(null);Number.isNaN(37);Number.isNaN(&quot;37&quot;);Number.isNaN(&quot;37.37&quot;);Number.isNaN(&quot;&quot;);Number.isNaN(&quot; &quot;); 下面的代码运行结果是什么？(自动类型转换)JavaScript（ECMAScript）是一种弱类型语言，它可对值进行自动类型转换，以适应正在执行的操作。 让我们通过下面的6个例子来说明一下。例子1：1console.log(1 + &quot;2&quot; + &quot;2&quot;); 得到的结果是：&quot;122&quot;解析： 1 + “2” + “2” 输出： “122” 。 1 + “2” 是执行的第一个操作。由于其中一个运算对象 “2” 是字符串，JavaScript会假设它需要执行字符串连接，因此，会将 1 的类转换为 “1” ， 1+”2” 结果就是 “12” 。然后， “12”+”2” 就是 “122” 。 例子2：1console.log(1 + +&quot;2&quot; + &quot;2&quot;); 得到的结果是：&quot;32&quot;解析： 1 + +”2” + “2” 输出： “32” 说明：根据运算的顺序，要执行的第一个运算是 +”2” （第一个 “2” 前面的额外 + 被视为一元运算符）。 因此，JavaScript将 “2” 的类型转换为数字，然后应用一元 + 号（即将其视为一个正数）。其结果就是得到一个数字 2 ，接下来的运算就是 1 + 2 ，这当然是 3 。 然后我们需要在一个数字和一个字符串之间进行运算（即， 3 和 “2”），同样的，JavaScript会将数值类型转换为字符串，并执行字符串的连接，产生 “32” 。 例子3：1console.log(1 + -&quot;1&quot; + &quot;2&quot;); 得到的结果是：&quot;02&quot;解析： 1 + -“1” + “2” 输出： “02” 。这里的解释和前一个例子相同，不同的地方是此处的一元运算符是 - 而不是 + 。 先是 “1” 变为 1 ，然后当应用 - 时又变为了 -1 ，然后将其与 1 相加，结果为 0 ，再将其转换为字符串，连接最后的 “2” 运算对象，得到 “02” 。 例子4：1console.log(+&quot;1&quot; + &quot;1&quot; + &quot;2&quot;); 得到的结果是：&quot;112&quot;解析： +”1” + “1” + “2” 输出： “112” 。虽然第一个运算对象 “1” 因为前缀的一元 + 运算符类型转换为数值，但当连接到第二个运算对象 “1” 的时候，又立即转换回字符串，然后又和最后的运算对象 “2” 连接，产生了字符串 “112” 。 例子5：1console.log( &quot;A&quot; - &quot;B&quot; + &quot;2&quot;); 得到的结果是：&quot;NaN2&quot;解析： “A” - “B” + “2” 输出： “NaN2” 。由于运算符 - 不能被应用于字符串，并且 “A” 和 “B” 都不能转换成数值，因此， “A” - “B” 的结果是 NaN ，然后再和字符串 “2” 连接，得到 “NaN2” 。 例子6：1console.log( &quot;A&quot; - &quot;B&quot; + 2); 得到的结果是：NaN解析： “A” - “B” + 2 输出： NaN 。参见前一个例子， “A” - “B” 结果为 NaN 。但是，应用任何运算符到 NaN 与其他任何的数字运算对象，结果仍然是 NaN 。 关于逻辑运算符，下面代码运行的结果是什么？逻辑运算符用于测定变量或值之间的逻辑。在我们实际开发过程中十分常用，所以面试官会把逻辑运算符的知识点当作考察应聘者的内容之一。 在JavaScript中， || 和 &amp;&amp; 都是逻辑运算符，用于在从左至右计算时，返回第一个可完全确定的“逻辑值”。 或 || 运算符。在 X||Y 的表达式中，首先计算 X 并将其解释执行为一个布尔值。 如果这个布尔值true，那么返回true（1），不再计算 Y ，因为“或”的条件已经满足。 如果这个布尔值为false，那么我们仍然不能知道 X||Y 是真是假，直到我们计算 Y ，并且也把它解释执行为一个布尔值。 因此， 0||1 的计算结果为true（1），同理计算 1||2 。 与 &amp;&amp; 运算符。在 X&amp;&amp;Y 的表达式中，首先计算 X 并将其解释执行为一个布尔值。 如果这个布尔值为 false，那么返回 false（0），不再计算 Y ，因为“与”的条件已经失败。 如果这个布尔值为true，但是，我们仍然不知道 X&amp;&amp;Y 是真是假，直到我们去计算 Y ，并且也把它解释执行为一个布尔值。 . 不过，关于 &amp;&amp; 运算符有趣的地方在于，当一个表达式计算为“true”的时候，那么就返回表达式本身。 这很好，虽然它在逻辑表达式方面计算为“真”，但如果你希望的话也可用于返回该值。这就解释了为什么，有些令人奇怪的是， 1 &amp;&amp; 2返回 2，而不是你以为的可能返回 true 或 1。 1234console.log( 0 || 1 );console.log( 1 || 2 );console.log( 0 &amp;&amp; 1 );console.log( 1 &amp;&amp; 2 ); 答案：···1102··· 以下代码将输出什么？(设置对象的属性)看下面的代码，输出的结果是什么？并解释你的答案。12345678var a=&#123;&#125;, b=&#123;key:&apos;b&apos;&#125;, c=&#123;key:&apos;c&apos;&#125;;a[b]=123;a[c]=456;console.log(a[b]); 不少人可能会以为答案是123 ，但结果是 456 ，为什么会是这样子的呢。 原因是我们忽略了一个知识点：JavaScript在设置对象的属性的时候，会暗中字符串化参数值。 在这里例子中，由于 b 和 c都是对象，把它们设置为对象a的参数，它们都将被转换为&quot;[object Object]&quot; 。 结果就是， a[b] 和 a[c] 都相当 “[object Object]” ，而后者会将前者的值覆盖。 因此，设置或引用 a[c] 和设置或引用 a[b] 完全相同。所以得到的答案是 456 。把对象b作为a的属性的时候，会先调用对象b的toString()方法。123var b=&#123;key:&apos;b&apos;&#125;; console.log(b.toString()); //[object Object] c也类似，因为转换后得自符串是一样的，所以后面的会覆盖前面的 关于this指向，以下代码将输出什么看下面的代码，输出的结果是什么？并解释你的答案。 1234567891011var person = &#123; _name: &apos;I am John&apos;, sayHello: function ()&#123; return this._name; &#125;&#125;; var sayHello = person.sayHello;console.log(sayHello());console.log(person.sayHello()); 代码运行的结果是：12undefinedI am John 第二个打印 person.sayHello()的结果是： I am John这个好理解。 为什么第一次打印出来的结果是 undefined 呢？明明是直接赋值过去的呀。这里涉及到的知识点就是：this的指向。 在执行sayHello()的时候，当访问到 this._name 时，此时的this已经不再是 person 对象，而是全局窗口对象，也就是 widnow 对象。 参考文章： Javascript 严格模式use strict详解 微信公众号：web前端教程 MDN web docs 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2018/04/16/经典前端题1/]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式详解]]></title>
    <url>%2F2018%2F04%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[用php实例代码解释软件设计模式 16 个 PHP 设计模式详解(1)概念 在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。 分类设计模式主要分为三大类，各自还有许多子类 创建型模式 结构型模式 行为型模式 1.创建型模式模式名|描述—|—抽象工厂模式| 为一个产品族提供了统一的创建接口。当需要这个产品族的某一系列的时候，可以从抽象工厂中选出相应的系列创建一个具体的工厂类工厂方法模式| 定义一个接口用于创建对象，但是让子类决定初始化哪个类。工厂方法把一个类的初始化下放到子类。生成器模式|将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。惰性初始模式| 推迟对象的创建、数据的计算等需要耗费较多资源的操作，只有在第一次访问的时候才执行。对象池模式| 通过回收利用对象避免获取和释放资源所需的昂贵成本。原型模式| 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。单例模式 |确保一个类只有一个实例，并提供对该实例的全局访问 2.结构性模式 模式名 描述 适配器模式 将某个类的接口转换成客户端期望的另一个接口表示。适配器模式可以消除由于接口不匹配所造成的类兼容性问题。 桥接模式 将一个抽象与实现解耦，以便两者可以独立的变化。 组合模式 把多个对象组成树状结构来表示局部与整体，这样用户可以一样的对待单个对象和对象的组合。 修饰模式 向某个对象动态地添加更多的功能。修饰模式是除类继承外另一种扩展功能的方法。 外观模式 为子系统中的一组接口提供一个一致的界面， 外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 享元 通过共享以便有效的支持大量小颗粒对象。 代理 为其他对象提供一个代理以控制对这个对象的访问。 3.行为型模式 模式名 描述 黑板 广义的观察者在系统范围内交流信息，允许多位读者和写者。 责任链 为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。 命令 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。 解释器 给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。 迭代器 提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。 中介者 包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用，从而使它们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用，保证这些作用可以彼此独立的变化。 备忘录 备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。 空对象 通过提供默认对象来避免空引用。 观察者模式 在对象间定义一个一对多的联系性，由此当一个对象改变了状态，所有其他相关的对象会被通知并且自动刷新。 规格 以布尔形式表示的可重绑定的商业逻辑。 状态 让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能获取的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。 策略 定义一个算法的系列，将其各个分装，并且使他们有交互性。策略模式使得算法在用户使用的时候能独立的改变。 模板方法 模板方法模式准备一个抽象类，将部分逻辑以具体方法及具体构造子类的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先构建一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。 访问者 封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。 从三类设计模式挑选16个常用的设计模式来讲解. 在说模式之前先讲一下UML类图和时序图 UML类图和时序图 车的类图结构为&lt;&gt;，表示车是一个抽象类； 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示； 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示； 小汽车与发动机之间是组合关系，使用带实心菱形的实线表示； 学生与班级之间是聚合关系，使用带空心菱形的实线表示； 学生与身份证之间为关联关系，使用一根实线表示； 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示； 类的关系： 泛化Generalization 实现Realization 依赖Dependency 关联Association 关联关系又分为： 一般关联关系 聚合关系Aggregation 合成关系Composition 类的继承包括：泛化和实现 泛化关系泛化关系用一条带空心箭头的直接表示；如下图表示（A继承自B）例：汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系；注：最终代码中，泛化关系表现为继承非抽象类； 实现关系实现关系用一条带空心箭头的虚线表示；eg：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才 可以用来定义对象。注：最终代码中，实现关系表现为继承抽象类； 聚合关系聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；！聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成； 与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在； 组合关系组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成；与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成； 但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了； 关联关系关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系； 比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系； 关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A；注：在最终代码中，关联对象通常是以成员变量的形式实现的； 依赖关系依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系；与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化； 显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生； 注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性； 时序图 时序图（Sequence DIagram）是显示对象之间交互的图，这些对象是按时间顺序排列的。时序图中显示的是参与交互的对象及其对象之间消息交互的顺序。时序图包括的建模元素主要有： 对象（Actor） 生命线（Lifeline） 控制焦点（Focus of control） 消息（Message）等等 关于时序图，以下这篇文章将概念介绍的比较详细；更多实例应用，参见后续章节模式中的时序图； http://smartlife.blog.51cto.com/1146871/284874 设计模式详解创建型模式 创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。工厂模式 分为三类 简单工厂模式 工厂方法模式 抽象工厂模式 简单工厂模式 简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 模式结构角色： Factory：工厂角色：工厂角色负责实现创建所有实例的内部逻辑 Product： 抽象产品角色:抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口 ConcreteProduct:具体产品角色:具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。实现Product父类的接口功能，也可添加自定义的功能 代码实例：1234567891011121314151617181920212223242526272829&lt;?php //简单工厂模式class Cat&#123; function __construct() &#123; echo &quot;I am Cat class &lt;br&gt;&quot;; &#125;&#125;class Dog&#123; function __construct() &#123; echo &quot;I am Dog class &lt;br&gt;&quot;; &#125;&#125;class Factory&#123; public static function CreateAnimal($name)&#123; if ($name == &apos;cat&apos;) &#123; return new Cat(); &#125; elseif ($name == &apos;dog&apos;) &#123; return new Dog(); &#125; &#125;&#125;$cat = Factory::CreateAnimal(&apos;cat&apos;);$dog = Factory::CreateAnimal(&apos;dog&apos;); Factory是工厂角色，里面有CreateAnimal这个抽象产品角色（其实可以有多个抽象产品角色）。 优缺点简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。 工厂方法模式 此模式中，通过定义一个抽象的核心工厂类，并定义创建产品对象的接口，创建具体产品实例的工作延迟到其工厂子类去完成。这样做的好处是核心类只关注工厂类的接口定义，而具体的产品实例交给具体的工厂子类去创建。当系统需要新增一个产品，无需修改现有系统代码，只需要添加一个具体产品类和其对应的工厂子类，是系统的扩展性变得很好，符合面向对象编程的开闭原则 模式结构角色： Product：抽象产品： ConcreteProduct：具体产品 Factory：抽象工厂 ConcreteFactory：具体工厂代码实例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?php //抽象产品interface Animal&#123; public function run(); public function say();&#125;//具体产品class Cat implements Animal&#123; public function run()&#123; echo &quot;I ran slowly &lt;br&gt;&quot;; &#125; public function say()&#123; echo &quot;I am Cat class &lt;br&gt;&quot;; &#125;&#125;//具体产品class Dog implements Animal&#123; public function run()&#123; echo &quot;I&apos;m running fast &lt;br&gt;&quot;; &#125; public function say()&#123; echo &quot;I am Dog class &lt;br&gt;&quot;; &#125;&#125;// 抽象工厂abstract class Factory&#123; abstract static function createAnimal();&#125;//具体工厂class CatFactory extends Factory&#123; public static function createAnimal() &#123; return new Cat(); &#125;&#125;//具体工厂class DogFactory extends Factory&#123; public static function createAnimal() &#123; return new Dog(); &#125;&#125;$cat = CatFactory::createAnimal();$cat-&gt;say();$cat-&gt;run();$dog = DogFactory::createAnimal();$dog-&gt;say();$dog-&gt;run(); 优缺点工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。 抽象工厂模式 提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 此模式是对工厂方法模式的进一步扩展。在工厂方法模式中，一个具体的工厂负责生产一类具体的产品，即一对一的关系，但是，如果需要一个具体的工厂生产多种产品对象，那么就需要用到抽象工厂模式了。 为了更清晰地理解工厂方法模式，需要先引入两个概念： 产品等级结构 ：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 产品族 ：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。 模式结构角色： 抽象工厂（AbstractFactory）：担任这个角色的是抽象工厂模式的核心，是与应用系统的商业逻辑无关的。 具体工厂（Factory）：这个角色直接在客户端的调用下创建产品的实例，这个角色含有选择合适的产品对象的逻辑，而这个逻辑是与应用系统商业逻辑紧密相关的。 抽象产品（AbstractProduct）：担任这个角色的类是抽象工厂模式所创建的对象的父类，或它们共同拥有的接口 具体产品（Product）：抽象工厂模式所创建的任何产品对象都是一个具体的产品类的实例。代码实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?php // 抽象产品，定义产品有哪些功能interface TV&#123; public function open(); public function watch();&#125;// 抽象产品，定义产品有哪些功能class HaierTv implements TV&#123; public function open() &#123; echo &quot;Open Haier TV &lt;br&gt;&quot;; &#125; public function watch() &#123; echo &quot;I&apos;m watching TV &lt;br&gt;&quot;; &#125;&#125;// 抽象产品，定义产品有哪些功能interface PC&#123; public function work(); public function play();&#125;// 具体产品，实现抽象产品定义的功能class LenovoPc implements PC&#123; public function work() &#123; echo &quot;I&apos;m working on a Lenovo computer &lt;br&gt;&quot;; &#125; public function play() &#123; echo &quot;Lenovo computers can be used to play games &lt;br&gt;&quot;; &#125;&#125;// 抽象工厂，定义创建哪些抽象产品abstract class Factory&#123; abstract public static function createPc(); abstract public static function createTv();&#125;// 具体工厂，实例化抽象产品class ProductFactory extends Factory&#123; public static function createTV() &#123; return new HaierTv(); &#125; public static function createPc() &#123; return new LenovoPc(); &#125;&#125;$newTv = ProductFactory::createTV();$newTv-&gt;open();$newTv-&gt;watch();$newPc = ProductFactory::createPc();$newPc-&gt;work();$newPc-&gt;play(); 建造者模式 又名：生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。例如，一辆汽车由轮子，发动机以及其他零件组成，对于普通人而言，我们使用的只是一辆完整的车，这时，我们需要加入一个构造者，让他帮我们把这些组件按序组装成为一辆完整的车。 模式结构角色： Builder: 抽象构造者类，为创建一个Product对象的各个部件指定抽象接口。 ConcreteBuilder：具体构造者类，实现Builder的接口以构造和装配该产品的各个部件。定义并明确它所创建的表示。提供一个检索产品的接口 Director：指挥者，构造一个使用Builder接口的对象。 Product：表示被构造的复杂对象。ConcreateBuilder创建该产品的内部表示并定义它的装配过程。 包含定义组成部件的类，包括将这些部件装配成最终产品的接口。 代码实例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?php abstract class Builder&#123; protected $car; abstract public function buildPartA(); abstract public function buildPartB(); abstract public function buildPartC(); abstract public function getResult();&#125;class CarBuilder extends Builder&#123; function __construct() &#123; $this-&gt;car = new Car(); &#125; public function buildPartA()&#123; $this-&gt;car-&gt;setPartA(&apos;发动机&apos;); &#125; public function buildPartB()&#123; $this-&gt;car-&gt;setPartB(&apos;轮子&apos;); &#125; public function buildPartC()&#123; $this-&gt;car-&gt;setPartC(&apos;其他零件&apos;); &#125; public function getResult()&#123; return $this-&gt;car; &#125;&#125;class Car&#123; protected $partA; protected $partB; protected $partC; public function setPartA($str)&#123; $this-&gt;partA = $str; &#125; public function setPartB($str)&#123; $this-&gt;partB = $str; &#125; public function setPartC($str)&#123; $this-&gt;partC = $str; &#125; public function show() &#123; echo &quot;这辆车由：&quot;.$this-&gt;partA.&apos;,&apos;.$this-&gt;partB.&apos;,和&apos;.$this-&gt;partC.&apos;组成&apos;; &#125;&#125;class Director&#123; public $myBuilder; public function startBuild() &#123; $this-&gt;myBuilder-&gt;buildPartA(); $this-&gt;myBuilder-&gt;buildPartB(); $this-&gt;myBuilder-&gt;buildPartC(); return $this-&gt;myBuilder-&gt;getResult(); &#125; public function setBuilder(Builder $builder) &#123; $this-&gt;myBuilder = $builder; &#125;&#125;$carBuilder = new CarBuilder();$director = new Director();$director-&gt;setBuilder($carBuilder);$newCar = $director-&gt;startBuild();$newCar-&gt;show(); 单例模式 单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。 实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。 单例模式的要点有：某个类只能有一个实例；它必须自行创建本身的实例；它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。角色： Singleton：单例类 代码实例：1234567891011121314151617181920212223242526272829303132class Singleton&#123; private static $instance; //私有构造方法，禁止使用new创建对象 private function __construct()&#123;&#125; public static function getInstance()&#123; if (!isset(self::$instance)) &#123; self::$instance = new self; &#125; return self::$instance; &#125; //将克隆方法设为私有，禁止克隆对象 private function __clone()&#123;&#125; public function say() &#123; echo &quot;这是用单例模式创建对象实例 &lt;br&gt;&quot;; &#125; public function operation() &#123; echo &quot;这里可以添加其他方法和操作 &lt;br&gt;&quot;; &#125;&#125;// $shiyanlou = new Singleton();$shiyanlou = Singleton::getInstance();$shiyanlou-&gt;say();$shiyanlou-&gt;operation();$newShiyanlou = Singleton::getInstance();var_dump($shiyanlou === $newShiyanlou); 上述的五个模式均属于创建型模式，接下来将要介绍的六个模式属于结构型模式。 结构型模式 结构型模式(Structural Pattern)描述如何将类或者对 象结合在一起形成更大的结构，就像搭积木，可以通过 简单积木的组合形成复杂的、功能更为强大的结构。 结构型模式可以分为类结构型模式和对象结构型模式： 类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。 对象结构型模式关心类与对象的组合，通过关联关系使得在一 个类中定义另一个类的实例对象，然后通过该对象调用其方法。 根据“合成复用原则”，在系统中尽量使用关联关系来替代继 承关系，因此大部分结构型模式都是对象结构型模式。适配器模式 在设计模式)中，适配器模式（英语：adapter pattern）有时候也称包装样式或者包装(wrapper)。将一个类)的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。 角色： Target：目标抽象类 Adapter：适配器类 Adaptee：适配者类 Client：客户类 实例代码123456789101112131415161718192021222324252627282930class Adaptee&#123; public function realRequest() &#123; echo &quot;这是被适配者真正的调用方法&quot;; &#125;&#125;interface Target&#123; public function request();&#125;class Adapter implements Target&#123; protected $adaptee; function __construct(Adaptee $adaptee) &#123; $this-&gt;adaptee = $adaptee; &#125; public function request() &#123; echo &quot;适配器转换：&quot;; $this-&gt;adaptee-&gt;realRequest(); &#125;&#125;$adaptee = new Adaptee();$target = new Adapter($adaptee);$target-&gt;request(); 优点：将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。 桥接模式 桥接模式是软件设计模式中最复杂的模式之一，它把事物对象和其具体行为、具体特征分离开来，使它们可以各自独立的变化。事物对象仅是一个抽象的概念。如“圆形”、“三角形”归于抽象的“形状”之下，而“画圆”、“画三角”归于实现行为的“画图”类之下，然后由“形状”调用“画图”。 理解桥接模式，重点需要理解如何将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化。桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。 角色： Abstraction：定义抽象的接口，该接口包含实现具体行为、具体特征的Implementor接口 Refined Abstraction：抽象接口Abstraction的子类，依旧是一个抽象的事物名 Implementor：定义具体行为、具体特征的应用接口 ConcreteImplementor：实现Implementor接口 实例代码;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?php interface DrawingAPI&#123; public function drawCircle($x,$y,$radius);&#125;/*** drawAPI1*/class DrawingAPI1 implements DrawingAPI&#123; public function drawCircle($x,$y,$radius) &#123; echo &quot;API1.circle at (&quot;.$x.&apos;,&apos;.$y.&apos;) radius &apos;.$radius.&apos;&lt;br&gt;&apos;; &#125;&#125;/*** drawAPI2*/class DrawingAPI2 implements DrawingAPI&#123; public function drawCircle($x,$y,$radius) &#123; echo &quot;API2.circle at (&quot;.$x.&apos;,&apos;.$y.&apos;) radius &apos;.$radius.&apos;&lt;br&gt;&apos;; &#125;&#125;/***shape接口*/interface Shape&#123; public function draw(); public function resize($radius);&#125;class CircleShape implements Shape&#123; private $x; private $y; private $radius; private $drawingAPI; function __construct($x,$y,$radius,DrawingAPI $drawingAPI) &#123; $this-&gt;x = $x; $this-&gt;y = $y; $this-&gt;radius = $radius; $this-&gt;drawingAPI = $drawingAPI; &#125; public function draw() &#123; $this-&gt;drawingAPI-&gt;drawCircle($this-&gt;x,$this-&gt;y,$this-&gt;radius); &#125; public function resize($radius) &#123; $this-&gt;radius = $radius; &#125;&#125;$shape1 = new CircleShape(1,2,4,new DrawingAPI1());$shape2 = new CircleShape(1,2,4,new DrawingAPI2());$shape1-&gt;draw();$shape2-&gt;draw();$shape1-&gt;resize(10);$shape1-&gt;draw(); 装饰器模式 修饰模式，是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。就功能而言，修饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。 一般来说，给一个对象或者类增加行为的方式可以有两种： 继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。 关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator) 通过使用修饰模式，可以在运行时扩充一个类的功能。原理是：增加一个修饰类包裹原来的类，包裹的方式一般是通过在将原来的对象作为修饰类的构造函数的参数。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用原来的类中的方法。修饰类必须和原来的类有相同的接口。 修饰模式是类继承的另外一种选择。类继承在编译时候增加行为，而装饰模式是在运行时增加行为。 角色 Component: 抽象构件 ConcreteComponent: 具体构件 Decorator: 抽象装饰类 ConcreteDecorator: 具体装饰类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?php abstract class Component &#123; abstract public function operation();&#125;class MyComponent extends Component&#123; public function operation() &#123; echo &quot;这是正常的组件方法 &lt;br&gt;&quot;; &#125;&#125;abstract class Decorator extends Component &#123; protected $component; function __construct(Component $component) &#123; $this-&gt;component = $component; &#125; public function operation() &#123; $this-&gt;component-&gt;operation(); &#125;&#125;class MyDecorator extends Decorator&#123; function __construct(Component $component) &#123; parent::__construct($component); &#125; public function addMethod() &#123; echo &quot;这是装饰器添加的方法 &lt;br&gt;&quot;; &#125; public function operation() &#123; $this-&gt;addMethod(); parent::operation(); &#125;&#125;$component = new MyComponent();$da = new MyDecorator($component);$da-&gt;operation(); 外观模式 外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式 举一个简单的例子，相信大家都使用过 C++ 语言，他是一门编译型语言，写完代码之后，我们需要经过编译之后才能运行，在IDE中，会有一个 Build 的按钮，点击它即可完成编译过程，但是这一个简单的动作背后，却是一系列复杂操作的协调配合，至少包括词法分析，语法分析，生成中间代码，生成汇编代码以及链接等操作，作为普通开发人员，我们不必在意这些过程是如何完成的，只需要点击Build按钮，IDE就会自动帮我们完成背后的工作。那么这个Build按钮就是IDE为我们提供的高级接口，通过他来完成各种子系统的协调工作。 角色： Facade：外观角色，提供高级接口 SubSystem：子系统角色，负责各自的功能实现 实例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php class SystemA&#123; public function operationA() &#123; echo &quot;operationA &lt;br&gt;&quot;; &#125;&#125;class SystemB&#123; public function operationB() &#123; echo &quot;operationB &lt;br&gt;&quot;; &#125;&#125;class SystemC&#123; public function operationC() &#123; echo &quot;operationC &lt;br&gt;&quot;; &#125;&#125;class Facade&#123; protected $systemA; protected $systemB; protected $systemC; function __construct() &#123; $this-&gt;systemA = new SystemA(); $this-&gt;systemB = new SystemB(); $this-&gt;systemC = new SystemC(); &#125; public function myOperation() &#123; $this-&gt;systemA-&gt;operationA(); $this-&gt;systemB-&gt;operationB(); $this-&gt;systemC-&gt;operationC(); &#125;&#125;$facade = new Facade();$facade-&gt;myOperation(); 优缺点：使用外观模式最大的优点就是子系统与客户端之间是松耦合的关系，客户端不必知道具体有哪些子系统，也无需知道他们是如何工作的，通过引入一个外观类，提供一个客户端间接访问子系统的高级接口。子系统和外观类可以独立运作，修改某一个子系统的内容，不会影响到其他子系统，也不会影响到外观对象。不过它的缺点就是它不够灵活，当需要增加一个子系统的时候，需要修改外观类。 享元模式 享元模式（英语：Flyweight Pattern）是一种软件设计模式)。它使用共享物件，用来尽可能减少内存使用量以及分享资讯给尽可能多的相似物件；它适合用于当大量物件只是重复因而导致无法令人接受的使用大量内存。通常物件中的部分状态是可以分享。常见做法是把它们放在外部数据结构，当需要使用时再将它们传递给享元。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。 要理解享元模式，先要理解两个重要的概念：内部状态和外部状态。 内部状态存储于flyweight中，它包含了独立于flyweight场景的信息，这些信息使得flyweight可以被共享。而外部状态取决于flyweight场景，并根据场景而变化，因此不可共享。用户对象负责在必要的时候将外部状态传递给flyweight。 角色 Flyweight： 抽象享元类 ConcreteFlyweight： 具体享元类 UnsharedConcreteFlyweight： 非共享具体享元类 FlyweightFactory： 享元工厂类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpinterface Flyweight&#123; public function operation();&#125;class MyFlyweight implements Flyweight&#123; protected $intrinsicState; function __construct($str) &#123; $this-&gt;intrinsicState = $str; &#125; public function operation() &#123; echo &apos;MyFlyweight[&apos;.$this-&gt;intrinsicState.&apos;] do operation. &lt;br&gt;&apos;; &#125;&#125;class FlyweightFactory&#123; protected static $flyweightPool; function __construct() &#123; if (!isset(self::$flyweightPool)) &#123; self::$flyweightPool = []; &#125; &#125; public function getFlyweight($str) &#123; if (!array_key_exists($str,self::$flyweightPool)) &#123; $fw = new MyFlyweight($str); self::$flyweightPool[$str] = $fw; return $fw; &#125; else &#123; echo &quot;aready in the pool,use the exist one: &lt;br&gt;&quot;; return self::$flyweightPool[$str]; &#125; &#125;&#125;$factory = new FlyweightFactory();$fw = $factory-&gt;getFlyweight(&apos;one&apos;);$fw-&gt;operation();$fw1 = $factory-&gt;getFlyweight(&apos;two&apos;);$fw1-&gt;operation();$fw2 = $factory-&gt;getFlyweight(&apos;one&apos;);$fw2-&gt;operation(); 享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。 代理模式所谓的代理者是指一个类别可以作为其它东西的接口。代理者可以作任何东西的接口：网络连接、内存中的大对象、文件或其它昂贵或无法复制的资源。 代理对象可以在客户端和目标对象之间起到 中介的作用，并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。 可能大家听得最多且最常用的就是VPN网络代理，或者代理服务器等。 角色-Subject: 抽象主题角色 Proxy: 代理主题角色 RealSubject: 真实主题角色实例代码1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?php interface Subject&#123; public function request();&#125;class RealSubject implements Subject&#123; public function request() &#123; echo &quot;RealSubject::request &lt;br&gt;&quot;; &#125;&#125;class Proxy implements Subject&#123; protected $realSubject; function __construct() &#123; $this-&gt;realSubject = new RealSubject(); &#125; public function beforeRequest() &#123; echo &quot;Proxy::beforeRequest &lt;br&gt;&quot;; &#125; public function request() &#123; $this-&gt;beforeRequest(); $this-&gt;realSubject-&gt;request(); $this-&gt;afterRequest(); &#125; public function afterRequest() &#123; echo &quot;Proxy::afterRequest &lt;br&gt;&quot;; &#125;&#125;$proxy = new Proxy();$proxy-&gt;request(); 下面将会介绍五种行为型模式。 行为型模式 行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。 行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。 通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象 之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。 行为型模式分为类行为型模式和对象行为型模式两种： 类行为型模式：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。 对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式 命令模式 在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。 主要特点就是将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式`或事务(Transaction)模式` 角色 Command: 抽象命令类 ConcreteCommand: 具体命令类 Invoker: 调用者 Receiver: 接收者 Client:客户类 示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php class Receiver&#123; public function Action() &#123; echo &quot;Receiver-&gt;Action&quot;; &#125;&#125;abstract class Command&#123; protected $receiver; function __construct(Receiver $receiver) &#123; $this-&gt;receiver = $receiver; &#125; abstract public function Execute();&#125;class MyCommand extends Command&#123; function __construct(Receiver $receiver) &#123; parent::__construct($receiver); &#125; public function Execute() &#123; $this-&gt;receiver-&gt;Action(); &#125;&#125;class Invoker&#123; protected $command; function __construct(Command $command) &#123; $this-&gt;command = $command; &#125; public function Invoke() &#123; $this-&gt;command-&gt;Execute(); &#125;&#125;$receiver = new Receiver();$command = new MyCommand($receiver);$invoker = new Invoker($command);$invoker-&gt;Invoke(); 中介者模式 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 举个简单的例子，就比如大家平时喜欢用微信聊天，你发送的聊天内容需要通过微信服务器进行中间处理，然后下发给你的好友，微信服务器就是一个中介者。 角色 Mediator: 抽象中介者 ConcreteMediator: 具体中介者 Colleague: 抽象同事类 ConcreteColleague: 具体同事类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?php abstract class Colleague&#123; protected $mediator; abstract public function sendMsg($who,$msg); abstract public function receiveMsg($msg); public function setMediator(Mediator $mediator)&#123; $this-&gt;mediator = $mediator; &#125;&#125;class ColleagueA extends Colleague&#123; public function sendMsg($toWho,$msg) &#123; echo &quot;Send Msg From ColleagueA To: &quot;.$toWho . &apos;&lt;br&gt;&apos;; $this-&gt;mediator-&gt;opreation($toWho,$msg); &#125; public function receiveMsg($msg) &#123; echo &quot;ColleagueA Receive Msg: &quot;.$msg . &apos;&lt;br&gt;&apos;; &#125;&#125;class ColleagueB extends Colleague&#123; public function sendMsg($toWho,$msg) &#123; echo &quot;Send Msg From ColleagueB To: &quot;.$toWho . &apos;&lt;br&gt;&apos;; $this-&gt;mediator-&gt;opreation($toWho,$msg); &#125; public function receiveMsg($msg) &#123; echo &quot;ColleagueB Receive Msg: &quot;.$msg . &apos;&lt;br&gt;&apos;; &#125;&#125;abstract class Mediator&#123; abstract public function opreation($id,$message); abstract public function register($id,Colleague $colleague);&#125;class MyMediator extends Mediator&#123; protected static $colleagues; function __construct() &#123; if (!isset(self::$colleagues)) &#123; self::$colleagues = []; &#125; &#125; public function opreation($id,$message) &#123; if (!array_key_exists($id,self::$colleagues)) &#123; echo &quot;colleague not found&quot;; return; &#125; $colleague = self::$colleagues[$id]; $colleague-&gt;receiveMsg($message); &#125; public function register($id,Colleague $colleague) &#123; if (!in_array($colleague, self::$colleagues)) &#123; self::$colleagues[$id] = $colleague; &#125; $colleague-&gt;setMediator($this); &#125;&#125;$colleagueA = new ColleagueA();$colleagueB = new ColleagueB();$mediator = new MyMediator();$mediator-&gt;register(1,$colleagueA);$mediator-&gt;register(2,$colleagueB);$colleagueA-&gt;sendMsg(2,&apos;hello admin&apos;);$colleagueB-&gt;sendMsg(1,&apos;shiyanlou&apos;); 中介者模式的两个主要作用：中转作用（结构性）：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，通过中介者即可。该中转作用属于中介者在结构上的支持。 协调作用（行为性）：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。 观察者模式 在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。 角色 Subject: 抽象目标类，一般至少提供三个接口： 添附(Attach)：新增观察者到串炼内，以追踪目标对象的变化。 解附(Detach)：将已经存在的观察者从串炼中移除。 通知(Notify)：利用观察者所提供的更新函式来通知此目标已经产生变化。 ConcreteSubject: 具体目标，提供了观察者欲追踪的状态，也可设置目标状态 Observer: 抽象观察者，定义观察者的更新操作接口 ConcreteObserver: 具体观察者，实现抽象观察者的接口，做出自己的更新操作 生活实例：举一个生活中的例子：比如用户（观察者）从报社订阅报纸，报社和用户之间是一对多依赖，用户可以在报社订阅（register）报纸，报社可以把最新的报纸发给用户（notify），用户自动收到更新。在用户不需要的时候还可以取消注册（remove）。示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?php abstract class Obeserver&#123; abstract function update(Subject $sub);&#125;abstract class Subject&#123; protected static $obeservers; function __construct() &#123; if (!isset(self::$obeservers)) &#123; self::$obeservers = []; &#125; &#125; public function attach(Obeserver $obeserver)&#123; if (!in_array($obeserver, self::$obeservers)) &#123; self::$obeservers[] = $obeserver; &#125; &#125; public function deattach(Obeserver $obeserver)&#123; if (in_array($obeserver, self::$obeservers)) &#123; $key = array_search($obeserver,self::$obeservers); unset(self::$obeservers[$key]); &#125; &#125; abstract public function setState($state); abstract public function getState(); public function notify() &#123; foreach (self::$obeservers as $key =&gt; $value) &#123; $value-&gt;update($this); &#125; &#125;&#125;class MySubject extends Subject&#123; protected $state; public function setState($state) &#123; $this-&gt;state = $state; &#125; public function getState() &#123; return $this-&gt;state; &#125;&#125;class MyObeserver extends Obeserver&#123; protected $obeserverName; function __construct($name) &#123; $this-&gt;obeserverName = $name; &#125; public function update(Subject $sub) &#123; $state = $sub-&gt;getState(); echo &quot;Update Obeserver[&quot;.$this-&gt;obeserverName.&apos;] State: &apos;.$state . &apos;&lt;br&gt;&apos;; &#125;&#125;$subject = new MySubject();$one = new MyObeserver(&apos;one&apos;);$two = new MyObeserver(&apos;two&apos;);$subject-&gt;attach($one);$subject-&gt;attach($two);$subject-&gt;setState(1);$subject-&gt;notify();echo &quot;--------------------- &lt;br&gt;&quot;;$subject-&gt;setState(2);$subject-&gt;deattach($two);$subject-&gt;notify(); 状态模式 状态模式：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。 有时，一个对象的行为受其一个或多个具体的属性变化而变化，这样的属性也叫作状态，这样的的对象也叫作有状态的对象。 角色 Context: 环境类，维护一个ConcreteState子类的实例，这个实例定义当前状态； State: 抽象状态类，定义一个接口以封装与Context的一个特定状态相关的行为； ConcreteState: 具体状态类，每一个子类实现一个与Context的一个状态相关的行为。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?php class Context&#123; protected $state; function __construct() &#123; $this-&gt;state = StateA::getInstance(); &#125; public function changeState(State $state) &#123; $this-&gt;state = $state; &#125; public function request() &#123; $this-&gt;state-&gt;handle($this); &#125;&#125;abstract class State&#123; abstract function handle(Context $context);&#125;class StateA extends State&#123; private static $instance; private function __construct()&#123;&#125; private function __clone()&#123;&#125; public static function getInstance() &#123; if (!isset(self::$instance)) &#123; self::$instance = new self; &#125; return self::$instance; &#125; public function handle(Context $context) &#123; echo &quot;doing something in State A.\n done,change state to B &lt;br&gt;&quot;; $context-&gt;changeState(StateB::getInstance()); &#125;&#125;class StateB extends State&#123; private static $instance; private function __construct()&#123;&#125; private function __clone()&#123;&#125; public static function getInstance() &#123; if (!isset(self::$instance)) &#123; self::$instance = new self; &#125; return self::$instance; &#125; public function handle(Context $context) &#123; echo &quot;doing something in State B.\n done,change state to A &lt;br&gt;&quot;; $context-&gt;changeState(StateA::getInstance()); &#125;&#125;$context = new Context();$context-&gt;request();$context-&gt;request();$context-&gt;request();$context-&gt;request(); 策略模式 策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。 常见示例：常见的排序算法有快速排序，冒泡排序，归并排序，选择排序等，如果我们需要在一个算法类中提供这些算法，一个常见的解决方法就是在类中定义多个方法，每个方法定义一种具体的排序算法，然后使用 if…else…去判断到底是哪种算法，或者直接调用某个具体方法。这种方法是将算法的实现硬编码到类中，这样做最大的弊端就是算法类类非常臃肿，而且当需要增加或者更换一种新的排序方法时候，需要修改算法类的代码，同时也需要修改客户端调用处的代码。策略模式就是为了解决这列问题而设计的。 角色 Context: 环境类，使用一个ConcreteStrategy对象来配置；维护一个对Stategy对象的引用，同时，可以定义一个接口来让Stategy访问它的数据。 Strategy: 抽象策略类，定义所有支持的算法的公共接口。Context使用这个接口来调用某ConcreteStrategy定义的算法； ConcreteStrategy: 具体策略类，实现 Strategy 接口的具体算法； 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?php abstract class Strategy&#123; abstract function use();&#125;class StrategyA extends Strategy&#123; public function use() &#123; echo &quot;这是使用策略A的方法 &lt;br&gt;&quot;; &#125;&#125;class StrategyB extends Strategy&#123; public function use() &#123; echo &quot;这是使用策略B的方法 &lt;br&gt;&quot;; &#125;&#125;class Context&#123; protected $startegy; public function setStrategy(Strategy $startegy) &#123; $this-&gt;startegy = $startegy; &#125; public function use() &#123; $this-&gt;startegy-&gt;use(); &#125;&#125;$context = new Context();$startegyA = new StrategyA();$startegyB = new StrategyB();$context-&gt;setStrategy($startegyA);$context-&gt;use();$context-&gt;setStrategy($startegyB);$context-&gt;use(); 【参考来源】 https://design-patterns.readthedocs.io https://www.shiyanlou.com/courses/699 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2018/04/16/设计模式详解/]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>设计模式</tag>
        <tag>实例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js十大排序算法详解]]></title>
    <url>%2F2018%2F04%2F03%2Fjs%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[用js实现的十大经典算法，有简单的例子+原理图+动图 十大经典算法导图 图片名词解释： n: 数据规模 k:“桶”的个数 In-place: 占用常数内存，不占用额外内存 Out-place: 占用额外内存 冒泡排序原始人冒泡排序原理图： 1234567891011121314151617//从小到大,先排好最大的（最后面的） function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; var temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr; &#125; var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]; console.log(bubbleSort(arr)) 进化版冒泡排序 对上述冒泡排序的一种优化， 优化思路：当一次遍历前后数组不产生变化时，说明该数组已经有序，结束排序。 原理图： 1234567891011121314151617181920212223242526// 如果在某次的排序中没有出现交换的情况， // 那么说明在无序的元素现在已经是有序了，就可以直接返回了。 function bubbleSort2(array) &#123; console.time(&apos;2.改进后冒泡排序耗时&apos;); var len = array.length, i, j, tmp, exchange; for (var i = 0; i &lt; len; i++) &#123; exchange = 0; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; var temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; exchange = 1; &#125; &#125; if (!exchange) return arr; &#125; console.timeEnd(&apos;2.改进后冒泡排序耗时&apos;); return arr; &#125; var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]; console.log(bubbleSort2(arr)); 冒泡动图： 选择排序 实现思路跟冒泡排序差不多， 可以说是冒泡排序的衍生版本； 原理图： 1234567891011121314151617181920function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; console.time(&apos;选择排序耗时&apos;); for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; //寻找最小的数 minIndex = j; //将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; console.timeEnd(&apos;选择排序耗时&apos;); return arr;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]； 选择排序动图： 插入排序 最普通的排序算法， 从数组下标1开始每增1项排序一次，越往后遍历次数越多； 打个比方就类比水浒传一百单八将的排名吧，每个好汉来了不知道自己排老几，怎么办，那就和已经排过级别的人比较，然后找到其对应的位置，单八将宋万、杜迁先上的梁山，先默认杜迁第一来的也是单八将最厉害的，然后宋万来了，一比较宋万厉害，那宋万排第一，杜迁排第二，接下来朱贵来了，朱贵没他们两个厉害，那就排第三，再后来林冲来了，林冲比他们三个都厉害，那林冲排第一，宋万第二，杜迁第三，朱贵第四，依次类推。梁山排名其实就是典型的插入排序。 原理图： 12345678910111213141516function insertionSort(array) &#123; console.time(&apos;插入排序耗时：&apos;); for (var i = 1; i &lt; array.length; i++) &#123; var key = array[i];//key是要插入的元素 var j = i - 1; while ( array[j] &gt; key) &#123; array[j + 1] = array[j]; j--; &#125; array[j + 1] = key; &#125; console.timeEnd(&apos;插入排序耗时：&apos;); return array;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(insertionSort(arr)); 二分插入排序 插入排序的一种优化实现， 通过二分法减少遍历时间。 原理图： 12345678910111213141516171819202122function binaryInsertionSort(array) &#123; console.time(&apos;二分插入排序耗时：&apos;); for (var i = 1; i &lt; array.length; i++) &#123; var key = array[i], left = 0, right = i - 1; while (left &lt;= right) &#123; var middle = parseInt((left + right) / 2); if (key &lt; array[middle]) &#123; right = middle - 1; &#125; else &#123; left = middle + 1; &#125; &#125; for (var j = i - 1; j &gt;= left; j--) &#123; array[j + 1] = array[j]; &#125; array[left] = key; &#125; console.timeEnd(&apos;二分插入排序耗时：&apos;); return array;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(binaryInsertionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]; 代码解释：首先外层循环没什么疑问，就是简单的遍历一遍数组，那么先看while循环，left和right两个变量可以简单的类比上面插入排序中的已排序的首末两个位置，然后选取未排序的第一个值和已排序的中间位置的值进行比较，这样的话也就是在最坏的情况下每层循环也只是计算了已排序的序列长度的一半的次数，简而言之就是在无限逼近left和right值，找到未排序第一个值应该在的位置。 还是以梁山排名为例子，在宋江没有到梁上之前，每个上梁上的人跟已经排过名的从大往小进行比较，然后找到自己的位置，在老大宋江来之后，后续人慢慢多了，然后宋老大就订了条规矩，就是每个新来的人和已排过名次的位于中间名次的好汉进行比较，胜了往前一位比较，败了往后一位比较，然后找到自己的位置。好了，while循环解释完毕，那么下面又多了一条for循环，这又是什么鬼？ 不要着急，待小编与你慢慢道来，看不懂没关系，先看循环体，循环体的意思就是把前一个值给后一个，然后看循环条件是从i-1的位置从后往前依次将前一个元素的值给后一个，先不要管i-1是谁，先问 i 是谁，i 不就是未排序的第一个元素么，不就是我们拿来对已进行排序的元素么，简而言之不就是新上梁山的好汉么，那么从left值开始到 i-1 的位置依次将前一个元素的值给后一个无非就是空出 left 的位置，left 的位置不就是新上梁上好汉的位置！ 二分插入排序动图： 希尔排序也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一 原理： 先将整个待排序记录序列分割成若干个子序列，在序列内分别进行直接插入排序，待整个序列基本有序时，再对全体记录进行一次直接插入排序;像比赛一样，1-6一组，2-7一组，每差5为一组进行比较，之后再每差2为一组进行比较，最后就是两两比较 原理图： 12345678910111213141516171819202122function shellSort(arr) &#123; var len = arr.length, temp, gap = 1; console.time(&apos;希尔排序耗时:&apos;); while(gap &lt; len/5) &#123; //动态定义间隔序列 gap =gap*5+1; &#125; for (gap; gap &gt; 0; gap = Math.floor(gap/5)) &#123; for (var i = gap; i &lt; len; i++) &#123; temp = arr[i]; for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123; arr[j+gap] = arr[j]; &#125; arr[j+gap] = temp; &#125; &#125; console.timeEnd(&apos;希尔排序耗时:&apos;); return arr;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(shellSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]； 1234567891011121314151617181920212223 function shellSort2(a) &#123; var n = a.length; var i, j, gap; for (gap = n / 2; gap &gt; 0; gap /= 2) //步长 &#123; for (i = 0; i &lt; gap; i++) //循环每一组，直接插入排序 &#123; for (j = i + gap; j &lt; n; j += gap) //组内排序 if (a[j] &lt; a[j - gap]) //a[j]与a[j-gap]将交换 &#123; var temp = a[j]; var k = j - gap; while (k &gt;= 0 &amp;&amp; a[k] &gt; temp) // &#123; a[k + gap] = a[k]; //a[j]=a[j-gap] k -= gap; // &#125; a[k + gap] = temp; &#125; &#125; &#125;&#125; 归并排序原理图： 比如现在有个十万人的司令部，习大大是首长，习大大跟司令说了，把所有的人按年龄排序，司令想了，让我一个人也忙活不过来啊，这怎么办，然后就把任务下达给军长，军长下达给师长，依次类推，排长再把一个排分成两个小队，小队再分成两个小组，最后分成两个人一组或一人一组，接下来就是组员之间进行比较，完了小队与小队比较，排与排之间比较，依次类推，最后军团和军团比较，形成最后的序列。 123456789101112131415161718192021222324252627282930313233function mergeSort(arr) &#123; //采用自上而下的递归方法 var len = arr.length; if(len &lt; 2) &#123; return arr; &#125; var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125; function merge(left, right)&#123; var result = []; console.time(&apos;归并排序耗时&apos;); while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length)&#123; result.push(left.shift()); &#125; while (right.length)&#123; result.push(right.shift()); &#125; console.timeEnd(&apos;归并排序耗时&apos;); return result;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(mergeSort(arr)); 并归排序动图： 快速排序快速排序在诸多算法排序中可能不是最好的， 但在JS语言实现中差不多是最快的！阮一峰老师研究JS实现排序时曾只针对该种排序进行讲解：javascript的快速排序实现。 步骤： 在数据集之中，选择一个元素作为”基准”（pivot）。 所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。 对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 原理图： 1234567891011121314151617181920var quickSort2 = function(arr) &#123; console.time(&apos;2.快速排序耗时&apos;); if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; console.log(pivot) var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; console.timeEnd(&apos;2.快速排序耗时&apos;); return quickSort2(left).concat([pivot], quickSort2(right));&#125;;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(quickSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]； 快速排序动图 堆排序 因为js模拟二叉树比较麻烦，所以堆排序的优势用js语言无法体现， 相对而言C语言的链表在实现上更能表现堆排序，堆排序或许更适合指针类的计算机语言。 原理图： 1.调整二叉树，形成大根堆(子节点都比父节点小)。2.交换堆第一元素跟最后元素位置，最后元素弹出堆。然后继续回到1，调整堆。3.重复2， 当所有节点弹出堆后；弹出的节点值就是有序的了。 123456789101112131415161718192021222324252627282930313233343536function heapSort(array) &#123; console.time(&apos;堆排序耗时&apos;); //建堆 var heapSize = array.length, temp; for (var i = Math.floor(heapSize / 2) - 1; i &gt;= 0; i--) &#123; heapify(array, i, heapSize); &#125; //堆排序 for (var j = heapSize - 1; j &gt;= 1; j--) &#123; temp = array[0]; array[0] = array[j]; array[j] = temp; console.log(array) heapify(array, 0, --heapSize); &#125; console.timeEnd(&apos;堆排序耗时&apos;); return array;&#125;function heapify(arr, x, len) &#123; var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp; if (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123; largest = l; &#125; if (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123; largest = r; &#125; if (largest != x) &#123; temp = arr[x]; arr[x] = arr[largest]; arr[largest] = temp; console.log(arr) heapify(arr, largest, len); &#125;&#125;var arr=[91,60,96,13,35,65,46,65,10,30,20,31,77,81,22];console.log(heapSort(arr));//[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96]； 这种算法有两个难点，一是建堆，而是堆排序。首先明白什么是堆，堆其实可以这么理解，类似金字塔，一层有一个元素，两层有两个元素，三层有四个元素，每层从数组中取元素，从左到右的顺序放到堆相应的位置上，也就是说每一层元素个数为2n-1 ；（n 代表行数），这就完成了建堆。 那么想，堆排序中最后一位不就是2n-m（n代表总行数，m代表差多少位不到完成堆的位数），那该元素的父级是谁，2n-1-m/2，2n-1-m/2是谁？拿总位数除以2就知道了，没错就是数组的中间值，这也是编者为什么从中间值入手的原因了。 而对于 l = 2x +1 与 r = 2x+2 ，不正是每个父级元素对应的子堆么，每一层的堆排序都能够把本层的最大值剔除出来，这样当所有 层循环结束之后，序列也就完成了。 这一点小编觉得和归并排序有点类似，都是细分到最小单元，从最小单元比较，但是同归并排序有两大点不同，一是堆排序并不像归并那么无序，只是一味的平分数组，而堆排序则是按原始序列排出金字塔式的结构，把最大值一层层往上冒，冒到金字塔最顶端的时候把它踢出来，这样达到排序的效果。堆排序动图： 计数排序12345678910111213141516171819202122function countingSort(array) &#123; var len = array.length, B = [], C = [], min = max = array[0]; console.time(&apos;计数排序耗时&apos;); for (var i = 0; i &lt; len; i++) &#123; min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1; &#125; for (var k = 0; k &lt;len; k++) &#123; var length = C[k]； for(var m = 0 ;m &lt;length ; m++)&#123; B.push(k); &#125; &#125; console.timeEnd(&apos;计数排序耗时&apos;); return B;&#125;var arr = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2];console.log(countingSort(arr)); //[1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9]； C数组的下标对应的数值就是该下标出现的次数动图： 桶排序 一看到这个名字就会觉得奇特，几个意思，我排序还要再准备几个桶不成？还真别说，想用桶排序还得真准备几个桶，但是此桶非彼桶，这个桶是用来装数据用的。其实桶排序和计数排序还有点类似，计数排序是找一个空数组把值作为下标找到其位置，再把出现的次数给存起来，这似乎看似很完美，但也有局限性，不用小编说相信读者也能明白，既然计数是把原数组的值当做下标来看待，那么该值必然是整数，那假如出现小数怎么办？这时候就出现了一种通用版的计数排序——桶排序。 简单例子： 期末考试完了老师要将同学们的分数按照从高到低排序。小哼的班上只有5个同学，这5个同学分别考了5分、3分、5分、2分和8分，哎，考得真是惨不忍睹（满分是10分）。接下来将分数进行从大到小排序，排序后是8 5 5 3 2。 首先我们需要申请一个大小为11的数组int a[11]。OK，现在你已经有了11个变量，编号从a[0]~a[10]。刚开始的时候，我们将a[0]~a[10]都初始化为0，表示这些分数还都没有人得过。例如a[0]等于0就表示目前还没有人得过0分，同理a[1]等于0就表示目前还没有人得过1分……a[10]等于0就表示目前还没有人得过10分。 下面开始处理每一个人的分数，第一个人的分数是5分，我们就将相对应的a[5]的值在原来的基础增加1，即将a[5]的值从0改为1，表示5分出现过了一次。 第二个人的分数是3分，我们就把相对应的a[3]的值在原来的基础上增加1，即将a[3]的值从0改为1，表示3分出现过了一次。 注意啦！第三个人的分数也是5分，所以a[5]的值需要在此基础上再增加1，即将a[5]的值从1改为2，表示5分出现过了两次。 按照刚才的方法处理第四个和第五个人的分数。最终结果就出来了 你发现没有，a[0]~a[10]中的数值其实就是0分到10分每个分数出现的次数。接下来，我们只需要将出现过的分数打印出来就可以了，出现几次就打印几次，具体如下。 桶排序与计数排序很相似，不过现在的桶不单计数，是实实在在地放入元素。举个例子，学校要对所有老师按年龄进行排序，这么多老师很难操作，那么先让他们按年龄段进行分组，20－30岁的一组，30－40岁一组，50－60岁一组，然后组内再排序。这样效率就大大提高了。桶排序也是于这种思想。 操作步骤： 确认范围，亦即求取原数组的最大值与最小值。 确认需要多少个桶（这个通常作为参数传入，不能大于原数组长度），然后最大值减最小值，除以桶的数量，但得每个桶最多能放多个元素，我们称这个数为桶的最大容量。 遍历原数组的所有元素，除以这个最大容量，就能得到它要放入的桶的编号了。在放入时可以使用插入排序，也可以在合并时才使用快速排序。 对所有桶进行遍历，如果桶内的元素已经排好序，直接一个个取出来，放到结果数组就行了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var arr = [2,5,3,0,2,8,0,3,4,3] function bucketSort(array, num)&#123; if(array.length &lt;= 1)&#123; return array &#125; var n = array.length; var min = Math.min.apply(0, array) var max = Math.max.apply(0, array) if(max === min)&#123; return array &#125; var capacity = (max - min + 1) /num; var buckets = new Array(max - min + 1) for(var i = 0; i &lt; n; i++)&#123; var el = array[i];//el可能是负数 var index = Math.floor((el - min) / capacity) var bucket = buckets[index] if(bucket)&#123; var jn = bucket.length; if(el &gt;= bucket[jn-1])&#123; bucket[jn] = el &#125;else&#123; insertSort: for(var j = 0; j &lt; jn; j++)&#123; if(bucket[j] &gt; el)&#123; while(jn &gt; j)&#123; //全部向后挪一位 bucket[jn] = bucket[jn-1] jn-- &#125; bucket[j] = el //让el占据bucket[j]的位置 break insertSort; &#125; &#125; &#125; &#125;else&#123; buckets[index] = [el] &#125; &#125; var index = 0 for(var i = 0; i &lt; num; i++)&#123; var bucket = buckets[i] for(var k = 0, kn = bucket.length; k &lt; kn; k++)&#123; array[index++] = bucket[k] &#125; &#125; return array; &#125; console.log( bucketSort(arr,4) ) //[ 0, 0, 2, 2, 3, 3, 3, 4, 5, 8 ] 基数排序 基数排序按照对位数分组的顺序的不同，可以分为LSD（Least significant digit）基数排序和MSD（Most significant digit）基数排序。 LSD基数排序LSD基数排序，是按照从低位到高位的顺序进行分组排序。MSD基数排序，是按照从高位到低位的顺序进行分组排序对于序列中的每个整数的每一位都可以看成是一个桶，而该位上的数字就可以认为是这个桶的键值。比如下面数组 [170, 45, 75, 90, 802, 2, 24, 66] 首先我们要确认最大值，一个for循环得最大数，因为最大数的位数最长。 然后，建立10个桶，亦即10个数组。 然后再遍历所有元素，取其个位数，个位数是什么就放进对应编号的数组，1放进1号桶。123456780号桶： 170，901号桶： 无2号桶： 802，23号桶： 无4号桶： 245号桶： 45， 756号桶： 667－9号桶： 无 然后再依次将元素从桶里最出来，覆盖原数组，或放到一个新数组，我们把这个经过第一次排序的数组叫sorted。 sorted = [170,90,802,2,24,45,75,66] 然后我们再一次遍历sorted数组的元素，这次取十位的值。这时要注意，2不存在十位，那么默认为0 123456789100号桶： 2，802 1号桶： 无 2号桶： 24 3号桶： 无 4号桶： 45 5号桶： 无 6号桶： 66 7号桶： 170， 75 8号桶： 无 9号桶： 90 再全部取出来 sorted = [2，802,24，45，66，170，75，90] 开始百位上的入桶操作，没有百位就默认为0：123450号桶： 2，24，45，66，75，901号桶： 1702－7号桶：无8号桶： 8029号桶： 无 再全部取出来 sorted = [2，24，45，66，75，90，170，802] 没有千位数，那么循环结束，返回结果桶sorted 从程序描述如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function radixSort(array) &#123; var max = Math.max.apply(0, array); var times = getLoopTimes(max), len = array.length; var buckets = []; for (let i = 0; i &lt; 10; i++) &#123; buckets[i] = []; //初始化10个桶 &#125; for (var radix = 1; radix &lt;= times; radix++) &#123; //个位，十位，百位，千位这样循环 lsdRadixSort(array, buckets, len, radix); &#125; return array;&#125;// 根据数字某个位数上的值得到桶的编号function getBucketNumer(num, d) &#123; return (num + &quot;&quot;).reverse()[d];&#125;//或者这个function getBucketNumer(num, i) &#123; return Math.floor((num / Math.pow(10, i)) % 10);&#125;//获取数字的位数function getLoopTimes(num) &#123; var digits = 0; do &#123; if (num &gt; 1) &#123; digits++; &#125; else &#123; break; &#125; &#125; while ((num = num / 10)); return digits;&#125;function lsdRadixSort(array, buckets, len, radix) &#123; //入桶 for (let i = 0; i &lt; len; i++) &#123; let el = array[i]; let index = getBucketNumer(el, radix); buckets[index].push(el); &#125; var k = 0; //重写原桶 for (let i = 0; i &lt; 10; i++) &#123; let bucket = buckets[i]; for (let j = 0; j &lt; bucket.length; j++) &#123; array[k++] = bucket[j]; &#125; bucket.length = 0; &#125;&#125;// testvar arr = [278, 109, 63, 930, 589, 184, 505, 269, 8, 83];console.log(radixSort(arr)); 字符串使用基数排序实现字典排序 此外，基数排序不局限于数字，可以稍作变换，就能应用于字符串的字典排序中。我们先来一个简单的例子，只对都是小写字母的字符串数组进行排序。 小写字母一共26个，考虑到长度不一样的情况，我们需要对够短的字符串进行补充，这时补上什么好呢？我们不能直接上0，而是补空白。然后根据字母与数字的对应关系，弄27个桶，空字符串对应0，a对应1，b对应2…. 字典排序是从左边开始比较， 因此我们需要用到MST基数排序。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576var character = &#123;&#125;;&quot;abcdefghijklmnopqrstuvwxyz&quot;.split(&quot;&quot;).forEach(function(el, i) &#123; character[el] = i + 1;&#125;);function toNum(c, length) &#123; var arr = []; arr.c = c; for (var i = 0; i &lt; length; i++) &#123; arr[i] = character[c[i]] || 0; &#125; return arr;&#125;function getBucketNumer(arr, i) &#123; return arr[i];&#125;function radixSort(array) &#123; var len = array.length; var loopTimes = 0; //求出最长的字符串，并得它的长度，那也是最高位 for (let i = 0; i &lt; len; i++) &#123; let el = array[i]; var charLen = el.length; if (charLen &gt; loopTimes) &#123; loopTimes = charLen; &#125; &#125; //将字符串转换为数字数组 var nums = []; for (let i = 0; i &lt; len; i++) &#123; nums.push(toNum(array[i], loopTimes)); &#125; //开始多关键字排序 msdRadixSort(nums, len, 0, loopTimes); //变回字符串 for (let i = 0; i &lt; len; i++) &#123; array[i] = nums[i].c; &#125; return array;&#125;function msdRadixSort(array, len, radix, radixs) &#123; var buckets = []; for (var i = 0; i &lt;= 26; i++) &#123; buckets[i] = []; &#125; //入桶 for (let i = 0; i &lt; len; i++) &#123; let el = array[i]; let index = getBucketNumer(el, radix); buckets[index].push(el); &#125; //递归子桶 for (let i = 0; i &lt;= 26; i++) &#123; let el = buckets[i]; //el.c是用来识别是桶还是我们临时创建的数字字符串 if (el.length &gt; 1 &amp;&amp; !el.c &amp;&amp; radix &lt; radixs) &#123; msdRadixSort(el, el.length, radix + 1, radixs); &#125; &#125; var k = 0; //重写原桶 for (let i = 0; i &lt;= 26; i++) &#123; let bucket = buckets[i]; for (let j = 0; j &lt; bucket.length; j++) &#123; array[k++] = bucket[j]; &#125; bucket.length = 0; &#125;&#125;var array = [&quot;ac&quot;, &quot;ee&quot;, &quot;ef&quot;, &quot;b&quot;, &quot;z&quot;, &quot;f&quot;, &quot;ep&quot;, &quot;gaaa&quot;, &quot;azh&quot;, &quot;az&quot;, &quot;r&quot;];var a = radixSort(array);console.log(a); 基数排序动图 基数排序 vs 计数排序 vs 桶排序这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶 计数排序：每个桶只存储单一键值 桶排序：每个桶存储一定范围的数值 参考来源： https://www.cnblogs.com/liyongshuai/p/7197962.html https://www.cnblogs.com/wteam-xq/p/4752610.html https://segmentfault.com/a/1190000012923917#articleHeader2 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2018/04/03/js十大排序算法详解/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用mock实现前端所需数据]]></title>
    <url>%2F2018%2F04%2F01%2F%E7%94%A8mock%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E6%89%80%E9%9C%80%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[mock.js的小demo及mock语法简述及JSON.stringify用法 [TOC] 工具： mock.js 官网:http://mockjs.com/ （进阶的有eolinker，是基于mock.js的可视化模拟数据API接口）:https://www.eolinker.com/ Mock概述：Mock.js实现的功能 基于 数据模板 生成数据 基于 HTML模板 生成数据 拦截并模拟 Ajax请求 用法：浏览器： index.html: 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://mockjs.com/dist/mock.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var data = Mock.mock(&#123; &apos;list|1-10&apos;: [&#123; &apos;id|+1&apos;: 1 &#125;] &#125;); $(&apos;&lt;pre&gt;&apos;).text(JSON.stringify(data, null, 4)) .appendTo(&apos;body&apos;); //JQuery //配置模拟数据 Mock.mock(&apos;http://g.cn&apos;,&#123; &apos;name&apos;:&apos;@name&apos;, &apos;age|1-100&apos;:100, &apos;color&apos;:&apos;@color&apos; &#125;); //发送Ajax请求 $.ajax(&#123; url:&apos;http://g.cn&apos;, dataType:&apos;json&apos; &#125;).done(function(data,status,xhr)&#123; console.log( JSON.stringify(data,null,4) ) &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 页面返回值：12345678910111213&#123;&quot;list&quot;: [ &#123; &quot;id&quot;: 1 &#125;, &#123; &quot;id&quot;: 2 &#125;, &#123; &quot;id&quot;: 3 &#125; ]&#125; 浏览器控制台输出：12345index.html:33 &#123; &quot;name&quot;: &quot;Deborah Williams&quot;, &quot;age&quot;: 2, &quot;color&quot;: &quot;#ecf279&quot;&#125; 语法Mock.js 的语法规范包括两部分： 数据模板定义（Data Temaplte Definition，DTD） 数据占位符定义（Data Placeholder Definition，DPD） 数据模板定义 DTD数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值：1234// 属性名 name// 生成规则 rule// 属性值 value&apos;name|rule&apos;: value 注意： 属性名 和 生成规则 之间用 | 分隔。 生成规则 是可选的。 生成规则 有 7 种格式： 1234567&apos;name|min-max&apos;: value&apos;name|count&apos;: value&apos;name|min-max.dmin-dmax&apos;: value&apos;name|min-max.dcount&apos;: value&apos;name|count.dmin-dmax&apos;: value&apos;name|count.dcount&apos;: value&apos;name|+step&apos;: value 生成规则 的 含义 需要依赖 属性值 才能确定。 属性值 中可以含有 @占位符。属性值 还指定了最终值的初始值和类型。 数据占位符定义 DPD 占位符 只是在属性值字符串中占个位置，并不出现在最终的属性值中。占位符 的格式为： 12@占位符@占位符(参数 [, 参数]) 注意： 用 @ 来标识其后的字符串是 占位符。 占位符 引用的是 Mock.Random 中的方法。 通过 Mock.Random.extend() 来扩展自定义占位符。 占位符 也可以引用 数据模板 中的属性。 占位符 会优先引用 数据模板 中的属性 1234567891011121314151617&#123; name: &#123; first: &apos;@FIRST&apos;, middle: &apos;@FIRST&apos;, last: &apos;@LAST&apos;, full: &apos;@first @middle @last&apos; &#125;&#125;// =&gt;&#123; &quot;name&quot;: &#123; &quot;first&quot;: &quot;Charles&quot;, &quot;middle&quot;: &quot;Brenda&quot;, &quot;last&quot;: &quot;Lopez&quot;, &quot;full&quot;: &quot;Charles Brenda Lopez&quot; &#125;&#125; 常用方法Mock.mock( rurl?, rtype?, template|function(options) )根据数据模板生成模拟数据。参数的含义和默认值如下所示： 参数 rurl：可选。表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。例如 /\/domain\/list.json/、’/domian/list.json’。 参数 rtype：可选。表示需要拦截的 Ajax 请求类型。例如 GET、POST、PUT、DELETE 等。 参数 template：可选。表示数据模板，可以是对象或字符串。例如 { ‘data|1-10’:[{}] }、‘@EMAIL’。 参数 function(options)：可选。表示用于生成响应数据的函数。 参数 options：指向本次请求的 Ajax 选项集。 Mock.mockjax(library)覆盖（拦截） Ajax 请求，目前内置支持 jQuery、Zepto、KISSY。 Mock.RandomMock.Random 是一个工具类，用于生成各种随机数据。Mock.Random 的方法在数据模板中称为“占位符”，引用格式为 @占位符(参数 [, 参数]) 。 Mock.tpl(input,options,helpers,partials)基于 Handlebars、Mustache 的 HTML 模板生成模拟数据。 方法使用详情请参考mock.js文档 相关知识JSON.stringify 方法 把一个对象通过 stringify 之后提交给后台或者存储在 Storage 里是很常用的手段。 demo：1234567var data = [ &#123;name: &quot;王尼玛&quot;, sex:1, age: 30&#125;, &#123;name: &quot;王尼美&quot;, sex:0, age: 20&#125;, &#123;name: &quot;王大锤&quot;, sex:1, age: 30&#125;];var str_json = JSON.stringify(data);console.log(str_json); 这个是我们日常用法，非常简单，对吧。 比如说，我们的数据非常复杂，还有类似头像，昵称，个人签名之类的信息。可是我保存在本地，只需要用户名，和性别，肿么破呢？也许你会说 so easy, 遍历数据重新提取下即可。例如：12345678910111213var data = [ &#123;name: &quot;王尼玛&quot;, sex:1, age: 30&#125;, &#123;name: &quot;王尼美&quot;, sex:0, age: 20&#125;, &#123;name: &quot;王大锤&quot;, sex:1, age: 30&#125;];for (var i=0, new_data=[]; i&lt;data.length; i++) &#123; new_data.push(&#123; name: data[i].name, sex: data[i].sex &#125;);&#125;var str_json = JSON.stringify(new_data);console.log(str_json); 确实分分钟搞定。 其实我们只需要用 stringify 第二个参数即可简单处理这种问题。1234567var data = [ &#123;name: &quot;王尼玛&quot;, sex:1, age: 30&#125;, &#123;name: &quot;王尼美&quot;, sex:0, age: 20&#125;, &#123;name: &quot;王大锤&quot;, sex:1, age: 30&#125;];var str_json = JSON.stringify(data, [&quot;name&quot;, &quot;sex&quot;]);console.log(str_json); 第二个参数如此强悍，为我们省去了不少麻烦。 还有第三个参数，用于格式化字符串用的。 123456789var data = [ &#123;name: &quot;王尼玛&quot;, sex:1, age: 30&#125;, &#123;name: &quot;王尼美&quot;, sex:0, age: 20&#125;, &#123;name: &quot;王大锤&quot;, sex:1, age: 30&#125;];var str_json = JSON.stringify(data, null, &quot;\t&quot;);console.log(str_json);str_json = JSON.stringify(data, [&quot;name&quot;, &quot;sex&quot;], &quot;\t&quot;);console.log(str_json); 不想要的 key 返回 undefined 即可123456789101112131415var data = [ &#123;name: &quot;王尼玛&quot;, sex:1, age: 30&#125;, &#123;name: &quot;王尼美&quot;, sex:0, age: 20&#125;, &#123;name: &quot;王大锤&quot;, sex:1, age: 30&#125;];var str_json = JSON.stringify(data, function (k, v) &#123; if (k === &quot;sex&quot;) &#123; return [&quot;女&quot;, &quot;男&quot;][v]; &#125; else if (k === &quot;age&quot; ) &#123; return undefined; &#125; return v;&#125;);console.log(str_json); JSON.stringify(str, null, 4) //表示使用四个空格缩进 参考链接： https://segmentfault.com/a/1190000003087224 https://www.cnblogs.com/52cik/p/js-json-stringify.html 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2018/04/01/用mock实现前端所需数据/]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ajax概念-简单例子复习/Ajax概念+简单例子复习]]></title>
    <url>%2F2018%2F03%2F28%2FAjax%E6%A6%82%E5%BF%B5-%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Ajax概念-简单例子复习/Ajax概念+简单例子复习 Ajax概念-简单例子复习/Ajax概念+简单例子复习同步与异步 同步：页面请求实时传给服务器，导致必填数据没有填的时候，要回到页面上重新从头填写，耗时长、客户体验差。 异步：在页面必填项写上必填选项，不用通过传给服务器判断必填内容是否已经填写完整，耗时短、用户体验强。 异步： XMLHttpRequest： XMLHttpRequest对象的出现分割了同步和异步。XMLHttpRequest出现之前是同步的，出现之后是异步的。 步骤： 利用html+css来实现页面，表达信息； 用XMLHttpRequest和web服务器进行数据的异步交换 运用js操作DOM，实现动态局部刷新； 创建XMLhttpRequest对象123456var request;if(window.XMLHttpRequest)&#123; request = new XMLHtpRequest();&#125;else&#123; request = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//IE5,IE6&#125; Ajax+HTTP请求HTTP请求，简洁版 建立TCP连接 Web浏览器向Web服务器发送请求命令 Web服务器发送请求头 Web服务器应答 Web服务器向浏览器发送数据 Web服务器关闭TCP连接 http 状态码 1XX 信息类 表示收到web浏览器请求 2xx 成功 200 3xx 重定向，表示请求没有成功， 4xx 表示客户端错误 5xx 服务器错误，表示服务器不能完成对请求的处理 XMLHttpRequest发送方法 open（method,url,async）//async:同步false；异步：true（默认） send(string) 例子： 1234567request.open(&quot;GET&quot;, &quot;get.php&quot;,true);request.send();request.open(&quot;POST&quot;, &quot;post.php&quot;,true)；request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);//写在中间，引用表单时，告诉服务器是什么格式，Content-type&quot;告诉服务器是表单格式，页面表单数据向服务端传输时的编码方式application/x-www-form-urlencodedrequest.send(&quot;name=jaymo&amp;sex=男&quot;); XMLHttpRequest取得相应 12345678var request=new XMLHttpRequest(); request.open(&quot;GET&quot;,&quot;get.php&quot;,true); request.send(); request.onreadyStatechange=function()&#123; if（request.readyState===4&amp;&amp;request.status===200）&#123; //做一些事 &#125; &#125; 例子例子简介： html：用来查询员工查询和新建 php：用来查询和新建的后台接口 XAMPP 启动xampp修改端口，改为8088；在浏览器输入：http://localhost:8088/ 建立php文件： test.php12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;测试页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;?phpecho &quot; Hello World! 这是测试页面。&quot;;?&gt; &lt;/body&gt;&lt;/html&gt; 真正例子json解析第一种方法：123var jsondata=&apos;&#123;&quot;staff&quot;:[&#123;&quot;name&quot;:&quot;红旗&quot;,&quot;age&quot;:18&#125;,&#123;&quot;name&quot;:&quot;郭靖&quot;,&quot;age&quot;:16&#125;]&#125;&apos;;var jsonobj=eval(&apos;(&apos;+jsondata+&apos;)&apos;);alert(jsonobj.staff[0].name); 第二种方法：123var jsondata=&apos;&#123;&quot;staff&quot;:[&#123;&quot;name&quot;:&quot;红旗&quot;,&quot;age&quot;:18&#125;,&#123;&quot;name&quot;:&quot;郭靖&quot;,&quot;age&quot;:16&#125;]&#125;&apos;;var jsonobj=JSON.parse(jsondata);alert(jsonobj.staff[0].name); 在JavaScript中有eval和JSON.parse两种方式，推荐后者，因为前者是不安全的，它不能验证json格式的合法性，不能避免在json中直接执行JavaScript代码，从而造成潜在威胁的存在。推荐用JSONlint进行json在线验证 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2018/03/28/Ajax概念-简单例子复习/]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
        <tag>json</tag>
        <tag>jQuery</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON的使用]]></title>
    <url>%2F2018%2F03%2F28%2FJSON%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Json复习 JSON的使用JSON的两种格式1&#123;&quot;name&quot;:&quot;JSON&quot;,&quot;address&quot;:&quot;北京市西城区&quot;,&quot;age&quot;:25&#125;//JSON的对象格式的字符串 1[&#123;&quot;name&quot;:&quot;JSON&quot;,&quot;address&quot;:&quot;北京市西城区&quot;,&quot;age&quot;:25&#125;]//数组对象格式 区别与联系： 对象格式和数组对象格式唯一的不同则是在对象格式的基础上加上了[]，再来看具体的结构，可以看出都是以键值对的形式出现的，中间以英文状态下的逗号（,）分隔。 两个重要函数JSON.stringify()JSON.parse()例子JSON字符串:1var str1 = &apos;&#123; &quot;name&quot;: &quot;cxh&quot;, &quot;sex&quot;: &quot;man&quot; &#125;&apos;; JSON对象:1var obj1= &#123; &quot;name&quot;: &quot;cxh&quot;, &quot;sex&quot;: &quot;man&quot; &#125;; JSON字符串转换为JSON对象要使用上面的str1，必须使用下面的方法先转化为JSON对象： 由JSON字符串转换为JSON对象：12345var obj = eval(&apos;(&apos; + str1+ &apos;)&apos;);console.log(obj);//或者var obj = JSON.parse(str1); console.log(obj); 一般，从后台传入到前台的是json字符串，不是真正的json对象，因此需要使用eval函数转换。 将字符串转换为json对象使用函数eval，或JSON.parse(str)。其中：eval(“(“ + str+ “)”)； SON对象转化为JSON字符串使用toJSONString()或者全局方法JSON.stringify()将JSON对象转化为JSON字符串 123var last=JSON.stringify(obj1); //将JSON对象转化为JSON字符console.log(last);typeof last; Js 中对 Json 数组的常用操作123456var persons = [ &#123;name: &quot;tina&quot;, age: 14&#125;, &#123;name: &quot;timo&quot;, age: 15&#125;, &#123;name: &quot;lily&quot;, age: 16&#125;, &#123;name: &quot;lucy&quot;, age: 16&#125;] 根据对象属性值得到相应对象123456789101112//1. 获取 name 等于 lily 的对象var lily=persons.filter((p)=&gt;&#123; return p.name==&quot;lily&quot;;&#125;);console.log(lily);//注：filter()方法返回的是一个数组var twins = persons.filter((p) =&gt; &#123; return p.age == 16;&#125;);console.log(twins); // 打印结果 [&#123;name: &quot;lily&quot;, age: 16&#125;,&#123;name: &quot;lucy&quot;, age: 16&#125;] 删除其中一个对象1234567891011121314// 删除 name 等于 tina 的对象，利用splice()方法// 1. 首先我们要得到这个对象var tina = persons.filter((p) =&gt; &#123; return p.name == &quot;tina&quot;;&#125;);//2. 其次得到这个对象在数组中对应的索引var index = persons.indexOf(tina[0]);//3. 如果存在则将其删除，index &gt; -1 代表存在index &gt; -1 &amp;&amp; persons.splice(index, 1);console.log(persons); 修改其中一个对象的属性值123456789//将 name 等于 timo 的 age 修改为 20//1. 得到 timo 对象var timo = persons.filter((p) =&gt; &#123; return p.name == &quot;timo&quot;;&#125;);//2. 修改agetimo[0].age = 20; 往数组中添加一个对象1persons.push(&#123;name: &quot;similar&quot;, age: 18&#125;); js 数组转json，json转数组1234567//数组转json串var arr = [1,2,3, &#123; a : 1 &#125; ];JSON.stringify( arr );//json字符串转数组var jsonStr = &apos;[1,2,3,&#123;&quot;a&quot;:1&#125;]&apos;;JSON.parse( jsonStr ); js解析json数组 解析json数组即对JSONArray的遍历 对于标准的json数组如1var result=[&#123;&quot;flag&quot;:1,&quot;macId&quot;:&quot;2&quot;,&quot;mbId&quot;:0,&quot;userName&quot;:&quot;XXX&quot;&#125;,&#123;&quot;flag&quot;:1,&quot;macId&quot;:&quot;1&quot;,&quot;mbId&quot;:1,&quot;userName&quot;:&quot;YYY&quot;&#125;] 进行遍历的时候，可以直接通过for循环遍历这个数组，有两种方法:1234567891011121314//1for (var i = 0; i &lt; result.length; i++) &#123; //result[i]表示获得第i个json对象即JSONObject //result[i]通过.字段名称即可获得指定字段的值 console.log(result[i].userName); &#125; //2 for(var i in result)&#123; //表示遍历数组，而i表示的是数组的下标值， //result[i]表示获得第i个json对象即JSONObject //result[i]通过.字段名称即可获得指定字段的值 result[i].userName; &#125; 对于不标准的json数组如1var result2=&#123;&quot;datas&quot;:[&#123;&quot;flag&quot;:1,&quot;macId&quot;:&quot;2&quot;,&quot;mbId&quot;:0,&quot;userName&quot;:&quot;XXX&quot;&#125;,&#123;&quot;flag&quot;:1,&quot;macId&quot;:&quot;1&quot;,&quot;mbId&quot;:1,&quot;userName&quot;:&quot;YYY&quot;&#125;]&#125;; 进行遍历之前得先解析出标准的json数组格式即[{},{}] var data= result2.datas; 123456789101112//1. for (var i = 0; i &lt; data.length; i++) &#123; //data[i]表示获得第i个json对象即JSONObject //data[i]通过.字段名称即可获得指定字段的值 data[i].userName; &#125;//2. for(var i in data)&#123; //表示遍历数组，而i表示的是数组的下标值， //data[i]表示获得第i个json对象即JSONObject //data[i]通过.字段名称即可获得指定字段的值 data[i].userName; &#125; 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2018/03/28/JSON的使用/]]></content>
      <categories>
        <category>json</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在npm发布第一个包]]></title>
    <url>%2F2018%2F03%2F14%2F%E5%9C%A8npm%E5%8F%91%E5%B8%83%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%85%2F</url>
    <content type="text"><![CDATA[第一个npm包:web-plus 准备工具 安装node.js 注册一个github账户用于托管代码 注册一个npm账户 开发你的module，更新至github 发布module至npmgithub创建项目 终端进入到项目文件夹，执行npm init命令，构建模块的描述文件，系统会提示你输入所需的信息，不想输入就直接Enter跳过。这里主要的几个配置如下: name就是你要发布的module名 version版本信息（每发布一次版本号都必须大于上一次发布的版本号）； entry入口文件 开发： npm init 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647$ npm initThis utility will walk you through creating a package.json file.It only covers the most common items, and tries to guess sensible defaults.See `npm help json` for definitive documentation on these fieldsand exactly what they do.Use `npm install &lt;pkg&gt;` afterwards to install a package andsave it as a dependency in the package.json file.Press ^C at any time to quit.package name: (npm-module) web-plusversion: (1.0.0)description: 前端常用代码片段entry point: (index.js)test command:git repository: git@github.com:JayMo666/webplus.gitkeywords: webauthor: JayMolicense: (ISC) MITAbout to write to F:\npm\npm-module\package.json:&#123; &quot;name&quot;: &quot;web-plus&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;前端常用代码片段&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;git+ssh://git@github.com/JayMo666/webplus.git&quot; &#125;, &quot;keywords&quot;: [ &quot;web&quot; ], &quot;author&quot;: &quot;JayMo&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;bugs&quot;: &#123; &quot;url&quot;: &quot;https://github.com/JayMo666/webplus/issues&quot; &#125;, &quot;homepage&quot;: &quot;https://github.com/JayMo666/webplus#readme&quot;&#125;Is this ok? (yes) npm注册npm 命令1.首先增加用户 npm adduser如：12345$ npm adduserUsername: jaymo666Password: *******Email: (this IS public) 1294****8@qq.comLogged in as jaymo666 on https://registry.npmjs.org/. 2.查看当前登录用户 npm whoami 3.登录命令（这里已经登录，不用执行此命令） npm login 开发包-编程目录结构 a.js index.js （这个是入口文件，要和package.json 文件中的 “main”的值一样） package.json (npm init 生成的） 开发index.js:就开发一个简单地hello程序 1234function hello(name)&#123; console.log(&quot;hello &quot;+ name);&#125;exports.hello=hello; b.js 12var h=require(&apos;./index&apos;);h.hello(&apos;jaymo&apos;); ##5.发布npm包 npm publish进入npm个人中心，可以看到自己的npm包已经发布在上面了 ##6.获取npm包 npm install package-name此处package-name使用web-plus即可可以看到，多了一个node_modules目录，里面多了一个web-plus文件夹，里面放的就是我们刚才创建的npm包，包含a.js、index.js、package.json三个文件 ##7.使用npm包跟使用普通的npm包一样，问了测试简单，创建一个index.js，输入12let a = require(&apos;web-plus&apos;)a.hello(&apos;jaymo&apos;) 执行node index即可看见输出了hello jaymo ##8.更新npm包更新npm包也是使用npm publish命令发布，不过必须更改npm包的版本号，即package.json的version字段，否则会报错1.查看版本 npm version2.修改版本npm version 版本3.然后发布npm publish ##9.易出现的错误： 如果在发布的文件下运行a.js文件测试： node a如果出现：Cannot find module ‘web-plus’错误，可能是在a文件中require(‘./文件名’);引入出错 如果是使用npm包出现Cannot find module ‘web-plus’错误，可能是：发布的包中package.json文件中main（入口文件）的值不是主文件名（在这里为index.js) 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2018/03/14/在npm发布第一个包/]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo博客再配置]]></title>
    <url>%2F2018%2F03%2F08%2F%E2%80%9Chexo%E5%8D%9A%E5%AE%A2%E5%86%8D%E9%85%8D%E7%BD%AE%E2%80%9D%2F</url>
    <content type="text"><![CDATA[记录更换电脑后开启的新功能 1.已结开启的功能1.1设置 RSS1.2侧边栏社交链接1.3设置「动画效果」1.4设置「背景动画」2.待开启2.1设置字体2.2开启打赏功能2.3订阅微信公众号3.hexo 官方插件地址：https://hexo.io/plugins/ 4.加入的插件： HEXO-自动摘录https://github.com/ashisherc/hexo-auto-excerpt HEXO辅助性live2d https://github.com/EYHN/hexo-helper-live2d Hexo跨博客文章推荐插件 https://github.com/huiwang/hexo-recommended-posts4.实现点击出现桃心效果 在网站底部加上访问量 【参考】 1.https://www.jianshu.com/p/f054333ac9e6 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2018/03/08/“hexo博客再配置”/]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迁移hexo到新电脑]]></title>
    <url>%2F2018%2F03%2F08%2F%E8%BF%81%E7%A7%BBhexo%E5%88%B0%E6%96%B0%E7%94%B5%E8%84%91%2F</url>
    <content type="text"><![CDATA[在更换新电脑的情况下恢复博客，保留了源码… 1、从官网Git下载git，在新电脑上安装，因为https速度慢，而且每次都要输入口令，常用的是使用ssh。使用下面方法创建：（1）打开git bash，在用户主目录下运行：ssh-keygen -t rsa -C “youremail@example.com“ 把其中的邮件地址换成自己的邮件地址，然后一路回车（2）最后完成后，会在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，千万不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。（3）登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」，你就应该看到已经添加的Key。注意：不要在git版本库中运行ssh，然后又将它提交，这样就把密码泄露出去了。（3）https://coding.net 中的ssh与github的共用 2、下载Node.js，并安装 3、打开git bash客户端，输入 npm install hexo-cli -g，开始安装hexo 4、下面就将原来的文件拷贝到新电脑中，但是要注意哪些文件是必须的，哪些文件是可以删除的。（1）讨论下哪些文件是必须拷贝的：首先是之前自己修改的文件，像站点配置_config.yml，theme文件夹里面的主题，以及source里面自己写的博客文件，这些肯定要拷贝的。除此之外，还有三个文件需要有，就是scaffolds文件夹（文章的模板）、package.json（说明使用哪些包）和.gitignore（限定在提交的时候哪些文件可以忽略）。其实，这三个文件不是我们修改的，所以即使丢失了，也没有关系，我们可以建立一个新的文件夹，然后在里面执行hexo init，就会生成这三个文件，我们只需要将它们拷贝过来使用即可。总结：_config.yml，theme/，source/，scaffolds/，package.json，.gitignore，是需要拷贝的。（2）再讨论下哪些文件是不必拷贝的，或者说可以删除的：首先是.git文件，无论是在站点根目录下，还是主题目录下的.git文件，都可以删掉。然后是文件夹node_modules（在用npm install会重新生成），public（这个在用hexo g时会重新生成），.deploy_git文件夹（在使用hexo d时也会重新生成），db.json文件。其实上面这些文件也就是.gitignore文件里面记载的可以忽略的内容。总结：.git/，public/，.deploy_git/，db.json文件需要删除。 5、在git bash中切换目录到新拷贝的文件夹里，使用 npm install 命令，进行模块安装。很明显我们这里没用hexo init初始化，因为有的文件我们已经拷贝生成过来了，所以不必用hexo init去整体初始化，如果不慎在此时用了hexo init，则站点的配置文件_config.yml里面内容会被清空使用默认值，所以这一步一定要慎重，不要用hexo init。 6、安装其他的一些必要组件，如果在node_modules里面有的，就不要重复安装了：（1）为了使用hexo d来部署到git上，需要安装npm install hexo-deployer-git –save（2）为了建立RSS订阅，需要安装npm install hexo-generator-feed –save（3）为了建立站点地图，需要安装npm install hexo-generator-sitemap –save插件安装后，有的需要对配置文件_config.yml进行配置，具体怎么配置，可以参考上面插件在github主页上的具体说明 7、使用hexo g，然后使用hexo d进行部署，如果都没有出错，就转移成功了！ 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2018/03/08/迁移hexo到新电脑/]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2018/03/07/hello-world/]]></content>
  </entry>
  <entry>
    <title><![CDATA[conda用法]]></title>
    <url>%2F2017%2F12%2F04%2Fconda%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Conda简单用法及在python2与python3之间切换 安装scipyconda install scipy conda会从从远程搜索scipy的相关信息和依赖项目，对于python 3.4，conda会同时安装numpy和mkl（运算加速的库）查看已经安装的packagesconda list 最新版的conda是从site-packages文件夹中搜索已经安装的包，不依赖于pip，因此可以显示出通过各种方式安装的包查看当前环境下已安装的包conda list 查看某个指定环境的已安装包conda list -n python34 查找package信息conda search numpy 安装packageconda install -n python34 numpy 如果不用-n指定环境名称，则被安装在当前活跃环境也可以通过-c指定通过某个channel安装更新packageconda update -n python34 numpy 删除packageconda remove -n python34 numpy conda将conda、python等都视为package，因此，完全可以使用conda来管理conda和python的版本，例如 更新conda，保持conda最新conda update conda 更新anacondaconda update anaconda 更新pythonconda update python 假设当前环境是python 3.4, conda会将python升级为3.4.x系列的当前最新版本如果创建新的python环境，比如3.4，运行conda create -n python34 python=3.4之后，conda仅安装python 3.4相关的必须项，如python, pip等，如果希望该环境像默认环境那样，安装anaconda集合包，只需要： 在当前环境下安装anaconda包集合conda install anaconda 结合创建环境的命令，以上操作可以合并为conda create -n python34 python=3.4 anaconda 也可以不用全部安装，根据需求安装自己需要的package即可 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/12/04/conda用法/]]></content>
  </entry>
  <entry>
    <title><![CDATA[网络管理员必备]]></title>
    <url>%2F2017%2F09%2F26%2FNetwork(1)%2F</url>
    <content type="text"><![CDATA[本文包括： [1]ping命令 [2]路由器和交换机的差异 [3]路由器的基本设置 [4]netsh网络配置命令 [5]安装失败（未签名） [6]管理用户网络应用 [7]映射网络驱动器 [8]网络适配器的原理 [9]交换机的分类 [10]交换机的功能 [11]交换机的接口种类 [12]路由器的工作原理 [13]初识TCP/IP的分层 网络管理员必备[1]ping命令“ping”命令是windows系统最长用的命令之一，是通过对一个网址发送测试数据包，看对方网址是否有响应并统计响应时间，以此测试网络，同时可以很好地帮助我们分析和判定网络故障。 方式：“ping IP地址/域名” 输入“ping IP地址”回车，我们可以看到本机跟这台网络设备的连接状态，如下图所示是连接正常的。例如：百度首页ip地址：119.75.217.109 2.还可以“ping 域名”,例如:ping baidu.com 3.如果“ping”后出现下图所示界面，说明本机跟这台网络设备的网络连接是不通的 4.键入“ping”直接回车我们还可以看到ping命令加其他参数的使用方法 5.比如，我们使用“ping IP地址 -t”命令，可以持续的ping指定的主机，如果没有手动停止，ping命令会一直持续下去，我们可以通过“Ctrl+C”停止命令。其他参数的使用方法用户可以自己体验 [2]路由器和交换机的差异1. 工作层次不同:交换机工作在七层模型的第二层（即数据链路层）；而路由器工作在第三层（即网络层）。交换机由于工作在第二层，它的工作原理比较简单，而路由器在第三层，可以得到更多的协议信息，也可以做出更加智能的转发或映射。 网络层（第三层）：能提供介质访问和链路管理等功能数据链路层（第二层）：具有寻址和路由选择等功能 2. 数据转发依据的对象不同交换机是利用网络设备的物理地址（即MAC地址）来确定转发数据的目的地址；路由器是利用网络设备的IP地址来确定转发数据的目的地址。其中物理地址是设备本身自带的，由设备的网卡生产厂商分配，已经固化到网卡硬件中，不可修改；而IP地址是在系统软件中分配的，可以修改。 通过命令“ipconfig/all”，可以查看本机的物理地址和IP地址。如下图所示，就是我的计算机的网卡信息。 3.路由器可以分割广播域，而交换机不能交换机只可以分割冲突域，不可以分割广播域，而路由器可以分割广播域。简单的来说，在同一个交换机下连接的设备，IP都在同一个网段，是属于同一个广播域的，如果不在同一网段，则无法进行通信；而路由器可以分配不同的广播域（即不同的网段），而这些不同网段的设备可以不穿过路由而进行相互通信。 目前，虽然三层或者第三层以上交换机具有VLAN功能，也可以分割广播域，但是各个广播域之间是不可以相互通信的，他们之前如果要通信交流还是需要路由器的支持。 4.路由器有防火墙服务，而交换机没有路由器设置的防火墙是运行在网络层的，通过设置特定的规定，允许或者限制传输的数据通过，或者过滤IP封包，禁止不符合规定的封包通过。而交换机不具备防火墙功能，如果只是通过交换机接通外部网络，相当于闭上眼、光着屁股在大街上跑，很不安全！ 注意：数据安全很重要，路由器、交换机的使用都要慎重！注意保密保护工作！ [3]路由器的基本设置 要实现多台计算机同时上网，主要设置的地方就是路由器，下面以企业中总路由器下的一个无线路由为大家介绍一下路由器的基本设置过程。 1.通过浏览器登录路由器。如果是新路由器，可以查看路由后面贴标签出的默认IP和登录账号、密码；如果是正常使用中的路由器，登录地址可以查看计算机的网关，如果登录密码修改过，请咨询管理员。 电脑和路由器相连：一种是通过网线连接，一种是通过无线连接。 电脑和路由器之间通过网线连接的话，你要在路由器上找到LAN口和WAN口。这里讲一下，WAN口全称Wide Area Network（广域网），LAN口全称Wide Area Network（局域网）。一般的路由有很多LAN口，一个WAN口。WAN口插主网线，LAN插电脑与路由连接的网线。这样电脑就和路由器连接了。 电脑连接上了路由器，就可以在浏览器上输入路由器的地址进入路由器的设置界面了 2.WAN口设置，“基本设置”中的“快速设置”，（1）如果外网地址没有固定IP，则类型选择动态；（2）如果外网地址有固定IP或者上层还有路由则将分配IP设置到wan口，如下图所示。 3.LAN口的设置，“基本设置”中的“内网设置”，设置IP地址（即内网中网络设备的网关比如设置成192.168.1.1，如果上层有路由是192.168.1.1，则次路由器可以设置成其他网段192.168.x.1）、子网掩码。4.“DHCP服务器”的设置，如果让用户自动获取IP地址使用，需要使用DHCP服务器，可以限制用户自动获取IP地址的范围，如下图的“起始IP地址”和“结束IP地址”（可以在上网行为管理的IP地址组中看到）。 5.无线的“基本设置”，要启用无线的话，勾选启用开关，并为无线网络设置一个名称，设置无线模式为“11b/g/n混合模式”，来兼容三种无线协议：802.11b、802.11g、802.11n。 6.无线的“安全设置”，如果需要做MAC地址绑定的安全管控，需要勾选mac地址“启用”：设置“允许”，将允许上网的计算机mac地址添加到mac地址列表；设置“禁用”，将不允许上网的计算机mac地址添加到mac地址列表。设置加密类型为常用的“WPA2-PSK”，并设置密码 7.“上网行为管理”设置，设置允许或者不允许上网的时间段；如果需要管理QQ等常用聊天软件，可以在聊天软件高级设置里进行启用，将允许使用QQ等聊天软件的账号添加到例外列表。 8.网络安全中设置内外网的“攻击防御”和“MAC地址绑定”（勾选“禁止未绑定IP/MAC的主机通过”，前面已经说过，不再赘述） 9.“端口映射”和“域名转发”，大多在系统集成中会用到，特别是监控设备想要远程访问，需要将设备的通讯端口等进行路由转发，此处需要注意的是，如果跨多层路由的话，每一层路由都是需要转发的。 10.修改路由器的登录密码。 [4]netsh网络配置命令netsh是Network Shell的缩写，是windows为我们提供的功能强大的网络配置命令行工具。下面用几个常用的“netsh interface ip show”小命令介绍netsh的用法。 1.netsh interface ip show address:显示本机IP地址配置，包括以太网的ip和本地回环ip地址，以太网ip地址就是我们常说的为本机网卡分配的一个地址，这个容易理解；本地还有ip地址，是一种叫做本地回环接口虚接口，在windows系统中都会采用如下图所示的127.0.0.1这个地址，用以提高网络的健壮性。 2.如果在上一步的基础上想要显示更多信息，可以用命令：netsh interface ip show config。 3.netsh interface ip show dns:显示本机使用的DNS服务器，同样包括以太网和本地回环接口的DNS信息。 4.netsh interface ip show ipnet:显示本IP地址所在的网络到媒体的映射，我们同时可以看到映射类型和所用接口等信息。 5.netsh interface ip show wins:如果设置了wins服务器，可以用此命令查看wins服务器的地址。 6.还有一个我喜欢用的不属于“netsh interface ip”这一系列的小命令，netsh firewall show state:查看本机防火墙的状态，每当我们公司某一台办公电脑在连接公司的某个系统连接不上的时候，我会用以查看防火墙状态，我们可以看到启用或禁用的功能模块，以及启用情况。 [5]安装失败（未签名）在我们安装驱动的时候，特别是用驱动精灵等驱动软件安装的时候，会出现“安装失败（未签名）”的情况，如何解决？ 方法/步骤 1.单击开始菜单里的“运行”，或者通过“windows键+R”打开“运行”，在输入框中输入“sigverif”回车 2.在打开的文件签名验证里点击“高级”按钮 3.如下图所示找到下载的驱动（如果未解压，需要先解压），然后点击“确认”按钮 4.切换到“正在记录”选项，选中如下图所示选项，点击“确定”按钮 5.回到第二步时候的界面，点击“开始”按钮，我们可以看到下图所示列表界面，点击“关闭”即可 6.从设备管理器安装驱动，右键单击我的电脑（xp）/计算机（win7）/这台电脑（win8），点击“管理”，在“计算机管理”中右侧边栏中单击“设备管理器”，找到我们要安装驱动的这个硬件，右键单击，选择“更新驱动程序” 7.勾选“从列表或指定位置安装”，点击“下一步”按钮 8.选择驱动程序解压后的文件夹，点击“下一步”按钮 9.到安装界面，用户需等待，知道出现安装成功的界面，点击“完成”按钮即可 10.返回到设备管理器，我们可以看到，此驱动已经安装完成 [6]管理用户网络应用现在各种网络应用程序纷繁复杂，而p2p软件又是其中最为流行的一种，而且提供了多样化得登陆方式，在此，我们以最常用的QQ为例。 我们大家都知道，QQ本身支持UDP、HTTP和HTTPS三种登陆方式，而且可以使用代理，意思是说，只要你允许了HTTP协议，QQ就可以登陆。 现在我们以封锁QQ为例，介绍一下，如何利用路由级的网络防火墙管理用户网络应用。 1.QQ登陆原理 QQ登录登陆的过程，由向服务器群的8000端口发送UDP数据包，从服务器群的回复中选择一个最快的作为登陆服务器。 如果没有服务器回复UDP数据包，则使用TCP80/443端口来进行连接。 QQ服务器： UDP8000端口类18个 TCPHTTP连接服务器5个 会员VIP服务器使用HTTPS443连接 2.如何封锁1.上面我们知道，QQ可以使用HTTP直接连接，一般不能封锁HTTP协议，所以最好的办法就是封锁它的服务器IP地址，但是QQ还可以使用代理登陆，这种情况我们就得在路由级防火墙中的HTTP检查机制中设置禁止QQ的HTTP连接。2.首先，配置用户访问规则，使用计算机集定义目的网络。也就是做好禁止内部客户访问QQ服务器的访问策略。 3.其次，配置HTTP策略，理由路由器的HTTP深层检查机制，禁止QQ使用HTTP代理。在允许ＱＱ使用HTTP代理的策略上点击右键，选中“配置HTTP” 4.在弹出的“为规则配置HTTP策略”对话框中，点击“签名”，然后点击“添加”，在弹出的“签名”对话框中，输入名称为“QQ”，指定签名搜索条件为在“请求URL”中搜索“tencent.com”，找到则阻止这个连接 5.最后，在防火墙策略选项中，点击“应用”来保存修改和更新防火墙策略，此时，QQ已经不能通过代理服务器登录了 [7]映射网络驱动器映射网络驱动器” 的意思是将局域网中的某个目录（一般是共享的文件夹之类的）映射成本地驱动器号，就是说把网络上其他机器的共享的文件夹映射自己机器上的一个磁盘，这样可以提高访问时间，相当于一个打开共享的快捷方式。 1.首先，找到这个共享文件夹，我们可以在网络里找到这台设备，或者打开开始菜单的“运行”，输入：“\这台设备的IP地址”，比如此例中的“\192.168.1.52” 2.在打开的共享界面，找到并右键单击要映射驱动器的文件件，选择“映射网络驱动器” 3.在映射驱动器的界面，选择好驱动器盘符，点击“完成”即可完成设置 4.打开资源管理器，我们可以看到，已经有了该驱动器，日常使用过程中直接点击打开即可 [8]网络适配器的原理网络适配器，也就是我们说的网卡，有些维修人员也叫网络接口卡，是计算机和网络电缆之间的物理接口，下面我们根据网络适配器需要完成的任务介绍一下它的工作原理。 1.为在计算机使用的数据（并行数据）和电缆上传输的电信号（串行数据）之间提供数据转换的功能。比如我们用的一个共享打印机，计算机直接连接打印机用的是并行数据，而如果我们通过网络连接别人共享的打印机，就是通过串行数据转换为并行数据来实现。2.判断从电缆接收的数据是否为传输给该计算机的数据。 3.在计算机和电缆之间控制数据流，每块网卡都有一个唯一的标识，我们一般叫做MAC地址，大部分网卡的MAC地址烧录在卡上的ROM芯片中，MAC地址有6段组成，通常表示为12个16进制数。我们可以通过命令提示符查看本机网卡的信息，操作步骤：1、单击开始菜单里的“运行”，在输入框中输入“cmd”，然后回车。2、在命令提示符界面输入“ipconfig /all”命令，回车，我们可以看到以下信息。如图所示的是本机无线网卡的信息，其中前3字节“A6-17-31”表示厂商代码，有IEEE负责分配；后3个字节“30-49-E2”表示网卡序号，由网卡厂商负责。 [9]交换机的分类交换机是网络连接的基础，有了交换机，就可以实现更多电脑的共享上网 1.广义上来讲，交换机分为两种：广域交换机和局域网交换机。广域网交换机主要用于电信领域，提供通信用的基础平台，我们平常接触很少；而局域网交换机是我们日常使用最多的，主要应用于日常的局域网络，连接计算机和网络打印机的终端设备 2.从传输介质和传输速度上可以分为以太网交换机、快速以太网交换机、千兆以太网交换机、FDDI交换机、ATM交换机和令牌交换机等 3.从规模应用上可以分为企业级、部门级和工作组交换机 [10]交换机的功能1.交换机功能学习功能，局域网内交换机会了解跟每一个插口相连接的MAC地址，并将地址同相应的端口映射起来存放在交换机缓存中的MAC地址表中 2.转发/过滤功能当一个数据帧的目的地址在MAC地址表中有映射时，它被转发到连接目的节点的端口而不是所有端口（如该数据帧为广播/组播帧则转发至所有端口） 3.消除回路功能当交换机包括一个冗余回路时，以太网交换机通过生成树协议避免回路的产生，同时允许存在后背路径 4.兼容功能交换机除了能连接两种同类型的网络之外，还可以在不同类型的网路（如以太网和快速以太网）之间起到互联作用。而且现在的交换机没有很严格的类型之分，百兆交换机一般也会加两个千兆口或光纤接入口 [11]交换机的接口种1.双绞线RJ-45接口-水晶头 2.光纤接口光纤需要熔接到带插头的尾纤，常见的尾纤插头有SC。 [12]路由器的工作原理路由器，大家都很熟悉了，办公室或者家里凡有两台以上的电脑需要上网的一般都安装了路由器，只有安装了路由器才能实现多台电脑同时上网。我们就了解下路由器的配置原理。 1.路由器的概念1.所谓“路由”，就是把数据从一个地方传送到另一个地方的行为和动作，路由器就是执行这个动作的机器，英文名Router 2.路由器能将不同网络或网段之间的数据信息进行“翻译”，以使他们能够相互“读”懂对方的数据，从而构建更大的网络。 2.路由器的典型功能 数据通道功能 包括转发决定、背板转发以及输出链路调度等，一般由特定的硬件来完成 控制功能 一般用软件来实现，包括与相邻路由器之间的信息交换、系统配置、系统管理等 3.路由器的主要功能 网络互连 路由器支持各种局域网和广域网接口，主要用于互连局域网和广域网，实现不同网络互相通信 数据处理 提供包括分组过滤、分组转发、优先级、复用、加密、压缩和防火墙等功能 网络管理 路由器提供包括配置管理、性能管理、容错管理和流量控制管理等功能 4.路由器的工作原理 接收来自它连接的某个网络的数据 将数据向上传递，并且（必要时）重新组合IP数据报 检查IP头部中的目的地址，如果目的地址位于发出数据的那个网络，那么路由器就放下被认为已经达到目的地的数据，因为数据是在目的计算机所在网络上传输 如果数据要送往另一个网络，那么路由器就查询路由表，以确定数据要转发到的目的地 路由器确定哪个适配器负责接收数据后，就通过相应的软件传递数据，以便通过网络来传送数据 [13]初识TCP/IP的分层大家可能经常使用TCP/IP协议，在进行网络配置或修改IP地址等操作的时候会用到该处，但很少有人去深入挖掘，在此我们简单的了解一下TCP/IP的分层。 1.TCP/IP协议 Internet采用了TCP/IP协议，但这并不是一个单一的协议，我们可能知道，TCP即传输控制协议，IP为网间协议，TCP/IP我们常常描述为互联网协议集。但可能很少人知道TCP/IP也是一种分层模型。它是基于硬件层次上的四个概念性层次构成，分别是网络接口层（数据链路层）、IP层（网络层）、传输层、应用层。 网络接口层:也称数据链路层，这是TCP/IP最底层。功能:负责接收IP数据报并发送至选定的网络。 IP层:IP层处理机器之间的通信。功能:它接收来自传输层的请求，将带有目的地址的分组发送出去。将分组封装到数据报中，填入数据报头，使用路由算法以决定是直接将数据报传送至目的主机还是传给路由器，然后把数据报送至相应的网络接口来传送。 传输层:是提供应用层之间的通信，即端到端的通信。功能:管理信息流，提供可靠的传输服务，以确保数据无差错的地按序到达。 2.TCP/IP模型的分界线协议地址分界线:以区分高层和低层的寻址，高层寻址使用IP地址，低层寻址使用物理地址。应用程序IP层之上的协议软件只使用IP地址，而网络接口层处理物理地址。 操作系统分界线:以区分系统与应用程序。在传输层和应用层之间。 3.复用与分解 发送报文时，发送方在报文中加和了报文类型、选用协议等附加信息。所有的报文以帧的形式在网络中复用传送，形成一个分组流。在接收方收到分组时，参考附加信息对接收到的分组进行分解。 参考网址：https://jingyan.baidu.com/season/38734 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/26/Network(1)/]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络管理员必备]]></title>
    <url>%2F2017%2F09%2F26%2FNetwork%2F</url>
    <content type="text"><![CDATA[本文包括： [1]ping命令 [2]路由器和交换机的差异 [3]路由器的基本设置 [4]netsh网络配置命令 [5]安装失败（未签名） [6]管理用户网络应用 [7]映射网络驱动器 [8]网络适配器的原理 [9]交换机的分类 [10]交换机的功能 [11]交换机的接口种类 [12]路由器的工作原理 [13]初识TCP/IP的分层 网络管理员必备[1]ping命令“ping”命令是windows系统最长用的命令之一，是通过对一个网址发送测试数据包，看对方网址是否有响应并统计响应时间，以此测试网络，同时可以很好地帮助我们分析和判定网络故障。 方式：“ping IP地址/域名” 输入“ping IP地址”回车，我们可以看到本机跟这台网络设备的连接状态，如下图所示是连接正常的。例如：百度首页ip地址：119.75.217.109 2.还可以“ping 域名”,例如:ping baidu.com 3.如果“ping”后出现下图所示界面，说明本机跟这台网络设备的网络连接是不通的 4.键入“ping”直接回车我们还可以看到ping命令加其他参数的使用方法 5.比如，我们使用“ping IP地址 -t”命令，可以持续的ping指定的主机，如果没有手动停止，ping命令会一直持续下去，我们可以通过“Ctrl+C”停止命令。其他参数的使用方法用户可以自己体验 [2]路由器和交换机的差异1. 工作层次不同:交换机工作在七层模型的第二层（即数据链路层）；而路由器工作在第三层（即网络层）。交换机由于工作在第二层，它的工作原理比较简单，而路由器在第三层，可以得到更多的协议信息，也可以做出更加智能的转发或映射。 网络层（第三层）：能提供介质访问和链路管理等功能数据链路层（第二层）：具有寻址和路由选择等功能 2. 数据转发依据的对象不同交换机是利用网络设备的物理地址（即MAC地址）来确定转发数据的目的地址；路由器是利用网络设备的IP地址来确定转发数据的目的地址。其中物理地址是设备本身自带的，由设备的网卡生产厂商分配，已经固化到网卡硬件中，不可修改；而IP地址是在系统软件中分配的，可以修改。 通过命令“ipconfig/all”，可以查看本机的物理地址和IP地址。如下图所示，就是我的计算机的网卡信息。 3.路由器可以分割广播域，而交换机不能交换机只可以分割冲突域，不可以分割广播域，而路由器可以分割广播域。简单的来说，在同一个交换机下连接的设备，IP都在同一个网段，是属于同一个广播域的，如果不在同一网段，则无法进行通信；而路由器可以分配不同的广播域（即不同的网段），而这些不同网段的设备可以不穿过路由而进行相互通信。 目前，虽然三层或者第三层以上交换机具有VLAN功能，也可以分割广播域，但是各个广播域之间是不可以相互通信的，他们之前如果要通信交流还是需要路由器的支持。 4.路由器有防火墙服务，而交换机没有路由器设置的防火墙是运行在网络层的，通过设置特定的规定，允许或者限制传输的数据通过，或者过滤IP封包，禁止不符合规定的封包通过。而交换机不具备防火墙功能，如果只是通过交换机接通外部网络，相当于闭上眼、光着屁股在大街上跑，很不安全！ 注意：数据安全很重要，路由器、交换机的使用都要慎重！注意保密保护工作！ [3]路由器的基本设置 要实现多台计算机同时上网，主要设置的地方就是路由器，下面以企业中总路由器下的一个无线路由为大家介绍一下路由器的基本设置过程。 1.通过浏览器登录路由器。如果是新路由器，可以查看路由后面贴标签出的默认IP和登录账号、密码；如果是正常使用中的路由器，登录地址可以查看计算机的网关，如果登录密码修改过，请咨询管理员。 电脑和路由器相连：一种是通过网线连接，一种是通过无线连接。 电脑和路由器之间通过网线连接的话，你要在路由器上找到LAN口和WAN口。这里讲一下，WAN口全称Wide Area Network（广域网），LAN口全称Wide Area Network（局域网）。一般的路由有很多LAN口，一个WAN口。WAN口插主网线，LAN插电脑与路由连接的网线。这样电脑就和路由器连接了。 电脑连接上了路由器，就可以在浏览器上输入路由器的地址进入路由器的设置界面了 2.WAN口设置，“基本设置”中的“快速设置”，（1）如果外网地址没有固定IP，则类型选择动态；（2）如果外网地址有固定IP或者上层还有路由则将分配IP设置到wan口，如下图所示。 3.LAN口的设置，“基本设置”中的“内网设置”，设置IP地址（即内网中网络设备的网关比如设置成192.168.1.1，如果上层有路由是192.168.1.1，则次路由器可以设置成其他网段192.168.x.1）、子网掩码。4.“DHCP服务器”的设置，如果让用户自动获取IP地址使用，需要使用DHCP服务器，可以限制用户自动获取IP地址的范围，如下图的“起始IP地址”和“结束IP地址”（可以在上网行为管理的IP地址组中看到）。 5.无线的“基本设置”，要启用无线的话，勾选启用开关，并为无线网络设置一个名称，设置无线模式为“11b/g/n混合模式”，来兼容三种无线协议：802.11b、802.11g、802.11n。 6.无线的“安全设置”，如果需要做MAC地址绑定的安全管控，需要勾选mac地址“启用”：设置“允许”，将允许上网的计算机mac地址添加到mac地址列表；设置“禁用”，将不允许上网的计算机mac地址添加到mac地址列表。设置加密类型为常用的“WPA2-PSK”，并设置密码 7.“上网行为管理”设置，设置允许或者不允许上网的时间段；如果需要管理QQ等常用聊天软件，可以在聊天软件高级设置里进行启用，将允许使用QQ等聊天软件的账号添加到例外列表。 8.网络安全中设置内外网的“攻击防御”和“MAC地址绑定”（勾选“禁止未绑定IP/MAC的主机通过”，前面已经说过，不再赘述） 9.“端口映射”和“域名转发”，大多在系统集成中会用到，特别是监控设备想要远程访问，需要将设备的通讯端口等进行路由转发，此处需要注意的是，如果跨多层路由的话，每一层路由都是需要转发的。 10.修改路由器的登录密码。 [4]netsh网络配置命令netsh是Network Shell的缩写，是windows为我们提供的功能强大的网络配置命令行工具。下面用几个常用的“netsh interface ip show”小命令介绍netsh的用法。 1.netsh interface ip show address:显示本机IP地址配置，包括以太网的ip和本地回环ip地址，以太网ip地址就是我们常说的为本机网卡分配的一个地址，这个容易理解；本地还有ip地址，是一种叫做本地回环接口虚接口，在windows系统中都会采用如下图所示的127.0.0.1这个地址，用以提高网络的健壮性。 2.如果在上一步的基础上想要显示更多信息，可以用命令：netsh interface ip show config。 3.netsh interface ip show dns:显示本机使用的DNS服务器，同样包括以太网和本地回环接口的DNS信息。 4.netsh interface ip show ipnet:显示本IP地址所在的网络到媒体的映射，我们同时可以看到映射类型和所用接口等信息。 5.netsh interface ip show wins:如果设置了wins服务器，可以用此命令查看wins服务器的地址。 6.还有一个我喜欢用的不属于“netsh interface ip”这一系列的小命令，netsh firewall show state:查看本机防火墙的状态，每当我们公司某一台办公电脑在连接公司的某个系统连接不上的时候，我会用以查看防火墙状态，我们可以看到启用或禁用的功能模块，以及启用情况。 [5]安装失败（未签名）在我们安装驱动的时候，特别是用驱动精灵等驱动软件安装的时候，会出现“安装失败（未签名）”的情况，如何解决？ 方法/步骤 1.单击开始菜单里的“运行”，或者通过“windows键+R”打开“运行”，在输入框中输入“sigverif”回车 2.在打开的文件签名验证里点击“高级”按钮 3.如下图所示找到下载的驱动（如果未解压，需要先解压），然后点击“确认”按钮 4.切换到“正在记录”选项，选中如下图所示选项，点击“确定”按钮 5.回到第二步时候的界面，点击“开始”按钮，我们可以看到下图所示列表界面，点击“关闭”即可 6.从设备管理器安装驱动，右键单击我的电脑（xp）/计算机（win7）/这台电脑（win8），点击“管理”，在“计算机管理”中右侧边栏中单击“设备管理器”，找到我们要安装驱动的这个硬件，右键单击，选择“更新驱动程序” 7.勾选“从列表或指定位置安装”，点击“下一步”按钮 8.选择驱动程序解压后的文件夹，点击“下一步”按钮 9.到安装界面，用户需等待，知道出现安装成功的界面，点击“完成”按钮即可 10.返回到设备管理器，我们可以看到，此驱动已经安装完成 [6]管理用户网络应用现在各种网络应用程序纷繁复杂，而p2p软件又是其中最为流行的一种，而且提供了多样化得登陆方式，在此，我们以最常用的QQ为例。 我们大家都知道，QQ本身支持UDP、HTTP和HTTPS三种登陆方式，而且可以使用代理，意思是说，只要你允许了HTTP协议，QQ就可以登陆。 现在我们以封锁QQ为例，介绍一下，如何利用路由级的网络防火墙管理用户网络应用。 1.QQ登陆原理 QQ登录登陆的过程，由向服务器群的8000端口发送UDP数据包，从服务器群的回复中选择一个最快的作为登陆服务器。 如果没有服务器回复UDP数据包，则使用TCP80/443端口来进行连接。 QQ服务器： UDP8000端口类18个 TCPHTTP连接服务器5个 会员VIP服务器使用HTTPS443连接 2.如何封锁1.上面我们知道，QQ可以使用HTTP直接连接，一般不能封锁HTTP协议，所以最好的办法就是封锁它的服务器IP地址，但是QQ还可以使用代理登陆，这种情况我们就得在路由级防火墙中的HTTP检查机制中设置禁止QQ的HTTP连接。2.首先，配置用户访问规则，使用计算机集定义目的网络。也就是做好禁止内部客户访问QQ服务器的访问策略。 3.其次，配置HTTP策略，理由路由器的HTTP深层检查机制，禁止QQ使用HTTP代理。在允许ＱＱ使用HTTP代理的策略上点击右键，选中“配置HTTP” 4.在弹出的“为规则配置HTTP策略”对话框中，点击“签名”，然后点击“添加”，在弹出的“签名”对话框中，输入名称为“QQ”，指定签名搜索条件为在“请求URL”中搜索“tencent.com”，找到则阻止这个连接 5.最后，在防火墙策略选项中，点击“应用”来保存修改和更新防火墙策略，此时，QQ已经不能通过代理服务器登录了 [7]映射网络驱动器映射网络驱动器” 的意思是将局域网中的某个目录（一般是共享的文件夹之类的）映射成本地驱动器号，就是说把网络上其他机器的共享的文件夹映射自己机器上的一个磁盘，这样可以提高访问时间，相当于一个打开共享的快捷方式。 1.首先，找到这个共享文件夹，我们可以在网络里找到这台设备，或者打开开始菜单的“运行”，输入：“\这台设备的IP地址”，比如此例中的“\192.168.1.52” 2.在打开的共享界面，找到并右键单击要映射驱动器的文件件，选择“映射网络驱动器” 3.在映射驱动器的界面，选择好驱动器盘符，点击“完成”即可完成设置 4.打开资源管理器，我们可以看到，已经有了该驱动器，日常使用过程中直接点击打开即可 [8]网络适配器的原理网络适配器，也就是我们说的网卡，有些维修人员也叫网络接口卡，是计算机和网络电缆之间的物理接口，下面我们根据网络适配器需要完成的任务介绍一下它的工作原理。 1.为在计算机使用的数据（并行数据）和电缆上传输的电信号（串行数据）之间提供数据转换的功能。比如我们用的一个共享打印机，计算机直接连接打印机用的是并行数据，而如果我们通过网络连接别人共享的打印机，就是通过串行数据转换为并行数据来实现。2.判断从电缆接收的数据是否为传输给该计算机的数据。 3.在计算机和电缆之间控制数据流，每块网卡都有一个唯一的标识，我们一般叫做MAC地址，大部分网卡的MAC地址烧录在卡上的ROM芯片中，MAC地址有6段组成，通常表示为12个16进制数。我们可以通过命令提示符查看本机网卡的信息，操作步骤：1、单击开始菜单里的“运行”，在输入框中输入“cmd”，然后回车。2、在命令提示符界面输入“ipconfig /all”命令，回车，我们可以看到以下信息。如图所示的是本机无线网卡的信息，其中前3字节“A6-17-31”表示厂商代码，有IEEE负责分配；后3个字节“30-49-E2”表示网卡序号，由网卡厂商负责。 [9]交换机的分类交换机是网络连接的基础，有了交换机，就可以实现更多电脑的共享上网 1.广义上来讲，交换机分为两种：广域交换机和局域网交换机。广域网交换机主要用于电信领域，提供通信用的基础平台，我们平常接触很少；而局域网交换机是我们日常使用最多的，主要应用于日常的局域网络，连接计算机和网络打印机的终端设备 2.从传输介质和传输速度上可以分为以太网交换机、快速以太网交换机、千兆以太网交换机、FDDI交换机、ATM交换机和令牌交换机等 3.从规模应用上可以分为企业级、部门级和工作组交换机 [10]交换机的功能1.交换机功能学习功能，局域网内交换机会了解跟每一个插口相连接的MAC地址，并将地址同相应的端口映射起来存放在交换机缓存中的MAC地址表中 2.转发/过滤功能当一个数据帧的目的地址在MAC地址表中有映射时，它被转发到连接目的节点的端口而不是所有端口（如该数据帧为广播/组播帧则转发至所有端口） 3.消除回路功能当交换机包括一个冗余回路时，以太网交换机通过生成树协议避免回路的产生，同时允许存在后背路径 4.兼容功能交换机除了能连接两种同类型的网络之外，还可以在不同类型的网路（如以太网和快速以太网）之间起到互联作用。而且现在的交换机没有很严格的类型之分，百兆交换机一般也会加两个千兆口或光纤接入口 [11]交换机的接口种1.双绞线RJ-45接口-水晶头 2.光纤接口光纤需要熔接到带插头的尾纤，常见的尾纤插头有SC。 [12]路由器的工作原理路由器，大家都很熟悉了，办公室或者家里凡有两台以上的电脑需要上网的一般都安装了路由器，只有安装了路由器才能实现多台电脑同时上网。我们就了解下路由器的配置原理。 1.路由器的概念1.所谓“路由”，就是把数据从一个地方传送到另一个地方的行为和动作，路由器就是执行这个动作的机器，英文名Router 2.路由器能将不同网络或网段之间的数据信息进行“翻译”，以使他们能够相互“读”懂对方的数据，从而构建更大的网络。 2.路由器的典型功能 数据通道功能 包括转发决定、背板转发以及输出链路调度等，一般由特定的硬件来完成 控制功能 一般用软件来实现，包括与相邻路由器之间的信息交换、系统配置、系统管理等 3.路由器的主要功能 网络互连 路由器支持各种局域网和广域网接口，主要用于互连局域网和广域网，实现不同网络互相通信 数据处理 提供包括分组过滤、分组转发、优先级、复用、加密、压缩和防火墙等功能 网络管理 路由器提供包括配置管理、性能管理、容错管理和流量控制管理等功能 4.路由器的工作原理 接收来自它连接的某个网络的数据 将数据向上传递，并且（必要时）重新组合IP数据报 检查IP头部中的目的地址，如果目的地址位于发出数据的那个网络，那么路由器就放下被认为已经达到目的地的数据，因为数据是在目的计算机所在网络上传输 如果数据要送往另一个网络，那么路由器就查询路由表，以确定数据要转发到的目的地 路由器确定哪个适配器负责接收数据后，就通过相应的软件传递数据，以便通过网络来传送数据 [13]初识TCP/IP的分层大家可能经常使用TCP/IP协议，在进行网络配置或修改IP地址等操作的时候会用到该处，但很少有人去深入挖掘，在此我们简单的了解一下TCP/IP的分层。 1.TCP/IP协议 Internet采用了TCP/IP协议，但这并不是一个单一的协议，我们可能知道，TCP即传输控制协议，IP为网间协议，TCP/IP我们常常描述为互联网协议集。但可能很少人知道TCP/IP也是一种分层模型。它是基于硬件层次上的四个概念性层次构成，分别是网络接口层（数据链路层）、IP层（网络层）、传输层、应用层。 网络接口层:也称数据链路层，这是TCP/IP最底层。功能:负责接收IP数据报并发送至选定的网络。 IP层:IP层处理机器之间的通信。功能:它接收来自传输层的请求，将带有目的地址的分组发送出去。将分组封装到数据报中，填入数据报头，使用路由算法以决定是直接将数据报传送至目的主机还是传给路由器，然后把数据报送至相应的网络接口来传送。 传输层:是提供应用层之间的通信，即端到端的通信。功能:管理信息流，提供可靠的传输服务，以确保数据无差错的地按序到达。 2.TCP/IP模型的分界线协议地址分界线:以区分高层和低层的寻址，高层寻址使用IP地址，低层寻址使用物理地址。应用程序IP层之上的协议软件只使用IP地址，而网络接口层处理物理地址。 操作系统分界线:以区分系统与应用程序。在传输层和应用层之间。 3.复用与分解 发送报文时，发送方在报文中加和了报文类型、选用协议等附加信息。所有的报文以帧的形式在网络中复用传送，形成一个分组流。在接收方收到分组时，参考附加信息对接收到的分组进行分解。 参考网址：https://jingyan.baidu.com/season/38734 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/26/Network/]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Threejs中的各种光源（Threejs第三章）]]></title>
    <url>%2F2017%2F09%2F22%2FThreejs3%2F</url>
    <content type="text"><![CDATA[本章你将了解1、怎么使用光源2、以及各种光源的区别，这些区别会通过实例对比来给大家讲清楚。这种对比方式应该是讲解最好的思路。 2.6 环境光和方向光接下来，我们来看看多种光源同时存在于场景之中，对物体颜色的影响。 当环境光和方向光同时存在的时候，会出现怎么样的情况呢？可以把这种情况想成两种光源同时作用于物体，它产生的情况，和每种光源分别作用于物体，然后将两者的结果相加，是一样的效果。例如：0x00FF00 + 0xFF0000 = 0xFFFF00，oxFFFF00 就是黄色。 2.7 点光源点光源是理想化为质点的向四面八方发出光线的光源。点光源是抽象化了的物理概念，为了把物理问题的研究简单化。就像平时说的光滑平面，质点，无空气阻力一样，点光源在现实中也是不存在的，指的是从一个点向周围空间均匀发光的光源。 点光源的特点是发光部分为一个小圆面，近似一个点 下面的例子介绍了怎么使用点光源： light = new THREE.PointLight(0xFF0000); light.position.set(0, 0,50); scene.add(light); 效果如下图： 2.8 混合光源将方向光和点光源混合使用。 效果如图所示： 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/22/Threejs3/]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
        <tag>3D</tag>
        <tag>threejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Threejs中的各种光源（Threejs第三章）]]></title>
    <url>%2F2017%2F09%2F22%2FThreejs3(1)%2F</url>
    <content type="text"><![CDATA[本章你将了解1、怎么使用光源2、以及各种光源的区别，这些区别会通过实例对比来给大家讲清楚。这种对比方式应该是讲解最好的思路。 2.6 环境光和方向光接下来，我们来看看多种光源同时存在于场景之中，对物体颜色的影响。 当环境光和方向光同时存在的时候，会出现怎么样的情况呢？可以把这种情况想成两种光源同时作用于物体，它产生的情况，和每种光源分别作用于物体，然后将两者的结果相加，是一样的效果。例如：0x00FF00 + 0xFF0000 = 0xFFFF00，oxFFFF00 就是黄色。 2.7 点光源点光源是理想化为质点的向四面八方发出光线的光源。点光源是抽象化了的物理概念，为了把物理问题的研究简单化。就像平时说的光滑平面，质点，无空气阻力一样，点光源在现实中也是不存在的，指的是从一个点向周围空间均匀发光的光源。 点光源的特点是发光部分为一个小圆面，近似一个点 下面的例子介绍了怎么使用点光源： light = new THREE.PointLight(0xFF0000); light.position.set(0, 0,50); scene.add(light); 效果如下图： 2.8 混合光源将方向光和点光源混合使用。 效果如图所示： 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/22/Threejs3(1)/]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
        <tag>3D</tag>
        <tag>threejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Threejs中的各种光源（Threejs第二章）]]></title>
    <url>%2F2017%2F09%2F22%2FThreejs2%2F</url>
    <content type="text"><![CDATA[作为3D技术的发展趋势，浏览器端3D技术越来越被一些技术公司重视。由此，Threejs非常注重3D渲染效果的真实性，对渲染真实性来说，使用光源是比不可少的技巧。Threejs，在光源方面提供了多种光源供选择。 第二章1.Threejs中的各种光源1.1光源基类在Threejs中，光源用Light表示，它是所有光源的基类。它的构造函数是：THREE.Light ( hex ) 它有一个参数hex，接受一个16进制的颜色值。例如要定义一种红色的光源，我们可以这样来定义： Var redLight = new THREE.Light(0xFF0000); 1.2由基类派生出来的其他种类光源THREE.Light只是其他所有光源的基类，要让光源除了具有颜色的特性之外，我们需要其他光源。看看，下面的类图，是目前光源的继承结构。 环境光是经过多次反射而来的光称为环境光，无法确定其最初的方向。环境光是一种无处不在的光。环境光源放出的光线被认为来自任何方向。因此，当你仅为场景指定环境光时，所有的物体无论法向量如何，都将表现为同样的明暗程度。 （这是因为，反射光可以从各个方向进入您的眼睛） 1.2.1 环境光用THREE.AmbientLight来表示，它的构造函数如下所示： THREE.AmbientLight( hex ) 它仍然接受一个16进制的颜色值，作为光源的颜色。环境光将照射场景中的所有物体，让物体显示出某种颜色。环境光的使用例子如下所示： var light = new THREE.AmbientLight( 0xff0000 ); scene.add( light ); 只需要将光源加入场景，场景就能够通过光源渲染出好的效果来了。 1.2.2点光源由这种光源放出的光线来自同一点，且方向辐射自四面八方。例如蜡烛放出的光，萤火虫放出的光。 点光源用PointLight来表示，它的构造函数如下所示： PointLight( color, intensity, distance ) 这个类的参数稍微复杂一些，我们花点时间来解释一下： Color：光的颜色 Intensity：光的强度，默认是1.0,就是说是100%强度的灯光， distance：光的距离，从光源所在的位置，经过distance这段距离之后，光的强度将从Intensity衰减为0。 默认情况下，这个值为0.0，表示光源强度不衰减。 #####1.2.3聚光灯这种光源的光线从一个锥体中射出，在被照射的物体上产生聚光的效果。使用这种光源需要指定光的射出方向以及锥体的顶角α。聚光灯示例如图所示： 聚光灯的构造函数是：THREE.SpotLight( hex, intensity, distance, angle, exponent ) 函数的参数如下所示： Hex：聚光灯发出的颜色，如0xFFFFFF Intensity：光源的强度，默认是1.0，如果为0.5，则强度是一半，意思是颜色会淡一些。和上面点光源一样。 Distance：光线的强度，从最大值衰减到0，需要的距离。 默认为0，表示光不衰减，如果非0，则表示从光源的位置到Distance的距离，光都在线性衰减。到离光源距离Distance时，光源强度为0. Angle：聚光灯着色的角度，用弧度作为单位，这个角度是和光源的方向形成的角度。 exponent：光源模型中，衰减的一个参数，越大衰减约快。 2.材质与光源的关系材质与光源有什么关系？什么是材质？ 2.1 材质的真相 材质就是物体的质地。材质就是材料和质感的完美结合。 在渲染程序中，它是表面各可视属性的结合，这些可视属性是指表面的色彩、纹理、光滑度、透明度、反射率、折射率、发光度等。正是有了这些属性，才能让我们识别三维中的模型是什么做成的，也正是有了这些属性，我们计算机三维的虚拟世界才会和真实世界一样缤纷多彩。 这就是材质的真相吗？答案是否定的。不要奇怪，我们必须仔细分析产生不同材质的原因，才能让我们更好的把握质感。那么，材质的真相到底是什么呢？仍然是光，离开光材质是无法体现的。 首先，我们来看一些例子。这些例子是一系类的，掌握一个，我们就印下了一个脚印. 2.2 脚印一：不带任何光源的物体我们首先在屏幕上画一个物体，不带任何的光源，定义物体的颜色为黑色，其值为0x000000，定义材质如下： var material = new THREE.MeshLambertMaterial( { color:0x000000} ); // 这是兰伯特材质，材质中的一种 先看看最终的运行截图，如下所示： 由这幅图得出结论，当没有任何光源的时候，最终的颜色将是材质的颜色。但是这个结论目前来说，并没有依据。结论：当没有任何光源的时候，最终的颜色将是黑色，无论材质是什么颜色。 2.3 脚印二：兰伯特材质与光源最常见的材质之一就是Lambert材质，这是在灰暗的或不光滑的表面产生均匀散射而形成的材质类型。比如一张纸就是Lambert表面。 首先它粗糙不均匀，不会产生镜面效果。我们在阅读书籍的时候，没有发现书上一处亮，一处不亮吧，它非常均匀，这就是兰伯特材质。 有的朋友觉得纸不粗糙啊，你怎么说它粗糙吗？人的肉眼是不好分辨出来，它粗不粗糙的。 Lambert材质表面会在所有方向上均匀地散射灯光，这就会使颜色看上去比较均匀。想想一张纸，无论什么颜色，是不是纸的各个部分颜色都比较均匀呢。 Lambert材质的图例如下所示：Lambert材质会受环境光的影响，呈现环境光的颜色，与材质本身颜色关系不大。 我们现在来做一个例子 例子：红色环境光照射下的长方体，它用的是淡红色(0x880000)的兰伯特材质。效果如下图： 最后整个效果中，长方体呈现的是红色。我们要说的是，长方体显示红色，是因为长方体反射了红色的光，长方体本身的颜色是0x880000，光源的颜色是0xFF0000，红色的光照在物体上，物体反射了红色的光，所以呈现红色。我们现在一直在使用环境光，从环境光的构造函数来看，它只有颜色，其位置对场景中的物体并没有影响，因为他是均匀的反射到物体的表面的。 2.4 脚印三：环境光对物体的影响环境光就是在场景中无处不在的光，它对物体的影响是均匀的，也就是无论你从物体的那个角度观察，物体的颜色都是一样的，这就是伟大的环境光。 你可以把环境光放在任何一个位置，它的光线是不会衰减的，是永恒的某个强度的一种光源。 2.5脚印四：方向光（平行光）平行光又称为方向光（Directional Light），是一组没有衰减的平行的光线，类似太阳光的效果。 方向光的模型如图：方向光的构造函数如下所示： THREE.DirectionalLight = function ( hex, intensity ) 其参数如下： Hex：关系的颜色，用16进制表示 Intensity：光线的强度，默认为1。因为RGB的三个值均在0~255之间，不能反映出光照的强度变化，光照越强，物体表面就更明亮。它的取值范围是0到1。如果为0，表示光线基本没什么作用，那么物体就会显示为黑色。呆会你可以尝试来更改这个参数，看看实际的效果 我们来看一个方向光的例子： 一个红色的方向光，把它放在（0,0,1）的位置，密度为1，照射在一个长方体中。效果如下图所示： 平行光有一个方向，它的方向是如何决定的呢？方向由位置和原点（0,0,0）来决定，方向光只与方向有关，与离物体的远近无关。分别将平行光放到（0,0,100），（0,0,50），（0,0,25），（0,0,1），渲染的结果还是红色和黑色，见下图，颜色的深浅不与离物体的距离相关。 但是它与方向有关，如果，我们灯光的位置改为（1,0,0.5），那么效果如图所示： 未完待续 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/22/Threejs2/]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
        <tag>3D</tag>
        <tag>threejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Threejs中的各种光源（Threejs第二章）]]></title>
    <url>%2F2017%2F09%2F22%2FThreejs2(1)%2F</url>
    <content type="text"><![CDATA[作为3D技术的发展趋势，浏览器端3D技术越来越被一些技术公司重视。由此，Threejs非常注重3D渲染效果的真实性，对渲染真实性来说，使用光源是比不可少的技巧。Threejs，在光源方面提供了多种光源供选择。 第二章1.Threejs中的各种光源1.1光源基类在Threejs中，光源用Light表示，它是所有光源的基类。它的构造函数是：THREE.Light ( hex ) 它有一个参数hex，接受一个16进制的颜色值。例如要定义一种红色的光源，我们可以这样来定义： Var redLight = new THREE.Light(0xFF0000); 1.2由基类派生出来的其他种类光源THREE.Light只是其他所有光源的基类，要让光源除了具有颜色的特性之外，我们需要其他光源。看看，下面的类图，是目前光源的继承结构。 环境光是经过多次反射而来的光称为环境光，无法确定其最初的方向。环境光是一种无处不在的光。环境光源放出的光线被认为来自任何方向。因此，当你仅为场景指定环境光时，所有的物体无论法向量如何，都将表现为同样的明暗程度。 （这是因为，反射光可以从各个方向进入您的眼睛） 1.2.1 环境光用THREE.AmbientLight来表示，它的构造函数如下所示： THREE.AmbientLight( hex ) 它仍然接受一个16进制的颜色值，作为光源的颜色。环境光将照射场景中的所有物体，让物体显示出某种颜色。环境光的使用例子如下所示： var light = new THREE.AmbientLight( 0xff0000 ); scene.add( light ); 只需要将光源加入场景，场景就能够通过光源渲染出好的效果来了。 1.2.2点光源由这种光源放出的光线来自同一点，且方向辐射自四面八方。例如蜡烛放出的光，萤火虫放出的光。 点光源用PointLight来表示，它的构造函数如下所示： PointLight( color, intensity, distance ) 这个类的参数稍微复杂一些，我们花点时间来解释一下： Color：光的颜色 Intensity：光的强度，默认是1.0,就是说是100%强度的灯光， distance：光的距离，从光源所在的位置，经过distance这段距离之后，光的强度将从Intensity衰减为0。 默认情况下，这个值为0.0，表示光源强度不衰减。 #####1.2.3聚光灯这种光源的光线从一个锥体中射出，在被照射的物体上产生聚光的效果。使用这种光源需要指定光的射出方向以及锥体的顶角α。聚光灯示例如图所示： 聚光灯的构造函数是：THREE.SpotLight( hex, intensity, distance, angle, exponent ) 函数的参数如下所示： Hex：聚光灯发出的颜色，如0xFFFFFF Intensity：光源的强度，默认是1.0，如果为0.5，则强度是一半，意思是颜色会淡一些。和上面点光源一样。 Distance：光线的强度，从最大值衰减到0，需要的距离。 默认为0，表示光不衰减，如果非0，则表示从光源的位置到Distance的距离，光都在线性衰减。到离光源距离Distance时，光源强度为0. Angle：聚光灯着色的角度，用弧度作为单位，这个角度是和光源的方向形成的角度。 exponent：光源模型中，衰减的一个参数，越大衰减约快。 2.材质与光源的关系材质与光源有什么关系？什么是材质？ 2.1 材质的真相 材质就是物体的质地。材质就是材料和质感的完美结合。 在渲染程序中，它是表面各可视属性的结合，这些可视属性是指表面的色彩、纹理、光滑度、透明度、反射率、折射率、发光度等。正是有了这些属性，才能让我们识别三维中的模型是什么做成的，也正是有了这些属性，我们计算机三维的虚拟世界才会和真实世界一样缤纷多彩。 这就是材质的真相吗？答案是否定的。不要奇怪，我们必须仔细分析产生不同材质的原因，才能让我们更好的把握质感。那么，材质的真相到底是什么呢？仍然是光，离开光材质是无法体现的。 首先，我们来看一些例子。这些例子是一系类的，掌握一个，我们就印下了一个脚印. 2.2 脚印一：不带任何光源的物体我们首先在屏幕上画一个物体，不带任何的光源，定义物体的颜色为黑色，其值为0x000000，定义材质如下： var material = new THREE.MeshLambertMaterial( { color:0x000000} ); // 这是兰伯特材质，材质中的一种 先看看最终的运行截图，如下所示： 由这幅图得出结论，当没有任何光源的时候，最终的颜色将是材质的颜色。但是这个结论目前来说，并没有依据。结论：当没有任何光源的时候，最终的颜色将是黑色，无论材质是什么颜色。 2.3 脚印二：兰伯特材质与光源最常见的材质之一就是Lambert材质，这是在灰暗的或不光滑的表面产生均匀散射而形成的材质类型。比如一张纸就是Lambert表面。 首先它粗糙不均匀，不会产生镜面效果。我们在阅读书籍的时候，没有发现书上一处亮，一处不亮吧，它非常均匀，这就是兰伯特材质。 有的朋友觉得纸不粗糙啊，你怎么说它粗糙吗？人的肉眼是不好分辨出来，它粗不粗糙的。 Lambert材质表面会在所有方向上均匀地散射灯光，这就会使颜色看上去比较均匀。想想一张纸，无论什么颜色，是不是纸的各个部分颜色都比较均匀呢。 Lambert材质的图例如下所示：Lambert材质会受环境光的影响，呈现环境光的颜色，与材质本身颜色关系不大。 我们现在来做一个例子 例子：红色环境光照射下的长方体，它用的是淡红色(0x880000)的兰伯特材质。效果如下图： 最后整个效果中，长方体呈现的是红色。我们要说的是，长方体显示红色，是因为长方体反射了红色的光，长方体本身的颜色是0x880000，光源的颜色是0xFF0000，红色的光照在物体上，物体反射了红色的光，所以呈现红色。我们现在一直在使用环境光，从环境光的构造函数来看，它只有颜色，其位置对场景中的物体并没有影响，因为他是均匀的反射到物体的表面的。 2.4 脚印三：环境光对物体的影响环境光就是在场景中无处不在的光，它对物体的影响是均匀的，也就是无论你从物体的那个角度观察，物体的颜色都是一样的，这就是伟大的环境光。 你可以把环境光放在任何一个位置，它的光线是不会衰减的，是永恒的某个强度的一种光源。 2.5脚印四：方向光（平行光）平行光又称为方向光（Directional Light），是一组没有衰减的平行的光线，类似太阳光的效果。 方向光的模型如图：方向光的构造函数如下所示： THREE.DirectionalLight = function ( hex, intensity ) 其参数如下： Hex：关系的颜色，用16进制表示 Intensity：光线的强度，默认为1。因为RGB的三个值均在0~255之间，不能反映出光照的强度变化，光照越强，物体表面就更明亮。它的取值范围是0到1。如果为0，表示光线基本没什么作用，那么物体就会显示为黑色。呆会你可以尝试来更改这个参数，看看实际的效果 我们来看一个方向光的例子： 一个红色的方向光，把它放在（0,0,1）的位置，密度为1，照射在一个长方体中。效果如下图所示： 平行光有一个方向，它的方向是如何决定的呢？方向由位置和原点（0,0,0）来决定，方向光只与方向有关，与离物体的远近无关。分别将平行光放到（0,0,100），（0,0,50），（0,0,25），（0,0,1），渲染的结果还是红色和黑色，见下图，颜色的深浅不与离物体的距离相关。 但是它与方向有关，如果，我们灯光的位置改为（1,0,0.5），那么效果如图所示： 未完待续 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/22/Threejs2(1)/]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
        <tag>3D</tag>
        <tag>threejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue进阶之路——深入响应式原理]]></title>
    <url>%2F2017%2F09%2F21%2FVue%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86(1)%2F</url>
    <content type="text"><![CDATA[Vue 最显著的特性之一便是不太引人注意的响应式系统 Vue 最显著的特性之一便是不太引人注意的响应式系统(reactivity system)。模型层(model)只是普通 JavaScript 对象，修改它则更新视图(view)。 如何追踪变化把一个普通 JavaScript 对象传给 Vue 实例的 data选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为getter/setter。 每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。 变化检测问题受现代 JavaScript 的限制,Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。例如：12345678var vm = new Vue(&#123; data:&#123; a:1 &#125;&#125;)// `vm.a` 是响应的vm.b = 2// `vm.b` 是非响应的 Vue 不允许在已经创建的实例上动态添加新的根级响应式属性(root-level reactive property)。然而它可以使用 Vue.set(object, key, value)方法将响应属性添加到嵌套的对象上： 1Vue.set(vm.someObject, &apos;b&apos;, 2) 您还可以使用vm.$set实例方法，这也是全局 Vue.set 方法的别名： 有时你想向已有对象上添加一些属性，例如使用 Object.assign()或 _.extend() 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：12// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;) 声明响应式属性由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值: 123456789var vm = new Vue(&#123; data: &#123; // 声明 message 为一个空值字符串 message: &apos;&apos; &#125;, template: &apos;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&apos;&#125;)// 之后设置 `message` vm.message = &apos;Hello!&apos; 如果你在 data 选项中未声明 message，Vue 将警告你渲染函数在试图访问的属性不存在。 data对象就像组件状态的概要，提前声明所有的响应式属性，可以让组件代码在以后重新阅读或其他开发人员阅读时更易于被理解。 异步更新队列可能你还没有注意到，Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会一次推入到队列中。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际（已去重的）工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和MutationObserver，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。 例如，当你设置 vm.someData = &#39;new value&#39;，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数在 DOM 更新完成后就会调用。例如：1&lt;div id=&quot;example&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; 1234567891011var vm = new Vue(&#123; el: &apos;#example&apos;, data: &#123; message: &apos;123&apos; &#125;&#125;)vm.message = &apos;new message&apos; // 更改数据vm.$el.textContent === &apos;new message&apos; // falseVue.nextTick(function () &#123; vm.$el.textContent === &apos;new message&apos; // true&#125;) 在组件内使用 vm.$nextTick() 实例方法特别方便，因为它不需要全局Vue，并且回调函数中的 this 将自动绑定到当前的 Vue 实例上：1234567891011121314151617Vue.component(&apos;example&apos;, &#123; template: &apos;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&apos;, data: function () &#123; return &#123; message: &apos;没有更新&apos; &#125; &#125;, methods: &#123; updateMessage: function () &#123; this.message = &apos;更新完成&apos; console.log(this.$el.textContent) // =&gt; &apos;没有更新&apos; this.$nextTick(function () &#123; console.log(this.$el.textContent) // =&gt; &apos;更新完成&apos; &#125;) &#125; &#125;&#125;) (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/21/Vue进阶之路——深入响应式原理(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
        <tag>Vue</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue进阶之路——过渡效果]]></title>
    <url>%2F2017%2F09%2F21%2FVue%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C(1)%2F</url>
    <content type="text"><![CDATA[Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。 概述Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。包括以下工具： 在 CSS 过渡和动画中自动应用 class 可以配合使用第三方 CSS 动画库，如 Animate.css 在过渡钩子函数中使用 JavaScript 直接操作 DOM 可以配合使用第三方 JavaScript 动画库，如 Velocity.js 单元素/组件的过渡Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡 条件渲染 （使用 v-if） 条件展示 （使用 v-show） 动态组件 组件根节点这里是一个典型的例子：HTMl:12345678&lt;div id=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;show = !show&quot;&gt; Toggle &lt;/button&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; JS:123456new Vue(&#123; el: &apos;#demo&apos;, data: &#123; show: true &#125;&#125;) CSS:123456.fade-enter-active, .fade-leave-active &#123; transition: opacity .5s&#125;.fade-enter, .fade-leave-to /* .fade-leave-active in &lt;2.1.8 */ &#123; opacity: 0&#125; 当插入或删除包含在 transition 组件中的元素时，Vue 将会做以下处理： 自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。 如果过渡组件提供了JavaScript 钩子函数，这些钩子函数将在恰当的时机被调用。 如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，和Vue的 nextTick概念不同) 过渡的-CSS-类名 会有 6 个(CSS)类名在 enter/leave 的过渡中切换: v-enter v-enter-active v-enter-to v-leave v-leave-active v-leave-to 对于这些在 enter/leave 过渡中切换的类名，v- 是这些类名的前缀。使用 &lt;transition name=&quot;my-transition&quot;&gt; 可以重置前缀，比如 v-enter替换为 my-transition-enter。 CSS 过渡CSS 动画用法同 CSS 过渡，区别是在动画中 v-enter类名在节点插入 DOM 后不会立即删除，而是在animationend 事件触发时删除。 示例： (省略了兼容性前缀)123456&lt;div id=&quot;example-2&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle show&lt;/button&gt; &lt;transition name=&quot;bounce&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;Look at me!&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: &apos;#example-2&apos;, data: &#123; show: true &#125;&#125;) 12345678910111213141516171819202122232425262728.bounce-enter-active &#123; animation: bounce-in .5s;&#125;.bounce-leave-active &#123; animation: bounce-out .5s;&#125;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125;@keyframes bounce-out &#123; 0% &#123; transform: scale(1); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(0); &#125;&#125; 自定义过渡类名我们可以通过以下特性来自定义过渡类名： enter-class enter-active-class leave-class leave-active-class 他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用。示例：12345678910111213&lt;link href=&quot;https://unpkg.com/animate.css@3.5.1/animate.min.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;&lt;div id=&quot;example-3&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt; Toggle render &lt;/button&gt; &lt;transition name=&quot;custom-classes-transition&quot; enter-active-class=&quot;animated tada&quot; leave-active-class=&quot;animated bounceOutRight&quot; &gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 同时使用 Transitions 和 AnimationsVue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 transitionend或 animationend ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。 JavaScript 钩子123456789101112&lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:after-enter=&quot;afterEnter&quot; v-on:enter-cancelled=&quot;enterCancelled&quot; v-on:before-leave=&quot;beforeLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 12345678910111213141516171819202122232425262728293031323334353637383940// ...methods: &#123; // -------- // 进入中 // -------- beforeEnter: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // 离开时 // -------- beforeLeave: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) &#123; // ... &#125;&#125; 这些钩子函数可以结合 CSS transitions/animations使用，也可以单独使用。 当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。 否则，它们会被同步调用，过渡会立即完成。 推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。 初始渲染的过渡可以通过appear 特性设置节点的在初始渲染的过渡123&lt;transition appear&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 这里默认和进入和离开过渡一样，同样也可以自定义 CSS 类名。 1234567&lt;transition appear appear-class=&quot;custom-appear-class&quot; appear-active-class=&quot;custom-appear-active-class&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 自定义 JavaScript 钩子：12345678&lt;transition appear v-on:before-appear=&quot;customBeforeAppearHook&quot; v-on:appear=&quot;customAppearHook&quot; v-on:after-appear=&quot;customAfterAppearHook&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 多个元素的过渡 对于原生标签可以使用 v-if/v-else 。最常见的多标签过渡是一个列表和描述这个列表为空消息的元素：123456&lt;transition&gt; &lt;table v-if=&quot;items.length &gt; 0&quot;&gt;&lt;!-- ... --&gt; &lt;/table&gt; &lt;p v-else&gt;Sorry, no items found.&lt;/p&gt;&lt;/transition&gt; 当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，给在 &lt;transition组件中的多个元素设置 key 是一个更好的实践。12345678&lt;transition&gt; &lt;button v-if=&quot;isEditing&quot; key=&quot;save&quot;&gt; Save &lt;/button&gt; &lt;button v-else key=&quot;edit&quot;&gt; Edit &lt;/button&gt;&lt;/transition&gt; 过渡模式 in-out: 新元素先进行过渡，完成之后当前元素过渡离开。 out-in: 当前元素先进行过渡，完成之后新元素过渡进入。 多个组件的过渡多个组件的过渡简单很多 - 我们不需要使用 key 特性。相反，我们只需要使用动态组件: 列表过渡怎么同时渲染整个列表，比如使用v-for？在这种场景中，使用 &lt;transition-group&gt;组件。在我们深入例子之前，先了解关于这个组件的几个特点： 不同于 &lt;transition&gt;， 它会以一个真实元素呈现：默认为一个 &lt;span&gt;。你也可以通过 tag 特性更换为其他元素。 内部元素 总是需要 提供唯一的 key 属性值 列表的位移过渡&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move特性，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过 name 属性来自定义前缀，也可以通过 move-class 属性手动设置。v-move 对于设置过渡的切换时机和过渡曲线非常有用，你会看到如下的例子： (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/21/Vue进阶之路——过渡效果(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
        <tag>Vue</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue进阶之路——过渡效果]]></title>
    <url>%2F2017%2F09%2F21%2FVue%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。 概述Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。包括以下工具： 在 CSS 过渡和动画中自动应用 class 可以配合使用第三方 CSS 动画库，如 Animate.css 在过渡钩子函数中使用 JavaScript 直接操作 DOM 可以配合使用第三方 JavaScript 动画库，如 Velocity.js 单元素/组件的过渡Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡 条件渲染 （使用 v-if） 条件展示 （使用 v-show） 动态组件 组件根节点这里是一个典型的例子：HTMl:12345678&lt;div id=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;show = !show&quot;&gt; Toggle &lt;/button&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; JS:123456new Vue(&#123; el: &apos;#demo&apos;, data: &#123; show: true &#125;&#125;) CSS:123456.fade-enter-active, .fade-leave-active &#123; transition: opacity .5s&#125;.fade-enter, .fade-leave-to /* .fade-leave-active in &lt;2.1.8 */ &#123; opacity: 0&#125; 当插入或删除包含在 transition 组件中的元素时，Vue 将会做以下处理： 自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。 如果过渡组件提供了JavaScript 钩子函数，这些钩子函数将在恰当的时机被调用。 如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，和Vue的 nextTick概念不同) 过渡的-CSS-类名 会有 6 个(CSS)类名在 enter/leave 的过渡中切换: v-enter v-enter-active v-enter-to v-leave v-leave-active v-leave-to 对于这些在 enter/leave 过渡中切换的类名，v- 是这些类名的前缀。使用 &lt;transition name=&quot;my-transition&quot;&gt; 可以重置前缀，比如 v-enter替换为 my-transition-enter。 CSS 过渡CSS 动画用法同 CSS 过渡，区别是在动画中 v-enter类名在节点插入 DOM 后不会立即删除，而是在animationend 事件触发时删除。 示例： (省略了兼容性前缀)123456&lt;div id=&quot;example-2&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle show&lt;/button&gt; &lt;transition name=&quot;bounce&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;Look at me!&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: &apos;#example-2&apos;, data: &#123; show: true &#125;&#125;) 12345678910111213141516171819202122232425262728.bounce-enter-active &#123; animation: bounce-in .5s;&#125;.bounce-leave-active &#123; animation: bounce-out .5s;&#125;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125;@keyframes bounce-out &#123; 0% &#123; transform: scale(1); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(0); &#125;&#125; 自定义过渡类名我们可以通过以下特性来自定义过渡类名： enter-class enter-active-class leave-class leave-active-class 他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用。示例：12345678910111213&lt;link href=&quot;https://unpkg.com/animate.css@3.5.1/animate.min.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;&lt;div id=&quot;example-3&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt; Toggle render &lt;/button&gt; &lt;transition name=&quot;custom-classes-transition&quot; enter-active-class=&quot;animated tada&quot; leave-active-class=&quot;animated bounceOutRight&quot; &gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 同时使用 Transitions 和 AnimationsVue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 transitionend或 animationend ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。 JavaScript 钩子123456789101112&lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:after-enter=&quot;afterEnter&quot; v-on:enter-cancelled=&quot;enterCancelled&quot; v-on:before-leave=&quot;beforeLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 12345678910111213141516171819202122232425262728293031323334353637383940// ...methods: &#123; // -------- // 进入中 // -------- beforeEnter: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // 离开时 // -------- beforeLeave: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) &#123; // ... &#125;&#125; 这些钩子函数可以结合 CSS transitions/animations使用，也可以单独使用。 当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。 否则，它们会被同步调用，过渡会立即完成。 推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。 初始渲染的过渡可以通过appear 特性设置节点的在初始渲染的过渡123&lt;transition appear&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 这里默认和进入和离开过渡一样，同样也可以自定义 CSS 类名。 1234567&lt;transition appear appear-class=&quot;custom-appear-class&quot; appear-active-class=&quot;custom-appear-active-class&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 自定义 JavaScript 钩子：12345678&lt;transition appear v-on:before-appear=&quot;customBeforeAppearHook&quot; v-on:appear=&quot;customAppearHook&quot; v-on:after-appear=&quot;customAfterAppearHook&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 多个元素的过渡 对于原生标签可以使用 v-if/v-else 。最常见的多标签过渡是一个列表和描述这个列表为空消息的元素：123456&lt;transition&gt; &lt;table v-if=&quot;items.length &gt; 0&quot;&gt;&lt;!-- ... --&gt; &lt;/table&gt; &lt;p v-else&gt;Sorry, no items found.&lt;/p&gt;&lt;/transition&gt; 当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，给在 &lt;transition组件中的多个元素设置 key 是一个更好的实践。12345678&lt;transition&gt; &lt;button v-if=&quot;isEditing&quot; key=&quot;save&quot;&gt; Save &lt;/button&gt; &lt;button v-else key=&quot;edit&quot;&gt; Edit &lt;/button&gt;&lt;/transition&gt; 过渡模式 in-out: 新元素先进行过渡，完成之后当前元素过渡离开。 out-in: 当前元素先进行过渡，完成之后新元素过渡进入。 多个组件的过渡多个组件的过渡简单很多 - 我们不需要使用 key 特性。相反，我们只需要使用动态组件: 列表过渡怎么同时渲染整个列表，比如使用v-for？在这种场景中，使用 &lt;transition-group&gt;组件。在我们深入例子之前，先了解关于这个组件的几个特点： 不同于 &lt;transition&gt;， 它会以一个真实元素呈现：默认为一个 &lt;span&gt;。你也可以通过 tag 特性更换为其他元素。 内部元素 总是需要 提供唯一的 key 属性值 列表的位移过渡&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move特性，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过 name 属性来自定义前缀，也可以通过 move-class 属性手动设置。v-move 对于设置过渡的切换时机和过渡曲线非常有用，你会看到如下的例子： (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/21/Vue进阶之路——过渡效果/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
        <tag>Vue</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue进阶之路——深入响应式原理]]></title>
    <url>%2F2017%2F09%2F21%2FVue%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Vue 最显著的特性之一便是不太引人注意的响应式系统 Vue 最显著的特性之一便是不太引人注意的响应式系统(reactivity system)。模型层(model)只是普通 JavaScript 对象，修改它则更新视图(view)。 如何追踪变化把一个普通 JavaScript 对象传给 Vue 实例的 data选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为getter/setter。 每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。 变化检测问题受现代 JavaScript 的限制,Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。例如：12345678var vm = new Vue(&#123; data:&#123; a:1 &#125;&#125;)// `vm.a` 是响应的vm.b = 2// `vm.b` 是非响应的 Vue 不允许在已经创建的实例上动态添加新的根级响应式属性(root-level reactive property)。然而它可以使用 Vue.set(object, key, value)方法将响应属性添加到嵌套的对象上： 1Vue.set(vm.someObject, &apos;b&apos;, 2) 您还可以使用vm.$set实例方法，这也是全局 Vue.set 方法的别名： 有时你想向已有对象上添加一些属性，例如使用 Object.assign()或 _.extend() 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：12// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;) 声明响应式属性由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值: 123456789var vm = new Vue(&#123; data: &#123; // 声明 message 为一个空值字符串 message: &apos;&apos; &#125;, template: &apos;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&apos;&#125;)// 之后设置 `message` vm.message = &apos;Hello!&apos; 如果你在 data 选项中未声明 message，Vue 将警告你渲染函数在试图访问的属性不存在。 data对象就像组件状态的概要，提前声明所有的响应式属性，可以让组件代码在以后重新阅读或其他开发人员阅读时更易于被理解。 异步更新队列可能你还没有注意到，Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会一次推入到队列中。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际（已去重的）工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和MutationObserver，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。 例如，当你设置 vm.someData = &#39;new value&#39;，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数在 DOM 更新完成后就会调用。例如：1&lt;div id=&quot;example&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; 1234567891011var vm = new Vue(&#123; el: &apos;#example&apos;, data: &#123; message: &apos;123&apos; &#125;&#125;)vm.message = &apos;new message&apos; // 更改数据vm.$el.textContent === &apos;new message&apos; // falseVue.nextTick(function () &#123; vm.$el.textContent === &apos;new message&apos; // true&#125;) 在组件内使用 vm.$nextTick() 实例方法特别方便，因为它不需要全局Vue，并且回调函数中的 this 将自动绑定到当前的 Vue 实例上：1234567891011121314151617Vue.component(&apos;example&apos;, &#123; template: &apos;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&apos;, data: function () &#123; return &#123; message: &apos;没有更新&apos; &#125; &#125;, methods: &#123; updateMessage: function () &#123; this.message = &apos;更新完成&apos; console.log(this.$el.textContent) // =&gt; &apos;没有更新&apos; this.$nextTick(function () &#123; console.log(this.$el.textContent) // =&gt; &apos;更新完成&apos; &#125;) &#125; &#125;&#125;) (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/21/Vue进阶之路——深入响应式原理/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
        <tag>Vue</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Threejs]]></title>
    <url>%2F2017%2F09%2F21%2FThreejs%2F</url>
    <content type="text"><![CDATA[一门3D技术语言。什么是threejs，很简单，你将它理解成three + js就可以了。three表示3D的意思，js表示javascript的意思。那么合起来，three.js就是使用javascript 来写3D程序的意思。Javascript是运行在网页端的脚本语言，那么毫无疑问Three.js也是运行在浏览器上的。 ##第一章来学习three.js之前最好了解一下WebGL。什么是WebGL? WebGL是在浏览器中实现三维效果的一套规范。 使用WebGL原生的API来写3D程序是一件非常痛苦的事情，幸好，有很多同行花业余时间写了一些WebGL开源框架，其中three.js就是非常优秀的一个，它掩 盖了很多麻烦的细节，那么，就让我们一起来看看，什么是three.js吧 1. 启程：实际上，我们要使用 Three.js 展示一些画面到浏览器上, 我们需要下面这三样东西:一个场景(scene)， 一个摄像头(camera) , 和一个渲染器(renderer)， 所以我们使用一个相机渲染一个场景. var scene = new THREE.Scene(); // 场景 var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);// 透视相机 var renderer = new THREE.WebGLRenderer(); // 渲染器 renderer.setSize(window.innerWidth, window.innerHeight); // 设置渲染器的大小为窗口的内宽度，也就是内容区的宽度 document.body.appendChild(renderer.domElement); 场景是所有物体的容器，如果要显示一个苹果，就需要将苹果对象加入场景中。 另一个组件是相机，相机决定了场景中那个角度的景色会显示出来。相机就像人的眼睛一样，人站在不同位置，抬头或者低头都能够看到不同的景色。 场景只有一种，但是相机却又很多种。和现实中一样，不同的相机确定了呈相的各个方面。比如有的相机适合人像，有的相机适合风景，专业的摄影师根据实际用途不一样，选择不同的相机。对程序员来说，只要设置不同的相机参数，就能够让相机产生不一样的效果。 2. 三维空间两种基本的相机 透视相机 正投影相机 2.1. 单反、双反都是相机2.1.1 认识相机在Threejs中相机的表示是THREE.Camera，它是相机的抽象基类，其子类有两种相机，分别是正投影相机THREE.OrthographicCamera和透视投影相机THREE.PerspectiveCamera。类图如下所示： 正投影相机有时候也叫正交投影摄像机，下图显示了正交摄像机投影和透视投影之间的差别。 2.1.2 两者的区别 正投影和透视投影的区别是：透视投影有一个基本点，就是远处的物体比近处的物体小。 在工程建筑领域，正投影的例子很多，例如下面就是一个正投影的例子：其特点是，远近高低比例都相同。 2.2 正投影相机下面我们来介绍正投影相机，正投影的构造函数如下所示： OrthographicCamera( left, right, top, bottom, near, far ) 结合下面一个图，我们来看看，各个参数的意思。 1、 left参数 left：左平面距离相机中心点的垂直距离。从图中可以看出，左平面是屏幕里面的那个平面。 2、 right参数 right：右平面距离相机中心点的垂直距离。从图中可以看出，右平面是屏幕稍微外面一点的那个平面。 3、 top参数 top：顶平面距离相机中心点的垂直距离。上图中的顶平面，是长方体头朝天的平面。 4、 bottom参数 bottom：底平面距离相机中心点的垂直距离。底平面是头朝地的平面。 5、near参数 near：近平面距离相机中心点的垂直距离。近平面是左边竖着的那个平面。 6、far参数 far：远平面距离相机中心点的垂直距离。远平面是右边竖着的那个平面。 有了这些参数和相机中心点，我们这里将相机的中心点又定义为相机的位置。通过这些参数，我们就能够在三维空间中唯一的确定上图的一个长方体。这个长方体也叫做视景体。 投影变换的目的就是定义一个视景体，使得视景体外多余的部分裁剪掉，最终图像只是视景体内的有关部分。 好了，看一个简单的例子： var camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 ); scene.add( camera ); 这个例子将浏览器窗口的宽度和高度作为了视景体的高度和宽度，相机正好在窗口的中心点上。这也是我们一般的设置方法，基本上为了方便，我们不会设置其他的值。 2.3 透视投影相机透视投影相机的构造函数如下所示： PerspectiveCamera( fov, aspect, near, far ) 我们来欣赏一幅图来看看这个函数的各个参数的意思： 先来明确这个图里涉及的概念。1、视角fov：这个最难理解,我的理解是,眼睛睁开的角度,即,视角的大小,如果设置为0,相当你闭上眼睛了,所以什么也看不到,如果为180,那么可以认为你的视界很广阔,但是在180度的时候，往往物体很小，因为他在你的整个可视区域中的比例变小了。 2、近平面near：这个呢，表示你近处的裁面的距离。补充一下，也可以认为是眼睛距离近处的距离，假设为10米远，请不要设置为负值，Three.js就傻了,不知道怎么算了, 3、远平面far：这个呢，表示你远处的裁面, 4、纵横比aspect：实际窗口的纵横比，即宽度除以高度。这个值越大，说明你宽度越大 好了，看看下面一个简单的例子： var camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 ); scene.add( camera ); 未完待续。。。 (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/21/Threejs/]]></content>
      <categories>
        <category>JS</category>
        <category>3D</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
        <tag>可视化</tag>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Threejs]]></title>
    <url>%2F2017%2F09%2F21%2FThreejs(1)%2F</url>
    <content type="text"><![CDATA[一门3D技术语言。什么是threejs，很简单，你将它理解成three + js就可以了。three表示3D的意思，js表示javascript的意思。那么合起来，three.js就是使用javascript 来写3D程序的意思。Javascript是运行在网页端的脚本语言，那么毫无疑问Three.js也是运行在浏览器上的。 ##第一章来学习three.js之前最好了解一下WebGL。什么是WebGL? WebGL是在浏览器中实现三维效果的一套规范。 使用WebGL原生的API来写3D程序是一件非常痛苦的事情，幸好，有很多同行花业余时间写了一些WebGL开源框架，其中three.js就是非常优秀的一个，它掩 盖了很多麻烦的细节，那么，就让我们一起来看看，什么是three.js吧 1. 启程：实际上，我们要使用 Three.js 展示一些画面到浏览器上, 我们需要下面这三样东西:一个场景(scene)， 一个摄像头(camera) , 和一个渲染器(renderer)， 所以我们使用一个相机渲染一个场景. var scene = new THREE.Scene(); // 场景 var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);// 透视相机 var renderer = new THREE.WebGLRenderer(); // 渲染器 renderer.setSize(window.innerWidth, window.innerHeight); // 设置渲染器的大小为窗口的内宽度，也就是内容区的宽度 document.body.appendChild(renderer.domElement); 场景是所有物体的容器，如果要显示一个苹果，就需要将苹果对象加入场景中。 另一个组件是相机，相机决定了场景中那个角度的景色会显示出来。相机就像人的眼睛一样，人站在不同位置，抬头或者低头都能够看到不同的景色。 场景只有一种，但是相机却又很多种。和现实中一样，不同的相机确定了呈相的各个方面。比如有的相机适合人像，有的相机适合风景，专业的摄影师根据实际用途不一样，选择不同的相机。对程序员来说，只要设置不同的相机参数，就能够让相机产生不一样的效果。 2. 三维空间两种基本的相机 透视相机 正投影相机 2.1. 单反、双反都是相机2.1.1 认识相机在Threejs中相机的表示是THREE.Camera，它是相机的抽象基类，其子类有两种相机，分别是正投影相机THREE.OrthographicCamera和透视投影相机THREE.PerspectiveCamera。类图如下所示： 正投影相机有时候也叫正交投影摄像机，下图显示了正交摄像机投影和透视投影之间的差别。 2.1.2 两者的区别 正投影和透视投影的区别是：透视投影有一个基本点，就是远处的物体比近处的物体小。 在工程建筑领域，正投影的例子很多，例如下面就是一个正投影的例子：其特点是，远近高低比例都相同。 2.2 正投影相机下面我们来介绍正投影相机，正投影的构造函数如下所示： OrthographicCamera( left, right, top, bottom, near, far ) 结合下面一个图，我们来看看，各个参数的意思。 1、 left参数 left：左平面距离相机中心点的垂直距离。从图中可以看出，左平面是屏幕里面的那个平面。 2、 right参数 right：右平面距离相机中心点的垂直距离。从图中可以看出，右平面是屏幕稍微外面一点的那个平面。 3、 top参数 top：顶平面距离相机中心点的垂直距离。上图中的顶平面，是长方体头朝天的平面。 4、 bottom参数 bottom：底平面距离相机中心点的垂直距离。底平面是头朝地的平面。 5、near参数 near：近平面距离相机中心点的垂直距离。近平面是左边竖着的那个平面。 6、far参数 far：远平面距离相机中心点的垂直距离。远平面是右边竖着的那个平面。 有了这些参数和相机中心点，我们这里将相机的中心点又定义为相机的位置。通过这些参数，我们就能够在三维空间中唯一的确定上图的一个长方体。这个长方体也叫做视景体。 投影变换的目的就是定义一个视景体，使得视景体外多余的部分裁剪掉，最终图像只是视景体内的有关部分。 好了，看一个简单的例子： var camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 ); scene.add( camera ); 这个例子将浏览器窗口的宽度和高度作为了视景体的高度和宽度，相机正好在窗口的中心点上。这也是我们一般的设置方法，基本上为了方便，我们不会设置其他的值。 2.3 透视投影相机透视投影相机的构造函数如下所示： PerspectiveCamera( fov, aspect, near, far ) 我们来欣赏一幅图来看看这个函数的各个参数的意思： 先来明确这个图里涉及的概念。1、视角fov：这个最难理解,我的理解是,眼睛睁开的角度,即,视角的大小,如果设置为0,相当你闭上眼睛了,所以什么也看不到,如果为180,那么可以认为你的视界很广阔,但是在180度的时候，往往物体很小，因为他在你的整个可视区域中的比例变小了。 2、近平面near：这个呢，表示你近处的裁面的距离。补充一下，也可以认为是眼睛距离近处的距离，假设为10米远，请不要设置为负值，Three.js就傻了,不知道怎么算了, 3、远平面far：这个呢，表示你远处的裁面, 4、纵横比aspect：实际窗口的纵横比，即宽度除以高度。这个值越大，说明你宽度越大 好了，看看下面一个简单的例子： var camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 ); scene.add( camera ); 未完待续。。。 (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/21/Threejs(1)/]]></content>
      <categories>
        <category>JS</category>
        <category>3D</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
        <tag>可视化</tag>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mock.js]]></title>
    <url>%2F2017%2F09%2F21%2FMock(1)%2F</url>
    <content type="text"><![CDATA[Mock.js 是一款模拟数据生成器，旨在帮助前端攻城师独立于后端进行开发，帮助编写单元测试 Mock.js 是一款模拟数据生成器，旨在帮助前端攻城师独立于后端进行开发，帮助编写单元测试。提供了以下模拟功能： 根据数据模板生成模拟数据 模拟 Ajax 请求，生成并返回模拟数据 基于 HTML 模板生成模拟数据 语法规范Mock.js 的语法规范包括两部分： 数据模板定义规范（Data Template Definition，DTD） 数据占位符定义规范（Data Placeholder Definition，DPD） 数据模板定义规范 DTD数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值： // 属性名 name // 生成规则 rule // 属性值 value &apos;name|rule&apos;: value 注意： 属性名 和 生成规则 之间用竖线 | 分隔。 生成规则 是可选的。 生成规则 有 7 种格式： ‘name|min-max’: value ‘name|count’: value ‘name|min-max.dmin-dmax’: value ‘name|min-max.dcount’: value ‘name|count.dmin-dmax’: value ‘name|count.dcount’: value ‘name|+step’: value 生成规则 的 含义 需要依赖 属性值的类型 才能确定。 属性值 中可以含有 @占位符。 属性值 还指定了最终值的初始值和类型。生成规则和示例：1. 属性值是字符串 String ‘name|min-max’: string通过重复 string 生成一个字符串，重复次数大于等于 min，小于等于 max。 ‘name|count’: string通过重复 string 生成一个字符串，重复次数等于 count。2. 属性值是数字 Number ‘name|+1’: number 属性值自动加 1，初始值为 number。 ‘name|min-max’: number生成一个大于等于 min、小于等于 max 的整数，属性值 number 只是用来确定类型。 ‘name|min-max.dmin-dmax’: number生成一个浮点数，整数部分大于等于 min、小于等于 max，小数部分保留 dmin 到 dmax 位。 3.属性值是布尔型 Boolean 4. 属性值是对象 Object 5. 属性值是数组 Array 6. 属性值是函数 Function ‘name’: function 执行函数 function，取其返回值作为最终的属性值，函数的上下文为属性 ‘name’ 所在的对象。 7. 属性值是正则表达式 RegExp ‘name’: regexp 根据正则表达式regexp 反向生成可以匹配它的字符串。用于生成自定义格式的字符串。 数据占位符定义规范 DPD占位符 只是在属性值字符串中占个位置，并不出现在最终的属性值中。 占位符 的格式为： @占位符 @占位符(参数 [, 参数]) 注意： 用 @ 来标识其后的字符串是 占位符。 占位符 引用的是 Mock.Random 中的方法。 通过Mock.Random.extend() 来扩展自定义占位符。 占位符 也可以引用 数据模板 中的属性。 占位符 会优先引用 数据模板 中的属性。 占位符 支持 相对路径 和 绝对路径。 Mock.mockMock.mock( rurl?, rtype?, template|function(options) )根据数据模板生成模拟数据。 ock.mock( template )根据数据模板生成模拟数据。 Mock.mock( rurl, template )记录数据模板。当拦截到匹配 rurl 的 Ajax 请求时，将根据数据模板 template 生成模拟数据，并作为响应数据返回。 Mock.mock( rurl, function(options) )记录用于生成响应数据的函数。当拦截到匹配 rurl 的 Ajax 请求时，函数 function(options) 将被执行，并把执行结果作为响应数据返回。 Mock.mock( rurl, rtype, template )记录数据模板。当拦截到匹配 rurl 和 rtype 的 Ajax 请求时，将根据数据模板 template 生成模拟数据，并作为响应数据返回。 Mock.mock( rurl, rtype, function(options) )记录用于生成响应数据的函数。当拦截到匹配 rurl 和 rtype 的 Ajax 请求时，函数 function(options) 将被执行，并把执行结果作为响应数据返回。 参数的含义和默认值如下所示： 参数 rurl：可选。表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。例如 /\/domain\/list.json/、’/domian/list.json’。 参数 rtype：可选。表示需要拦截的 Ajax 请求类型。例如 GET、POST、PUT、DELETE 等。 参数 template：可选。表示数据模板，可以是对象或字符串。例如 { ‘data|1-10’:[{}] }、‘@EMAIL’。 参数 function(options)：可选。表示用于生成响应数据的函数。 参数 options：指向本次请求的 Ajax 选项集。 从 1.0 开始，Mock.js 通过覆盖和模拟原生 XMLHttpRequest 的行为来拦截 Ajax 请求，不再依赖于第三方 Ajax 工具库（例如 jQuery、Zepto 等）。 Mock.mockjax(library)Mock.setup()Mock.setup( settings )配置拦截 Ajax 请求时的行为。支持的配置项有：timeout。 timeout指定被拦截的 Ajax 请求的响应时间，单位是毫秒。值可以是正整数，例如 400，表示 400 毫秒 后才会返回响应内容；也可以是横杠 ‘-‘ 风格的字符串，例如 ‘200-600’，表示响应时间介于 200 和 600 毫秒之间。默认值是’10-100’。 目前，接口 Mock.setup( settings ) 仅用于配置 Ajax 请求，将来可能用于配置 Mock 的其他行为。 (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/21/Mock(1)/]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mock.js]]></title>
    <url>%2F2017%2F09%2F21%2FMock%2F</url>
    <content type="text"><![CDATA[Mock.js 是一款模拟数据生成器，旨在帮助前端攻城师独立于后端进行开发，帮助编写单元测试 Mock.js 是一款模拟数据生成器，旨在帮助前端攻城师独立于后端进行开发，帮助编写单元测试。提供了以下模拟功能： 根据数据模板生成模拟数据 模拟 Ajax 请求，生成并返回模拟数据 基于 HTML 模板生成模拟数据 语法规范Mock.js 的语法规范包括两部分： 数据模板定义规范（Data Template Definition，DTD） 数据占位符定义规范（Data Placeholder Definition，DPD） 数据模板定义规范 DTD数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值： // 属性名 name // 生成规则 rule // 属性值 value &apos;name|rule&apos;: value 注意： 属性名 和 生成规则 之间用竖线 | 分隔。 生成规则 是可选的。 生成规则 有 7 种格式： ‘name|min-max’: value ‘name|count’: value ‘name|min-max.dmin-dmax’: value ‘name|min-max.dcount’: value ‘name|count.dmin-dmax’: value ‘name|count.dcount’: value ‘name|+step’: value 生成规则 的 含义 需要依赖 属性值的类型 才能确定。 属性值 中可以含有 @占位符。 属性值 还指定了最终值的初始值和类型。生成规则和示例：1. 属性值是字符串 String ‘name|min-max’: string通过重复 string 生成一个字符串，重复次数大于等于 min，小于等于 max。 ‘name|count’: string通过重复 string 生成一个字符串，重复次数等于 count。2. 属性值是数字 Number ‘name|+1’: number 属性值自动加 1，初始值为 number。 ‘name|min-max’: number生成一个大于等于 min、小于等于 max 的整数，属性值 number 只是用来确定类型。 ‘name|min-max.dmin-dmax’: number生成一个浮点数，整数部分大于等于 min、小于等于 max，小数部分保留 dmin 到 dmax 位。 3.属性值是布尔型 Boolean 4. 属性值是对象 Object 5. 属性值是数组 Array 6. 属性值是函数 Function ‘name’: function 执行函数 function，取其返回值作为最终的属性值，函数的上下文为属性 ‘name’ 所在的对象。 7. 属性值是正则表达式 RegExp ‘name’: regexp 根据正则表达式regexp 反向生成可以匹配它的字符串。用于生成自定义格式的字符串。 数据占位符定义规范 DPD占位符 只是在属性值字符串中占个位置，并不出现在最终的属性值中。 占位符 的格式为： @占位符 @占位符(参数 [, 参数]) 注意： 用 @ 来标识其后的字符串是 占位符。 占位符 引用的是 Mock.Random 中的方法。 通过Mock.Random.extend() 来扩展自定义占位符。 占位符 也可以引用 数据模板 中的属性。 占位符 会优先引用 数据模板 中的属性。 占位符 支持 相对路径 和 绝对路径。 Mock.mockMock.mock( rurl?, rtype?, template|function(options) )根据数据模板生成模拟数据。 ock.mock( template )根据数据模板生成模拟数据。 Mock.mock( rurl, template )记录数据模板。当拦截到匹配 rurl 的 Ajax 请求时，将根据数据模板 template 生成模拟数据，并作为响应数据返回。 Mock.mock( rurl, function(options) )记录用于生成响应数据的函数。当拦截到匹配 rurl 的 Ajax 请求时，函数 function(options) 将被执行，并把执行结果作为响应数据返回。 Mock.mock( rurl, rtype, template )记录数据模板。当拦截到匹配 rurl 和 rtype 的 Ajax 请求时，将根据数据模板 template 生成模拟数据，并作为响应数据返回。 Mock.mock( rurl, rtype, function(options) )记录用于生成响应数据的函数。当拦截到匹配 rurl 和 rtype 的 Ajax 请求时，函数 function(options) 将被执行，并把执行结果作为响应数据返回。 参数的含义和默认值如下所示： 参数 rurl：可选。表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。例如 /\/domain\/list.json/、’/domian/list.json’。 参数 rtype：可选。表示需要拦截的 Ajax 请求类型。例如 GET、POST、PUT、DELETE 等。 参数 template：可选。表示数据模板，可以是对象或字符串。例如 { ‘data|1-10’:[{}] }、‘@EMAIL’。 参数 function(options)：可选。表示用于生成响应数据的函数。 参数 options：指向本次请求的 Ajax 选项集。 从 1.0 开始，Mock.js 通过覆盖和模拟原生 XMLHttpRequest 的行为来拦截 Ajax 请求，不再依赖于第三方 Ajax 工具库（例如 jQuery、Zepto 等）。 Mock.mockjax(library)Mock.setup()Mock.setup( settings )配置拦截 Ajax 请求时的行为。支持的配置项有：timeout。 timeout指定被拦截的 Ajax 请求的响应时间，单位是毫秒。值可以是正整数，例如 400，表示 400 毫秒 后才会返回响应内容；也可以是横杠 ‘-‘ 风格的字符串，例如 ‘200-600’，表示响应时间介于 200 和 600 毫秒之间。默认值是’10-100’。 目前，接口 Mock.setup( settings ) 仅用于配置 Ajax 请求，将来可能用于配置 Mock 的其他行为。 (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/21/Mock/]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli 脚手架总结]]></title>
    <url>%2F2017%2F09%2F20%2Fvue-cli%20%E8%84%9A%E6%89%8B%E6%9E%B6%E6%80%BB%E7%BB%93(1)%2F</url>
    <content type="text"><![CDATA[工地上，脚手架是帮助工人作业搭建的架子。 vue-cli 可以帮助我们写好 vuejs 代码的工具 vue-cli 介绍工地上，脚手架是帮助工人作业搭建的架子。 vue-cli 可以帮助我们写好 vuejs 代码的工具，vue-cli 可以做什么： 1、目录结构2、本地调试3、代码部署4、热更新5、单元测试 （ESlint） vue-cli 的脚手架项目模板有browserify 和 webpack , 现在自己在用的是webpack , 官网给出了两个模板： webpack-simple 和 webpack 两种。两种的区别在于webpack-simple 没有包括Eslint 检查功能等等功能，普通项目基本用webpack-simple 就足够了. 搭建官方项目模板步骤： $ npm install -g vue-cli $ vue init （例如：$ vue init webpack my-project） 我们还需要把项目的依赖下载下来。使用命令: cd youdemoname 然后执行npm install 就可以了，这个时候你的项目中有多了一个node_modules 目录 使用”npm run dev“ 命令来运行项目 “npm-run-bulid“ 来执行发布，会自动生成dist文件 默认情况下，浏览器打开 http://localhost:8080，就可以看到脚手架项目初始化的效果了。 (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/20/vue-cli 脚手架总结(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
        <tag>Vue</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli 脚手架总结]]></title>
    <url>%2F2017%2F09%2F20%2Fvue-cli%20%E8%84%9A%E6%89%8B%E6%9E%B6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[工地上，脚手架是帮助工人作业搭建的架子。 vue-cli 可以帮助我们写好 vuejs 代码的工具 vue-cli 介绍工地上，脚手架是帮助工人作业搭建的架子。 vue-cli 可以帮助我们写好 vuejs 代码的工具，vue-cli 可以做什么： 1、目录结构2、本地调试3、代码部署4、热更新5、单元测试 （ESlint） vue-cli 的脚手架项目模板有browserify 和 webpack , 现在自己在用的是webpack , 官网给出了两个模板： webpack-simple 和 webpack 两种。两种的区别在于webpack-simple 没有包括Eslint 检查功能等等功能，普通项目基本用webpack-simple 就足够了. 搭建官方项目模板步骤： $ npm install -g vue-cli $ vue init （例如：$ vue init webpack my-project） 我们还需要把项目的依赖下载下来。使用命令: cd youdemoname 然后执行npm install 就可以了，这个时候你的项目中有多了一个node_modules 目录 使用”npm run dev“ 命令来运行项目 “npm-run-bulid“ 来执行发布，会自动生成dist文件 默认情况下，浏览器打开 http://localhost:8080，就可以看到脚手架项目初始化的效果了。 (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/20/vue-cli 脚手架总结/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
        <tag>Vue</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[REST]]></title>
    <url>%2F2017%2F09%2F20%2FREST%2F</url>
    <content type="text"><![CDATA[REST是一种设计API的模式什么是Web API呢？ 如果我们想要获取某个电商网站的某个商品，输入http://localhost:3000/products/123，就可以看到id为123的商品页面，但这个结果是HTML页面，它同时混合包含了Product的数据和Product的展示两个部分。对于用户来说，阅读起来没有问题，但是，如果机器读取，就很难从HTML中解析出Product的数据。 如果一个URL返回的不是HTML，而是机器能直接解析的数据，这个URL就可以看成是一个Web API。比如，读取http://localhost:3000/api/products/123，如果能直接返回Product的数据，那么机器就可以直接读取。 REST就是一种设计API的模式。最常用的数据格式是JSON。由于JSON能直接被JavaScript读取，所以，以JSON格式编写的REST风格的API具有简单、易读、易用的特点。 编写API有什么好处呢？由于API就是把Web App的功能全部封装了，所以，通过API操作数据，可以极大地把前端和后端的代码隔离，使得后端代码易于测试，前端代码编写更简单。 此外，如果我们把前端页面看作是一种用于展示的客户端，那么API就是为客户端提供数据、操作数据的接口。这种设计可以获得极高的扩展性。例如，当用户需要在手机上购买商品时，只需要开发针对iOS和Android的两个客户端，通过客户端访问API，就可以完成通过浏览器页面提供的功能，而后端代码基本无需改动。 当一个Web应用以API的形式对外提供功能时，整个应用的结构就扩展为： 把网页视为一种客户端，是REST架构可扩展的一个关键。 (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/20/REST/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[REST]]></title>
    <url>%2F2017%2F09%2F20%2FREST(1)%2F</url>
    <content type="text"><![CDATA[REST是一种设计API的模式什么是Web API呢？ 如果我们想要获取某个电商网站的某个商品，输入http://localhost:3000/products/123，就可以看到id为123的商品页面，但这个结果是HTML页面，它同时混合包含了Product的数据和Product的展示两个部分。对于用户来说，阅读起来没有问题，但是，如果机器读取，就很难从HTML中解析出Product的数据。 如果一个URL返回的不是HTML，而是机器能直接解析的数据，这个URL就可以看成是一个Web API。比如，读取http://localhost:3000/api/products/123，如果能直接返回Product的数据，那么机器就可以直接读取。 REST就是一种设计API的模式。最常用的数据格式是JSON。由于JSON能直接被JavaScript读取，所以，以JSON格式编写的REST风格的API具有简单、易读、易用的特点。 编写API有什么好处呢？由于API就是把Web App的功能全部封装了，所以，通过API操作数据，可以极大地把前端和后端的代码隔离，使得后端代码易于测试，前端代码编写更简单。 此外，如果我们把前端页面看作是一种用于展示的客户端，那么API就是为客户端提供数据、操作数据的接口。这种设计可以获得极高的扩展性。例如，当用户需要在手机上购买商品时，只需要开发针对iOS和Android的两个客户端，通过客户端访问API，就可以完成通过浏览器页面提供的功能，而后端代码基本无需改动。 当一个Web应用以API的形式对外提供功能时，整个应用的结构就扩展为： 把网页视为一种客户端，是REST架构可扩展的一个关键。 (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/20/REST(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>初级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R笔记]]></title>
    <url>%2F2017%2F09%2F20%2FR%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一门可视化语言。http://bayes.math.montana.edu/Rweb/Rnotes/R.html 前言：关于R在R的官方教程里是这么给R下注解的:一个数据分析和图形显示的程序设计环境(A system for data analysis and visualization which is built based on S language.)。R的源起R是S语言的一种实现。S语言是由 AT&amp;T贝尔实验室开发的一种用来进行数据探索、统计分析、作图的解释型语言。最初S语言的实现版本主要是S-PLUS。S-PLUS是一个商业 软件，它基于S语言，并由MathSoft公司的统计科学部进一步完善。后来Auckland大学的Robert Gentleman 和 Ross Ihaka 及其他志愿人员开发了一个R系统。R的使用与S-PLUS有很多类似之处，两个软件有一定的兼容性。R is freeR是用于统计分析、绘图的语言和操作环境。R是属于GNU系统的一个自由、免费、源代码开放的软件，它是一个用于统计计算和统计制图的优秀工具。R是一套完整的数据处理、计算和制图软件系统。其功能包括：数据存储和处理系统；数组运算工具（其向量、矩阵运算方面功能尤其强大）；完整连贯的统计分析工具；优秀的统计制图功能；简便而强大的编程语言：可操纵数据的输入和输入，可实现分支、循环，用户可自定义功能。R是一个免费的自由软件，它有UNIX、LINUX、MacOS和WINDOWS版本，都是可以免费下载和使用的,在那儿可以下载到R的安装程序、各种外挂程序和文档。在R的安装程序中只包含了8个基础模块，其他外在模块可以通过CRAN获得。R的特点(1) 有效的数据处理和保存机制。(2) 拥有一整套数组和矩阵的操作运算符。(3) 一系列连贯而又完整的数据分析中间工具。(4) 图形统计可以对数据直接进行分析和显示，可用于多种图形设备。(5) 一种相当完善、简洁和高效的程序设计语言。它包括条件语句、循环语句、用户自定义的递归函数以及输入输出接口。(6) R语言是彻底面向对象的统计编程语言。(7) R语言和其它编程语言、数据库之间有很好的接口。(8) R语言是自由软件，可以放心大胆地使用，但其功能却不比任何其它同类软件差。(9) R语言具有丰富的网上资源一 入门训练 获取帮助 help.start() 开启帮助文档help(solve) 显示某命令的帮助信息，或者?solve 对于由特殊字符指定的功能，这些参数必须用单引号或双引号括起来，使之成为一个“字符串”,如help(“[[“) 与某个主题相关的例子通常可以用下面的命令得到example(topic) 命令简介 R对大小写是敏感的；名称不能以数字开始； 基本的命令由表达式或者赋值语句组成。如果一个表达式被作为一条命令给出，它将被求值、打印而表达式的值并不被保存。一个赋值语句同样对表达式求值之后把表达式的值传给一个变量，不过并不会自动的被打印出来； 命令由分号(;)来分隔，或者另起新行； 基本命令可以由花括号(f和g)合并为一组复合表达式； 注释几乎可以被放在任何地方，只要是以井号( # )开始，到行末结束； 如果一个命令在行莫仍没有结束，R将会给出一个不同的提示符，默认的是‘+’。 命令文件的执行和输出转向到文件如果命令存储于一个外部文件中，比如工作目录work中的commands.R，他们可以随时在R的任务中被执行 source(“commands.R”)在Windows中Source也可以由File菜单执行。函数sink，sink(“record.lis”)将把所有后续的输出由终端转向一个外部文件，record.lis。命令sink() 将把信息重新恢复到终端上。 数据的保持与对象的清除R所创建、操作的实体是对象。对象可以是变量、数组、字符串、函数以及由这些元素组成的其它结构； objects() 用来显示目前存储在R中的对象的名字。而当前存储的所有对象的组合被称为workspace；清除对象可以使用rm命令：rm(x, y, z, ink, junk, temp, foo, bar)所有在一个R任务中被创建的对象都可以在文件中被永久保存，并在其它的R任务中被使用。在每个R任务结束时用户都有机会保存当前有效的所有对象。如果用户这样做的话，对象将被写入当前目录一个名为.RData。当R被再次启动时R会从这个文件中再载入workspace。同时相关的命令记录也被载入。所以，推荐大家在用R进行不同的分析时分别使用不同的工作目录。 基本数据结构 数值型(numeric）1,1.2,3.1415926复数型(complex)1+2i字符型(character)‘A’/ “hello world!”逻辑型(logical)TRUE / FALSE 基本数据对象 向量(vector), 见下节矩阵(matrix)：更一般的说数组是向量在多维情况下的一般形式。事实上它们是可以被两个或更多的指标索引的向量，并且以特定的方式被打印出来。因子(factors) 提供了一种处理分类数据的更简介的方式。列表(list)：是向量的一种一般形式，并不需要保证其中的元素都是相同的类型，而且其中的元素经常是向量和列表本身。数据框(data frame)：是一种与矩阵相似的结构，其中的列可以是不同的数据类型。可以把数据框看作一种数据”矩阵”，它的每行是一个观测单位，而且(可能)同时包含数值型和分类的变量。函数( function)：能够在R的workspace中存储的对象。我们可以通过函数来扩展R的功能。二 简单操作，数值与向量2.1 向量与赋值R对命名了的数据结构进行操作。最简单的数据结构是数字向量；如， x &lt;- c(10.4, 5.6, 3.1, 6.4, 21.7) c()是创建函数，赋值运算符是’&lt;-‘，与函数assign()等价assign(“x”, c(10.4, 5.6, 3.1, 6.4, 21.7)) 也可以写成：c(10.4, 5.6, 3.1, 6.4, 21.7) -&gt; x如果一个表达式被当作一个完整的命令，它的值将被打印到终端但不被储存。单独输入x则会将值打印出来。也可以打印倒数：1/xy &lt;- c(x, 0, x) 也可以将向量作为元素。2.2 向量运算 操作是按照向量中的元素一个一个进行的。同一个表达式中的向量并不需要具有相同的长度。如果它们的长度不同,表达式的结果是一个与表达式中最长向量有相同长度的向量。表达式中较短的向量会根据它的长度被重复使用若干次(不一定是整数次)，直到与长度最长的向量相匹配。而常数很明显的将被不断重复。如，v &lt;- 2x + y + 1常用运算有：+，-，，/，^（次方）；log, exp, sin, cos, tan,sqrt等；max和min的作用是选出所给向量中最大的或最小的元素；range函数的值是一个长度为2的向量，即c(min(x),max(x))length(x)返回了向量x中元素的个数，也就是x的长度。sum(x)给出了x中所有元素的总和；prod(x)给出x中所有元素的乘积；mean(x)和var(x)，分别计算样本均值和样本方差，这两个函数分别相当于sum(x)/length(x)，sum((x-mean(x)) ^2)/(length(x) -1)。如果var()的参数是一个np的矩阵，那么函数的值是一个pp的样本协方差矩阵，认为每行是一个p变量的样本向量。sort(x)返回一个与x具有相同长度的向量，其中的元素按招升序排列。还有其他更灵活的排序功能(参见order()和sort.list())。pmax和pmin将返回一个与最长的向量长度相等的向量，向量中的元素由参数中所有向量在相应位置的最大值(最小值)组成；如果要使用复数，需要直接给出一个复数部分。因此sqrt(-17)将会返回NaN(无效数值)和一个警告，而sqrt(-17+0i)将按照复数进行运算。2.3 生成序列最简单的方法是用冒号‘：’，冒号具有最高运算优先级。例如1:30就是向量c(1,2,. . .,29,30)。30:1构造一个递减序列。利用seq()函数构造序列：有五个参数，from, to, by, length, along from, to可以不写参数名，seq(2,10)就相当于2:10。 by指定步长，默认为1，如seq(-5, 5, by=.2)即为c(-5.0, -4.8, -4.6, …, 4.6, 4.8, 5.0) length指定序列长度，如seq(length=51, from=-5, by=.2)，等同于seq(-5, 5, by=.2) along=vector只能单独使用，产生一个“1:length(vector)”序列。类似的函数是rep(),这个函数可以用多种复杂的方法来 复制一个对象。最简单的形式是&gt; s5 &lt;- rep(x, times=5)2.4 逻辑向量 TRUE, FALSE, 和NA(not available), 前两个可以简写为T和F，但T/F并不是系统保留字，可以被用户覆盖，所以最好还是不要简写。逻辑向量是由条件给出的，如下列语句令temp成为一个与x长度相同，相应位置根据是否与条件相符而由TRUE或FALSE组成的向量： temp 13逻辑操作符包括&lt;, &lt;=, &gt;, &gt;=,完全相等==和不等于!=，与或非分别为&amp;, |, !。在普通运算中，FALSE当做0而TRUE当做1。2.5 缺失值NA(not available): 一般来讲一个NA的任何操作都将返回NA。 is.na(x)返回一个与x等长的逻辑向量，并且由相应位置的元素是否是NA来决定这个逻辑向量相应位置的元素是TRUE还是FALSE。 x==NA是一个与x具有相同长度而其所有元素都是NA的向量。NaN(Not a Number): 由数值运算产生，如0/0, Inf-Inf. is.na(x)对于NA和NaN值都返回TRUE， is.nan(x)只对NaN值返回TRUE。2.6 字符向量 字符串在输入时可以使用单引号(‘)或双以号(“); 在打印时用双引号(有时不用引号)。R使用与C语言风格基本相同的转义符, 所以输入\打印的也是\, 输入” 打印引号”, n: 换行, t: tab, b: 回格。字符向量可以通过函数c()连接；paste()可以接受任意个参数，并从它们中逐个取出字符并连成字符串，形成的字符串的个数与参数中最长字符串的长度相同。如果参数中包含数字的话，数字将被强制转化为字符串。在默认情况下，参数中的各字符串是被一个空格分隔的，不过通过参数sep=string 用户可以把它更改为其他字符串，包括空字符串。例如： labs &lt;- paste(c(“X”,”Y”), 1:10, sep=””) 使变量labs成为字符变量c(“X1”, “Y2”, “X3”, “Y4”, “X5”, “Y6”, “X7”, “Y8”, “X9”, “Y10”)2.7 index vector—数据集子集的选择与修改 任何结果为一个向量的表达式都可以通过追加索引向量(index vector)来选择其中的子集。1 逻辑的向量。 y 0] -&gt; z 表示创建一个对象z，其中的元素由向量x+1中与x中的非缺失值和正数对应的向量组成。 正整数的向量x[6] 是x的第六个元素x[1:10] 选取了x的前10个元素(假设x的长度不小于10)。c(“x”,”y”)[rep(c(1,2,2,1), times=4)] 产生了一个字符向量，长度为16，由”x”, “y”, “y”, “x”重复4次而组成。 负整数的向量y &lt;- x[-(1:5)] 表示向量y取向量x前5个元素以外的元素。 字符串的向量只存在于拥有names属性并由它来区分向量中元素的向量。这种情况下一个由名称组成的子向量起到了和正整数的索引向量相同的效果。fruit &lt;- c(5, 10, 1, 20)names(fruit) &lt;- c(“orange”, “banana”, “apple”, “peach”)lunch &lt;- fruit[c(“apple”,”orange”)]子集的修改x[is.na(x)] &lt;- 0 表示将向量x中所以NA元素用0来代替y[y &lt; 0] &lt;- -y[y &lt; 0] 表示将向量(-y)中 与向量y的负元素对应位置的元素 赋值给 向量y中 与向量y负元素对应的元素。作用相当于：y &lt;- abs(y)三 对象，模式和属性3.1 固有属性：模式和长度对象是R所进行操作的实体，对象可以是向量、列表等，详见1.6.对象的模式包括numeri，ccomplex，character，logical，list，function，expression等。可以用mode(object)查看。对象的长度是对象的另一固有属性。可以用length(object)查看。attribute(object)可以查看更深入的属性。模式的转换在允许的情况下(大多数情况都是允许的)，R可以完成各种模式的转换。例如：d&lt;-as.character(z)，将数值向量z&lt;-(0:9)转化为字符向量c(“0”, “1”, “2”, …, “9”)。as.integer(d)将d转化为数值向量。R中很多形式为as.something()的函数，可以完成从一个模式向另一个模式的转化，或者是令对象取得它当前模式不具有的某些属性。3.2 改变对象的长度e &lt;- numeric() 产生一个numeric型的空向量e。character()等类似。此时长度为对象0。此时新添加一个元素会使e的长度自动调整。e[3] &lt;- 17 令e为一个长度为3的向量（此时，该向量的前两个元素都是NA）缩短（截断）一个对象的长度，只需要一个赋值命令。因此，若alpha是一个长度为10的对象，下面的命令alpha &lt;- alpha[2 * 1:5]3.3 属性的获取和设置 函数attributes(object)将给出当前对象所具有的所有非基本属性（长度和模式属于基本属性）的一个列表。函数attr(object,name)可以被用来选取一个指定的属性。除了为某些特殊的目的创建新属性这样特殊的环境下，这些函数很少被用到。当函数attr()用在赋值语句左侧时，既可以是将对象与一种新的属性关联，也可以是对原有属性的更改。例如 attr(z,”dim”) &lt;- c(10,10) 另R将z作为一个10X10的矩阵看待。3.4 对象的类别对象的一个特别属性，类别，被用来指定对象在R编程中的风格。比如：如果对象类别”data.frame”则会以特定方式处理。unclass()可以去除对象的类别。summary()可以查看对象的基本信息（min, max, mean, etc.）四 有序因子和无序因子 因子是一种向量对象，它给自己的组件指定了一个离散的分类（分组），它的组件由其他等长的向量组成。R提供了有序因子和无序因子。通俗点说，因子就是将对象的值分成不同的组（levels）。用函数factor()创建一个因子，levels按序排列(字母序或数值序)。例如province&lt;-c(“四川”,”湖南”,”江苏”,”四川”,”四川”,”四川”,”湖南”,”江苏”,”湖南”,”江苏”)，为province创建因子： pf&lt;-factor(province) 创建province的因子pfpf 打印出来 [1] 四川 湖南 江苏 四川 四川 四川 湖南 江苏 湖南 江苏Levels: 湖南 江苏 四川函数levels()可以用来观察因子中有多少不同的levels。假如我们拥有这些省份考生的分数：score&lt;-c(95,86,84,92,84,79,86,99,85,90)函数tappley()可以用来计算各省的平均分数，函数tapply()的作用是对它第一个参数的组件中所包含的每个组应用一个参数三指定的函数。smeans&lt;-tapply(score,pf,mean)smeans 湖南 江苏 四川85.66667 91.00000 87.50000再例如，下面命令会给出各组的lengthtapply(score,pf,length)湖南 江苏 四川 3 3 4 函数ordered()可以创建有序因子 ordered(province) [1] 四川 湖南 江苏 四川 四川 四川 湖南 江苏 湖南 江苏Levels: 湖南 &lt; 江苏 &lt; 四川 五 数组和矩阵5.1 数组数组可以看成一个由递增下标表示的数据项的集合，例如数值。数组的生成如果一个向量需要在R中以数组的方式被处理，则必须含有一个维数向量作为它的dim属性。维度向量由dim()指定，例如，z是一个由1500个元素组成的向量。下面的赋值语句 dim(z) &lt;- c(3,5,100) 使它具有dim属性，并且将被当作一个3X5X100的数组进行处理。 c(3,5,100) 就是他的维度向量。还可以用到像matrix()和array()这样的函数来赋值。比如array(1:20, dim=c(4,5))matrix(1:24, 3,4)数据向量中的值被赋给数组中的值时，将遵循与FORTRAN相同的原则”主列顺序”，即第一个下标变化的最快，最后的下标变化最慢。数组的运算数组可以在算数表达式中使用，结果也是一个数组，这个数组由数据向量逐个元素的运算后组成，通常参与运算的对象应当具有相同的dim属性。5.2 数组的索引和数组的子块 数组中的单个元素可以通过下标来指定，下标由逗号分隔，写在括号内。我们可以通过在下标的位置给出一个索引向量来指定一个数组的子块，不过如果在任何一个索引位置上给出空的索引向量，则相当于选取了这个下标的全部范围。如a[2,,]，a[,3,]等5.3 索引数组除了索引向量，还可以使用索引数组来指定数组的某些元素。例如：有4X5的数组a，若要得到a中的a[1,3], a[2,2] 和a[3,1]这三个元素，可以生成索引向量i，然后用a[i]得到它们。 a &lt;- array(1:20,dim=c(4,5)) # Generate a 4 by 5 array.i &lt;- array(c(1:3,3:1),dim=c(3,2))i[,1] [,2][1,] 1 3[2,] 2 2[3,] 3 1a[i][1] 9 6 3a[i] &lt;- 0 # 将这三个元素用0替换。5.4 向量，数组的混合运算表达式从左到右被扫描；参与运算的任意对象如果大小不足，都将被重复使用直到与其他参与运算的对象等长；当较短的向量和数组在运算中相遇时，所有的数组必须具有相同的dim属性，否则返回一个错误；如果有任意参与运算的向量比参与运算的矩阵或数组长，将会产生错误；如果数组结构正常声称，并且没有错误或者强制转换被应用于向量上，那么得到的结果与参与运算的数组具有相同的dim属性。5.5 矩阵的运算构建分区矩阵：cbind()和rbind()，cbind()按照水平方向，或者说按列的方式将矩阵连接到一起。rbind()按照垂直的方向，或者说按行的方式将矩阵连接到一起。 外积：操作符是%o%: ab &lt;- a %o% b 或者ab &lt;- outer(a, b, ““)其中的乘法操作可以由任意一个双变量的函数替代。广义转置：函数t(A)，或aperm(A, c(2,1))；获取行数/列数：nrow(A)和ncol(A)分别返回矩阵A的行数和列数。矩阵乘法：操作符为%%；交叉乘积（cross product）：crossprod(X，Y)等同于t(X) %*% y，crossprod(X)等价于crossprod(X, X)；diag(v)：如果v是向量，diag(v)返回一个由v的元素为对角元素的对角矩阵。 如果v为矩阵，diag(v)返回一个由v主对角元素组成的向量。 如果v只是一个数值，那么diag(v)是一个vXv的单位矩阵。 特征值和特征向量：eigen(Sm)。这个函数的结果是由名为values和vectors的两部分组成的列表。如果只是需要特征值：eigen(Sm)$values最小二乘拟合即QR分解：lsfit(), qr()。强制转换为向量：as.vector()，或者直接c().解线性方程和求矩阵的逆，奇异值分解与行列式见；六 列表和数据帧6.1 列表列表是由称作组件的有序对象集合构成的对象。组件的模式或类型不一定相同。形如Lst &lt;- list(name_1=object_1, . . ., name_m=object_m)的赋值将创建一个包含m个组件的列表，并根据参数中指定的名称为其命名。（其名称可以自由选取）。如果它们的名称被省略，组件将只是被编号。例如： Lst &lt;- list(name=”Fred”, wife=”Mary”, no.children=3,child.ages=c(4,7,9))所使用的组件是被复制到新的列表中的，对原始对象没有影响。组件总是被编号的，并且可以通过编号指定。Lst[[1]] 即为”Fred”，也可以用 Lst$name，Lst[[“name”]]指定。如果Lst[[4]]是一个有下标的数组，Lst[[4]][1]就是它的第一项。区分Lst[[1]]和Lst[1]，’[[…]]’是选择单个元素时使用的操作符，而’[…]’是一个一般的下标操作符。因此，前者代表列表Lst中的第一个对象；后者是列表Lst的子列表，仅包含列表的第一项。组件的名称可以缩写，可缩写的程度是只要能令组件被唯一的识别就可以了。如：Lst$na等价于Lst$name， Lst$w等价于Lst$wife。扩展列表可以通过指定额外组件的方式。例如Lst[5] &lt;- list(matrix=Mat)连接列表当连接函数c()的参数为列表时，其结果也是一个模式为列表的对象。由参数中的列表作为组件依次连接而成。list.ABC &lt;- c(list.A, list.B, list.C)6.2 数据帧 数据帧是类别为”data.frame”的列表；数据帧会被当作各列具有不同模式和属性的矩阵。数据帧按照矩阵的方式显示，选取的行或列也按照矩阵的方式来索引。创建数据帧直接创建：那些满足对数据帧的列（组件）限制的对象可以通过函数data.frame来构建成为一个数据帧 t &lt;- data.frame(home=statef, loot=income, shot=incomef)强制转换：如果一个列表的组件与数据帧的限制一致，这个列表就可以通过函数as.data.frame()强制转化为一个数据帧。外部文件：创建数据帧最简单的方法应当是使用read.table()函数从外部文件中读取整个数据帧。数据帧和列表的限制1 组件必须是向量（数值型，字符形，逻辑型），因子，数值矩阵，列表，或其他数据帧；2 矩阵，列表，数据帧向新数据帧提供的变量数分别等于它们的列数，元素数和变量数；3 数值向量，逻辑值和因子在数据帧中保持不变，字符向量将被强制转化为因子，其水平是字符向量中所出现的值；4 数据帧中作为变量的向量结构必须具有相同的长度，而矩阵结构应当具有相同的行大小。 挂接和卸载数据帧当觉得使用’$’引用数据帧元素(如’t$home’)麻烦时，可以进行数据帧挂接 attach(t) 这样可以直接引用数据帧内的元素，而无需’$’，前提是数据帧外没有同名的变量(如name)。挂接后若要对数据帧元素进行赋值操作，仍需用’$’，否则视为赋值给数据帧外的元素。赋值后必须要先卸载(detach)再重新挂接后，新值才可见。detach(t) attach()是具有一般性的函数，即它不仅能够将目录和数据帧挂接在搜索路径上，还能挂接其他类别的对象。特别是模式为”list”的对象可以通过相同的方式挂接： attach(any.old.list)任何被挂接的对象都可以用detach来卸载，通过指定位置编号或者指定名称这样的方式.搜索路径函数search()将显示目前的搜索路径，可以用来查看数据帧/列表的挂接状态。ls()（或objects()）命令可以用来检查搜索路径任意位置上的内容。如：ls(), ls(2), ls(t)R可以在搜索路径中包含至多20个项目,列表和数据帧只能在位置2或更靠后的位置上挂接。 数据帧使用惯例 1 将每个独立的，适当定义的问题所包含的所有变量收入同一个数据帧中，并赋予合适的、易理解、易辨识的名称；2 处理问题时，当相应的数据帧挂接于位置2，同时在第1层工作目录下存放操作的数值和临时变量；3 在结束一次工作之前，将你认为对将来有参考价值的变量通过$标记的形式添加到数据帧里面，然后detach()；4 最后，将工作目录下所有不需要的变量剔除，并且尽量将剩下多余的临时变量都清除干净。这样我们可以很简单的在同一个目录下处理多个问题，而且对每个问题都可以使用x,y,z这样的变量名。七 从文件中读取数据7.1 函数read.table()该函数可以直接将文件中完整的数据帧读入。此时文件要符合特定的格式：1 第一行应当提供数据帧中每个变量的名称；2 每一行(除变量名称行)应包含一个行标号和各变量的值。3 若没有表头(变量名称行)，也没有行标号，只有变量值，则默认变量名称为”v1”,”v2”…4 若有表头，但没有行标号，则可以指定参数header=TRUE.7.2 函数scan()该函数从键盘或文件中读取数据，并存入向量或列表中。 inp &lt;- scan(file, what)第一个参数是文件名,如“test.txt”，若为“”或空，则从键盘读入数据；第二个参数用于确定读入数据的模式。 如：list(“”,0,0) 指定读入到列表中，列表有三项，且列表第一项是字符型，第二三项是数值型。若为0，则指定读入到一个数值向量中，若为“”则指定读入到字符向量中。7.3 内置数据集的读取 R本身提供超过50个数据集，同时在功能包（包括标准功能包）中附带更多的数据集。与S-Plus不同，这些数据即必须通过data函数载入。 data() #获得基本系统提供的数据集列表，然后通过形如data(infert) #来载入名为infert的数据集从其他package中载入数据集data(package=”nls”) #查看nls中数据集data(Puromycin, package=”nls”) #读取nls中Puromycin数据集。用library()挂接package后，它的数据集也自动包含到搜索路径中了。library(nls) #载入package nlsdata() #查看数据集date(Puromycin) #载入Puromycin数据集 7.4 编辑数据在使用一个数据帧或矩阵时，edit提供一个独立的工作表式编辑环境。 xnew &lt;- edit(xold) #对数据集xold进行编辑。并在完成时将改动后的对象赋值给xnewxnew &lt;- edit(data.frame()) #可以通过工作表界面录入新数据。fix()函数用于直接修改已有的对象，等价于 x&lt;-edit(x).八 概率分布8.1 R是一个统计表集合(略读) R提供了一套完整的统计表集合。函数可以对累积分布函数P(X&lt;=x)，概率密度函数，分位函数（对给定的q，求满足P(X&lt;=x) &gt; q的最小x）求值，并根据分布进行模拟。 对于所给的名称，加前缀’d’代表密度(density)，’p’代表CDF，’q’代表分位函数，’r’代表模拟（随即散布）。这几类函数的第一个参数是有规律的，形为dxxx的函数为x，pxxx的函数为q，qxxx的函数为p，rxxx的函数为n（rhyper和rwilcox是特例，他们的第一个参数为nn）。目前为止，非中心参数(non-centrality parameter)仅对CDF和少数几个其他函数有效，细节请参考在线帮助。所有pxxx和qxxx的函数都具有逻辑参数lower.tail和log.p，而所有的dxxx函数都有参数log，这个是我们可以直接通过 pxxx(t, …, lower.tail = FALSE, log.p = TRUE)获取，比如说，累积失效函数（cumulative/integrated hazard function），H(t) =-log(1-F(t))，以及更精确的对数似然（通过dxxx(…, log = TRUE)）。此外，对于来自正态分布，具有学生化样本区间的分布还有ptukey和qtukey这样的函数。下面是一些例子 2-tailed p-value for t distribution2*pt(-2.43, df = 13) upper 1% point for an F(2, 7) distributionqf(0.99, 2, 7)8.2 检测数据集的分布 函数summary和fivenum这两个函数可以给出摘要，后者只给出数值；函数stem可以将数值统计结果以类似直方图的方式显示出来；函数hist()可以绘制直方图；函数density和line可以获得更漂亮的密度图；功能包fun中的ecdf函数能绘制经验累积分布函数；还可以进行拟合正态分布，覆盖拟合CDF；还可以绘制Quantile-quantile (Q-Q)图有助于我们更细致的检测其分布形态；8.3 单样本和两样本检验（略读）九 语句组、循环和条件操作 R是一种表达式语言，也就是说其命令类型只有函数或表达式，并由它们返回一个结果。语句组由花括号‘{ }’确定，此时结果是该组中最后一个能返回值的语句的结果。条件语句 if (expr_1) expr_2 else expr_3其中条件表达式expr1必须返回一个逻辑值，操作符&amp;&amp;和||经常被用于条件部分。&amp;和|与&amp;&amp;，||的区别在于，&amp;和|按照逐个元素的方式进行计算，&amp;&amp;和||对向量的第一个元素进行运算，只有在必需的时候才对第二个参数求值。if/else结构的向量版本是函数ifelse，其形式为ifelse (condition,a,b)，产生函数结果的规则是：如果condition[i]为真，对应a[i]元素；反之对应的是b[i]元素。根据这个原则函数返回一个由a,b中相应元素组成的向量，向量长度与其最长的参数等长。循环语句for (name in expr_1) expr_2其中name是循环变量，expr1是一个向量表达式（通常是1:20这样的序列），而expr2经常是一个表达式语句组，expr2随着name依次取expr1结果向量的值而被多次重复运行。repeat(expr)while(condition) expr break语句可以用来中断任何循环，可能是非正常的中断。而且这是中止repeat循环的唯一方式。next语句可以中止一个特定的循环，跳至下一个.十 编写自己的函数10.1 函数的定义 name &lt;- function(arg_1, arg_2, …) expressionexpression是一个R表达式（通常是表达式语句组），并使用参数arg_i来计算出一个数值，表达式的值就是函数的返回值。函数调用的形式通常都是name(expr1,expr2,…)10.2 定义新的二元操作符可以将函数定义为新的二元操作符：“%!%” &lt;- function(X, y) { … }正如矩阵乘法运算符，%*%，和矩阵外积运算符%o%10.3 指定参数和默认值 如果被调用函数的参数按照”name = obj”的形式给出，那么参数的次序可以是任意的。而且，参数序列可以在开始依次序给出，而将指定名称的参数置于后面。因此，如果由一个函数fun1被定义为 fun1 &lt;- function(data, data.frame, graph, limit) {[function body omitted]}那么函数可以有多种等价的使用方法，例如ans &lt;- fun1(d, df, TRUE, 20)ans &lt;- fun1(d, df, graph=TRUE, limit=20)ans &lt;- fun1(data=d, limit=20, graph=TRUE, data.frame=df)默认值 ：在很多情况下，参数都会被赋予一个普遍适用的默认值。fun1 &lt;- function(data, data.frame, graph=TRUE, limit=20) { … }则函数可以这样被调用ans &lt;- fun1(d, df)此时与上面三种情况等价，也可以这样调用ans &lt;- fun1(d, df, limit=10)此时改变了一个默认值。NOTE：参数可以是任意表达式，甚至可以是包含其他参数的表达式；10.4 额外参数“…” 当需要将一个函数的参数传递给另一个函数时，可以通过包含一个额外的参数”…”实现。fun1 &lt;- function(data, data.frame, graph=TRUE, limit=20, …) {[omitted statements]if (graph)par(pch=”*”, …)[more omissions]}10.5 全局变量和局部变量函数内的赋值都是局部变量，退出函数就丢失了。如果要在函数内进行永久赋值（定义全局变量），需要用到“超赋值”操作符, &lt;&lt;-或者函数assign()。10.6 一些高级示例区组设计的效率因子 (E±ciency factors)删除打印数组中的所有名称递归的数值积分10.7 范畴（Scope） 函数主体内出现的标识(symbol)可以被分为3类；正式参数、局部变量和自由变量。正式参数就是出现在函数参数列表中的参数，他们的值由实际的函数参数与正式参数的绑定（binding）过程决定。局部变量是在参数主体中，由表达式求值过程决定的变量。自由变量为既不是正式参数又不是局部变量的变量。赋值之后自由变量成为局部变量。 在R中，自由变量的值由函数被创建的环境中与其同名的第一个变量值决定（我理解为最近的同名变量），这种方式被称为词汇式范畴(lexical scope)。而在S中，该值由同名的全局变量决定。例如下面的函数cube，在R中cube（2）=8，在S中报错为sq()找不到n。cube &lt;- function(n) {sq &lt;- function() nnnsq()}一个银行账户的例子，详见《R语言笔记》。10.8 定制环境详见《R语言笔记》。10.9 类别，通用函数和对象定位 一个对象的类别(class)决定了他会如何被通用函数(generic function)处理。如果参数本身没有任何类别属性，或者其类别在特定问题中并不满足通用函数的要求，通常会有一个默认的动作被执行。类别机制使用户可以为特定的目的设计和编写通用函数。使用&gt; methods(class=”data.frame”)可以查看数据帧的通用函数。使用&gt; methods(plot)可以查看plot函数能处理的类别。十一 R的统计模型待阅。 十二 图形过程在Windows下用window()命令可以打开图形窗口。12.1 高级绘图命令 高级绘图函数，由函数参数提供数据生成一幅完整的图形。其中适当的坐标轴，标签和标题都自动生成了（除非你另外指定了）。高级绘图命令每次都生成一幅新的图形，清除当前的图形（如果需要的话）。 1 plot()函数 这是一个通用函数：生成图形的类型取决于第一个参数的类型或类别(class)。plot(x,y) plot(xy)：如果x，y是向量，plot(x,y)生成一幅y对x的散点图。用包含两个元素x，y的一个列表或一个两列的矩阵作为一个参数（第二种形式那样的）也能达成相同的效果。plot(x)：如果x是一个时间序列，这个命令生成一个时间序列图，如果x是一个数值型向量，则生成一个向量值对它们向量索引的土，而如果x是一个复向量，则生成一个向量中元素的虚部对实部的图。plot(f) plot(f,y)：f是一个因子对象，y是一个数值型向量。第一种形式生成一个f的条形图；第二种形式生成y对应于f各个水平的箱线图。plot(df) plot( expr) plot(y expr)：df是一个数据帧，y是任意对象，expr是由对象名称组成的列表，分隔符’+’(例如，a + b + c)。前两种形式生成分布式的图形，第一种是数据帧中的变量，第二种是一系列被命名的对象。第三种形式生成y对expr中每个对象的图。2 显示多元数据 如果X是一个数值矩阵或数据帧，下面的命令 pairs(X)生成一个配对的散点图矩阵，矩阵由X中的每列的列变量对其他各列列变量的散点图组成，得到的矩阵中每个散点图行、列长度都是固定的。 当问题涉及到三、四个变量时，使用coplot更好些。如果a和b是数值向量，c是数值向量或因子对象（全都是相同长度的），下面的命令 coplot(a ~ b | c)对应c的某些给定值生成数个a对b的散点图。当c是一个因子时，这个命令也就是对c的每个水平生成a对b的散点图。当c是数值向量的时候，这个数值向量被分为一系列的条件区间（conditioning intervals），对应c的每个区间生成一个a对b的散点图。区间的数量和位置可以通过coplot()的参数given.values来控制，函数co.intervals()也可以用来选择区间。我们也可以使用两个给定变量通过命令coplot(a ~ b | c+d)对c和d的每个联合条件区间生成a对b的散点图。 函数coplot()和pairs()都可以使用参数panel=，这个参数可以用来定制我们得到的图形类型。默认的是points()函数，生成一个散点图，不过通过在参数panel=中提供某些其它的低级图形函数，我们可以生成需要的各种图形。一个很有用的函数例子是panel.smooth()。3 显示图形 qqnorm(x) qqline(x) qqplot(x,y)分布比较图。第一种形式生成向量x对期望正态分数（一个正态记分图），第二个在上面的图上添加一条穿过分布分位点和数据分位点的直线。第三个命令生成x的分位点对y分位点图，用于分别比较它们的分布。hist(x) hist(x,nclass=n) hist(x,breaks=b, . . . )生成数值变量x的直方图。通常会自动选定一个合理的类别数，不过可以通过nclass=参数来指定一个推荐值。或者通过参数breaks=来指定分界点。如果给定了probability=TRUE参数，那么条形图代表相对频数而不是累计数。dotchart(x, . . . )创建一个x中数据的点图(dotchart)。点图中y轴给出x中数据的标签，x轴给出它们的值。它允许对落入某一特定区间的所有数据项方便的进行可视化选择。image(x,y,z, . . . ) contour(x,y,z, . . . ) persp(x,y,z, . . . )生成三个变量的图。函数image是用不同的颜色绘制一些矩形方格来展示z的值，函数contour通过绘制等高线来展示z的值，函数persp绘制一个3D面。4 参数配置 add=TRUE 强制函数按照低级图形函数的方式操作，将图形置于当前图形上（仅对某些函数有效）。axes=FALSE 暂时禁止坐标轴的生成|以便使用axis()函数添加你自己定制的坐标轴。默认情况是axes=TRUE，即包含坐标轴。log=”x” log=”y” log=”xy” 令x,y或者两者全都对数化。这个参数对许多函数都有效，不过不是全部。type= 参数type=控制所生成图形的类型： type=”p” 绘制单独的点（默认值） type=”l” 绘制线 type=”b” 绘制由线连接的点（both） type=”o” 将点绘在线上 type=”h” 绘制从点到零轴的垂线（high-density） type=”s” 阶梯式图。第一种形式中，点由垂线的顶部定义；第二种形式里用底部定义。 type=”n” 不绘制。不过坐标轴是绘出的（默认情况）而且要根据数据绘出坐标系统。用来给后续的低级图形函数创建图形作基础。xlab=string ylab=string x轴或y轴的标签。使用这些参数来改变默认的标签，通常的默认值是调用高级绘图函数时所使用对象的名称。main=string 图表标题，位于图形的顶部，大字体显示。sub=string 子标题，位于x轴下面，用较小的字体显示。12.2 低级绘图命令 有些时候高级绘图函数并不能很精确的生成我们想要的图形。这种情况下，我们可以通过低级绘图命令在当前图形上添加信息（例如，点、线或文本）。points(x,y) lines(x,y)在当前图形上添加点或线。函数plot()的参数type=也可以用于这些函数（默认的是”p”代表points()和”l”代表lines()）。text(x,y,labels, . . . )给定点坐标x,y，在该点添加文本。通常labels是一个整数或字符向量，其中labels[i]出现在点(x[i],y[i])。默认值是1:length(x)。Note： 这个函数通常用于这样的序列中 plot(x, y, type=”n”); text(x, y, names)图形参数type=”n”阻止了点的生成，但是建立了坐标轴，由函数text()提供字符向量names所指定的特定字符。 abline(a, b) abline(h=y) abline(v=x) abline(lm.obj)在当前图上添加一条斜率为b，截距为a的直线。h=y在图形指定的高度上绘制一条贯穿图形的水平线，同样的，v=x在x轴的指定位置绘制一条贯穿的垂线。而lm.obj是一个包含coefficients组件的列表，该组件的长度为2，分别当作截距和斜率。polygon(x, y, . . . )绘制一个多边形，其顶点由(x,y)指定。同时还（可选的）可以加上阴影线，如果图形设备允许的话还可以将多边形填充。legend(x, y, legend, . . . )这当前图形的指定位置添加图例。绘制的字符，线条类型，颜色等等由字符向量legend指定。除此之外至少还要给出一个参数v，与绘图单元的相应值，分别有：legend( , fill=v)填充方框的颜色legend( , col=v)绘制点线的颜色legend( , lty=v)线条类型legend( , lwd=v)线条宽度legend( , pch=v)绘制字符(字符向量) title(main,sub)在当前图形的顶部用大字题添加一个标题main，在底部用较小的字体添加子标题sub。axis(side, . . . )在当前图形的指定边上添加坐标，在哪个边上由第一个参数指定（1到4，从底部按照顺时针顺序）。其他参数控制坐标的位置|在图形内或图形外，以及标记的位置和标签。适合在调用参数为axes=FALSE的函数plot()后添加定制的坐标轴。低级绘图函数通常都需要一些位置信息（例如，x,y坐标）来决定在哪里添加新的元素。坐标以用户坐标(user coordinates)的形式给出，这个坐标系是根据所提供的数据由之前的高级绘图语句定义的。需要x,y参数的地方还可以选用一个单独的参数，即一个由名为x,y的元素组成的列表。相似的，一个两列的矩阵也可以。像locator()（后面会提到）这样的函数也可以按照这种方式交互的指定图形中的位置。添加数学注释某些情况下需要在图形中加入数学符号或公式。在R中可以通过在text, mtext,axis或title中指定一个表达式来实现。例如，下面的代码绘制了二项概率函数的公式： text(x, y, expression_r(paste(bgroup(“(“, atop(n, x), “)”),p^x, q^{n-x})))更多的信息，包括其特性的一个完整列表可以在R中通过下面的命令得到：help(plotmath)example(plotmath)添加Hershey矢量字体help(Hershey)example(Hershey)12.3 图形的交互R提供了函数，使用户可以通过鼠标从图形中释放信息或添加信息。 locator(n,type)等待用户使用鼠标左键在当前图形上选择位置。直到n(默认是512)个点都选完或者点击了鼠标另一个键（Unix,Windows)，在Mac下用鼠标点击图形窗口外的部分也可以结束。参数type的效果和在高级绘图函数中使用时是一样的，即在选择的点绘制指定的图形。默认情况是不绘制图形。函数locator()将所选点的坐标返回到一个列表中，列表包含x,y两个组件。通常locator()在调用的时候并不带参数。这个功能在为图例或标签这样的图形元素选择位置时比较有用，尤其是这些位置不好通过计算得到的时候。举个例子，如果要在一个野点附近添加一些信息，可以使用下面的命令 text(locator(1), “Outlier”, adj=0) identify(x, y, labels)允许用户在x,y（使用鼠标左键）定义的点附近绘制相应的labels的组件（如果没有给出labels就给出该点的序号），突显该点。当鼠标的另一个键被点击时（Unix,Windows）返回被选点的序号，在Mac下通过点击图形窗口外来实现这个效果。有时我们更想确定图形中的点，而非它们的位置。例如，我们可能希望从图示中选出某些感兴趣的观测点，然后进行某些操作。通过两个数值向量x,y给定一系列坐标(x; y)，我们可以使用identify()函数： plot(x,y) &gt; identify(x,y)函数identify()本身不绘图，但是允许用户移动鼠标，在某点附近点击左键。离鼠标指针最近的点将被突显，并标出其序号（也就是它在向量x/y中的位置）。或者使用identify()的labels参数，把某些信息（例如案例名称）作为突显的标志；或者通过plot=FALSE参数取消所有突显标志。当选点的过程结束后，identify()返回所选点的序号；用户可以使用这些序号从x和y中释放所选的点。12.4 使用图形参数 通过图形参数可以定制图形显示的几乎所有方面。R包含大量的图形参数，可以控制的包括线条类型，颜色，图标排列，文本对齐等等。1 持续性变更 (Permanent changes): par()函数 通过par()函数设定图形参数的值会持续性的更改参数的值，也就是说这之后（在当前设备上）所有对图形函数的调用都受到新值的影响。函数par()用于存取和修改当前图形设备的图形参数列表。par()不带任何参数，返回当前设备所有图形参数和它们的值的列表。par(c(“col”,”lty”))参数为一个字符向量，仅返回参数中指定的图形参数（也是作为一个列表）。par(col=4, lty=2)带指定参数（或一个列表型参数），设定指定图形参数的值，并将参数的原始值作为一个列表返回。所以如果想设定参数绘制一些图形后再恢复成原来的设定，可以这么做： oldpar &lt;- par(col=4, lty=2). . . plotting commands . . .par(oldpar)2 临时性变更：图形函数的参数 图形参数也可以作为（几乎）所有图形函数的命名参数。这种方式的效果和用于par()函数的效果是一样的，只不过这种改变只在函数调用的区间内有效。比如： plot(x, y, pch=”+”)生成一个以加号作为绘图符号的散点图，而不改变后续图形的默认的绘图符号。3 图形参数列表A 图形元素R图表由点、线、文本和多边形（填充区）组成。下面的图形参数控制了图形元素的绘制：pch=”+” 用来绘点的字符。这个默认值随不同的图形驱动是不同的，不过通常都是’±’。除非使用”.”作为绘图字符，否则绘制的点都会比适当的位置高一点或者低一点，而不是恰好在指定位置。pch=4当给定一个0到18的整数时，会生成一个特殊的绘图符号。通过下面的命令可以看这些符号都有什么。legend(locator(1), as.character(0:18), pch=0:18)lty=2 线条类型。并不是所有图形设备都支持多种线条类型（在那些支持的设备上也不全一样），不过线条类型1始终是实线，2及以上的是点、划线或者它们的组合。lwd=2 线条宽度。所需的线条宽度，是”标准”线条宽度的倍数。对line()等函数绘制的线条和坐标轴都有效果。col=2 点、线、文本、填充区和图像使用的颜色。每种图形元素都有其可用的颜色列表，这个参数的值就是颜色在列表中的序号。显然，这个参数值对有限的一类设备有效。font=2 指定文本所使用字体的一个整数。如果可能的话，设备驱动会把1对应普通文本，2对应粗体，3对应斜体，4对应粗斜体。font.axis font.lab font.main font.sub 这几个参数分别指定坐标轴注释，x,y轴的标签，主、副标题所用的字体。adj=-0.1 文本对齐和绘图位置有关。0代表左对齐，1代表右对齐，0.5代表水平的中间位置。当前的值使会图位置到左端距离的比例，所以-0.1在文本和绘图位置之间留10%的空白。cex=1.5 字符缩放。这个值是所需文本字符（包括绘图字符）的大小，与默认文本大小相关。B 坐标轴和标记很多R的高级图形都有坐标轴，你可以使用低级图形函数axis()自己创建坐标轴。坐标轴包含三个主要组件：轴线axis line（线条类型由参数lty控制），标记tick mark（沿着轴线划分单元），标号tick label（用来标出这些单元）。这些组件可以用下面这些参数定制。lab=c(5,7,12)前两个数字分别是x和y轴上所要划分的区间数。第三个数字是坐标轴标签的长度，用字符数来衡量（包括小数点）。参数的值如果选得太小可能导致所有标号都聚在一起。las=1 坐标轴标签的方向。0代表总是和坐标轴平行，1代表总是水平的，2代表总是垂直于坐标轴。mgp=c(3,1,0)坐标轴组件的位置。第一个组件是坐标轴标签到坐标轴的距离，单位是文本行(text lines)。第二个组件是到标号的距离，最后一个是轴的巍直到轴线的距离（一般都是0）。正数代表绘图区域外，负数代表区域内。tck=0.01 标号的长度，绘图区域大小的一个分数作单位。当tck比较小时（小于0.5），就强制x和y轴上的标记为相同大小。tck=1就是生成网格线。取负值时标记画向绘图区域外。内部标记可以使用tck=0.01和mgp=c(1,-1.5,0)。xaxs=”s” yaxs=”d” 分别是x、y轴的类型。如果是s(standard)或e(extended)类型，那最大和最小的标记都始终在数据区域之外。如果有某个点离边界非常近，那么扩展型(extended)的轴会稍稍扩展一下。这种类型的轴有时会在边界附近留出大片空白。而i(internal)或r(默认值)类型的轴，标记始终在数据区域内，不过r类型会在边界留出少量空白。如果这个参数设为d，就锁定当前轴，对之后绘制的所有图形都用这个轴（直到参数被重新设定为其他的那几个值）。这个参数适用于生成一系列固定尺度的图。C 图边缘（Figure margins）在R中一个单独图形，图（figure），包含一个绘图区(plot region)，以及环绕着这个区域的边缘（其中可能含有坐标轴标签、标题等等），（通常）这两部分以轴为边界。一个典型的图是 控制图的样式的图形参数包括：mai=c(1,0.5,0.5,0)分别是底部，左侧，顶部，右侧的宽度，单位是英寸。mar=c(4,2,2,1)与mai相似，只是单位是文本行(text lines)。由于更改一个就会改变另一个的值，所以在这个意义上，mai和mar是等价的。这个参数的默认值通常都太大了；右侧边缘很少用到，如果没标题，顶部边缘也不需要，左侧和底部的边缘应当足够大，以容纳坐标轴和标号。此外，默认值并没有考虑到设备表面的大小：比如，使用postscript()驱动，height=4参数时，除非用mar，mai另外设定，否则图的边缘就要占上大约50%。使用多图环境时（后面会提到）。边缘会减少一半，不过这在多图共用一页的时候可能还不够。D 多图环境R允许在一页上创建一个n£m的图的阵列。每个图由自己的边缘，图的阵列还有一个可选的外部边缘，如下图所示。 与多图环境相关的图形参数有：mfcol=c(3, 2) mfrow=c(2, 4) 设定多图阵列的大小。第一个值是行数，第二个值是列数。这两个参数唯一的区别是mfcol把图按列排入，mfrow把图按行排入。上图所示的版式可用mfrow=c(3,2)创建；上图显示的是绘制四幅图后的情况。mfg=c(2, 2, 3, 2) 当前图在多图环境下的位置。前两个数字是当前图的行、列数；后两个是其在多图阵列中的行列数。这个参数用来在多图阵列中跳转。你甚至可以在后两个数中使用和真值(true value)不同的值，在同一页上得到大小不同的图。fig=c(4, 9, 1, 4)/10 当前图在页面的位置，取值分别是左下角到左边界，右边界，下、上边界的距离与对应边的百分比数。给出的例子是一个页面右下角的图。这个参数可以设定图在页面的绝对位置。oma=c(2, 0, 3, 0) omi=(0, 0, 0.8, 0) 外部边缘的大小。与mar和mai相似，第一个用文本行作单位，第二个以英寸作单位，从下方开始按照顺时针顺序指定。外部边缘对页标题这类东西很有用。文本可以通过带outer=TRUE参数的mtext()函数加入外部边缘。默认情况下是没有外部边缘的因此必须通过oma或omi指定。函数split.screen()和layout()可以对多个图形作更复杂的排列。12.6 设备驱动 R几乎可以在任何一种类型的显示器和打印设备上生成（不同质量的）图形。不过，在这之前，需要告诉R要处理的是哪一种设备。这通过启动一个设备驱动来完成。设备驱动通过调用设备驱动函数来启动。某些常用的设备驱动有：X11()[Unix] 使用X11视窗系统windows()[Windows] 使用 Windows 视窗系统postscript()在PostScript打印机上打印或者创建PostScript图形文件pictex()生成一个LATEX文件当一个设备使用完之后，可以通过下面的命令终止设备驱动 dev.off()这个命令可以确保设备已经结束；例如，在某些硬拷贝的设备中，这个命令可以保证每页都已经完成，并且都被传送到打印机了。PostScript文档通过给postscript()函数带上file参数，我们可以把图形以PostScript格式存储到文件中。如果没有给出horizontal=FALSE参数，图形是横向的，你可以通过width和height参数控制图形的大小（图形会自动适应）。例如，命令postscript(“file.ps”, horizontal=FALSE, height=5, pointsize=10)为一个五英寸的图生成一个包含PostScript代码的文件，可以放在文当中。如果命令中的指定的文件名已经存在，将会被覆盖。多重图形设备每个对设备驱动的新调用都会打开一个新的图形设备，在设备列表中加入新的一项。这个设备就成为当前设备，图形输出就传送到这个设备。dev.list() 返回所有活动中设备的序号和名称。在列表位置1的设备始终是空设备(null device)，这个设备不接收任何图形命令。dev.next() dev.prev() 分别返回当前设备的后一个和前一个设备的序号和名称。dev.set(which=k) 用来把当前设备更改为设备列表中位置k的那个。返回设备的序号和标签。dev.off(k) 终止图形列表位置k的那个图形设备。对于某些设备，比如postscript，这个命令会立刻打印文件或者正常结束文件，具体怎样处理取决于设备是怎样初始化的。dev.copy(device,. . . ,which=k) dev.print(device,. . . ,which=k)建立一个设备k的拷贝。其中device是一个设备函数，例如postscript，如果需要的话可以在’. . . ‘中指定其它的参数，dev.print效果相似，不过复制的设备会立刻关闭，所以打印硬拷贝这样的终止操作也会被立即执行。graphics.off() 终止列表中的所有图形设备，空设备除外。 (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/20/R笔记/]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>初级</tag>
        <tag>可视化</tag>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R笔记]]></title>
    <url>%2F2017%2F09%2F20%2FR%E7%AC%94%E8%AE%B0(1)%2F</url>
    <content type="text"><![CDATA[一门可视化语言。http://bayes.math.montana.edu/Rweb/Rnotes/R.html 前言：关于R在R的官方教程里是这么给R下注解的:一个数据分析和图形显示的程序设计环境(A system for data analysis and visualization which is built based on S language.)。R的源起R是S语言的一种实现。S语言是由 AT&amp;T贝尔实验室开发的一种用来进行数据探索、统计分析、作图的解释型语言。最初S语言的实现版本主要是S-PLUS。S-PLUS是一个商业 软件，它基于S语言，并由MathSoft公司的统计科学部进一步完善。后来Auckland大学的Robert Gentleman 和 Ross Ihaka 及其他志愿人员开发了一个R系统。R的使用与S-PLUS有很多类似之处，两个软件有一定的兼容性。R is freeR是用于统计分析、绘图的语言和操作环境。R是属于GNU系统的一个自由、免费、源代码开放的软件，它是一个用于统计计算和统计制图的优秀工具。R是一套完整的数据处理、计算和制图软件系统。其功能包括：数据存储和处理系统；数组运算工具（其向量、矩阵运算方面功能尤其强大）；完整连贯的统计分析工具；优秀的统计制图功能；简便而强大的编程语言：可操纵数据的输入和输入，可实现分支、循环，用户可自定义功能。R是一个免费的自由软件，它有UNIX、LINUX、MacOS和WINDOWS版本，都是可以免费下载和使用的,在那儿可以下载到R的安装程序、各种外挂程序和文档。在R的安装程序中只包含了8个基础模块，其他外在模块可以通过CRAN获得。R的特点(1) 有效的数据处理和保存机制。(2) 拥有一整套数组和矩阵的操作运算符。(3) 一系列连贯而又完整的数据分析中间工具。(4) 图形统计可以对数据直接进行分析和显示，可用于多种图形设备。(5) 一种相当完善、简洁和高效的程序设计语言。它包括条件语句、循环语句、用户自定义的递归函数以及输入输出接口。(6) R语言是彻底面向对象的统计编程语言。(7) R语言和其它编程语言、数据库之间有很好的接口。(8) R语言是自由软件，可以放心大胆地使用，但其功能却不比任何其它同类软件差。(9) R语言具有丰富的网上资源一 入门训练 获取帮助 help.start() 开启帮助文档help(solve) 显示某命令的帮助信息，或者?solve 对于由特殊字符指定的功能，这些参数必须用单引号或双引号括起来，使之成为一个“字符串”,如help(“[[“) 与某个主题相关的例子通常可以用下面的命令得到example(topic) 命令简介 R对大小写是敏感的；名称不能以数字开始； 基本的命令由表达式或者赋值语句组成。如果一个表达式被作为一条命令给出，它将被求值、打印而表达式的值并不被保存。一个赋值语句同样对表达式求值之后把表达式的值传给一个变量，不过并不会自动的被打印出来； 命令由分号(;)来分隔，或者另起新行； 基本命令可以由花括号(f和g)合并为一组复合表达式； 注释几乎可以被放在任何地方，只要是以井号( # )开始，到行末结束； 如果一个命令在行莫仍没有结束，R将会给出一个不同的提示符，默认的是‘+’。 命令文件的执行和输出转向到文件如果命令存储于一个外部文件中，比如工作目录work中的commands.R，他们可以随时在R的任务中被执行 source(“commands.R”)在Windows中Source也可以由File菜单执行。函数sink，sink(“record.lis”)将把所有后续的输出由终端转向一个外部文件，record.lis。命令sink() 将把信息重新恢复到终端上。 数据的保持与对象的清除R所创建、操作的实体是对象。对象可以是变量、数组、字符串、函数以及由这些元素组成的其它结构； objects() 用来显示目前存储在R中的对象的名字。而当前存储的所有对象的组合被称为workspace；清除对象可以使用rm命令：rm(x, y, z, ink, junk, temp, foo, bar)所有在一个R任务中被创建的对象都可以在文件中被永久保存，并在其它的R任务中被使用。在每个R任务结束时用户都有机会保存当前有效的所有对象。如果用户这样做的话，对象将被写入当前目录一个名为.RData。当R被再次启动时R会从这个文件中再载入workspace。同时相关的命令记录也被载入。所以，推荐大家在用R进行不同的分析时分别使用不同的工作目录。 基本数据结构 数值型(numeric）1,1.2,3.1415926复数型(complex)1+2i字符型(character)‘A’/ “hello world!”逻辑型(logical)TRUE / FALSE 基本数据对象 向量(vector), 见下节矩阵(matrix)：更一般的说数组是向量在多维情况下的一般形式。事实上它们是可以被两个或更多的指标索引的向量，并且以特定的方式被打印出来。因子(factors) 提供了一种处理分类数据的更简介的方式。列表(list)：是向量的一种一般形式，并不需要保证其中的元素都是相同的类型，而且其中的元素经常是向量和列表本身。数据框(data frame)：是一种与矩阵相似的结构，其中的列可以是不同的数据类型。可以把数据框看作一种数据”矩阵”，它的每行是一个观测单位，而且(可能)同时包含数值型和分类的变量。函数( function)：能够在R的workspace中存储的对象。我们可以通过函数来扩展R的功能。二 简单操作，数值与向量2.1 向量与赋值R对命名了的数据结构进行操作。最简单的数据结构是数字向量；如， x &lt;- c(10.4, 5.6, 3.1, 6.4, 21.7) c()是创建函数，赋值运算符是’&lt;-‘，与函数assign()等价assign(“x”, c(10.4, 5.6, 3.1, 6.4, 21.7)) 也可以写成：c(10.4, 5.6, 3.1, 6.4, 21.7) -&gt; x如果一个表达式被当作一个完整的命令，它的值将被打印到终端但不被储存。单独输入x则会将值打印出来。也可以打印倒数：1/xy &lt;- c(x, 0, x) 也可以将向量作为元素。2.2 向量运算 操作是按照向量中的元素一个一个进行的。同一个表达式中的向量并不需要具有相同的长度。如果它们的长度不同,表达式的结果是一个与表达式中最长向量有相同长度的向量。表达式中较短的向量会根据它的长度被重复使用若干次(不一定是整数次)，直到与长度最长的向量相匹配。而常数很明显的将被不断重复。如，v &lt;- 2x + y + 1常用运算有：+，-，，/，^（次方）；log, exp, sin, cos, tan,sqrt等；max和min的作用是选出所给向量中最大的或最小的元素；range函数的值是一个长度为2的向量，即c(min(x),max(x))length(x)返回了向量x中元素的个数，也就是x的长度。sum(x)给出了x中所有元素的总和；prod(x)给出x中所有元素的乘积；mean(x)和var(x)，分别计算样本均值和样本方差，这两个函数分别相当于sum(x)/length(x)，sum((x-mean(x)) ^2)/(length(x) -1)。如果var()的参数是一个np的矩阵，那么函数的值是一个pp的样本协方差矩阵，认为每行是一个p变量的样本向量。sort(x)返回一个与x具有相同长度的向量，其中的元素按招升序排列。还有其他更灵活的排序功能(参见order()和sort.list())。pmax和pmin将返回一个与最长的向量长度相等的向量，向量中的元素由参数中所有向量在相应位置的最大值(最小值)组成；如果要使用复数，需要直接给出一个复数部分。因此sqrt(-17)将会返回NaN(无效数值)和一个警告，而sqrt(-17+0i)将按照复数进行运算。2.3 生成序列最简单的方法是用冒号‘：’，冒号具有最高运算优先级。例如1:30就是向量c(1,2,. . .,29,30)。30:1构造一个递减序列。利用seq()函数构造序列：有五个参数，from, to, by, length, along from, to可以不写参数名，seq(2,10)就相当于2:10。 by指定步长，默认为1，如seq(-5, 5, by=.2)即为c(-5.0, -4.8, -4.6, …, 4.6, 4.8, 5.0) length指定序列长度，如seq(length=51, from=-5, by=.2)，等同于seq(-5, 5, by=.2) along=vector只能单独使用，产生一个“1:length(vector)”序列。类似的函数是rep(),这个函数可以用多种复杂的方法来 复制一个对象。最简单的形式是&gt; s5 &lt;- rep(x, times=5)2.4 逻辑向量 TRUE, FALSE, 和NA(not available), 前两个可以简写为T和F，但T/F并不是系统保留字，可以被用户覆盖，所以最好还是不要简写。逻辑向量是由条件给出的，如下列语句令temp成为一个与x长度相同，相应位置根据是否与条件相符而由TRUE或FALSE组成的向量： temp 13逻辑操作符包括&lt;, &lt;=, &gt;, &gt;=,完全相等==和不等于!=，与或非分别为&amp;, |, !。在普通运算中，FALSE当做0而TRUE当做1。2.5 缺失值NA(not available): 一般来讲一个NA的任何操作都将返回NA。 is.na(x)返回一个与x等长的逻辑向量，并且由相应位置的元素是否是NA来决定这个逻辑向量相应位置的元素是TRUE还是FALSE。 x==NA是一个与x具有相同长度而其所有元素都是NA的向量。NaN(Not a Number): 由数值运算产生，如0/0, Inf-Inf. is.na(x)对于NA和NaN值都返回TRUE， is.nan(x)只对NaN值返回TRUE。2.6 字符向量 字符串在输入时可以使用单引号(‘)或双以号(“); 在打印时用双引号(有时不用引号)。R使用与C语言风格基本相同的转义符, 所以输入\打印的也是\, 输入” 打印引号”, n: 换行, t: tab, b: 回格。字符向量可以通过函数c()连接；paste()可以接受任意个参数，并从它们中逐个取出字符并连成字符串，形成的字符串的个数与参数中最长字符串的长度相同。如果参数中包含数字的话，数字将被强制转化为字符串。在默认情况下，参数中的各字符串是被一个空格分隔的，不过通过参数sep=string 用户可以把它更改为其他字符串，包括空字符串。例如： labs &lt;- paste(c(“X”,”Y”), 1:10, sep=””) 使变量labs成为字符变量c(“X1”, “Y2”, “X3”, “Y4”, “X5”, “Y6”, “X7”, “Y8”, “X9”, “Y10”)2.7 index vector—数据集子集的选择与修改 任何结果为一个向量的表达式都可以通过追加索引向量(index vector)来选择其中的子集。1 逻辑的向量。 y 0] -&gt; z 表示创建一个对象z，其中的元素由向量x+1中与x中的非缺失值和正数对应的向量组成。 正整数的向量x[6] 是x的第六个元素x[1:10] 选取了x的前10个元素(假设x的长度不小于10)。c(“x”,”y”)[rep(c(1,2,2,1), times=4)] 产生了一个字符向量，长度为16，由”x”, “y”, “y”, “x”重复4次而组成。 负整数的向量y &lt;- x[-(1:5)] 表示向量y取向量x前5个元素以外的元素。 字符串的向量只存在于拥有names属性并由它来区分向量中元素的向量。这种情况下一个由名称组成的子向量起到了和正整数的索引向量相同的效果。fruit &lt;- c(5, 10, 1, 20)names(fruit) &lt;- c(“orange”, “banana”, “apple”, “peach”)lunch &lt;- fruit[c(“apple”,”orange”)]子集的修改x[is.na(x)] &lt;- 0 表示将向量x中所以NA元素用0来代替y[y &lt; 0] &lt;- -y[y &lt; 0] 表示将向量(-y)中 与向量y的负元素对应位置的元素 赋值给 向量y中 与向量y负元素对应的元素。作用相当于：y &lt;- abs(y)三 对象，模式和属性3.1 固有属性：模式和长度对象是R所进行操作的实体，对象可以是向量、列表等，详见1.6.对象的模式包括numeri，ccomplex，character，logical，list，function，expression等。可以用mode(object)查看。对象的长度是对象的另一固有属性。可以用length(object)查看。attribute(object)可以查看更深入的属性。模式的转换在允许的情况下(大多数情况都是允许的)，R可以完成各种模式的转换。例如：d&lt;-as.character(z)，将数值向量z&lt;-(0:9)转化为字符向量c(“0”, “1”, “2”, …, “9”)。as.integer(d)将d转化为数值向量。R中很多形式为as.something()的函数，可以完成从一个模式向另一个模式的转化，或者是令对象取得它当前模式不具有的某些属性。3.2 改变对象的长度e &lt;- numeric() 产生一个numeric型的空向量e。character()等类似。此时长度为对象0。此时新添加一个元素会使e的长度自动调整。e[3] &lt;- 17 令e为一个长度为3的向量（此时，该向量的前两个元素都是NA）缩短（截断）一个对象的长度，只需要一个赋值命令。因此，若alpha是一个长度为10的对象，下面的命令alpha &lt;- alpha[2 * 1:5]3.3 属性的获取和设置 函数attributes(object)将给出当前对象所具有的所有非基本属性（长度和模式属于基本属性）的一个列表。函数attr(object,name)可以被用来选取一个指定的属性。除了为某些特殊的目的创建新属性这样特殊的环境下，这些函数很少被用到。当函数attr()用在赋值语句左侧时，既可以是将对象与一种新的属性关联，也可以是对原有属性的更改。例如 attr(z,”dim”) &lt;- c(10,10) 另R将z作为一个10X10的矩阵看待。3.4 对象的类别对象的一个特别属性，类别，被用来指定对象在R编程中的风格。比如：如果对象类别”data.frame”则会以特定方式处理。unclass()可以去除对象的类别。summary()可以查看对象的基本信息（min, max, mean, etc.）四 有序因子和无序因子 因子是一种向量对象，它给自己的组件指定了一个离散的分类（分组），它的组件由其他等长的向量组成。R提供了有序因子和无序因子。通俗点说，因子就是将对象的值分成不同的组（levels）。用函数factor()创建一个因子，levels按序排列(字母序或数值序)。例如province&lt;-c(“四川”,”湖南”,”江苏”,”四川”,”四川”,”四川”,”湖南”,”江苏”,”湖南”,”江苏”)，为province创建因子： pf&lt;-factor(province) 创建province的因子pfpf 打印出来 [1] 四川 湖南 江苏 四川 四川 四川 湖南 江苏 湖南 江苏Levels: 湖南 江苏 四川函数levels()可以用来观察因子中有多少不同的levels。假如我们拥有这些省份考生的分数：score&lt;-c(95,86,84,92,84,79,86,99,85,90)函数tappley()可以用来计算各省的平均分数，函数tapply()的作用是对它第一个参数的组件中所包含的每个组应用一个参数三指定的函数。smeans&lt;-tapply(score,pf,mean)smeans 湖南 江苏 四川85.66667 91.00000 87.50000再例如，下面命令会给出各组的lengthtapply(score,pf,length)湖南 江苏 四川 3 3 4 函数ordered()可以创建有序因子 ordered(province) [1] 四川 湖南 江苏 四川 四川 四川 湖南 江苏 湖南 江苏Levels: 湖南 &lt; 江苏 &lt; 四川 五 数组和矩阵5.1 数组数组可以看成一个由递增下标表示的数据项的集合，例如数值。数组的生成如果一个向量需要在R中以数组的方式被处理，则必须含有一个维数向量作为它的dim属性。维度向量由dim()指定，例如，z是一个由1500个元素组成的向量。下面的赋值语句 dim(z) &lt;- c(3,5,100) 使它具有dim属性，并且将被当作一个3X5X100的数组进行处理。 c(3,5,100) 就是他的维度向量。还可以用到像matrix()和array()这样的函数来赋值。比如array(1:20, dim=c(4,5))matrix(1:24, 3,4)数据向量中的值被赋给数组中的值时，将遵循与FORTRAN相同的原则”主列顺序”，即第一个下标变化的最快，最后的下标变化最慢。数组的运算数组可以在算数表达式中使用，结果也是一个数组，这个数组由数据向量逐个元素的运算后组成，通常参与运算的对象应当具有相同的dim属性。5.2 数组的索引和数组的子块 数组中的单个元素可以通过下标来指定，下标由逗号分隔，写在括号内。我们可以通过在下标的位置给出一个索引向量来指定一个数组的子块，不过如果在任何一个索引位置上给出空的索引向量，则相当于选取了这个下标的全部范围。如a[2,,]，a[,3,]等5.3 索引数组除了索引向量，还可以使用索引数组来指定数组的某些元素。例如：有4X5的数组a，若要得到a中的a[1,3], a[2,2] 和a[3,1]这三个元素，可以生成索引向量i，然后用a[i]得到它们。 a &lt;- array(1:20,dim=c(4,5)) # Generate a 4 by 5 array.i &lt;- array(c(1:3,3:1),dim=c(3,2))i[,1] [,2][1,] 1 3[2,] 2 2[3,] 3 1a[i][1] 9 6 3a[i] &lt;- 0 # 将这三个元素用0替换。5.4 向量，数组的混合运算表达式从左到右被扫描；参与运算的任意对象如果大小不足，都将被重复使用直到与其他参与运算的对象等长；当较短的向量和数组在运算中相遇时，所有的数组必须具有相同的dim属性，否则返回一个错误；如果有任意参与运算的向量比参与运算的矩阵或数组长，将会产生错误；如果数组结构正常声称，并且没有错误或者强制转换被应用于向量上，那么得到的结果与参与运算的数组具有相同的dim属性。5.5 矩阵的运算构建分区矩阵：cbind()和rbind()，cbind()按照水平方向，或者说按列的方式将矩阵连接到一起。rbind()按照垂直的方向，或者说按行的方式将矩阵连接到一起。 外积：操作符是%o%: ab &lt;- a %o% b 或者ab &lt;- outer(a, b, ““)其中的乘法操作可以由任意一个双变量的函数替代。广义转置：函数t(A)，或aperm(A, c(2,1))；获取行数/列数：nrow(A)和ncol(A)分别返回矩阵A的行数和列数。矩阵乘法：操作符为%%；交叉乘积（cross product）：crossprod(X，Y)等同于t(X) %*% y，crossprod(X)等价于crossprod(X, X)；diag(v)：如果v是向量，diag(v)返回一个由v的元素为对角元素的对角矩阵。 如果v为矩阵，diag(v)返回一个由v主对角元素组成的向量。 如果v只是一个数值，那么diag(v)是一个vXv的单位矩阵。 特征值和特征向量：eigen(Sm)。这个函数的结果是由名为values和vectors的两部分组成的列表。如果只是需要特征值：eigen(Sm)$values最小二乘拟合即QR分解：lsfit(), qr()。强制转换为向量：as.vector()，或者直接c().解线性方程和求矩阵的逆，奇异值分解与行列式见；六 列表和数据帧6.1 列表列表是由称作组件的有序对象集合构成的对象。组件的模式或类型不一定相同。形如Lst &lt;- list(name_1=object_1, . . ., name_m=object_m)的赋值将创建一个包含m个组件的列表，并根据参数中指定的名称为其命名。（其名称可以自由选取）。如果它们的名称被省略，组件将只是被编号。例如： Lst &lt;- list(name=”Fred”, wife=”Mary”, no.children=3,child.ages=c(4,7,9))所使用的组件是被复制到新的列表中的，对原始对象没有影响。组件总是被编号的，并且可以通过编号指定。Lst[[1]] 即为”Fred”，也可以用 Lst$name，Lst[[“name”]]指定。如果Lst[[4]]是一个有下标的数组，Lst[[4]][1]就是它的第一项。区分Lst[[1]]和Lst[1]，’[[…]]’是选择单个元素时使用的操作符，而’[…]’是一个一般的下标操作符。因此，前者代表列表Lst中的第一个对象；后者是列表Lst的子列表，仅包含列表的第一项。组件的名称可以缩写，可缩写的程度是只要能令组件被唯一的识别就可以了。如：Lst$na等价于Lst$name， Lst$w等价于Lst$wife。扩展列表可以通过指定额外组件的方式。例如Lst[5] &lt;- list(matrix=Mat)连接列表当连接函数c()的参数为列表时，其结果也是一个模式为列表的对象。由参数中的列表作为组件依次连接而成。list.ABC &lt;- c(list.A, list.B, list.C)6.2 数据帧 数据帧是类别为”data.frame”的列表；数据帧会被当作各列具有不同模式和属性的矩阵。数据帧按照矩阵的方式显示，选取的行或列也按照矩阵的方式来索引。创建数据帧直接创建：那些满足对数据帧的列（组件）限制的对象可以通过函数data.frame来构建成为一个数据帧 t &lt;- data.frame(home=statef, loot=income, shot=incomef)强制转换：如果一个列表的组件与数据帧的限制一致，这个列表就可以通过函数as.data.frame()强制转化为一个数据帧。外部文件：创建数据帧最简单的方法应当是使用read.table()函数从外部文件中读取整个数据帧。数据帧和列表的限制1 组件必须是向量（数值型，字符形，逻辑型），因子，数值矩阵，列表，或其他数据帧；2 矩阵，列表，数据帧向新数据帧提供的变量数分别等于它们的列数，元素数和变量数；3 数值向量，逻辑值和因子在数据帧中保持不变，字符向量将被强制转化为因子，其水平是字符向量中所出现的值；4 数据帧中作为变量的向量结构必须具有相同的长度，而矩阵结构应当具有相同的行大小。 挂接和卸载数据帧当觉得使用’$’引用数据帧元素(如’t$home’)麻烦时，可以进行数据帧挂接 attach(t) 这样可以直接引用数据帧内的元素，而无需’$’，前提是数据帧外没有同名的变量(如name)。挂接后若要对数据帧元素进行赋值操作，仍需用’$’，否则视为赋值给数据帧外的元素。赋值后必须要先卸载(detach)再重新挂接后，新值才可见。detach(t) attach()是具有一般性的函数，即它不仅能够将目录和数据帧挂接在搜索路径上，还能挂接其他类别的对象。特别是模式为”list”的对象可以通过相同的方式挂接： attach(any.old.list)任何被挂接的对象都可以用detach来卸载，通过指定位置编号或者指定名称这样的方式.搜索路径函数search()将显示目前的搜索路径，可以用来查看数据帧/列表的挂接状态。ls()（或objects()）命令可以用来检查搜索路径任意位置上的内容。如：ls(), ls(2), ls(t)R可以在搜索路径中包含至多20个项目,列表和数据帧只能在位置2或更靠后的位置上挂接。 数据帧使用惯例 1 将每个独立的，适当定义的问题所包含的所有变量收入同一个数据帧中，并赋予合适的、易理解、易辨识的名称；2 处理问题时，当相应的数据帧挂接于位置2，同时在第1层工作目录下存放操作的数值和临时变量；3 在结束一次工作之前，将你认为对将来有参考价值的变量通过$标记的形式添加到数据帧里面，然后detach()；4 最后，将工作目录下所有不需要的变量剔除，并且尽量将剩下多余的临时变量都清除干净。这样我们可以很简单的在同一个目录下处理多个问题，而且对每个问题都可以使用x,y,z这样的变量名。七 从文件中读取数据7.1 函数read.table()该函数可以直接将文件中完整的数据帧读入。此时文件要符合特定的格式：1 第一行应当提供数据帧中每个变量的名称；2 每一行(除变量名称行)应包含一个行标号和各变量的值。3 若没有表头(变量名称行)，也没有行标号，只有变量值，则默认变量名称为”v1”,”v2”…4 若有表头，但没有行标号，则可以指定参数header=TRUE.7.2 函数scan()该函数从键盘或文件中读取数据，并存入向量或列表中。 inp &lt;- scan(file, what)第一个参数是文件名,如“test.txt”，若为“”或空，则从键盘读入数据；第二个参数用于确定读入数据的模式。 如：list(“”,0,0) 指定读入到列表中，列表有三项，且列表第一项是字符型，第二三项是数值型。若为0，则指定读入到一个数值向量中，若为“”则指定读入到字符向量中。7.3 内置数据集的读取 R本身提供超过50个数据集，同时在功能包（包括标准功能包）中附带更多的数据集。与S-Plus不同，这些数据即必须通过data函数载入。 data() #获得基本系统提供的数据集列表，然后通过形如data(infert) #来载入名为infert的数据集从其他package中载入数据集data(package=”nls”) #查看nls中数据集data(Puromycin, package=”nls”) #读取nls中Puromycin数据集。用library()挂接package后，它的数据集也自动包含到搜索路径中了。library(nls) #载入package nlsdata() #查看数据集date(Puromycin) #载入Puromycin数据集 7.4 编辑数据在使用一个数据帧或矩阵时，edit提供一个独立的工作表式编辑环境。 xnew &lt;- edit(xold) #对数据集xold进行编辑。并在完成时将改动后的对象赋值给xnewxnew &lt;- edit(data.frame()) #可以通过工作表界面录入新数据。fix()函数用于直接修改已有的对象，等价于 x&lt;-edit(x).八 概率分布8.1 R是一个统计表集合(略读) R提供了一套完整的统计表集合。函数可以对累积分布函数P(X&lt;=x)，概率密度函数，分位函数（对给定的q，求满足P(X&lt;=x) &gt; q的最小x）求值，并根据分布进行模拟。 对于所给的名称，加前缀’d’代表密度(density)，’p’代表CDF，’q’代表分位函数，’r’代表模拟（随即散布）。这几类函数的第一个参数是有规律的，形为dxxx的函数为x，pxxx的函数为q，qxxx的函数为p，rxxx的函数为n（rhyper和rwilcox是特例，他们的第一个参数为nn）。目前为止，非中心参数(non-centrality parameter)仅对CDF和少数几个其他函数有效，细节请参考在线帮助。所有pxxx和qxxx的函数都具有逻辑参数lower.tail和log.p，而所有的dxxx函数都有参数log，这个是我们可以直接通过 pxxx(t, …, lower.tail = FALSE, log.p = TRUE)获取，比如说，累积失效函数（cumulative/integrated hazard function），H(t) =-log(1-F(t))，以及更精确的对数似然（通过dxxx(…, log = TRUE)）。此外，对于来自正态分布，具有学生化样本区间的分布还有ptukey和qtukey这样的函数。下面是一些例子 2-tailed p-value for t distribution2*pt(-2.43, df = 13) upper 1% point for an F(2, 7) distributionqf(0.99, 2, 7)8.2 检测数据集的分布 函数summary和fivenum这两个函数可以给出摘要，后者只给出数值；函数stem可以将数值统计结果以类似直方图的方式显示出来；函数hist()可以绘制直方图；函数density和line可以获得更漂亮的密度图；功能包fun中的ecdf函数能绘制经验累积分布函数；还可以进行拟合正态分布，覆盖拟合CDF；还可以绘制Quantile-quantile (Q-Q)图有助于我们更细致的检测其分布形态；8.3 单样本和两样本检验（略读）九 语句组、循环和条件操作 R是一种表达式语言，也就是说其命令类型只有函数或表达式，并由它们返回一个结果。语句组由花括号‘{ }’确定，此时结果是该组中最后一个能返回值的语句的结果。条件语句 if (expr_1) expr_2 else expr_3其中条件表达式expr1必须返回一个逻辑值，操作符&amp;&amp;和||经常被用于条件部分。&amp;和|与&amp;&amp;，||的区别在于，&amp;和|按照逐个元素的方式进行计算，&amp;&amp;和||对向量的第一个元素进行运算，只有在必需的时候才对第二个参数求值。if/else结构的向量版本是函数ifelse，其形式为ifelse (condition,a,b)，产生函数结果的规则是：如果condition[i]为真，对应a[i]元素；反之对应的是b[i]元素。根据这个原则函数返回一个由a,b中相应元素组成的向量，向量长度与其最长的参数等长。循环语句for (name in expr_1) expr_2其中name是循环变量，expr1是一个向量表达式（通常是1:20这样的序列），而expr2经常是一个表达式语句组，expr2随着name依次取expr1结果向量的值而被多次重复运行。repeat(expr)while(condition) expr break语句可以用来中断任何循环，可能是非正常的中断。而且这是中止repeat循环的唯一方式。next语句可以中止一个特定的循环，跳至下一个.十 编写自己的函数10.1 函数的定义 name &lt;- function(arg_1, arg_2, …) expressionexpression是一个R表达式（通常是表达式语句组），并使用参数arg_i来计算出一个数值，表达式的值就是函数的返回值。函数调用的形式通常都是name(expr1,expr2,…)10.2 定义新的二元操作符可以将函数定义为新的二元操作符：“%!%” &lt;- function(X, y) { … }正如矩阵乘法运算符，%*%，和矩阵外积运算符%o%10.3 指定参数和默认值 如果被调用函数的参数按照”name = obj”的形式给出，那么参数的次序可以是任意的。而且，参数序列可以在开始依次序给出，而将指定名称的参数置于后面。因此，如果由一个函数fun1被定义为 fun1 &lt;- function(data, data.frame, graph, limit) {[function body omitted]}那么函数可以有多种等价的使用方法，例如ans &lt;- fun1(d, df, TRUE, 20)ans &lt;- fun1(d, df, graph=TRUE, limit=20)ans &lt;- fun1(data=d, limit=20, graph=TRUE, data.frame=df)默认值 ：在很多情况下，参数都会被赋予一个普遍适用的默认值。fun1 &lt;- function(data, data.frame, graph=TRUE, limit=20) { … }则函数可以这样被调用ans &lt;- fun1(d, df)此时与上面三种情况等价，也可以这样调用ans &lt;- fun1(d, df, limit=10)此时改变了一个默认值。NOTE：参数可以是任意表达式，甚至可以是包含其他参数的表达式；10.4 额外参数“…” 当需要将一个函数的参数传递给另一个函数时，可以通过包含一个额外的参数”…”实现。fun1 &lt;- function(data, data.frame, graph=TRUE, limit=20, …) {[omitted statements]if (graph)par(pch=”*”, …)[more omissions]}10.5 全局变量和局部变量函数内的赋值都是局部变量，退出函数就丢失了。如果要在函数内进行永久赋值（定义全局变量），需要用到“超赋值”操作符, &lt;&lt;-或者函数assign()。10.6 一些高级示例区组设计的效率因子 (E±ciency factors)删除打印数组中的所有名称递归的数值积分10.7 范畴（Scope） 函数主体内出现的标识(symbol)可以被分为3类；正式参数、局部变量和自由变量。正式参数就是出现在函数参数列表中的参数，他们的值由实际的函数参数与正式参数的绑定（binding）过程决定。局部变量是在参数主体中，由表达式求值过程决定的变量。自由变量为既不是正式参数又不是局部变量的变量。赋值之后自由变量成为局部变量。 在R中，自由变量的值由函数被创建的环境中与其同名的第一个变量值决定（我理解为最近的同名变量），这种方式被称为词汇式范畴(lexical scope)。而在S中，该值由同名的全局变量决定。例如下面的函数cube，在R中cube（2）=8，在S中报错为sq()找不到n。cube &lt;- function(n) {sq &lt;- function() nnnsq()}一个银行账户的例子，详见《R语言笔记》。10.8 定制环境详见《R语言笔记》。10.9 类别，通用函数和对象定位 一个对象的类别(class)决定了他会如何被通用函数(generic function)处理。如果参数本身没有任何类别属性，或者其类别在特定问题中并不满足通用函数的要求，通常会有一个默认的动作被执行。类别机制使用户可以为特定的目的设计和编写通用函数。使用&gt; methods(class=”data.frame”)可以查看数据帧的通用函数。使用&gt; methods(plot)可以查看plot函数能处理的类别。十一 R的统计模型待阅。 十二 图形过程在Windows下用window()命令可以打开图形窗口。12.1 高级绘图命令 高级绘图函数，由函数参数提供数据生成一幅完整的图形。其中适当的坐标轴，标签和标题都自动生成了（除非你另外指定了）。高级绘图命令每次都生成一幅新的图形，清除当前的图形（如果需要的话）。 1 plot()函数 这是一个通用函数：生成图形的类型取决于第一个参数的类型或类别(class)。plot(x,y) plot(xy)：如果x，y是向量，plot(x,y)生成一幅y对x的散点图。用包含两个元素x，y的一个列表或一个两列的矩阵作为一个参数（第二种形式那样的）也能达成相同的效果。plot(x)：如果x是一个时间序列，这个命令生成一个时间序列图，如果x是一个数值型向量，则生成一个向量值对它们向量索引的土，而如果x是一个复向量，则生成一个向量中元素的虚部对实部的图。plot(f) plot(f,y)：f是一个因子对象，y是一个数值型向量。第一种形式生成一个f的条形图；第二种形式生成y对应于f各个水平的箱线图。plot(df) plot( expr) plot(y expr)：df是一个数据帧，y是任意对象，expr是由对象名称组成的列表，分隔符’+’(例如，a + b + c)。前两种形式生成分布式的图形，第一种是数据帧中的变量，第二种是一系列被命名的对象。第三种形式生成y对expr中每个对象的图。2 显示多元数据 如果X是一个数值矩阵或数据帧，下面的命令 pairs(X)生成一个配对的散点图矩阵，矩阵由X中的每列的列变量对其他各列列变量的散点图组成，得到的矩阵中每个散点图行、列长度都是固定的。 当问题涉及到三、四个变量时，使用coplot更好些。如果a和b是数值向量，c是数值向量或因子对象（全都是相同长度的），下面的命令 coplot(a ~ b | c)对应c的某些给定值生成数个a对b的散点图。当c是一个因子时，这个命令也就是对c的每个水平生成a对b的散点图。当c是数值向量的时候，这个数值向量被分为一系列的条件区间（conditioning intervals），对应c的每个区间生成一个a对b的散点图。区间的数量和位置可以通过coplot()的参数given.values来控制，函数co.intervals()也可以用来选择区间。我们也可以使用两个给定变量通过命令coplot(a ~ b | c+d)对c和d的每个联合条件区间生成a对b的散点图。 函数coplot()和pairs()都可以使用参数panel=，这个参数可以用来定制我们得到的图形类型。默认的是points()函数，生成一个散点图，不过通过在参数panel=中提供某些其它的低级图形函数，我们可以生成需要的各种图形。一个很有用的函数例子是panel.smooth()。3 显示图形 qqnorm(x) qqline(x) qqplot(x,y)分布比较图。第一种形式生成向量x对期望正态分数（一个正态记分图），第二个在上面的图上添加一条穿过分布分位点和数据分位点的直线。第三个命令生成x的分位点对y分位点图，用于分别比较它们的分布。hist(x) hist(x,nclass=n) hist(x,breaks=b, . . . )生成数值变量x的直方图。通常会自动选定一个合理的类别数，不过可以通过nclass=参数来指定一个推荐值。或者通过参数breaks=来指定分界点。如果给定了probability=TRUE参数，那么条形图代表相对频数而不是累计数。dotchart(x, . . . )创建一个x中数据的点图(dotchart)。点图中y轴给出x中数据的标签，x轴给出它们的值。它允许对落入某一特定区间的所有数据项方便的进行可视化选择。image(x,y,z, . . . ) contour(x,y,z, . . . ) persp(x,y,z, . . . )生成三个变量的图。函数image是用不同的颜色绘制一些矩形方格来展示z的值，函数contour通过绘制等高线来展示z的值，函数persp绘制一个3D面。4 参数配置 add=TRUE 强制函数按照低级图形函数的方式操作，将图形置于当前图形上（仅对某些函数有效）。axes=FALSE 暂时禁止坐标轴的生成|以便使用axis()函数添加你自己定制的坐标轴。默认情况是axes=TRUE，即包含坐标轴。log=”x” log=”y” log=”xy” 令x,y或者两者全都对数化。这个参数对许多函数都有效，不过不是全部。type= 参数type=控制所生成图形的类型： type=”p” 绘制单独的点（默认值） type=”l” 绘制线 type=”b” 绘制由线连接的点（both） type=”o” 将点绘在线上 type=”h” 绘制从点到零轴的垂线（high-density） type=”s” 阶梯式图。第一种形式中，点由垂线的顶部定义；第二种形式里用底部定义。 type=”n” 不绘制。不过坐标轴是绘出的（默认情况）而且要根据数据绘出坐标系统。用来给后续的低级图形函数创建图形作基础。xlab=string ylab=string x轴或y轴的标签。使用这些参数来改变默认的标签，通常的默认值是调用高级绘图函数时所使用对象的名称。main=string 图表标题，位于图形的顶部，大字体显示。sub=string 子标题，位于x轴下面，用较小的字体显示。12.2 低级绘图命令 有些时候高级绘图函数并不能很精确的生成我们想要的图形。这种情况下，我们可以通过低级绘图命令在当前图形上添加信息（例如，点、线或文本）。points(x,y) lines(x,y)在当前图形上添加点或线。函数plot()的参数type=也可以用于这些函数（默认的是”p”代表points()和”l”代表lines()）。text(x,y,labels, . . . )给定点坐标x,y，在该点添加文本。通常labels是一个整数或字符向量，其中labels[i]出现在点(x[i],y[i])。默认值是1:length(x)。Note： 这个函数通常用于这样的序列中 plot(x, y, type=”n”); text(x, y, names)图形参数type=”n”阻止了点的生成，但是建立了坐标轴，由函数text()提供字符向量names所指定的特定字符。 abline(a, b) abline(h=y) abline(v=x) abline(lm.obj)在当前图上添加一条斜率为b，截距为a的直线。h=y在图形指定的高度上绘制一条贯穿图形的水平线，同样的，v=x在x轴的指定位置绘制一条贯穿的垂线。而lm.obj是一个包含coefficients组件的列表，该组件的长度为2，分别当作截距和斜率。polygon(x, y, . . . )绘制一个多边形，其顶点由(x,y)指定。同时还（可选的）可以加上阴影线，如果图形设备允许的话还可以将多边形填充。legend(x, y, legend, . . . )这当前图形的指定位置添加图例。绘制的字符，线条类型，颜色等等由字符向量legend指定。除此之外至少还要给出一个参数v，与绘图单元的相应值，分别有：legend( , fill=v)填充方框的颜色legend( , col=v)绘制点线的颜色legend( , lty=v)线条类型legend( , lwd=v)线条宽度legend( , pch=v)绘制字符(字符向量) title(main,sub)在当前图形的顶部用大字题添加一个标题main，在底部用较小的字体添加子标题sub。axis(side, . . . )在当前图形的指定边上添加坐标，在哪个边上由第一个参数指定（1到4，从底部按照顺时针顺序）。其他参数控制坐标的位置|在图形内或图形外，以及标记的位置和标签。适合在调用参数为axes=FALSE的函数plot()后添加定制的坐标轴。低级绘图函数通常都需要一些位置信息（例如，x,y坐标）来决定在哪里添加新的元素。坐标以用户坐标(user coordinates)的形式给出，这个坐标系是根据所提供的数据由之前的高级绘图语句定义的。需要x,y参数的地方还可以选用一个单独的参数，即一个由名为x,y的元素组成的列表。相似的，一个两列的矩阵也可以。像locator()（后面会提到）这样的函数也可以按照这种方式交互的指定图形中的位置。添加数学注释某些情况下需要在图形中加入数学符号或公式。在R中可以通过在text, mtext,axis或title中指定一个表达式来实现。例如，下面的代码绘制了二项概率函数的公式： text(x, y, expression_r(paste(bgroup(“(“, atop(n, x), “)”),p^x, q^{n-x})))更多的信息，包括其特性的一个完整列表可以在R中通过下面的命令得到：help(plotmath)example(plotmath)添加Hershey矢量字体help(Hershey)example(Hershey)12.3 图形的交互R提供了函数，使用户可以通过鼠标从图形中释放信息或添加信息。 locator(n,type)等待用户使用鼠标左键在当前图形上选择位置。直到n(默认是512)个点都选完或者点击了鼠标另一个键（Unix,Windows)，在Mac下用鼠标点击图形窗口外的部分也可以结束。参数type的效果和在高级绘图函数中使用时是一样的，即在选择的点绘制指定的图形。默认情况是不绘制图形。函数locator()将所选点的坐标返回到一个列表中，列表包含x,y两个组件。通常locator()在调用的时候并不带参数。这个功能在为图例或标签这样的图形元素选择位置时比较有用，尤其是这些位置不好通过计算得到的时候。举个例子，如果要在一个野点附近添加一些信息，可以使用下面的命令 text(locator(1), “Outlier”, adj=0) identify(x, y, labels)允许用户在x,y（使用鼠标左键）定义的点附近绘制相应的labels的组件（如果没有给出labels就给出该点的序号），突显该点。当鼠标的另一个键被点击时（Unix,Windows）返回被选点的序号，在Mac下通过点击图形窗口外来实现这个效果。有时我们更想确定图形中的点，而非它们的位置。例如，我们可能希望从图示中选出某些感兴趣的观测点，然后进行某些操作。通过两个数值向量x,y给定一系列坐标(x; y)，我们可以使用identify()函数： plot(x,y) &gt; identify(x,y)函数identify()本身不绘图，但是允许用户移动鼠标，在某点附近点击左键。离鼠标指针最近的点将被突显，并标出其序号（也就是它在向量x/y中的位置）。或者使用identify()的labels参数，把某些信息（例如案例名称）作为突显的标志；或者通过plot=FALSE参数取消所有突显标志。当选点的过程结束后，identify()返回所选点的序号；用户可以使用这些序号从x和y中释放所选的点。12.4 使用图形参数 通过图形参数可以定制图形显示的几乎所有方面。R包含大量的图形参数，可以控制的包括线条类型，颜色，图标排列，文本对齐等等。1 持续性变更 (Permanent changes): par()函数 通过par()函数设定图形参数的值会持续性的更改参数的值，也就是说这之后（在当前设备上）所有对图形函数的调用都受到新值的影响。函数par()用于存取和修改当前图形设备的图形参数列表。par()不带任何参数，返回当前设备所有图形参数和它们的值的列表。par(c(“col”,”lty”))参数为一个字符向量，仅返回参数中指定的图形参数（也是作为一个列表）。par(col=4, lty=2)带指定参数（或一个列表型参数），设定指定图形参数的值，并将参数的原始值作为一个列表返回。所以如果想设定参数绘制一些图形后再恢复成原来的设定，可以这么做： oldpar &lt;- par(col=4, lty=2). . . plotting commands . . .par(oldpar)2 临时性变更：图形函数的参数 图形参数也可以作为（几乎）所有图形函数的命名参数。这种方式的效果和用于par()函数的效果是一样的，只不过这种改变只在函数调用的区间内有效。比如： plot(x, y, pch=”+”)生成一个以加号作为绘图符号的散点图，而不改变后续图形的默认的绘图符号。3 图形参数列表A 图形元素R图表由点、线、文本和多边形（填充区）组成。下面的图形参数控制了图形元素的绘制：pch=”+” 用来绘点的字符。这个默认值随不同的图形驱动是不同的，不过通常都是’±’。除非使用”.”作为绘图字符，否则绘制的点都会比适当的位置高一点或者低一点，而不是恰好在指定位置。pch=4当给定一个0到18的整数时，会生成一个特殊的绘图符号。通过下面的命令可以看这些符号都有什么。legend(locator(1), as.character(0:18), pch=0:18)lty=2 线条类型。并不是所有图形设备都支持多种线条类型（在那些支持的设备上也不全一样），不过线条类型1始终是实线，2及以上的是点、划线或者它们的组合。lwd=2 线条宽度。所需的线条宽度，是”标准”线条宽度的倍数。对line()等函数绘制的线条和坐标轴都有效果。col=2 点、线、文本、填充区和图像使用的颜色。每种图形元素都有其可用的颜色列表，这个参数的值就是颜色在列表中的序号。显然，这个参数值对有限的一类设备有效。font=2 指定文本所使用字体的一个整数。如果可能的话，设备驱动会把1对应普通文本，2对应粗体，3对应斜体，4对应粗斜体。font.axis font.lab font.main font.sub 这几个参数分别指定坐标轴注释，x,y轴的标签，主、副标题所用的字体。adj=-0.1 文本对齐和绘图位置有关。0代表左对齐，1代表右对齐，0.5代表水平的中间位置。当前的值使会图位置到左端距离的比例，所以-0.1在文本和绘图位置之间留10%的空白。cex=1.5 字符缩放。这个值是所需文本字符（包括绘图字符）的大小，与默认文本大小相关。B 坐标轴和标记很多R的高级图形都有坐标轴，你可以使用低级图形函数axis()自己创建坐标轴。坐标轴包含三个主要组件：轴线axis line（线条类型由参数lty控制），标记tick mark（沿着轴线划分单元），标号tick label（用来标出这些单元）。这些组件可以用下面这些参数定制。lab=c(5,7,12)前两个数字分别是x和y轴上所要划分的区间数。第三个数字是坐标轴标签的长度，用字符数来衡量（包括小数点）。参数的值如果选得太小可能导致所有标号都聚在一起。las=1 坐标轴标签的方向。0代表总是和坐标轴平行，1代表总是水平的，2代表总是垂直于坐标轴。mgp=c(3,1,0)坐标轴组件的位置。第一个组件是坐标轴标签到坐标轴的距离，单位是文本行(text lines)。第二个组件是到标号的距离，最后一个是轴的巍直到轴线的距离（一般都是0）。正数代表绘图区域外，负数代表区域内。tck=0.01 标号的长度，绘图区域大小的一个分数作单位。当tck比较小时（小于0.5），就强制x和y轴上的标记为相同大小。tck=1就是生成网格线。取负值时标记画向绘图区域外。内部标记可以使用tck=0.01和mgp=c(1,-1.5,0)。xaxs=”s” yaxs=”d” 分别是x、y轴的类型。如果是s(standard)或e(extended)类型，那最大和最小的标记都始终在数据区域之外。如果有某个点离边界非常近，那么扩展型(extended)的轴会稍稍扩展一下。这种类型的轴有时会在边界附近留出大片空白。而i(internal)或r(默认值)类型的轴，标记始终在数据区域内，不过r类型会在边界留出少量空白。如果这个参数设为d，就锁定当前轴，对之后绘制的所有图形都用这个轴（直到参数被重新设定为其他的那几个值）。这个参数适用于生成一系列固定尺度的图。C 图边缘（Figure margins）在R中一个单独图形，图（figure），包含一个绘图区(plot region)，以及环绕着这个区域的边缘（其中可能含有坐标轴标签、标题等等），（通常）这两部分以轴为边界。一个典型的图是 控制图的样式的图形参数包括：mai=c(1,0.5,0.5,0)分别是底部，左侧，顶部，右侧的宽度，单位是英寸。mar=c(4,2,2,1)与mai相似，只是单位是文本行(text lines)。由于更改一个就会改变另一个的值，所以在这个意义上，mai和mar是等价的。这个参数的默认值通常都太大了；右侧边缘很少用到，如果没标题，顶部边缘也不需要，左侧和底部的边缘应当足够大，以容纳坐标轴和标号。此外，默认值并没有考虑到设备表面的大小：比如，使用postscript()驱动，height=4参数时，除非用mar，mai另外设定，否则图的边缘就要占上大约50%。使用多图环境时（后面会提到）。边缘会减少一半，不过这在多图共用一页的时候可能还不够。D 多图环境R允许在一页上创建一个n£m的图的阵列。每个图由自己的边缘，图的阵列还有一个可选的外部边缘，如下图所示。 与多图环境相关的图形参数有：mfcol=c(3, 2) mfrow=c(2, 4) 设定多图阵列的大小。第一个值是行数，第二个值是列数。这两个参数唯一的区别是mfcol把图按列排入，mfrow把图按行排入。上图所示的版式可用mfrow=c(3,2)创建；上图显示的是绘制四幅图后的情况。mfg=c(2, 2, 3, 2) 当前图在多图环境下的位置。前两个数字是当前图的行、列数；后两个是其在多图阵列中的行列数。这个参数用来在多图阵列中跳转。你甚至可以在后两个数中使用和真值(true value)不同的值，在同一页上得到大小不同的图。fig=c(4, 9, 1, 4)/10 当前图在页面的位置，取值分别是左下角到左边界，右边界，下、上边界的距离与对应边的百分比数。给出的例子是一个页面右下角的图。这个参数可以设定图在页面的绝对位置。oma=c(2, 0, 3, 0) omi=(0, 0, 0.8, 0) 外部边缘的大小。与mar和mai相似，第一个用文本行作单位，第二个以英寸作单位，从下方开始按照顺时针顺序指定。外部边缘对页标题这类东西很有用。文本可以通过带outer=TRUE参数的mtext()函数加入外部边缘。默认情况下是没有外部边缘的因此必须通过oma或omi指定。函数split.screen()和layout()可以对多个图形作更复杂的排列。12.6 设备驱动 R几乎可以在任何一种类型的显示器和打印设备上生成（不同质量的）图形。不过，在这之前，需要告诉R要处理的是哪一种设备。这通过启动一个设备驱动来完成。设备驱动通过调用设备驱动函数来启动。某些常用的设备驱动有：X11()[Unix] 使用X11视窗系统windows()[Windows] 使用 Windows 视窗系统postscript()在PostScript打印机上打印或者创建PostScript图形文件pictex()生成一个LATEX文件当一个设备使用完之后，可以通过下面的命令终止设备驱动 dev.off()这个命令可以确保设备已经结束；例如，在某些硬拷贝的设备中，这个命令可以保证每页都已经完成，并且都被传送到打印机了。PostScript文档通过给postscript()函数带上file参数，我们可以把图形以PostScript格式存储到文件中。如果没有给出horizontal=FALSE参数，图形是横向的，你可以通过width和height参数控制图形的大小（图形会自动适应）。例如，命令postscript(“file.ps”, horizontal=FALSE, height=5, pointsize=10)为一个五英寸的图生成一个包含PostScript代码的文件，可以放在文当中。如果命令中的指定的文件名已经存在，将会被覆盖。多重图形设备每个对设备驱动的新调用都会打开一个新的图形设备，在设备列表中加入新的一项。这个设备就成为当前设备，图形输出就传送到这个设备。dev.list() 返回所有活动中设备的序号和名称。在列表位置1的设备始终是空设备(null device)，这个设备不接收任何图形命令。dev.next() dev.prev() 分别返回当前设备的后一个和前一个设备的序号和名称。dev.set(which=k) 用来把当前设备更改为设备列表中位置k的那个。返回设备的序号和标签。dev.off(k) 终止图形列表位置k的那个图形设备。对于某些设备，比如postscript，这个命令会立刻打印文件或者正常结束文件，具体怎样处理取决于设备是怎样初始化的。dev.copy(device,. . . ,which=k) dev.print(device,. . . ,which=k)建立一个设备k的拷贝。其中device是一个设备函数，例如postscript，如果需要的话可以在’. . . ‘中指定其它的参数，dev.print效果相似，不过复制的设备会立刻关闭，所以打印硬拷贝这样的终止操作也会被立即执行。graphics.off() 终止列表中的所有图形设备，空设备除外。 (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/20/R笔记(1)/]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>初级</tag>
        <tag>可视化</tag>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[J微信时代，博客阅读]]></title>
    <url>%2F2017%2F09%2F20%2F%E5%BE%AE%E4%BF%A1%E6%97%B6%E4%BB%A3%EF%BC%8C%E5%8D%9A%E5%AE%A2%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[博客沒有消失，只是变成了知乎，微博了而已先来看一下博客的定义：博客，英文名为Blogger,为WebLog的混成词。它的正式名称为网络日记，是一种通常由个人管理、不定期张贴新的文章的网站。许多博客专注在特定的课题上提供评论或新闻，其他则被作为个人的日记。比较著名的有新浪、网易等博客。 随着互联网的发展，曾经的博客渐渐的变得无人问津。 博客是否会退出历史舞台？或者博客未来可能会变什么样? 很多人批评「碎片化阅读」，我却觉得碎片化阅读是社会的一个救星。微信的一个巨大功劳，是将阅读重新送回日常生活，提供了碎片化阅读的最好机会。因为人们此前根本连碎片化的阅读都逐渐失去了。我看到朋友圈所有人都在转各种文章，我的一些从不阅读的亲友，如今开始阅读一些短小的内容。这些阅读都是微信重新送回来的。 我们反对的是碎片化阅读，不是利用碎片化时间来阅读。利用零散时间阅读，这是一个可以充分利用时间的表现。我们反对的碎片化阅读指的是浮浅和无视语境的阅读。这和长短无关，和读者有没有整体性的视角有关。 而博客给了我们记录自己的生活，学习，常常都是很用心写出来的文章。是看了某部电影的感受，学习了某个小技术的总结或应用，是生活的记录，长长的文字，是我们的经历。 但我们过十年二十年以后，看看自己的博客（希望还在），毕竟是自己的故事，当时的所见所感，不论发自肺腑，大体是暗合心境的，我们的记录翻开的时候就是现在的我与过去的我的相遇，相视一笑。 随着微博，语音记录等新事物的出现，博客面临着巨大的挑战。据研究报告显示，现今博客用户数量大幅减少，但趋于平稳。也就是说有一批博客的忠实用户存在着。年轻人从16到20出头的年轻人几乎不使用博客。其主要用户是那些30岁左右至40岁左右的人。博客是否会消失主要取决于它自身如何演化。如果把知乎这样的算作博客的话，那这个演化其实已经开始了。博客不会消失，只是不知道变了身的博客对你来说是不是还叫博客而已。 所以博客沒有消失，只是变成了知乎，微博了而已。 (function(){ var appid = 'cysmzRdbl'; var conf = 'prod_7c789e58c2fd9306e64aff79a862b4df'; var width = window.innerWidth || document.documentElement.clientWidth; if (width < 960) { window.document.write(''); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/20/微信时代，博客阅读/]]></content>
      <categories>
        <category>感想</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>感想</tag>
        <tag>写作</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[J微信时代，博客阅读]]></title>
    <url>%2F2017%2F09%2F20%2F%E5%BE%AE%E4%BF%A1%E6%97%B6%E4%BB%A3%EF%BC%8C%E5%8D%9A%E5%AE%A2%E9%98%85%E8%AF%BB(1)%2F</url>
    <content type="text"><![CDATA[博客沒有消失，只是变成了知乎，微博了而已先来看一下博客的定义：博客，英文名为Blogger,为WebLog的混成词。它的正式名称为网络日记，是一种通常由个人管理、不定期张贴新的文章的网站。许多博客专注在特定的课题上提供评论或新闻，其他则被作为个人的日记。比较著名的有新浪、网易等博客。 随着互联网的发展，曾经的博客渐渐的变得无人问津。 博客是否会退出历史舞台？或者博客未来可能会变什么样? 很多人批评「碎片化阅读」，我却觉得碎片化阅读是社会的一个救星。微信的一个巨大功劳，是将阅读重新送回日常生活，提供了碎片化阅读的最好机会。因为人们此前根本连碎片化的阅读都逐渐失去了。我看到朋友圈所有人都在转各种文章，我的一些从不阅读的亲友，如今开始阅读一些短小的内容。这些阅读都是微信重新送回来的。 我们反对的是碎片化阅读，不是利用碎片化时间来阅读。利用零散时间阅读，这是一个可以充分利用时间的表现。我们反对的碎片化阅读指的是浮浅和无视语境的阅读。这和长短无关，和读者有没有整体性的视角有关。 而博客给了我们记录自己的生活，学习，常常都是很用心写出来的文章。是看了某部电影的感受，学习了某个小技术的总结或应用，是生活的记录，长长的文字，是我们的经历。 但我们过十年二十年以后，看看自己的博客（希望还在），毕竟是自己的故事，当时的所见所感，不论发自肺腑，大体是暗合心境的，我们的记录翻开的时候就是现在的我与过去的我的相遇，相视一笑。 随着微博，语音记录等新事物的出现，博客面临着巨大的挑战。据研究报告显示，现今博客用户数量大幅减少，但趋于平稳。也就是说有一批博客的忠实用户存在着。年轻人从16到20出头的年轻人几乎不使用博客。其主要用户是那些30岁左右至40岁左右的人。博客是否会消失主要取决于它自身如何演化。如果把知乎这样的算作博客的话，那这个演化其实已经开始了。博客不会消失，只是不知道变了身的博客对你来说是不是还叫博客而已。 所以博客沒有消失，只是变成了知乎，微博了而已。 (function(){ var appid = 'cysmzRdbl'; var conf = 'prod_7c789e58c2fd9306e64aff79a862b4df'; var width = window.innerWidth || document.documentElement.clientWidth; if (width < 960) { window.document.write(''); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/09/20/微信时代，博客阅读(1)/]]></content>
      <categories>
        <category>感想</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>感想</tag>
        <tag>写作</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Websocket协议入门]]></title>
    <url>%2F2017%2F06%2F29%2FWebsocket(1)%2F</url>
    <content type="text"><![CDATA[WebSocket WebSocket是HTML5新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。 WebSocket协议WebSocket并不是全新的协议，而是利用了HTTP协议来建立连接。我们来看看WebSocket连接是如何创建的。 首先，WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求，格式如下：1234567GET ws://localhost:3000/ws/chat HTTP/1.1Host: localhostUpgrade: websocketConnection: UpgradeOrigin: http://localhost:3000Sec-WebSocket-Key: client-random-stringSec-WebSocket-Version: 13 该请求和普通的HTTP请求有几点不同： GET请求的地址不是类似/path/，而是以ws://开头的地址；请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接；Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据；Sec-WebSocket-Version指定了WebSocket的协议版本。 随后，服务器如果接受该请求，就会返回如下响应：1234HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: server-random-string 该响应代码101表示本次连接的HTTP协议即将被更改，更改后的协议就是Upgrade: websocket指定的WebSocket协议。 版本号和子协议规定了双方能理解的数据格式，以及是否支持压缩等等。如果仅使用WebSocket的API，就不需要关心这些。 为什么WebSocket连接可以实现全双工通信而HTTP连接不行呢？实际上HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但是HTTP协议的请求－应答机制限制了全双工通信。 安全的WebSocket连接机制和HTTPS类似。首先，浏览器用wss://xxx创建WebSocket连接时，会先通过HTTPS创建安全的连接，然后，该HTTPS连接升级为WebSocket连接，底层通信走的仍然是安全的SSL/TLS协议。 浏览器很显然，要支持WebSocket通信，浏览器得支持这个协议，这样才能发出ws://xxx的请求。目前，支持WebSocket的主流浏览器如下： Chrome Firefox IE &gt;= 10 Sarafi &gt;= 6 Android &gt;= 4.4 iOS &gt;= 8 服务器由于WebSocket是一个协议，服务器具体怎么实现，取决于所用编程语言和框架本身。Node.js本身支持的协议包括TCP协议和HTTP协议，要支持WebSocket协议，需要对Node.js提供的HTTPServer做额外的开发。已经有若干基于Node.js的稳定可靠的WebSocket实现，我们直接用npm安装使用即可。 使用wsws模块在Node.js中，使用最广泛的WebSocket模块是ws，我们创建一个hello-ws的文件夹，然后在package.json(自己创建）中添加ws的依赖：123&quot;dependencies&quot;: &#123; &quot;ws&quot;: &quot;1.1.1&quot;&#125; package.json文件完整内容：12345678910111213141516171819202122&#123; &quot;name&quot;: &quot;hello-ws&quot;, &quot;version&quot;: &quot;3.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;app.js&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node app.js&quot; &#125;, &quot;keywords&quot;: [ &quot;koa&quot;, &quot;async&quot; ], &quot;author&quot;: &quot;Michael Liao&quot;, &quot;license&quot;: &quot;Apache-2.0&quot;, &quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://github.com/michaelliao/learn-javascript.git&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;ws&quot;: &quot;1.1.1&quot; &#125;&#125; 整个工程结构如下： 1234567hello-ws/|+- app.js &lt;-- 启动js文件|+- package.json &lt;-- 项目描述文件|+- node_modules/ &lt;-- npm安装的所有依赖包 运行npm install后，我们就可以在app.js中编写WebSocket的服务器端代码。 创建一个WebSocket的服务器实例非常容易：123456789101112131415161718192021// 导入WebSocket模块:const WebSocket = require(&apos;ws&apos;);// 引用Server类:const WebSocketServer = WebSocket.Server;// 实例化:const wss = new WebSocketServer(&#123; port: 3000&#125;);wss.on(&apos;connection&apos;, function (ws) &#123; console.log(`[SERVER] connection()`); ws.on(&apos;message&apos;, function (message) &#123; console.log(`[SERVER] Received: $&#123;message&#125;`); ws.send(`ECHO: $&#123;message&#125;`, (err) =&gt; &#123; if (err) &#123; console.log(`[SERVER] error: $&#123;err&#125;`); &#125; &#125;); &#125;)&#125;); 如果有WebSocket请求接入，wss对象可以响应connection事件来处理这个WebSocket. 在connection事件中，回调函数会传入一个WebSocket的实例，表示这个WebSocket连接。对于每个WebSocket连接，我们都要对它绑定某些事件方法来处理不同的事件。这里，我们通过响应message事件，在收到消息后再返回一个ECHO: xxx的消息给客户端。 创建WebSocket连接现在，这个简单的服务器端WebSocket程序就编写好了。如何真正创建WebSocket并且给服务器发消息呢？方法是在浏览器中写JavaScript代码。 在命令行用npm start或node app.js执行。然后，打开可以执行JavaScript代码的浏览器Console，依次输入代码：1234567// 打开一个WebSocket:var ws = new WebSocket(&apos;ws://localhost:3000/test&apos;);// 响应onmessage事件:ws.onmessage = function(msg) &#123; console.log(msg); &#125;;// 给服务器发送一个字符串:ws.send(&apos;Hello!&apos;); 一切正常的话，可以看到Console的输出如下：1MessageEvent &#123;isTrusted: true, data: &quot;ECHO: Hello!&quot;, origin: &quot;ws://localhost:3000&quot;, lastEventId: &quot;&quot;, source: null…&#125; 这样，我们就在浏览器中成功地收到了服务器发送的消息！ 如果嫌在浏览器中输入JavaScript代码比较麻烦，我们还可以直接用ws模块提供的WebSocket来充当客户端。换句话说，ws模块既包含了服务器端，又包含了客户端。 ws的WebSocket就表示客户端，它其实就是WebSocketServer响应connection事件时回调函数传入的变量ws的类型。 客户端的写法如下：123456789101112let ws = new WebSocket(&apos;ws://localhost:3000/test&apos;);// 打开WebSocket连接后立刻发送一条消息:ws.on(&apos;open&apos;, function () &#123; console.log(`[CLIENT] open()`); ws.send(&apos;Hello!&apos;);&#125;);// 响应收到的消息:ws.on(&apos;message&apos;, function (message) &#123; console.log(`[CLIENT] Received: $&#123;message&#125;`);&#125; 在Node环境下，ws模块的客户端可以用于测试服务器端代码，否则，每次都必须在浏览器执行JavaScript代码。 同源策略从上面的测试可以看出，WebSocket协议本身不要求同源策略（Same-origin Policy），也就是某个地址为http://a.com的网页可以通过WebSocket连接到ws://b.com。但是，浏览器会发送Origin的HTTP头给服务器，服务器可以根据Origin拒绝这个WebSocket请求。所以，是否要求同源要看服务器端如何检查。 路由还需要注意到服务器在响应connection事件时并未检查请求的路径，因此，在客户端打开ws://localhost:3000/any/path可以写任意的路径。 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/29/Websocket(1)/]]></content>
      <categories>
        <category>Node</category>
        <category>WebSocket</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>http</tag>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Websocket协议入门]]></title>
    <url>%2F2017%2F06%2F29%2FWebsocket%2F</url>
    <content type="text"><![CDATA[WebSocket WebSocket是HTML5新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。 WebSocket协议WebSocket并不是全新的协议，而是利用了HTTP协议来建立连接。我们来看看WebSocket连接是如何创建的。 首先，WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求，格式如下：1234567GET ws://localhost:3000/ws/chat HTTP/1.1Host: localhostUpgrade: websocketConnection: UpgradeOrigin: http://localhost:3000Sec-WebSocket-Key: client-random-stringSec-WebSocket-Version: 13 该请求和普通的HTTP请求有几点不同： GET请求的地址不是类似/path/，而是以ws://开头的地址；请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接；Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据；Sec-WebSocket-Version指定了WebSocket的协议版本。 随后，服务器如果接受该请求，就会返回如下响应：1234HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: server-random-string 该响应代码101表示本次连接的HTTP协议即将被更改，更改后的协议就是Upgrade: websocket指定的WebSocket协议。 版本号和子协议规定了双方能理解的数据格式，以及是否支持压缩等等。如果仅使用WebSocket的API，就不需要关心这些。 为什么WebSocket连接可以实现全双工通信而HTTP连接不行呢？实际上HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但是HTTP协议的请求－应答机制限制了全双工通信。 安全的WebSocket连接机制和HTTPS类似。首先，浏览器用wss://xxx创建WebSocket连接时，会先通过HTTPS创建安全的连接，然后，该HTTPS连接升级为WebSocket连接，底层通信走的仍然是安全的SSL/TLS协议。 浏览器很显然，要支持WebSocket通信，浏览器得支持这个协议，这样才能发出ws://xxx的请求。目前，支持WebSocket的主流浏览器如下： Chrome Firefox IE &gt;= 10 Sarafi &gt;= 6 Android &gt;= 4.4 iOS &gt;= 8 服务器由于WebSocket是一个协议，服务器具体怎么实现，取决于所用编程语言和框架本身。Node.js本身支持的协议包括TCP协议和HTTP协议，要支持WebSocket协议，需要对Node.js提供的HTTPServer做额外的开发。已经有若干基于Node.js的稳定可靠的WebSocket实现，我们直接用npm安装使用即可。 使用wsws模块在Node.js中，使用最广泛的WebSocket模块是ws，我们创建一个hello-ws的文件夹，然后在package.json(自己创建）中添加ws的依赖：123&quot;dependencies&quot;: &#123; &quot;ws&quot;: &quot;1.1.1&quot;&#125; package.json文件完整内容：12345678910111213141516171819202122&#123; &quot;name&quot;: &quot;hello-ws&quot;, &quot;version&quot;: &quot;3.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;app.js&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node app.js&quot; &#125;, &quot;keywords&quot;: [ &quot;koa&quot;, &quot;async&quot; ], &quot;author&quot;: &quot;Michael Liao&quot;, &quot;license&quot;: &quot;Apache-2.0&quot;, &quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://github.com/michaelliao/learn-javascript.git&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;ws&quot;: &quot;1.1.1&quot; &#125;&#125; 整个工程结构如下： 1234567hello-ws/|+- app.js &lt;-- 启动js文件|+- package.json &lt;-- 项目描述文件|+- node_modules/ &lt;-- npm安装的所有依赖包 运行npm install后，我们就可以在app.js中编写WebSocket的服务器端代码。 创建一个WebSocket的服务器实例非常容易：123456789101112131415161718192021// 导入WebSocket模块:const WebSocket = require(&apos;ws&apos;);// 引用Server类:const WebSocketServer = WebSocket.Server;// 实例化:const wss = new WebSocketServer(&#123; port: 3000&#125;);wss.on(&apos;connection&apos;, function (ws) &#123; console.log(`[SERVER] connection()`); ws.on(&apos;message&apos;, function (message) &#123; console.log(`[SERVER] Received: $&#123;message&#125;`); ws.send(`ECHO: $&#123;message&#125;`, (err) =&gt; &#123; if (err) &#123; console.log(`[SERVER] error: $&#123;err&#125;`); &#125; &#125;); &#125;)&#125;); 如果有WebSocket请求接入，wss对象可以响应connection事件来处理这个WebSocket. 在connection事件中，回调函数会传入一个WebSocket的实例，表示这个WebSocket连接。对于每个WebSocket连接，我们都要对它绑定某些事件方法来处理不同的事件。这里，我们通过响应message事件，在收到消息后再返回一个ECHO: xxx的消息给客户端。 创建WebSocket连接现在，这个简单的服务器端WebSocket程序就编写好了。如何真正创建WebSocket并且给服务器发消息呢？方法是在浏览器中写JavaScript代码。 在命令行用npm start或node app.js执行。然后，打开可以执行JavaScript代码的浏览器Console，依次输入代码：1234567// 打开一个WebSocket:var ws = new WebSocket(&apos;ws://localhost:3000/test&apos;);// 响应onmessage事件:ws.onmessage = function(msg) &#123; console.log(msg); &#125;;// 给服务器发送一个字符串:ws.send(&apos;Hello!&apos;); 一切正常的话，可以看到Console的输出如下：1MessageEvent &#123;isTrusted: true, data: &quot;ECHO: Hello!&quot;, origin: &quot;ws://localhost:3000&quot;, lastEventId: &quot;&quot;, source: null…&#125; 这样，我们就在浏览器中成功地收到了服务器发送的消息！ 如果嫌在浏览器中输入JavaScript代码比较麻烦，我们还可以直接用ws模块提供的WebSocket来充当客户端。换句话说，ws模块既包含了服务器端，又包含了客户端。 ws的WebSocket就表示客户端，它其实就是WebSocketServer响应connection事件时回调函数传入的变量ws的类型。 客户端的写法如下：123456789101112let ws = new WebSocket(&apos;ws://localhost:3000/test&apos;);// 打开WebSocket连接后立刻发送一条消息:ws.on(&apos;open&apos;, function () &#123; console.log(`[CLIENT] open()`); ws.send(&apos;Hello!&apos;);&#125;);// 响应收到的消息:ws.on(&apos;message&apos;, function (message) &#123; console.log(`[CLIENT] Received: $&#123;message&#125;`);&#125; 在Node环境下，ws模块的客户端可以用于测试服务器端代码，否则，每次都必须在浏览器执行JavaScript代码。 同源策略从上面的测试可以看出，WebSocket协议本身不要求同源策略（Same-origin Policy），也就是某个地址为http://a.com的网页可以通过WebSocket连接到ws://b.com。但是，浏览器会发送Origin的HTTP头给服务器，服务器可以根据Origin拒绝这个WebSocket请求。所以，是否要求同源要看服务器端如何检查。 路由还需要注意到服务器在响应connection事件时并未检查请求的路径，因此，在客户端打开ws://localhost:3000/any/path可以写任意的路径。 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/29/Websocket/]]></content>
      <categories>
        <category>Node</category>
        <category>WebSocket</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>http</tag>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js复习]]></title>
    <url>%2F2017%2F06%2F29%2Fnode-document(1)%2F</url>
    <content type="text"><![CDATA[前阵子学习了Node，已经了解了Node的基本知识，并安装了node，npm，了解了怎么去运行，现在这篇是复习一下node。 Node(复习） Node.js:基于JavaScript语言和V8引擎的开源Web服务器项目 在Node上运行的JavaScript相比其他后端开发语言有何优势？ 最大的优势是借助JavaScript天生的事件驱动机制加V8高性能引擎，使编写高性能Web服务轻而易举。其次，JavaScript语言本身是完善的函数式语言,在Node环境下，通过模块化的JavaScript代码，加上函数式编程，并且无需考虑浏览器兼容性问题，直接使用最新的ECMAScript 6标准，可以完全满足工程上的需求。 io.js，这又是什么鬼？ io.js是“尝鲜版”，而Node.js是线上稳定版，相当于Fedora Linux和RHEL的关系。 #npm npm其实是Node.js的包管理工具（package manager）。 为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。 更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。 第一个Node程序选择一个目录，例如F:\Node，把文件保存为hello.js，就可以打开命令行窗口，把当前目录切换到hello.js所在目录，然后输入以下命令运行这个程序了：12F:\Node&gt;node hello.jsHello, world. 也可以保存为别的名字，比如first.js，但是必须要以.js结尾。此外，文件名只能是英文字母、数字和下划线的组合。 命令行模式和Node交互模式 请注意区分命令行模式和Node交互模式。 看到类似C:>是在Windows提供的命令行模式： 看到&gt;是在Node交互式环境下： 在Node交互式环境下，我们可以输入JavaScript代码并立刻执行。 使用严格模式如果在JavaScript文件开头写上&#39;use strict&#39;;，那么Node在执行该JavaScript时将使用严格模式。但是，在服务器环境下，如果有很多JavaScript文件，每个文件都写上’use strict’;很麻烦。我们可以给Nodejs传递一个参数，让Node直接为所有js文件开启严格模式： 1node --use_strict 给指定文件开启严格模式：1node --use_strict 文件名(例如:hello.js) 模块 在Node环境中，一个.js文件就称之为一个模块（module）。 使用模块有什么好处？ 最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。 使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。 比如，我们编写了一个hello.js文件，这个hello.js文件就是一个模块，模块的名字就是文件名（去掉.js后缀），所以hello.js文件就是名为hello的模块。 123456789&apos;use strict&apos;;var s = &apos;Hello&apos;;function greet(name) &#123; console.log(s + &apos;, &apos; + name + &apos;!&apos;);&#125;module.exports = greet; 函数greet()是我们在hello模块中定义的，你可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数greet作为模块的输出暴露出去，这样其他模块就可以使用greet函数了。 问题是其他模块怎么使用hello模块的这个greet函数呢？我们再编写一个main.js文件，调用hello模块的greet函数：12345678&apos;use strict&apos;;// 引入hello模块:var greet = require(&apos;./hello&apos;);var s = &apos;Michael&apos;;greet(s); // Hello, Michael! 注意到引入hello模块用Node提供的require函数：1var greet = require(&apos;./hello&apos;); 引入的模块作为变量保存在greet变量中，那greet变量到底是什么东西？其实变量greet就是在hello.js中我们用module.exports = greet;输出的greet函数。所以，main.js就成功地引用了hello.js模块中定义的greet()函数，接下来就可以直接使用它了。 在使用require()引入模块的时候，请注意模块的相对路径。因为main.js和hello.js位于同一个目录，所以我们用了当前目录.：1var greet = require(&apos;./hello&apos;); // 不要忘了写相对目录! 如果只写模块名：1var greet = require(&apos;hello&apos;); 则Node会依次在内置模块、全局模块和当前模块下查找hello.js，你很可能会得到一个错误： module.js throw err; ^ Error: Cannot find module &apos;hello&apos; at Function.Module._resolveFilename at Function.Module._load ... at Function.Module._load at Function.Module.runMain 遇到这个错误，你要检查： 模块名是否写对了； 模块文件是否存在； 相对路径是否写对了。 CommonJS规范这种模块加载机制被称为CommonJS规范。在这个规范下，每个.js文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突，例如，hello.js和main.js都申明了全局变量var s = ‘xxx’，但互不影响。 小结：要在模块中对外输出变量，用 module.exports = variable; 输出的变量可以是任意对象、函数、数组等等。 要引入其他模块输出的对象，用： var foo = require(&apos;other_module&apos;); 深入了解模块原理 JavaScript语言本身并没有一种模块机制来保证不同模块可以使用相同的变量名。 其实要实现“模块”这个功能，并不需要语法层面的支持。Node.js也并不会增加任何JavaScript语法。实现“模块”功能的奥妙就在于JavaScript是一种函数式编程语言，它支持闭包。如果我们把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。 请注意我们编写的hello.js代码是这样的： var s = &apos;Hello&apos;; var name = &apos;world&apos;; console.log(s + &apos; &apos; + name + &apos;!&apos;); Node.js加载了hello.js后，它可以把代码包装一下，变成这样执行： (function () { // 读取的hello.js代码: var s = &apos;Hello&apos;; var name = &apos;world&apos;; console.log(s + &apos; &apos; + name + &apos;!&apos;); // hello.js代码结束 })(); 所以，Node利用JavaScript的函数式编程的特性，轻而易举地实现了模块的隔离。 但是，模块的输出module.exports怎么实现？ 这个也很容易实现，Node可以先准备一个对象module： // 准备module对象: var module = { id: &apos;hello&apos;, exports: {} }; var load = function (module) { // 读取的hello.js代码: function greet(name) { console.log(&apos;Hello, &apos; + name + &apos;!&apos;); } module.exports = greet; // hello.js代码结束 return module.exports; }; var exported = load(module); // 保存module: save(module, exported); 可见，变量module是Node在加载js文件前准备的一个变量，并将其传入加载函数，我们在hello.js中可以直接使用变量module原因就在于它实际上是函数的一个参数： module.exports = greet; 通过把参数module传递给load()函数，hello.js就顺利地把一个变量传递给了Node执行环境，Node会把module变量保存到某个地方。 由于Node保存了所有导入的module，当我们用require()获取module时，Node找到对应的module，把这个module的exports变量返回，这样，另一个模块就顺利拿到了模块的输出： var greet = require(&apos;./hello&apos;); 以上是Node实现JavaScript模块的一个简单的原理介绍。 module.exports vs exports很多时候，你会看到，在Node环境中，有两种方法可以在一个模块中输出变量： 方法一：对module.exports赋值： // hello.js function hello() { console.log(&apos;Hello, world!&apos;); } function greet(name) { console.log(&apos;Hello, &apos; + name + &apos;!&apos;); } module.exports = { hello: hello, greet: greet }; 方法二：直接使用exports： // hello.js function hello() { console.log(&apos;Hello, world!&apos;); } function greet(name) { console.log(&apos;Hello, &apos; + name + &apos;!&apos;); } function hello() { console.log(&apos;Hello, world!&apos;); } exports.hello = hello; exports.greet = greet; 但是你不可以直接对exports赋值： // 代码可以执行，但是模块并没有输出任何变量: exports = { hello: hello, greet: greet }; 结论:如果要输出一个函数或数组，必须直接对module.exports对象赋值。 直接对module.exports赋值，可以应对任何情况 module.exports = { foo: function () { return &apos;foo&apos;; } }; 或者： module.exports = function () { return &apos;foo&apos;; }; 基本模块因为Node.js是运行在服务区端的JavaScript环境，服务器程序和浏览器程序相比，最大的特点是没有浏览器的安全限制了，而且，服务器程序必须能接收网络请求，读写文件，处理二进制内容，所以，Node.js内置的常用模块就是为了实现基本的服务器功能。这些模块在浏览器环境中是无法被执行的，因为它们的底层代码是用C/C++在Node.js运行环境中实现的。 global在前面的JavaScript课程中，我们已经知道，JavaScript有且仅有一个全局对象，在浏览器中，叫window对象。而在Node.js环境中，也有唯一的全局对象，但不叫window，而叫global，这个对象的属性和方法也和浏览器环境的window不同。进入Node.js交互环境，可以直接输入： E:\Node&gt;node &gt; global.console Console { log: [Function: bound ], info: [Function: bound ], warn: [Function: bound ], error: [Function: bound ], dir: [Function: bound ], time: [Function: bound ], timeEnd: [Function: bound ], trace: [Function: bound trace], assert: [Function: bound ], Console: [Function: Console] } &gt; process·process·也是Node.js提供的一个对象，它代表当前Node.js进程。通过process对象可以拿到许多有用信息： &gt; process==global.process true &gt; process.version &apos;v4.6.0&apos; &gt; process.platform &apos;win32&apos; &gt; process.arch &apos;x64&apos; &gt; &gt; process.cwd() &apos;E:\\Node&apos; JavaScript程序是由事件驱动执行的单线程模型，Node.js也不例外。Node.js不断执行响应事件的JavaScript函数，直到没有任何响应事件的函数可以执行时，Node.js就退出了。 如果我们想要在下一次事件响应中执行代码，可以调用process.nextTick()： // test.js // process.nextTick()将在下一轮事件循环中调用: process.nextTick(function () { console.log(&apos;nextTick callback!&apos;); }); console.log(&apos;nextTick was set!&apos;); 用Node执行上面的代码node test.js，你会看到，打印输出是：12nextTick was set!nextTick callback! 这说明传入process.nextTick()的函数不是立刻执行，而是要等到下一次事件循环。 Node.js进程本身的事件就由process对象来处理。如果我们响应exit事件，就可以在程序即将退出时执行某个回调函数：1234// 程序即将退出时的回调函数:process.on(&apos;exit&apos;, function (code) &#123; console.log(&apos;about to exit with code: &apos; + code);&#125;); 判断JavaScript执行环境有很多JavaScript代码既能在浏览器中执行，也能在Node环境执行，但有些时候，程序本身需要判断自己到底是在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断：12345if (typeof(window) === &apos;undefined&apos;) &#123; console.log(&apos;node.js&apos;);&#125; else &#123; console.log(&apos;browser&apos;);&#125; fsNode.js内置的fs模块就是 文件系统模块 ，负责读写文件。 和所有其它JavaScript模块不同的是，fs模块同时提供了异步和同步的方法。 回顾一下什么是异步方法。因为JavaScript的单线程模型，执行IO操作时，JavaScript代码无需等待，而是传入回调函数后，继续执行后续JavaScript代码。比如jQuery提供的getJSON()操作：1234$.getJSON(&apos;http://example.com/ajax&apos;, function (data) &#123; console.log(&apos;IO结果返回后执行...&apos;);&#125;);console.log(&apos;不等待IO结果直接执行后续代码...&apos;); 而同步的IO操作则需要等待函数返回：12// 根据网络耗时，函数将执行几十毫秒~几秒不等:var data = getJSONSync(&apos;http://example.com/ajax&apos;); 同步操作的好处是代码简单，缺点是程序将等待IO操作，在等待时间内，无法响应其它任何事件。而异步读取不用等待IO操作，但代码较麻烦。 异步读文件按照JavaScript的标准，异步读取一个文本文件的代码如下： 1234567891011&apos;use strict&apos;;var fs = require(&apos;fs&apos;);fs.readFile(&apos;sample.txt&apos;, &apos;utf-8&apos;, function (err, data) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); &#125;&#125;); 请注意，sample.txt文件必须在当前目录下，且文件编码为utf-8。 异步读取时，传入的回调函数接收两个参数，当正常读取时，err参数为null，data参数为读取到的String。当读取发生错误时，err参数代表一个错误对象，data为undefined。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。后面我们还会经常编写这种回调函数。 由于err是否为null就是判断是否出错的标志，所以通常的判断逻辑总是：12345if (err) &#123; // 出错了&#125; else &#123; // 正常&#125; 如果我们要读取的文件不是文本文件，而是二进制文件，怎么办？ 下面的例子演示了如何读取一个图片文件： 123456789101112&apos;use strict&apos;;var fs = require(&apos;fs&apos;);fs.readFile(&apos;sample.png&apos;, function (err, data) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); console.log(data.length + &apos; bytes&apos;); &#125;&#125;); 当读取二进制文件时，不传入文件编码时，回调函数的data参数将返回一个Buffer对象。在Node.js中，Buffer对象就是一个包含零个或任意个字节的数组（注意和Array不同）。 Buffer对象可以和String作转换，例如，把一个Buffer对象转换成String：123// Buffer -&gt; Stringvar text = data.toString(&apos;utf-8&apos;);console.log(text); 或者把一个String转换成Buffer：123// String -&gt; Buffervar buf = new Buffer(text, &apos;utf-8&apos;);console.log(buf); 同步读文件 除了标准的异步读取模式外，fs也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个Sync后缀，并且不接收回调函数，函数直接返回结果。 用fs模块同步读取一个文本文件的代码如下： 123456&apos;use strict&apos;;var fs = require(&apos;fs&apos;);var data = fs.readFileSync(&apos;sample.txt&apos;, &apos;utf-8&apos;);console.log(data); 可见，原异步调用的回调函数的data被函数直接返回，函数名需要改为readFileSync，其它参数不变。 如果同步读取文件发生错误，则需要用try…catch捕获该错误：123456try &#123; var data = fs.readFileSync(&apos;sample.txt&apos;, &apos;utf-8&apos;); console.log(data);&#125; catch (err) &#123; // 出错了&#125; 写文件 将数据写入文件是通过fs.writeFile()实现的： 123456789101112&apos;use strict&apos;;var fs = require(&apos;fs&apos;);var data = &apos;Hello, Node.js&apos;;fs.writeFile(&apos;output.txt&apos;, data, function (err) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(&apos;ok.&apos;); &#125;&#125;); writeFile()的参数依次为文件名、数据和回调函数。如果传入的数据是String，默认按UTF-8编码写入文本文件，如果传入的参数是Buffer，则写入的是二进制文件。回调函数由于只关心成功与否，因此只需要一个err参数。 和readFile()类似，writeFile()也有一个同步方法，叫writeFileSync()：123456&apos;use strict&apos;;var fs = require(&apos;fs&apos;);var data = &apos;Hello, Node.js&apos;;fs.writeFileSync(&apos;output.txt&apos;, data); stat如果我们要获取文件大小，创建时间等信息，可以使用fs.stat()，它返回一个Stat对象，能告诉我们文件或目录的详细信息：12345678910111213141516171819202122&apos;use strict&apos;;var fs = require(&apos;fs&apos;);fs.stat(&apos;sample.txt&apos;, function (err, stat) &#123; if (err) &#123; console.log(err); &#125; else &#123; // 是否是文件: console.log(&apos;isFile: &apos; + stat.isFile()); // 是否是目录: console.log(&apos;isDirectory: &apos; + stat.isDirectory()); if (stat.isFile()) &#123; // 文件大小: console.log(&apos;size: &apos; + stat.size); // 创建时间, Date对象: console.log(&apos;birth time: &apos; + stat.birthtime); // 修改时间, Date对象: console.log(&apos;modified time: &apos; + stat.mtime); &#125; &#125;&#125;); 运行结果如下：12345isFile: trueisDirectory: falsesize: 181birth time: Fri Dec 11 2015 09:43:41 GMT+0800 (CST)modified time: Fri Dec 11 2015 12:09:00 GMT+0800 (CST) stat()也有一个对应的同步函数statSync() 异步还是同步 在fs模块中，提供同步方法是为了方便使用。那我们到底是应该用异步方法还是同步方法呢？ 由于Node环境执行的JavaScript代码是服务器端代码，所以，绝大部分需要在服务器运行期反复执行业务逻辑的代码，必须使用异步代码，否则，同步代码在执行时期，服务器将停止响应，因为JavaScript只有一个执行线程。 服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次，不影响服务器正常运行时的异步执行。 streamstream是Node.js提供的又一个仅在服务区端可用的模块，目的是支持“流”这种数据结构。 什么是流？流是一种抽象的数据结构。流的特点是数据是有序的，而且必须依次读取，或者依次写入，不能像Array那样随机定位。 在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：data事件表示流的数据已经可以读取了，end事件表示这个流已经到末尾了，没有数据可以读取了，error事件表示出错了。 下面是一个从文件流读取文本内容的示例：12345678910111213141516171819&apos;use strict&apos;;var fs = require(&apos;fs&apos;);// 打开一个流:var rs = fs.createReadStream(&apos;sample.txt&apos;, &apos;utf-8&apos;);rs.on(&apos;data&apos;, function (chunk) &#123; console.log(&apos;DATA:&apos;) console.log(chunk);&#125;);rs.on(&apos;end&apos;, function () &#123; console.log(&apos;END&apos;);&#125;);rs.on(&apos;error&apos;, function (err) &#123; console.log(&apos;ERROR: &apos; + err);&#125;); 要注意，data事件可能会有多次，每次传递的chunk是流的一部分数据。 要以流的形式写入文件，只需要不断调用write()方法，最后以end()结束：12345678910111213&apos;use strict&apos;;var fs = require(&apos;fs&apos;);var ws1 = fs.createWriteStream(&apos;output1.txt&apos;, &apos;utf-8&apos;);ws1.write(&apos;使用Stream写入文本数据...\n&apos;);ws1.write(&apos;END.&apos;);ws1.end();var ws2 = fs.createWriteStream(&apos;output2.txt&apos;);ws2.write(new Buffer(&apos;使用Stream写入二进制数据...\n&apos;, &apos;utf-8&apos;));ws2.write(new Buffer(&apos;END.&apos;, &apos;utf-8&apos;));ws2.end(); 所有可以读取数据的流都继承自stream.Readable，所有可以写入的流都继承自stream.Writable。 pipe就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个Readable流和一个Writable流串起来后，所有的数据自动从Readable流进入Writable流，这种操作叫pipe。 在Node.js中，Readable流有一个pipe()方法，就是用来干这件事的。 让我们用pipe()把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序：12345678&apos;use strict&apos;;var fs = require(&apos;fs&apos;);var rs = fs.createReadStream(&apos;sample.txt&apos;);var ws = fs.createWriteStream(&apos;copied.txt&apos;);rs.pipe(ws); 默认情况下，当Readable流的数据读取完毕，end事件触发后，将自动关闭Writable流。如果我们不希望自动关闭Writable流，需要传入参数： 1readable.pipe(writable, &#123; end: false &#125;); httpHTTP协议要理解Web服务器程序的工作原理，首先，我们要对HTTP协议有基本的了解。 HTTP服务器要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的http模块完成了。应用程序并不直接和HTTP协议打交道，而是操作http模块提供的request和response对象。 request对象封装了HTTP请求，我们调用request对象的属性和方法就可以拿到所有HTTP请求的信息； response对象封装了HTTP响应，我们操作response对象的方法，就可以把HTTP响应返回给浏览器。 用Node.js实现一个HTTP服务器程序非常简单。我们来实现一个最简单的Web程序hello.js，它对于所有请求，都返回Hello world!：123456789101112131415161718192021&apos;use strict&apos;;// 导入http模块:var http = require(&apos;http&apos;);// 创建http server，并传入回调函数:var server = http.createServer(function (request, response) &#123; // 回调函数接收request和response对象, // 获得HTTP请求的method和url: console.log(request.method + &apos;: &apos; + request.url); // 将HTTP响应200写入response, 同时设置Content-Type: text/html: response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/html&apos;&#125;); // 将HTTP响应的HTML内容写入response: response.end(&apos;&lt;h1&gt;Hello world!&lt;/h1&gt;&apos;);&#125;);// 让服务器监听8080端口:server.listen(8080);console.log(&apos;Server is running at http://127.0.0.1:8080/&apos;); 在命令提示符下运行该程序，可以看到以下输出：12$ node hello.js Server is running at http://127.0.0.1:8080/ 不要关闭命令提示符，直接打开浏览器输入http://localhost:8080，即可看到服务器响应的内容。同时，在命令提示符窗口，可以看到程序打印的请求信息： 12GET: /GET: /favicon.ico 文件服务器让我们继续扩展一下上面的Web程序。我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析request.url中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。 解析URL需要用到Node.js提供的url模块，它使用起来非常简单，通过parse()将一个字符串解析为一个Url对象： 12345&apos;use strict&apos;;var url = require(&apos;url&apos;);console.log(url.parse(&apos;http://user:pass@host.com:8080/path/to/file?query=string#hash&apos;)); 结果如下：12345678910111213Url &#123; protocol: &apos;http:&apos;, slashes: true, auth: &apos;user:pass&apos;, host: &apos;host.com:8080&apos;, port: &apos;8080&apos;, hostname: &apos;host.com&apos;, hash: &apos;#hash&apos;, search: &apos;?query=string&apos;, query: &apos;query=string&apos;, pathname: &apos;/path/to/file&apos;, path: &apos;/path/to/file?query=string&apos;, href: &apos;http://user:pass@host.com:8080/path/to/file?query=string#hash&apos; &#125; 处理本地文件目录需要使用Node.js提供的path模块，它可以方便地构造目录：12345678910&apos;use strict&apos;;var path = require(&apos;path&apos;);// 解析当前目录:var workDir = path.resolve(&apos;.&apos;); //F:\Node// 组合完整的文件路径:当前目录+&apos;pub&apos;+&apos;index.html&apos;:var filePath = path.join(workDir, &apos;pub&apos;, &apos;index.html&apos;);// &apos;F:\Node\pub\index.html&apos; 最后，我们实现一个文件服务器file_server.js：1234567891011121314151617181920212223242526272829303132333435363738394041&apos;use strict&apos;;var fs = require(&apos;fs&apos;), url = require(&apos;url&apos;), path = require(&apos;path&apos;), http = require(&apos;http&apos;);// 从命令行参数获取root目录，默认是当前目录:var root = path.resolve(process.argv[2] || &apos;.&apos;);console.log(&apos;Static root dir: &apos; + root);// 创建服务器:var server = http.createServer(function (request, response) &#123; // 获得URL的path，类似 &apos;/css/bootstrap.css&apos;: var pathname = url.parse(request.url).pathname; // 获得对应的本地文件路径，类似 &apos;/srv/www/css/bootstrap.css&apos;: var filepath = path.join(root, pathname); // 获取文件状态: fs.stat(filepath, function (err, stats) &#123; if (!err &amp;&amp; stats.isFile()) &#123; // 没有出错并且文件存在: console.log(&apos;200 &apos; + request.url); // 发送200响应: response.writeHead(200); // 将文件流导向response: fs.createReadStream(filepath).pipe(response); &#125; else &#123; // 出错了或者文件不存在: console.log(&apos;404 &apos; + request.url); // 发送404响应: response.writeHead(404); response.end(&apos;404 Not Found&apos;); &#125; &#125;);&#125;);server.listen(8080);console.log(&apos;Server is running at http://127.0.0.1:8080/&apos;); 没有必要手动读取文件内容。由于response对象本身是一个Writable Stream，直接用pipe()方法就实现了自动读取文件内容并输出到HTTP响应。 在命令行运行node file_server.js ./path/to/dir，把/path/to/dir改成你本地的file_server.js路径下一个有效的目录，然后在浏览器中输入http://localhost:8080/index.html： 只要当前目录下存在文件index.html，服务器就可以把文件内容发送给浏览器。观察控制台输出：1234F:\Node&gt;node demo2.js ./path/to/dirStatic root dir: F:\Node\path\to\dirServer is running at http://127.0.0.1:8080/200 /index.html 第一个请求是浏览器请求index.html页面，后续请求是浏览器解析HTML后发送的其它资源请求。 cryptocrypto模块的目的是为了提供通用的加密和哈希算法。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。Nodejs用C/C++实现这些算法后，通过cypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。 MD5和SHA1 MD5是一种常用的哈希算法，用于给任意数据一个“签名”。这个签名通常用一个十六进制的字符串表示：123456789const crypto = require(&apos;crypto&apos;);const hash = crypto.createHash(&apos;md5&apos;);// 可任意多次调用update():hash.update(&apos;Hello, world!&apos;);hash.update(&apos;Hello, nodejs!&apos;);console.log(hash.digest(&apos;hex&apos;)); // 7e1977739c748beac0c0fd14fd26a544 update()方法默认字符串编码为UTF-8，也可以传入Buffer。 如果要计算SHA1，只需要把&#39;md5&#39;改成&#39;sha1&#39;，就可以得到SHA1的结果1f32b9c9932c02227819a4151feed43e131aca40。 还可以使用更安全的sha256和sha512。 HmacHmac算法也是一种哈希算法，它可以利用MD5或SHA1等哈希算法。不同的是，Hmac还需要一个密钥：12345678const crypto = require(&apos;crypto&apos;);const hmac = crypto.createHmac(&apos;sha256&apos;, &apos;secret-key&apos;);hmac.update(&apos;Hello, world!&apos;);hmac.update(&apos;Hello, nodejs!&apos;);console.log(hmac.digest(&apos;hex&apos;)); // 80f7e22570. 只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，因此，可以把Hmac理解为用随机数“增强”的哈希算法。 AES AES是一种常用的对称加密算法，加解密都用同一个密钥。crypto模块提供了AES支持，但是需要自己封装好函数，便于使用：123456789101112131415161718192021222324const crypto = require(&apos;crypto&apos;);function aesEncrypt(data, key) &#123; const cipher = crypto.createCipher(&apos;aes192&apos;, key); var crypted = cipher.update(data, &apos;utf8&apos;, &apos;hex&apos;); crypted += cipher.final(&apos;hex&apos;); return crypted;&#125;function aesDecrypt(encrypted, key) &#123; const decipher = crypto.createDecipher(&apos;aes192&apos;, key); var decrypted = decipher.update(encrypted, &apos;hex&apos;, &apos;utf8&apos;); decrypted += decipher.final(&apos;utf8&apos;); return decrypted;&#125;var data = &apos;Hello, this is a secret message!&apos;;var key = &apos;Password!&apos;;var encrypted = aesEncrypt(data, key);var decrypted = aesDecrypt(encrypted, key);console.log(&apos;Plain text: &apos; + data);console.log(&apos;Encrypted text: &apos; + encrypted);console.log(&apos;Decrypted text: &apos; + decrypted); 运行结果如下：123Plain text: Hello, this is a secret message!Encrypted text: 8a944d97bdabc157a5b7a40cb180e7...Decrypted text: Hello, this is a secret message! 可以看出，加密后的字符串通过解密又得到了原始内容。 注意到AES有很多不同的算法，如aes192，aes-128-ecb，aes-256-cbc等，AES除了密钥外还可以指定IV（Initial Vector），不同的系统只要IV不同，用相同的密钥加密相同的数据得到的加密结果也是不同的。加密结果通常有两种表示方法：hex和base64，这些功能Nodejs全部都支持，但是在应用中要注意，如果加解密双方一方用Nodejs，另一方用Java、PHP等其它语言，需要仔细测试。如果无法正确解密，要确认双方是否遵循同样的AES算法，字符串密钥和IV是否相同，加密后的数据是否统一为hex或base64格式。 Diffie-Hellman DH算法是一种密钥交换协议，它可以让双方在不泄漏密钥的情况下协商出一个密钥来。DH算法基于数学原理，比如小明和小红想要协商一个密钥，可以这么做： 小明先选一个素数和一个底数，例如，素数p=23，底数g=5（底数可以任选），再选择一个秘密整数a=6，计算A=g^a mod p=8，然后大声告诉小红：p=23，g=5，A=8； 小红收到小明发来的p，g，A后，也选一个秘密整数b=15，然后计算B=g^b mod p=19，并大声告诉小明：B=19； 小明自己计算出s=B^a mod p=2，小红也自己计算出s=A^b mod p=2，因此，最终协商的密钥s为2。 在这个过程中，密钥2并不是小明告诉小红的，也不是小红告诉小明的，而是双方协商计算出来的。第三方只能知道p=23，g=5，A=8，B=19，由于不知道双方选的秘密整数a=6和b=15，因此无法计算出密钥2。 用crypto模块实现DH算法如下：1234567891011121314151617181920212223const crypto = require(&apos;crypto&apos;);// xiaoming&apos;s keys:var ming = crypto.createDiffieHellman(512);var ming_keys = ming.generateKeys();var prime = ming.getPrime();var generator = ming.getGenerator();console.log(&apos;Prime: &apos; + prime.toString(&apos;hex&apos;));console.log(&apos;Generator: &apos; + generator.toString(&apos;hex&apos;));// xiaohong&apos;s keys:var hong = crypto.createDiffieHellman(prime, generator);var hong_keys = hong.generateKeys();// exchange and generate secret:var ming_secret = ming.computeSecret(hong_keys);var hong_secret = hong.computeSecret(ming_keys);// print secret:console.log(&apos;Secret of Xiao Ming: &apos; + ming_secret.toString(&apos;hex&apos;));console.log(&apos;Secret of Xiao Hong: &apos; + hong_secret.toString(&apos;hex&apos;)); 运行后，可以得到如下输出：12345$ node dh.js Prime: a8224c...deead3Generator: 02Secret of Xiao Ming: 695308...d519beSecret of Xiao Hong: 695308...d519be 注意每次输出都不一样，因为素数的选择是随机的。 证书crypto模块也可以处理数字证书。数字证书通常用在SSL连接，也就是Web的https连接。一般情况下，https连接只需要处理服务器端的单向认证，如无特殊需求（例如自己作为Root给客户发认证证书），建议用反向代理服务器如Nginx等Web服务器去处理证书。 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/29/node-document(1)/]]></content>
      <categories>
        <category>JS</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Node</tag>
        <tag>模块</tag>
        <tag>npm</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js复习]]></title>
    <url>%2F2017%2F06%2F29%2Fnode-document%2F</url>
    <content type="text"><![CDATA[前阵子学习了Node，已经了解了Node的基本知识，并安装了node，npm，了解了怎么去运行，现在这篇是复习一下node。 Node(复习） Node.js:基于JavaScript语言和V8引擎的开源Web服务器项目 在Node上运行的JavaScript相比其他后端开发语言有何优势？ 最大的优势是借助JavaScript天生的事件驱动机制加V8高性能引擎，使编写高性能Web服务轻而易举。其次，JavaScript语言本身是完善的函数式语言,在Node环境下，通过模块化的JavaScript代码，加上函数式编程，并且无需考虑浏览器兼容性问题，直接使用最新的ECMAScript 6标准，可以完全满足工程上的需求。 io.js，这又是什么鬼？ io.js是“尝鲜版”，而Node.js是线上稳定版，相当于Fedora Linux和RHEL的关系。 #npm npm其实是Node.js的包管理工具（package manager）。 为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。 更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。 第一个Node程序选择一个目录，例如F:\Node，把文件保存为hello.js，就可以打开命令行窗口，把当前目录切换到hello.js所在目录，然后输入以下命令运行这个程序了：12F:\Node&gt;node hello.jsHello, world. 也可以保存为别的名字，比如first.js，但是必须要以.js结尾。此外，文件名只能是英文字母、数字和下划线的组合。 命令行模式和Node交互模式 请注意区分命令行模式和Node交互模式。 看到类似C:>是在Windows提供的命令行模式： 看到&gt;是在Node交互式环境下： 在Node交互式环境下，我们可以输入JavaScript代码并立刻执行。 使用严格模式如果在JavaScript文件开头写上&#39;use strict&#39;;，那么Node在执行该JavaScript时将使用严格模式。但是，在服务器环境下，如果有很多JavaScript文件，每个文件都写上’use strict’;很麻烦。我们可以给Nodejs传递一个参数，让Node直接为所有js文件开启严格模式： 1node --use_strict 给指定文件开启严格模式：1node --use_strict 文件名(例如:hello.js) 模块 在Node环境中，一个.js文件就称之为一个模块（module）。 使用模块有什么好处？ 最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。 使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。 比如，我们编写了一个hello.js文件，这个hello.js文件就是一个模块，模块的名字就是文件名（去掉.js后缀），所以hello.js文件就是名为hello的模块。 123456789&apos;use strict&apos;;var s = &apos;Hello&apos;;function greet(name) &#123; console.log(s + &apos;, &apos; + name + &apos;!&apos;);&#125;module.exports = greet; 函数greet()是我们在hello模块中定义的，你可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数greet作为模块的输出暴露出去，这样其他模块就可以使用greet函数了。 问题是其他模块怎么使用hello模块的这个greet函数呢？我们再编写一个main.js文件，调用hello模块的greet函数：12345678&apos;use strict&apos;;// 引入hello模块:var greet = require(&apos;./hello&apos;);var s = &apos;Michael&apos;;greet(s); // Hello, Michael! 注意到引入hello模块用Node提供的require函数：1var greet = require(&apos;./hello&apos;); 引入的模块作为变量保存在greet变量中，那greet变量到底是什么东西？其实变量greet就是在hello.js中我们用module.exports = greet;输出的greet函数。所以，main.js就成功地引用了hello.js模块中定义的greet()函数，接下来就可以直接使用它了。 在使用require()引入模块的时候，请注意模块的相对路径。因为main.js和hello.js位于同一个目录，所以我们用了当前目录.：1var greet = require(&apos;./hello&apos;); // 不要忘了写相对目录! 如果只写模块名：1var greet = require(&apos;hello&apos;); 则Node会依次在内置模块、全局模块和当前模块下查找hello.js，你很可能会得到一个错误： module.js throw err; ^ Error: Cannot find module &apos;hello&apos; at Function.Module._resolveFilename at Function.Module._load ... at Function.Module._load at Function.Module.runMain 遇到这个错误，你要检查： 模块名是否写对了； 模块文件是否存在； 相对路径是否写对了。 CommonJS规范这种模块加载机制被称为CommonJS规范。在这个规范下，每个.js文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突，例如，hello.js和main.js都申明了全局变量var s = ‘xxx’，但互不影响。 小结：要在模块中对外输出变量，用 module.exports = variable; 输出的变量可以是任意对象、函数、数组等等。 要引入其他模块输出的对象，用： var foo = require(&apos;other_module&apos;); 深入了解模块原理 JavaScript语言本身并没有一种模块机制来保证不同模块可以使用相同的变量名。 其实要实现“模块”这个功能，并不需要语法层面的支持。Node.js也并不会增加任何JavaScript语法。实现“模块”功能的奥妙就在于JavaScript是一种函数式编程语言，它支持闭包。如果我们把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。 请注意我们编写的hello.js代码是这样的： var s = &apos;Hello&apos;; var name = &apos;world&apos;; console.log(s + &apos; &apos; + name + &apos;!&apos;); Node.js加载了hello.js后，它可以把代码包装一下，变成这样执行： (function () { // 读取的hello.js代码: var s = &apos;Hello&apos;; var name = &apos;world&apos;; console.log(s + &apos; &apos; + name + &apos;!&apos;); // hello.js代码结束 })(); 所以，Node利用JavaScript的函数式编程的特性，轻而易举地实现了模块的隔离。 但是，模块的输出module.exports怎么实现？ 这个也很容易实现，Node可以先准备一个对象module： // 准备module对象: var module = { id: &apos;hello&apos;, exports: {} }; var load = function (module) { // 读取的hello.js代码: function greet(name) { console.log(&apos;Hello, &apos; + name + &apos;!&apos;); } module.exports = greet; // hello.js代码结束 return module.exports; }; var exported = load(module); // 保存module: save(module, exported); 可见，变量module是Node在加载js文件前准备的一个变量，并将其传入加载函数，我们在hello.js中可以直接使用变量module原因就在于它实际上是函数的一个参数： module.exports = greet; 通过把参数module传递给load()函数，hello.js就顺利地把一个变量传递给了Node执行环境，Node会把module变量保存到某个地方。 由于Node保存了所有导入的module，当我们用require()获取module时，Node找到对应的module，把这个module的exports变量返回，这样，另一个模块就顺利拿到了模块的输出： var greet = require(&apos;./hello&apos;); 以上是Node实现JavaScript模块的一个简单的原理介绍。 module.exports vs exports很多时候，你会看到，在Node环境中，有两种方法可以在一个模块中输出变量： 方法一：对module.exports赋值： // hello.js function hello() { console.log(&apos;Hello, world!&apos;); } function greet(name) { console.log(&apos;Hello, &apos; + name + &apos;!&apos;); } module.exports = { hello: hello, greet: greet }; 方法二：直接使用exports： // hello.js function hello() { console.log(&apos;Hello, world!&apos;); } function greet(name) { console.log(&apos;Hello, &apos; + name + &apos;!&apos;); } function hello() { console.log(&apos;Hello, world!&apos;); } exports.hello = hello; exports.greet = greet; 但是你不可以直接对exports赋值： // 代码可以执行，但是模块并没有输出任何变量: exports = { hello: hello, greet: greet }; 结论:如果要输出一个函数或数组，必须直接对module.exports对象赋值。 直接对module.exports赋值，可以应对任何情况 module.exports = { foo: function () { return &apos;foo&apos;; } }; 或者： module.exports = function () { return &apos;foo&apos;; }; 基本模块因为Node.js是运行在服务区端的JavaScript环境，服务器程序和浏览器程序相比，最大的特点是没有浏览器的安全限制了，而且，服务器程序必须能接收网络请求，读写文件，处理二进制内容，所以，Node.js内置的常用模块就是为了实现基本的服务器功能。这些模块在浏览器环境中是无法被执行的，因为它们的底层代码是用C/C++在Node.js运行环境中实现的。 global在前面的JavaScript课程中，我们已经知道，JavaScript有且仅有一个全局对象，在浏览器中，叫window对象。而在Node.js环境中，也有唯一的全局对象，但不叫window，而叫global，这个对象的属性和方法也和浏览器环境的window不同。进入Node.js交互环境，可以直接输入： E:\Node&gt;node &gt; global.console Console { log: [Function: bound ], info: [Function: bound ], warn: [Function: bound ], error: [Function: bound ], dir: [Function: bound ], time: [Function: bound ], timeEnd: [Function: bound ], trace: [Function: bound trace], assert: [Function: bound ], Console: [Function: Console] } &gt; process·process·也是Node.js提供的一个对象，它代表当前Node.js进程。通过process对象可以拿到许多有用信息： &gt; process==global.process true &gt; process.version &apos;v4.6.0&apos; &gt; process.platform &apos;win32&apos; &gt; process.arch &apos;x64&apos; &gt; &gt; process.cwd() &apos;E:\\Node&apos; JavaScript程序是由事件驱动执行的单线程模型，Node.js也不例外。Node.js不断执行响应事件的JavaScript函数，直到没有任何响应事件的函数可以执行时，Node.js就退出了。 如果我们想要在下一次事件响应中执行代码，可以调用process.nextTick()： // test.js // process.nextTick()将在下一轮事件循环中调用: process.nextTick(function () { console.log(&apos;nextTick callback!&apos;); }); console.log(&apos;nextTick was set!&apos;); 用Node执行上面的代码node test.js，你会看到，打印输出是：12nextTick was set!nextTick callback! 这说明传入process.nextTick()的函数不是立刻执行，而是要等到下一次事件循环。 Node.js进程本身的事件就由process对象来处理。如果我们响应exit事件，就可以在程序即将退出时执行某个回调函数：1234// 程序即将退出时的回调函数:process.on(&apos;exit&apos;, function (code) &#123; console.log(&apos;about to exit with code: &apos; + code);&#125;); 判断JavaScript执行环境有很多JavaScript代码既能在浏览器中执行，也能在Node环境执行，但有些时候，程序本身需要判断自己到底是在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断：12345if (typeof(window) === &apos;undefined&apos;) &#123; console.log(&apos;node.js&apos;);&#125; else &#123; console.log(&apos;browser&apos;);&#125; fsNode.js内置的fs模块就是 文件系统模块 ，负责读写文件。 和所有其它JavaScript模块不同的是，fs模块同时提供了异步和同步的方法。 回顾一下什么是异步方法。因为JavaScript的单线程模型，执行IO操作时，JavaScript代码无需等待，而是传入回调函数后，继续执行后续JavaScript代码。比如jQuery提供的getJSON()操作：1234$.getJSON(&apos;http://example.com/ajax&apos;, function (data) &#123; console.log(&apos;IO结果返回后执行...&apos;);&#125;);console.log(&apos;不等待IO结果直接执行后续代码...&apos;); 而同步的IO操作则需要等待函数返回：12// 根据网络耗时，函数将执行几十毫秒~几秒不等:var data = getJSONSync(&apos;http://example.com/ajax&apos;); 同步操作的好处是代码简单，缺点是程序将等待IO操作，在等待时间内，无法响应其它任何事件。而异步读取不用等待IO操作，但代码较麻烦。 异步读文件按照JavaScript的标准，异步读取一个文本文件的代码如下： 1234567891011&apos;use strict&apos;;var fs = require(&apos;fs&apos;);fs.readFile(&apos;sample.txt&apos;, &apos;utf-8&apos;, function (err, data) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); &#125;&#125;); 请注意，sample.txt文件必须在当前目录下，且文件编码为utf-8。 异步读取时，传入的回调函数接收两个参数，当正常读取时，err参数为null，data参数为读取到的String。当读取发生错误时，err参数代表一个错误对象，data为undefined。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。后面我们还会经常编写这种回调函数。 由于err是否为null就是判断是否出错的标志，所以通常的判断逻辑总是：12345if (err) &#123; // 出错了&#125; else &#123; // 正常&#125; 如果我们要读取的文件不是文本文件，而是二进制文件，怎么办？ 下面的例子演示了如何读取一个图片文件： 123456789101112&apos;use strict&apos;;var fs = require(&apos;fs&apos;);fs.readFile(&apos;sample.png&apos;, function (err, data) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); console.log(data.length + &apos; bytes&apos;); &#125;&#125;); 当读取二进制文件时，不传入文件编码时，回调函数的data参数将返回一个Buffer对象。在Node.js中，Buffer对象就是一个包含零个或任意个字节的数组（注意和Array不同）。 Buffer对象可以和String作转换，例如，把一个Buffer对象转换成String：123// Buffer -&gt; Stringvar text = data.toString(&apos;utf-8&apos;);console.log(text); 或者把一个String转换成Buffer：123// String -&gt; Buffervar buf = new Buffer(text, &apos;utf-8&apos;);console.log(buf); 同步读文件 除了标准的异步读取模式外，fs也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个Sync后缀，并且不接收回调函数，函数直接返回结果。 用fs模块同步读取一个文本文件的代码如下： 123456&apos;use strict&apos;;var fs = require(&apos;fs&apos;);var data = fs.readFileSync(&apos;sample.txt&apos;, &apos;utf-8&apos;);console.log(data); 可见，原异步调用的回调函数的data被函数直接返回，函数名需要改为readFileSync，其它参数不变。 如果同步读取文件发生错误，则需要用try…catch捕获该错误：123456try &#123; var data = fs.readFileSync(&apos;sample.txt&apos;, &apos;utf-8&apos;); console.log(data);&#125; catch (err) &#123; // 出错了&#125; 写文件 将数据写入文件是通过fs.writeFile()实现的： 123456789101112&apos;use strict&apos;;var fs = require(&apos;fs&apos;);var data = &apos;Hello, Node.js&apos;;fs.writeFile(&apos;output.txt&apos;, data, function (err) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(&apos;ok.&apos;); &#125;&#125;); writeFile()的参数依次为文件名、数据和回调函数。如果传入的数据是String，默认按UTF-8编码写入文本文件，如果传入的参数是Buffer，则写入的是二进制文件。回调函数由于只关心成功与否，因此只需要一个err参数。 和readFile()类似，writeFile()也有一个同步方法，叫writeFileSync()：123456&apos;use strict&apos;;var fs = require(&apos;fs&apos;);var data = &apos;Hello, Node.js&apos;;fs.writeFileSync(&apos;output.txt&apos;, data); stat如果我们要获取文件大小，创建时间等信息，可以使用fs.stat()，它返回一个Stat对象，能告诉我们文件或目录的详细信息：12345678910111213141516171819202122&apos;use strict&apos;;var fs = require(&apos;fs&apos;);fs.stat(&apos;sample.txt&apos;, function (err, stat) &#123; if (err) &#123; console.log(err); &#125; else &#123; // 是否是文件: console.log(&apos;isFile: &apos; + stat.isFile()); // 是否是目录: console.log(&apos;isDirectory: &apos; + stat.isDirectory()); if (stat.isFile()) &#123; // 文件大小: console.log(&apos;size: &apos; + stat.size); // 创建时间, Date对象: console.log(&apos;birth time: &apos; + stat.birthtime); // 修改时间, Date对象: console.log(&apos;modified time: &apos; + stat.mtime); &#125; &#125;&#125;); 运行结果如下：12345isFile: trueisDirectory: falsesize: 181birth time: Fri Dec 11 2015 09:43:41 GMT+0800 (CST)modified time: Fri Dec 11 2015 12:09:00 GMT+0800 (CST) stat()也有一个对应的同步函数statSync() 异步还是同步 在fs模块中，提供同步方法是为了方便使用。那我们到底是应该用异步方法还是同步方法呢？ 由于Node环境执行的JavaScript代码是服务器端代码，所以，绝大部分需要在服务器运行期反复执行业务逻辑的代码，必须使用异步代码，否则，同步代码在执行时期，服务器将停止响应，因为JavaScript只有一个执行线程。 服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次，不影响服务器正常运行时的异步执行。 streamstream是Node.js提供的又一个仅在服务区端可用的模块，目的是支持“流”这种数据结构。 什么是流？流是一种抽象的数据结构。流的特点是数据是有序的，而且必须依次读取，或者依次写入，不能像Array那样随机定位。 在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：data事件表示流的数据已经可以读取了，end事件表示这个流已经到末尾了，没有数据可以读取了，error事件表示出错了。 下面是一个从文件流读取文本内容的示例：12345678910111213141516171819&apos;use strict&apos;;var fs = require(&apos;fs&apos;);// 打开一个流:var rs = fs.createReadStream(&apos;sample.txt&apos;, &apos;utf-8&apos;);rs.on(&apos;data&apos;, function (chunk) &#123; console.log(&apos;DATA:&apos;) console.log(chunk);&#125;);rs.on(&apos;end&apos;, function () &#123; console.log(&apos;END&apos;);&#125;);rs.on(&apos;error&apos;, function (err) &#123; console.log(&apos;ERROR: &apos; + err);&#125;); 要注意，data事件可能会有多次，每次传递的chunk是流的一部分数据。 要以流的形式写入文件，只需要不断调用write()方法，最后以end()结束：12345678910111213&apos;use strict&apos;;var fs = require(&apos;fs&apos;);var ws1 = fs.createWriteStream(&apos;output1.txt&apos;, &apos;utf-8&apos;);ws1.write(&apos;使用Stream写入文本数据...\n&apos;);ws1.write(&apos;END.&apos;);ws1.end();var ws2 = fs.createWriteStream(&apos;output2.txt&apos;);ws2.write(new Buffer(&apos;使用Stream写入二进制数据...\n&apos;, &apos;utf-8&apos;));ws2.write(new Buffer(&apos;END.&apos;, &apos;utf-8&apos;));ws2.end(); 所有可以读取数据的流都继承自stream.Readable，所有可以写入的流都继承自stream.Writable。 pipe就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个Readable流和一个Writable流串起来后，所有的数据自动从Readable流进入Writable流，这种操作叫pipe。 在Node.js中，Readable流有一个pipe()方法，就是用来干这件事的。 让我们用pipe()把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序：12345678&apos;use strict&apos;;var fs = require(&apos;fs&apos;);var rs = fs.createReadStream(&apos;sample.txt&apos;);var ws = fs.createWriteStream(&apos;copied.txt&apos;);rs.pipe(ws); 默认情况下，当Readable流的数据读取完毕，end事件触发后，将自动关闭Writable流。如果我们不希望自动关闭Writable流，需要传入参数： 1readable.pipe(writable, &#123; end: false &#125;); httpHTTP协议要理解Web服务器程序的工作原理，首先，我们要对HTTP协议有基本的了解。 HTTP服务器要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的http模块完成了。应用程序并不直接和HTTP协议打交道，而是操作http模块提供的request和response对象。 request对象封装了HTTP请求，我们调用request对象的属性和方法就可以拿到所有HTTP请求的信息； response对象封装了HTTP响应，我们操作response对象的方法，就可以把HTTP响应返回给浏览器。 用Node.js实现一个HTTP服务器程序非常简单。我们来实现一个最简单的Web程序hello.js，它对于所有请求，都返回Hello world!：123456789101112131415161718192021&apos;use strict&apos;;// 导入http模块:var http = require(&apos;http&apos;);// 创建http server，并传入回调函数:var server = http.createServer(function (request, response) &#123; // 回调函数接收request和response对象, // 获得HTTP请求的method和url: console.log(request.method + &apos;: &apos; + request.url); // 将HTTP响应200写入response, 同时设置Content-Type: text/html: response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/html&apos;&#125;); // 将HTTP响应的HTML内容写入response: response.end(&apos;&lt;h1&gt;Hello world!&lt;/h1&gt;&apos;);&#125;);// 让服务器监听8080端口:server.listen(8080);console.log(&apos;Server is running at http://127.0.0.1:8080/&apos;); 在命令提示符下运行该程序，可以看到以下输出：12$ node hello.js Server is running at http://127.0.0.1:8080/ 不要关闭命令提示符，直接打开浏览器输入http://localhost:8080，即可看到服务器响应的内容。同时，在命令提示符窗口，可以看到程序打印的请求信息： 12GET: /GET: /favicon.ico 文件服务器让我们继续扩展一下上面的Web程序。我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析request.url中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。 解析URL需要用到Node.js提供的url模块，它使用起来非常简单，通过parse()将一个字符串解析为一个Url对象： 12345&apos;use strict&apos;;var url = require(&apos;url&apos;);console.log(url.parse(&apos;http://user:pass@host.com:8080/path/to/file?query=string#hash&apos;)); 结果如下：12345678910111213Url &#123; protocol: &apos;http:&apos;, slashes: true, auth: &apos;user:pass&apos;, host: &apos;host.com:8080&apos;, port: &apos;8080&apos;, hostname: &apos;host.com&apos;, hash: &apos;#hash&apos;, search: &apos;?query=string&apos;, query: &apos;query=string&apos;, pathname: &apos;/path/to/file&apos;, path: &apos;/path/to/file?query=string&apos;, href: &apos;http://user:pass@host.com:8080/path/to/file?query=string#hash&apos; &#125; 处理本地文件目录需要使用Node.js提供的path模块，它可以方便地构造目录：12345678910&apos;use strict&apos;;var path = require(&apos;path&apos;);// 解析当前目录:var workDir = path.resolve(&apos;.&apos;); //F:\Node// 组合完整的文件路径:当前目录+&apos;pub&apos;+&apos;index.html&apos;:var filePath = path.join(workDir, &apos;pub&apos;, &apos;index.html&apos;);// &apos;F:\Node\pub\index.html&apos; 最后，我们实现一个文件服务器file_server.js：1234567891011121314151617181920212223242526272829303132333435363738394041&apos;use strict&apos;;var fs = require(&apos;fs&apos;), url = require(&apos;url&apos;), path = require(&apos;path&apos;), http = require(&apos;http&apos;);// 从命令行参数获取root目录，默认是当前目录:var root = path.resolve(process.argv[2] || &apos;.&apos;);console.log(&apos;Static root dir: &apos; + root);// 创建服务器:var server = http.createServer(function (request, response) &#123; // 获得URL的path，类似 &apos;/css/bootstrap.css&apos;: var pathname = url.parse(request.url).pathname; // 获得对应的本地文件路径，类似 &apos;/srv/www/css/bootstrap.css&apos;: var filepath = path.join(root, pathname); // 获取文件状态: fs.stat(filepath, function (err, stats) &#123; if (!err &amp;&amp; stats.isFile()) &#123; // 没有出错并且文件存在: console.log(&apos;200 &apos; + request.url); // 发送200响应: response.writeHead(200); // 将文件流导向response: fs.createReadStream(filepath).pipe(response); &#125; else &#123; // 出错了或者文件不存在: console.log(&apos;404 &apos; + request.url); // 发送404响应: response.writeHead(404); response.end(&apos;404 Not Found&apos;); &#125; &#125;);&#125;);server.listen(8080);console.log(&apos;Server is running at http://127.0.0.1:8080/&apos;); 没有必要手动读取文件内容。由于response对象本身是一个Writable Stream，直接用pipe()方法就实现了自动读取文件内容并输出到HTTP响应。 在命令行运行node file_server.js ./path/to/dir，把/path/to/dir改成你本地的file_server.js路径下一个有效的目录，然后在浏览器中输入http://localhost:8080/index.html： 只要当前目录下存在文件index.html，服务器就可以把文件内容发送给浏览器。观察控制台输出：1234F:\Node&gt;node demo2.js ./path/to/dirStatic root dir: F:\Node\path\to\dirServer is running at http://127.0.0.1:8080/200 /index.html 第一个请求是浏览器请求index.html页面，后续请求是浏览器解析HTML后发送的其它资源请求。 cryptocrypto模块的目的是为了提供通用的加密和哈希算法。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。Nodejs用C/C++实现这些算法后，通过cypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。 MD5和SHA1 MD5是一种常用的哈希算法，用于给任意数据一个“签名”。这个签名通常用一个十六进制的字符串表示：123456789const crypto = require(&apos;crypto&apos;);const hash = crypto.createHash(&apos;md5&apos;);// 可任意多次调用update():hash.update(&apos;Hello, world!&apos;);hash.update(&apos;Hello, nodejs!&apos;);console.log(hash.digest(&apos;hex&apos;)); // 7e1977739c748beac0c0fd14fd26a544 update()方法默认字符串编码为UTF-8，也可以传入Buffer。 如果要计算SHA1，只需要把&#39;md5&#39;改成&#39;sha1&#39;，就可以得到SHA1的结果1f32b9c9932c02227819a4151feed43e131aca40。 还可以使用更安全的sha256和sha512。 HmacHmac算法也是一种哈希算法，它可以利用MD5或SHA1等哈希算法。不同的是，Hmac还需要一个密钥：12345678const crypto = require(&apos;crypto&apos;);const hmac = crypto.createHmac(&apos;sha256&apos;, &apos;secret-key&apos;);hmac.update(&apos;Hello, world!&apos;);hmac.update(&apos;Hello, nodejs!&apos;);console.log(hmac.digest(&apos;hex&apos;)); // 80f7e22570. 只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，因此，可以把Hmac理解为用随机数“增强”的哈希算法。 AES AES是一种常用的对称加密算法，加解密都用同一个密钥。crypto模块提供了AES支持，但是需要自己封装好函数，便于使用：123456789101112131415161718192021222324const crypto = require(&apos;crypto&apos;);function aesEncrypt(data, key) &#123; const cipher = crypto.createCipher(&apos;aes192&apos;, key); var crypted = cipher.update(data, &apos;utf8&apos;, &apos;hex&apos;); crypted += cipher.final(&apos;hex&apos;); return crypted;&#125;function aesDecrypt(encrypted, key) &#123; const decipher = crypto.createDecipher(&apos;aes192&apos;, key); var decrypted = decipher.update(encrypted, &apos;hex&apos;, &apos;utf8&apos;); decrypted += decipher.final(&apos;utf8&apos;); return decrypted;&#125;var data = &apos;Hello, this is a secret message!&apos;;var key = &apos;Password!&apos;;var encrypted = aesEncrypt(data, key);var decrypted = aesDecrypt(encrypted, key);console.log(&apos;Plain text: &apos; + data);console.log(&apos;Encrypted text: &apos; + encrypted);console.log(&apos;Decrypted text: &apos; + decrypted); 运行结果如下：123Plain text: Hello, this is a secret message!Encrypted text: 8a944d97bdabc157a5b7a40cb180e7...Decrypted text: Hello, this is a secret message! 可以看出，加密后的字符串通过解密又得到了原始内容。 注意到AES有很多不同的算法，如aes192，aes-128-ecb，aes-256-cbc等，AES除了密钥外还可以指定IV（Initial Vector），不同的系统只要IV不同，用相同的密钥加密相同的数据得到的加密结果也是不同的。加密结果通常有两种表示方法：hex和base64，这些功能Nodejs全部都支持，但是在应用中要注意，如果加解密双方一方用Nodejs，另一方用Java、PHP等其它语言，需要仔细测试。如果无法正确解密，要确认双方是否遵循同样的AES算法，字符串密钥和IV是否相同，加密后的数据是否统一为hex或base64格式。 Diffie-Hellman DH算法是一种密钥交换协议，它可以让双方在不泄漏密钥的情况下协商出一个密钥来。DH算法基于数学原理，比如小明和小红想要协商一个密钥，可以这么做： 小明先选一个素数和一个底数，例如，素数p=23，底数g=5（底数可以任选），再选择一个秘密整数a=6，计算A=g^a mod p=8，然后大声告诉小红：p=23，g=5，A=8； 小红收到小明发来的p，g，A后，也选一个秘密整数b=15，然后计算B=g^b mod p=19，并大声告诉小明：B=19； 小明自己计算出s=B^a mod p=2，小红也自己计算出s=A^b mod p=2，因此，最终协商的密钥s为2。 在这个过程中，密钥2并不是小明告诉小红的，也不是小红告诉小明的，而是双方协商计算出来的。第三方只能知道p=23，g=5，A=8，B=19，由于不知道双方选的秘密整数a=6和b=15，因此无法计算出密钥2。 用crypto模块实现DH算法如下：1234567891011121314151617181920212223const crypto = require(&apos;crypto&apos;);// xiaoming&apos;s keys:var ming = crypto.createDiffieHellman(512);var ming_keys = ming.generateKeys();var prime = ming.getPrime();var generator = ming.getGenerator();console.log(&apos;Prime: &apos; + prime.toString(&apos;hex&apos;));console.log(&apos;Generator: &apos; + generator.toString(&apos;hex&apos;));// xiaohong&apos;s keys:var hong = crypto.createDiffieHellman(prime, generator);var hong_keys = hong.generateKeys();// exchange and generate secret:var ming_secret = ming.computeSecret(hong_keys);var hong_secret = hong.computeSecret(ming_keys);// print secret:console.log(&apos;Secret of Xiao Ming: &apos; + ming_secret.toString(&apos;hex&apos;));console.log(&apos;Secret of Xiao Hong: &apos; + hong_secret.toString(&apos;hex&apos;)); 运行后，可以得到如下输出：12345$ node dh.js Prime: a8224c...deead3Generator: 02Secret of Xiao Ming: 695308...d519beSecret of Xiao Hong: 695308...d519be 注意每次输出都不一样，因为素数的选择是随机的。 证书crypto模块也可以处理数字证书。数字证书通常用在SSL连接，也就是Web的https连接。一般情况下，https连接只需要处理服务器端的单向认证，如无特殊需求（例如自己作为Root给客户发认证证书），建议用反向代理服务器如Nginx等Web服务器去处理证书。 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/29/node-document/]]></content>
      <categories>
        <category>JS</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Node</tag>
        <tag>模块</tag>
        <tag>npm</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS构造函数及new运算符]]></title>
    <url>%2F2017%2F06%2F24%2Fcontructor-new(1)%2F</url>
    <content type="text"><![CDATA[JS中的函数即可以是构造函数又可以当作普通函数来调用，当使用new来创建对象时，对应的函数就是构造函数，通过对象来调用时就是普通函数。 普通函数的创建有：显式声明、匿名定义、new Function() 等三种方式。 当通过new来创建一个新对象时，JS底层将新对象的原型链指向了构造函数的原型对象，于是就在新对象和函数对象之间建立了一条原型链，通过新对象可以访问到函数对象原型prototype中的方法和属性。 和其他高级语言一样 Javascript 中也有构造函数和 new 运算符，我们知道 new 是用来实例化一个类，从而在内存中分配一个实例对象。 但在 Javascript 中，万物皆对象，为什么还要通过 new 来产生对象？ 本文将带你一起来探索 Javascript 中 new 的奥秘… 1、认识new运算符 1234567891011121314151617181920function Animal(name)&#123;this.name = name;&#125; Animal.color = &quot;black&quot;; Animal.prototype.say = function()&#123;console.log(&quot;I&apos;m &quot; + this.name); &#125;; var cat = new Animal(&quot;cat&quot;); console.log( cat.name, //cat cat.color //undefined ); cat.say(); //I&apos;m cat console.log( Animal.name, //Animal Animal.color //back ); Animal.say(); //Animal.say is not a function 2、代码解读 1-3行创建了一个函数Animal,并在其this上定义了属性:name,name的值是函数被执行时的形参。 第4行在Animal对象（Animal本身是一个函数对象）上定义了一个静态属性:color,并赋值“black” 5-7行在Animal函数的原型对象prototype上定义了一个say()方法，say方法输出了this的name值。 第8行通过new关键字创建了一个新对象cat 10-14行cat对象尝试访问name和color属性，并调用say方法。 16-20行Animal对象尝试访问name和color属性，并调用say方法。 3、重点解析 第8行代码是关键： var cat = new Animal(&quot;cat&quot;); Animal 本身是一个普通函数，但当通过new来创建对象时，Animal就是构造函数。JS引擎执行这句代码时，在内部做了很多工作，用伪代码模拟其工作流程如下： new Animal(&quot;cat&quot;) = { var obj = {}; obj.__proto__ = Animal.prototype; var result = Animal.call(obj,&quot;cat&quot;); return typeof result === &apos;object&apos;? result : obj; } （1）创建一个空对象obj; （2）把obj的__proto__指向构造函数Animal的原型对象prototype，此时便建立了obj对象的原型链：obj-&gt;Animal.prototype-&gt;Object.prototype-&gt;null （3）在obj对象的执行环境调用Animal 函数并传递参数“cat”。 相当于var result = obj.Animal(“cat”)。 （4）考察第3步返回的返回值，如果无返回值或者返回一个非对象值，则将obj返回作为新对象；否则会将返回值作为新对象返回。 理解了其运行机制以后，我们知道cat其实就是过程（4）的返回值，因此我们对cat对象的认知就多了一些： cat的原型链是：cat-&gt;Animal.prototype-&gt;Object.prototype-&gt;null cat上新增了一个属性：name 分析完了cat的产生过程，我们再看看输出结果： cat.name -&gt; 在过程（3）中，obj对象就产生了name属性。因此cat.name就是这里的obj.name cat.color -&gt; cat会先查找自身的color，没有找到便会沿着原型链查找，在上述例子中，我们仅在Animal对象上定义了color,并没有在其原型链上定义，因此找不到。 cat.say -&gt; cat会先查找自身的say方法，没有找到便会沿着原型链查找，在上述例子中，我们在Animal的prototype上定义了say,因此在原型链上找到了say方法。 另外，在say方法中还访问this.name，这里的this指的是其调用者obj,因此输出的是obj.name的值。 对于Animal来说，它本身也是一个对象，因此，它在访问属性和方法时也遵守上述查找规则，所以： Animal.color -&gt; “black” Animal.name -&gt; “Animal” , Animal先查找自身的name,找到了name, 但这个name不是我们定义的name,而是函数对象内置的属性。 一般情况下，函数对象在产生时会内置name属性并将函数名作为赋值（仅函数对象）。 Animal.say -&gt; Animal在自身没有找到say方法，也会沿着其原型链查找，话说Animal的原型链是什么呢？ 从测试结果看：Animal的原型链是这样的：Animal-&gt;Function.prototype-&gt;Object.prototype-&gt;null 因此Animal的原型链上没有定义say方法！ 4、new存在的意义认识了new运算符之后，我们再回到开篇提到的问题：JS中万物皆对象，为什么还要通过new来产生对象？ 要弄明白这个问题，我们首先要搞清楚cat和Animal的关系： 通过上面的分析，我们发现cat继承了Animal中的部分属性，因此我们可以简单的理解：Animal和cat是继承关系。 另一方面，cat是通过new产生的对象，那么cat到底是不是Animal的实例对象？ 我们先来了解一下JS是如何来定义“实例对象”的？ A instanceof B 如果上述表达式为true,JS认为A是B的实例对象，我们用这个方法来判断一下cat和Animal cat instanceof Animal; //true 从执行结果看：cat确实是Animal实例，要想证实这个结果，我们再来了解一下JS中instanceof的判断规则： var L = A.__proto__; var R = B.prototype; if(L === R) return true; 如果A的proto 等价于 B的prototype，就返回true 在new的执行过程（2）中，cat的proto指向了Animal的prototype，所以cat和Animal符合instanceof的判断结果。 因此，我们认为：cat 是Animal的实例对象。 5、总结在Javascript中, 通过new可以产生原对象的一个实例对象，而这个实例对象继承了原对象的属性和方法。因此，new存在的意义在于它实现了Javascript中的继承，而不仅仅是实例化了一个对象！ 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/24/contructor-new(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS构造函数及new运算符]]></title>
    <url>%2F2017%2F06%2F24%2Fcontructor-new%2F</url>
    <content type="text"><![CDATA[JS中的函数即可以是构造函数又可以当作普通函数来调用，当使用new来创建对象时，对应的函数就是构造函数，通过对象来调用时就是普通函数。 普通函数的创建有：显式声明、匿名定义、new Function() 等三种方式。 当通过new来创建一个新对象时，JS底层将新对象的原型链指向了构造函数的原型对象，于是就在新对象和函数对象之间建立了一条原型链，通过新对象可以访问到函数对象原型prototype中的方法和属性。 和其他高级语言一样 Javascript 中也有构造函数和 new 运算符，我们知道 new 是用来实例化一个类，从而在内存中分配一个实例对象。 但在 Javascript 中，万物皆对象，为什么还要通过 new 来产生对象？ 本文将带你一起来探索 Javascript 中 new 的奥秘… 1、认识new运算符 1234567891011121314151617181920function Animal(name)&#123;this.name = name;&#125; Animal.color = &quot;black&quot;; Animal.prototype.say = function()&#123;console.log(&quot;I&apos;m &quot; + this.name); &#125;; var cat = new Animal(&quot;cat&quot;); console.log( cat.name, //cat cat.color //undefined ); cat.say(); //I&apos;m cat console.log( Animal.name, //Animal Animal.color //back ); Animal.say(); //Animal.say is not a function 2、代码解读 1-3行创建了一个函数Animal,并在其this上定义了属性:name,name的值是函数被执行时的形参。 第4行在Animal对象（Animal本身是一个函数对象）上定义了一个静态属性:color,并赋值“black” 5-7行在Animal函数的原型对象prototype上定义了一个say()方法，say方法输出了this的name值。 第8行通过new关键字创建了一个新对象cat 10-14行cat对象尝试访问name和color属性，并调用say方法。 16-20行Animal对象尝试访问name和color属性，并调用say方法。 3、重点解析 第8行代码是关键： var cat = new Animal(&quot;cat&quot;); Animal 本身是一个普通函数，但当通过new来创建对象时，Animal就是构造函数。JS引擎执行这句代码时，在内部做了很多工作，用伪代码模拟其工作流程如下： new Animal(&quot;cat&quot;) = { var obj = {}; obj.__proto__ = Animal.prototype; var result = Animal.call(obj,&quot;cat&quot;); return typeof result === &apos;object&apos;? result : obj; } （1）创建一个空对象obj; （2）把obj的__proto__指向构造函数Animal的原型对象prototype，此时便建立了obj对象的原型链：obj-&gt;Animal.prototype-&gt;Object.prototype-&gt;null （3）在obj对象的执行环境调用Animal 函数并传递参数“cat”。 相当于var result = obj.Animal(“cat”)。 （4）考察第3步返回的返回值，如果无返回值或者返回一个非对象值，则将obj返回作为新对象；否则会将返回值作为新对象返回。 理解了其运行机制以后，我们知道cat其实就是过程（4）的返回值，因此我们对cat对象的认知就多了一些： cat的原型链是：cat-&gt;Animal.prototype-&gt;Object.prototype-&gt;null cat上新增了一个属性：name 分析完了cat的产生过程，我们再看看输出结果： cat.name -&gt; 在过程（3）中，obj对象就产生了name属性。因此cat.name就是这里的obj.name cat.color -&gt; cat会先查找自身的color，没有找到便会沿着原型链查找，在上述例子中，我们仅在Animal对象上定义了color,并没有在其原型链上定义，因此找不到。 cat.say -&gt; cat会先查找自身的say方法，没有找到便会沿着原型链查找，在上述例子中，我们在Animal的prototype上定义了say,因此在原型链上找到了say方法。 另外，在say方法中还访问this.name，这里的this指的是其调用者obj,因此输出的是obj.name的值。 对于Animal来说，它本身也是一个对象，因此，它在访问属性和方法时也遵守上述查找规则，所以： Animal.color -&gt; “black” Animal.name -&gt; “Animal” , Animal先查找自身的name,找到了name, 但这个name不是我们定义的name,而是函数对象内置的属性。 一般情况下，函数对象在产生时会内置name属性并将函数名作为赋值（仅函数对象）。 Animal.say -&gt; Animal在自身没有找到say方法，也会沿着其原型链查找，话说Animal的原型链是什么呢？ 从测试结果看：Animal的原型链是这样的：Animal-&gt;Function.prototype-&gt;Object.prototype-&gt;null 因此Animal的原型链上没有定义say方法！ 4、new存在的意义认识了new运算符之后，我们再回到开篇提到的问题：JS中万物皆对象，为什么还要通过new来产生对象？ 要弄明白这个问题，我们首先要搞清楚cat和Animal的关系： 通过上面的分析，我们发现cat继承了Animal中的部分属性，因此我们可以简单的理解：Animal和cat是继承关系。 另一方面，cat是通过new产生的对象，那么cat到底是不是Animal的实例对象？ 我们先来了解一下JS是如何来定义“实例对象”的？ A instanceof B 如果上述表达式为true,JS认为A是B的实例对象，我们用这个方法来判断一下cat和Animal cat instanceof Animal; //true 从执行结果看：cat确实是Animal实例，要想证实这个结果，我们再来了解一下JS中instanceof的判断规则： var L = A.__proto__; var R = B.prototype; if(L === R) return true; 如果A的proto 等价于 B的prototype，就返回true 在new的执行过程（2）中，cat的proto指向了Animal的prototype，所以cat和Animal符合instanceof的判断结果。 因此，我们认为：cat 是Animal的实例对象。 5、总结在Javascript中, 通过new可以产生原对象的一个实例对象，而这个实例对象继承了原对象的属性和方法。因此，new存在的意义在于它实现了Javascript中的继承，而不仅仅是实例化了一个对象！ 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/24/contructor-new/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JS执行细节]]></title>
    <url>%2F2017%2F06%2F24%2FGlobal-object-window(1)%2F</url>
    <content type="text"><![CDATA[在JS中，当一段JS代码在浏览器中被加载执行，JS引擎会在内存中构建一个全局执行环境，执行环境的作用是保证所有的函数能按照正确的顺序被执行，而window对象则是这个执行环境中的一个全局对象，window对象中内置了很多操作api和对象，document对象就是其中一个 深入理解JS执行细节Javascript从定义到执行，JS引擎在实现层做了很多初始化工作，因此在学习JS引擎工作机制之前，我们需要引入几个相关的概念：执行环境栈、全局对象、执行环境、变量对象、活动对象、作用域和作用域链等，这些概念正是JS引擎工作的核心组件。这篇文章的目的不是孤立的为你讲解每一个概念，而是通过一个简单的DEMO来展开分析，全局讲解JS引擎从定义到执行的每一个细节，以及这些概念在其中所扮演的角色。 12345678910var x = 1; //定义一个全局变量 xfunction A(y)&#123; var x = 2; //定义一个局部变量 x function B(z)&#123; //定义一个内部函数 B console.log(x+y+z); &#125; return B; //返回函数B的引用&#125;var C = A(1); //执行A,返回BC(1); //执行函数B，输出 4 下面我们将分全局初始化、执行函数A、执行函数B 三个阶段来分析JS引擎的工作机制： 1、全局初始化JS引擎在进入一段可执行的代码时，需要完成以下三个初始化工作： 首先，创建一个全局对象(Global Object) ， 这个对象全局只存在一份，它的属性在任何地方都可以访问，它的存在伴随着应用程序的整个生命周期。全局对象在创建时，将Math,String,Date,document 等常用的JS对象作为其属性。由于这个全局对象不能通过名字直接访问，因此还有另外一个属性window,并将window指向了自身，这样就可以通过window访问这个全局对象了。用伪代码模拟全局对象的大体结构如下： 123456789//创建一个全局对象var globalObject = &#123; Math:&#123;&#125;, String:&#123;&#125;, Date:&#123;&#125;, document:&#123;&#125;, //DOM操作 ... window:this //让window属性指向了自身&#125; 然后，JS引擎需要构建一个执行环境栈( Execution Context Stack) ，与此同时，也要创建一个全局执行环境（Execution Context）EC ，并将这个全局执行环境EC压入执行环境栈中。执行环境栈的作用是为了保证程序能够按照正确的顺序被执行。在javascript中，每个函数都有自己的执行环境，当执行一个函数时，该函数的执行环境就会被推入执行环境栈的顶部并获取执行权。当这个函数执行完毕，它的执行环境又从这个栈的顶部被删除，并把执行权并还给之前执行环境。我们用伪代码来模拟执行环境栈和EC的关系： 12345678910ECStack = [ //执行环境栈 EC(G) = &#123; //全局执行环境 VO(G):&#123; //定义全局变量对象 ... //包含全局对象原有的属性 x = 1; //定义变量x A = function()&#123;...&#125;; //定义函数A A[[scope]] = this; //定义A的scope，并赋值为VO本身 &#125; &#125;]; 2、 执行函数A当执行进入A(1) 时，JS引擎需要完成以下工作： 首先，JS引擎会创建函数A的执行环境EC，然后EC推入执行环境栈的顶部并获取执行权。此时执行环境栈中有两个执行环境，分别是全局执行环境**和函数A执行环境，A的执行环境在栈顶，全局执行环境在栈的底部。然后，创建函数A的作用域链(Scope Chain) ，在javascript中，每个执行环境都有自己的作用域链，用于标识符解析，当执行环境被创建时，它的作用域链就初始化为当前运行函数的scope所包含的对象。 ** 接着，JS引擎会创建一个当前函数的活动对象(Activation Object) AO，这里的活动对象扮演着变量对象的角色，只是在函数中的叫法不同而已（你可以认为变量对象是一个总的概念，而活动对象是它的一个分支）， AO中包含了函数的形参、arguments对象、this对象、以及局部变量和内部函数的定义，然后AO会被推入作用域链的顶端。需要注意的是，在定义函数B的时候，JS引擎同样也会为B添加了一个scope属性,并将scope指向了定义函数B时所在的环境，定义函数B的环境就是A的活动对象AO， 而AO位于链表的前端，由于链表具有首尾相连的特点，因此函数B的scope指向了A的整个作用域链。 我们再看看此时的ECStack结构： 12345678910111213141516171819202122ECStack = [ //执行环境栈 EC(A) = &#123; //A的执行环境 [scope]:VO(G), //VO是全局变量对象 AO(A) : &#123; //创建函数A的活动对象 y:1, x:2, //定义局部变量x B:function()&#123;...&#125;, //定义函数B B[[scope]] = this; //this指代AO本身，而AO位于scopeChain的顶端，因此B[[scope]]指向整个作用域链 arguments:[],//平时我们在函数中访问的arguments就是AO中的arguments this:window //函数中的this指向调用者window对象 &#125;, scopeChain:&lt;AO(A),A[[scope]]&gt; //链表初始化为A[[scope]],然后再把AO加入该作用域链的顶端,此时A的作用域链：AO(A)-&gt;VO(G) &#125;, EC(G) = &#123; //全局执行环境 VO(G):&#123; //创建全局变量对象 ... //包含全局对象原有的属性 x = 1; //定义变量x A = function()&#123;...&#125;; //定义函数A A[[scope]] = this; //定义A的scope，A[[scope]] == VO(G) &#125; &#125;]; 3、 执行函数B函数A被执行以后，返回了B的引用，并赋值给了变量C，执行 C(1) 就相当于执行B(1)，JS引擎需要完成以下工作： 首先，还和上面一样，创建函数B的执行环境EC，然后EC推入执行环境栈的顶部并获取执行权。 此时执行环境栈中有两个执行环境，分别是全局执行环境和函数B的执行环境，B的执行环境在栈顶，全局执行环境在栈的底部。（注意：当函数A返回后，A的执行环境就会从栈中被删除，只留下全局执行环境）然后，创建函数B的作用域链，并初始化为函数B的scope所包含的对象，即包含了A的作用域链。最后，创建函数B的活动对象AO,并将B的形参z, arguments对象 和 this对象作为AO的属性。此时ECStack将会变成这样：1234567891011121314151617181920ECStack = [ //执行环境栈 EC(B) = &#123; //创建B的执行环境,并处于作用域链的顶端 [scope]:AO(A), //指向函数A的作用域链,AO(A)-&gt;VO(G) var AO(B) = &#123; //创建函数B的活动对象 z:1, arguments:[], this:window &#125; scopeChain:&lt;AO(B),B[[scope]]&gt; //链表初始化为B[[scope]],再将AO(B)加入链表表头，此时B的作用域链：AO(B)-&gt;AO(A)-VO(G) &#125;, EC(A), //A的执行环境已经从栈顶被删除, EC(G) = &#123; //全局执行环境 VO:&#123; //定义全局变量对象 ... //包含全局对象原有的属性 x = 1; //定义变量x A = function()&#123;...&#125;; //定义函数A A[[scope]] = this; //定义A的scope，A[[scope]] == VO(G) &#125; &#125;]; 当函数B执行“x+y+z”时，需要对x、y、z 三个标识符进行一一解析，解析过程遵守变量查找规则：先查找自己的活动对象中是否存在该属性，如果存在，则停止查找并返回；如果不存在，继续沿着其作用域链从顶端依次查找，直到找到为止，如果整个作用域链上都未找到该变量，则返回“undefined”。从上面的分析可以看出函数B的作用域链是这样的：1AO(B)-&gt;AO(A)-&gt;VO(G) 因此，变量x会在AO(A)中被找到，而不会查找VO(G)中的x，变量y也会在AO(A)中被找到，变量z 在自身的AO(B)中就找到了。所以执行结果：2+1+1=4 ps:var C = A(1); // 使y=1;C(1); //使z=1 4、总结了解了JS引擎的工作机制之后，我们不能只停留在理解概念的层面，而要将其作为基础工具，用以优化和改善我们在实际工作中的代码，提高执行效率，产生实际价值才是我们的真正目的。就拿变量查找机制来说，如果你的代码嵌套很深，每引用一次全局变量，JS引擎就要查找整个作用域链，比如处于作用域链的最底端window和document对象就存在这个问题，因此我们围绕这个问题可以做很多性能优化的工作，当然还有其他方面的优化，此处不再赘述，本文仅当作抛砖引玉吧！ 来源：一像素 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/24/Global-object-window(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS引擎</tag>
        <tag>作用域</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JS执行细节]]></title>
    <url>%2F2017%2F06%2F24%2FGlobal-object-window%2F</url>
    <content type="text"><![CDATA[在JS中，当一段JS代码在浏览器中被加载执行，JS引擎会在内存中构建一个全局执行环境，执行环境的作用是保证所有的函数能按照正确的顺序被执行，而window对象则是这个执行环境中的一个全局对象，window对象中内置了很多操作api和对象，document对象就是其中一个 深入理解JS执行细节Javascript从定义到执行，JS引擎在实现层做了很多初始化工作，因此在学习JS引擎工作机制之前，我们需要引入几个相关的概念：执行环境栈、全局对象、执行环境、变量对象、活动对象、作用域和作用域链等，这些概念正是JS引擎工作的核心组件。这篇文章的目的不是孤立的为你讲解每一个概念，而是通过一个简单的DEMO来展开分析，全局讲解JS引擎从定义到执行的每一个细节，以及这些概念在其中所扮演的角色。 12345678910var x = 1; //定义一个全局变量 xfunction A(y)&#123; var x = 2; //定义一个局部变量 x function B(z)&#123; //定义一个内部函数 B console.log(x+y+z); &#125; return B; //返回函数B的引用&#125;var C = A(1); //执行A,返回BC(1); //执行函数B，输出 4 下面我们将分全局初始化、执行函数A、执行函数B 三个阶段来分析JS引擎的工作机制： 1、全局初始化JS引擎在进入一段可执行的代码时，需要完成以下三个初始化工作： 首先，创建一个全局对象(Global Object) ， 这个对象全局只存在一份，它的属性在任何地方都可以访问，它的存在伴随着应用程序的整个生命周期。全局对象在创建时，将Math,String,Date,document 等常用的JS对象作为其属性。由于这个全局对象不能通过名字直接访问，因此还有另外一个属性window,并将window指向了自身，这样就可以通过window访问这个全局对象了。用伪代码模拟全局对象的大体结构如下： 123456789//创建一个全局对象var globalObject = &#123; Math:&#123;&#125;, String:&#123;&#125;, Date:&#123;&#125;, document:&#123;&#125;, //DOM操作 ... window:this //让window属性指向了自身&#125; 然后，JS引擎需要构建一个执行环境栈( Execution Context Stack) ，与此同时，也要创建一个全局执行环境（Execution Context）EC ，并将这个全局执行环境EC压入执行环境栈中。执行环境栈的作用是为了保证程序能够按照正确的顺序被执行。在javascript中，每个函数都有自己的执行环境，当执行一个函数时，该函数的执行环境就会被推入执行环境栈的顶部并获取执行权。当这个函数执行完毕，它的执行环境又从这个栈的顶部被删除，并把执行权并还给之前执行环境。我们用伪代码来模拟执行环境栈和EC的关系： 12345678910ECStack = [ //执行环境栈 EC(G) = &#123; //全局执行环境 VO(G):&#123; //定义全局变量对象 ... //包含全局对象原有的属性 x = 1; //定义变量x A = function()&#123;...&#125;; //定义函数A A[[scope]] = this; //定义A的scope，并赋值为VO本身 &#125; &#125;]; 2、 执行函数A当执行进入A(1) 时，JS引擎需要完成以下工作： 首先，JS引擎会创建函数A的执行环境EC，然后EC推入执行环境栈的顶部并获取执行权。此时执行环境栈中有两个执行环境，分别是全局执行环境**和函数A执行环境，A的执行环境在栈顶，全局执行环境在栈的底部。然后，创建函数A的作用域链(Scope Chain) ，在javascript中，每个执行环境都有自己的作用域链，用于标识符解析，当执行环境被创建时，它的作用域链就初始化为当前运行函数的scope所包含的对象。 ** 接着，JS引擎会创建一个当前函数的活动对象(Activation Object) AO，这里的活动对象扮演着变量对象的角色，只是在函数中的叫法不同而已（你可以认为变量对象是一个总的概念，而活动对象是它的一个分支）， AO中包含了函数的形参、arguments对象、this对象、以及局部变量和内部函数的定义，然后AO会被推入作用域链的顶端。需要注意的是，在定义函数B的时候，JS引擎同样也会为B添加了一个scope属性,并将scope指向了定义函数B时所在的环境，定义函数B的环境就是A的活动对象AO， 而AO位于链表的前端，由于链表具有首尾相连的特点，因此函数B的scope指向了A的整个作用域链。 我们再看看此时的ECStack结构： 12345678910111213141516171819202122ECStack = [ //执行环境栈 EC(A) = &#123; //A的执行环境 [scope]:VO(G), //VO是全局变量对象 AO(A) : &#123; //创建函数A的活动对象 y:1, x:2, //定义局部变量x B:function()&#123;...&#125;, //定义函数B B[[scope]] = this; //this指代AO本身，而AO位于scopeChain的顶端，因此B[[scope]]指向整个作用域链 arguments:[],//平时我们在函数中访问的arguments就是AO中的arguments this:window //函数中的this指向调用者window对象 &#125;, scopeChain:&lt;AO(A),A[[scope]]&gt; //链表初始化为A[[scope]],然后再把AO加入该作用域链的顶端,此时A的作用域链：AO(A)-&gt;VO(G) &#125;, EC(G) = &#123; //全局执行环境 VO(G):&#123; //创建全局变量对象 ... //包含全局对象原有的属性 x = 1; //定义变量x A = function()&#123;...&#125;; //定义函数A A[[scope]] = this; //定义A的scope，A[[scope]] == VO(G) &#125; &#125;]; 3、 执行函数B函数A被执行以后，返回了B的引用，并赋值给了变量C，执行 C(1) 就相当于执行B(1)，JS引擎需要完成以下工作： 首先，还和上面一样，创建函数B的执行环境EC，然后EC推入执行环境栈的顶部并获取执行权。 此时执行环境栈中有两个执行环境，分别是全局执行环境和函数B的执行环境，B的执行环境在栈顶，全局执行环境在栈的底部。（注意：当函数A返回后，A的执行环境就会从栈中被删除，只留下全局执行环境）然后，创建函数B的作用域链，并初始化为函数B的scope所包含的对象，即包含了A的作用域链。最后，创建函数B的活动对象AO,并将B的形参z, arguments对象 和 this对象作为AO的属性。此时ECStack将会变成这样：1234567891011121314151617181920ECStack = [ //执行环境栈 EC(B) = &#123; //创建B的执行环境,并处于作用域链的顶端 [scope]:AO(A), //指向函数A的作用域链,AO(A)-&gt;VO(G) var AO(B) = &#123; //创建函数B的活动对象 z:1, arguments:[], this:window &#125; scopeChain:&lt;AO(B),B[[scope]]&gt; //链表初始化为B[[scope]],再将AO(B)加入链表表头，此时B的作用域链：AO(B)-&gt;AO(A)-VO(G) &#125;, EC(A), //A的执行环境已经从栈顶被删除, EC(G) = &#123; //全局执行环境 VO:&#123; //定义全局变量对象 ... //包含全局对象原有的属性 x = 1; //定义变量x A = function()&#123;...&#125;; //定义函数A A[[scope]] = this; //定义A的scope，A[[scope]] == VO(G) &#125; &#125;]; 当函数B执行“x+y+z”时，需要对x、y、z 三个标识符进行一一解析，解析过程遵守变量查找规则：先查找自己的活动对象中是否存在该属性，如果存在，则停止查找并返回；如果不存在，继续沿着其作用域链从顶端依次查找，直到找到为止，如果整个作用域链上都未找到该变量，则返回“undefined”。从上面的分析可以看出函数B的作用域链是这样的：1AO(B)-&gt;AO(A)-&gt;VO(G) 因此，变量x会在AO(A)中被找到，而不会查找VO(G)中的x，变量y也会在AO(A)中被找到，变量z 在自身的AO(B)中就找到了。所以执行结果：2+1+1=4 ps:var C = A(1); // 使y=1;C(1); //使z=1 4、总结了解了JS引擎的工作机制之后，我们不能只停留在理解概念的层面，而要将其作为基础工具，用以优化和改善我们在实际工作中的代码，提高执行效率，产生实际价值才是我们的真正目的。就拿变量查找机制来说，如果你的代码嵌套很深，每引用一次全局变量，JS引擎就要查找整个作用域链，比如处于作用域链的最底端window和document对象就存在这个问题，因此我们围绕这个问题可以做很多性能优化的工作，当然还有其他方面的优化，此处不再赘述，本文仅当作抛砖引玉吧！ 来源：一像素 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/24/Global-object-window/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS引擎</tag>
        <tag>作用域</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器同源政策及其规避方法]]></title>
    <url>%2F2017%2F06%2F24%2Fsame-origin-poolicy(1)%2F</url>
    <content type="text"><![CDATA[浏览器安全的基石是”同源政策”（same-origin policy）。很多开发者都知道这一点，但了解得不全面。本文详细介绍”同源政策”的各个方面，以及如何规避它。 一、概述1.1 含义1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”。所谓”同源”指的是”三个相同”。 协议相同 域名相同 端口相同 举例来说，http://www.example.com/dir/page.html这个网址，协议是http://，域名是www.example.com，端口是80（默认端口可以省略）。它的同源情况如下。 http://www.example.com/dir2/other.html：同源 http://example.com/dir/other.html：不同源（域名不同） http://v2.www.example.com/dir/other.html：不同源（域名不同） http://www.example.com:81/dir/other.html：不同源（端口不同） 1.2 目的同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。 1.3 限制范围随着互联网的发展，”同源政策”越来越严格。目前，如果非同源，共有三种行为受到限制。（1） Cookie、LocalStorage 和 IndexDB 无法读取。（2） DOM 无法获得。（3） AJAX 请求不能发送。 虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面，我将详细介绍，如何规避上面三种限制。 二、CookieCookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie。举例来说，A网页是http://w1.example.com/a.html，B网页是http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享Cookie。 1document.domain = &apos;example.com&apos;; 现在，A网页通过脚本设置一个 Cookie。1document.cookie = &quot;test1=hello&quot;; B网页就可以读到这个 Cookie。1var allCookie = document.cookie; 注意，这种方法只适用于Cookie 和iframe窗口，LocalStorage 和 IndexDB无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。 另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如.example.com。1Set-Cookie: key=value; domain=.example.com; path=/ 这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。 三、iframe如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。 比如，父窗口运行下面的命令，如果iframe窗口不是同源，就会报错。12document.getElementById(&quot;myIFrame&quot;).contentWindow.document// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame. 上面命令中，父窗口想获取子窗口的DOM，因为跨源导致报错。反之亦然，子窗口获取主窗口的DOM也会报错。12window.parent.document.body// 报错 如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的document.domain属性，就可以规避同源政策，拿到DOM。 对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。 片段识别符（fragment identifier） window.name 跨文档通信API（Cross-document messaging） 3.1 片段识别符片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。父窗口可以把信息，写入子窗口的片段标识符。 12var src = originURL + &apos;#&apos; + data;document.getElementById(&apos;myIFrame&apos;).src = src; 子窗口通过监听hashchange事件得到通知。123456window.onhashchange = checkMessage;function checkMessage() &#123; var message = window.location.hash; // ...&#125; 同样的，子窗口也可以改变父窗口的片段标识符。parent.location.href= target + &quot;#&quot; + hash; 3.2 window.name浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入window.name属性。1window.name = data; 接着，子窗口跳回一个与主窗口同域的网址。1location = &apos;http://parent.url.com/xxx.html&apos;; 然后，主窗口就可以读取子窗口的window.name了。1var data = document.getElementById(&apos;myFrame&apos;).contentWindow.name; 这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。 3.3 window.postMessage上面两种方法都属于破解，HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。举例来说，父窗口http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法就可以了。12var popup = window.open(&apos;http://bbb.com&apos;, &apos;title&apos;);popup.postMessage(&apos;Hello World!&apos;, &apos;http://bbb.com&apos;); postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即”协议 + 域名 + 端口”。也可以设为*，表示不限制域名，向所有窗口发送。子窗口向父窗口发送消息的写法类似。 1window.opener.postMessage(&apos;Nice to see you&apos;, &apos;http://aaa.com&apos;); 父窗口和子窗口都可以通过message事件，监听对方的消息。123window.addEventListener(&apos;message&apos;, function(e) &#123; console.log(e.data);&#125;,false); message事件的事件对象event，提供以下三个属性。 event.source：发送消息的窗口 event.origin: 消息发向的网址 event.data: 消息内容 下面的例子是，子窗口通过event.source属性引用父窗口，然后发送消息。1234window.addEventListener(&apos;message&apos;, receiveMessage);function receiveMessage(event) &#123; event.source.postMessage(&apos;Nice to see you!&apos;, &apos;*&apos;);&#125; event.origin属性可以过滤不是发给本窗口的消息。123456789window.addEventListener(&apos;message&apos;, receiveMessage);function receiveMessage(event) &#123; if (event.origin !== &apos;http://aaa.com&apos;) return; if (event.data === &apos;Hello World&apos;) &#123; event.source.postMessage(&apos;Hello&apos;, event.origin); &#125; else &#123; console.log(event.data); &#125;&#125; 3.4 LocalStorage通过window.postMessage，读写其他窗口的 LocalStorage也成为了可能。下面是一个例子，主窗口写入iframe子窗口的localStorage。1234567window.onmessage = function(e) &#123; if (e.origin !== &apos;http://bbb.com&apos;) &#123; return; &#125; var payload = JSON.parse(e.data); localStorage.setItem(payload.key, JSON.stringify(payload.data));&#125;; 上面代码中，子窗口将父窗口发来的消息，写入自己的LocalStorage。父窗口发送消息的代码如下。123var win = document.getElementsByTagName(&apos;iframe&apos;)[0].contentWindow;var obj = &#123; name: &apos;Jack&apos; &#125;;win.postMessage(JSON.stringify(&#123;key: &apos;storage&apos;, data: obj&#125;), &apos;http://bbb.com&apos;); 加强版的子窗口接收消息的代码如下。1234567891011121314151617window.onmessage = function(e) &#123; if (e.origin !== &apos;http://bbb.com&apos;) return; var payload = JSON.parse(e.data); switch (payload.method) &#123; case &apos;set&apos;: localStorage.setItem(payload.key, JSON.stringify(payload.data)); break; case &apos;get&apos;: var parent = window.parent; var data = localStorage.getItem(payload.key); parent.postMessage(data, &apos;http://aaa.com&apos;); break; case &apos;remove&apos;: localStorage.removeItem(payload.key); break; &#125;&#125;; 加强版的父窗口发送消息代码如下。1234567891011var win = document.getElementsByTagName(&apos;iframe&apos;)[0].contentWindow;var obj = &#123; name: &apos;Jack&apos; &#125;;// 存入对象win.postMessage(JSON.stringify(&#123;key: &apos;storage&apos;, method: &apos;set&apos;, data: obj&#125;), &apos;http://bbb.com&apos;);// 读取对象win.postMessage(JSON.stringify(&#123;key: &apos;storage&apos;, method: &quot;get&quot;&#125;), &quot;*&quot;);window.onmessage = function(e) &#123; if (e.origin != &apos;http://aaa.com&apos;) return; // &quot;Jack&quot; console.log(JSON.parse(e.data).name);&#125;; 四、AJAX同源政策规定，AJAX请求只能发给同源的网址，否则就报错。除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。 JSONP WebSocket CORS 4.1 JSONPJSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。它的基本思想是，网页通过添加一个&lt;script&gt;元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。 首先，网页动态插入&lt;script&gt;元素，由它向跨源网址发出请求。1234567891011121314function addScriptTag(src) &#123; var script = document.createElement(&apos;script&apos;); script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;); script.src = src; document.body.appendChild(script);&#125;window.onload = function () &#123; addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);&#125;function foo(data) &#123; console.log(&apos;Your public IP address is: &apos; + data.ip);&#125;; 上面代码通过动态添加&lt;script&gt;元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。 123foo(&#123; &quot;ip&quot;: &quot;8.8.8.8&quot;&#125;); 由于&lt;script&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 4.2 WebSocketWebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自维基百科）。12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat 4.3 CORSCORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。 详细CORS介绍的文章:如何通过CORS完成跨源AJAX请求 来源：阮一峰 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/24/same-origin-poolicy(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>浏览器</tag>
        <tag>Jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器同源政策及其规避方法]]></title>
    <url>%2F2017%2F06%2F24%2Fsame-origin-poolicy%2F</url>
    <content type="text"><![CDATA[浏览器安全的基石是”同源政策”（same-origin policy）。很多开发者都知道这一点，但了解得不全面。本文详细介绍”同源政策”的各个方面，以及如何规避它。 一、概述1.1 含义1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”。所谓”同源”指的是”三个相同”。 协议相同 域名相同 端口相同 举例来说，http://www.example.com/dir/page.html这个网址，协议是http://，域名是www.example.com，端口是80（默认端口可以省略）。它的同源情况如下。 http://www.example.com/dir2/other.html：同源 http://example.com/dir/other.html：不同源（域名不同） http://v2.www.example.com/dir/other.html：不同源（域名不同） http://www.example.com:81/dir/other.html：不同源（端口不同） 1.2 目的同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。 1.3 限制范围随着互联网的发展，”同源政策”越来越严格。目前，如果非同源，共有三种行为受到限制。（1） Cookie、LocalStorage 和 IndexDB 无法读取。（2） DOM 无法获得。（3） AJAX 请求不能发送。 虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面，我将详细介绍，如何规避上面三种限制。 二、CookieCookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie。举例来说，A网页是http://w1.example.com/a.html，B网页是http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享Cookie。 1document.domain = &apos;example.com&apos;; 现在，A网页通过脚本设置一个 Cookie。1document.cookie = &quot;test1=hello&quot;; B网页就可以读到这个 Cookie。1var allCookie = document.cookie; 注意，这种方法只适用于Cookie 和iframe窗口，LocalStorage 和 IndexDB无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。 另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如.example.com。1Set-Cookie: key=value; domain=.example.com; path=/ 这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。 三、iframe如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。 比如，父窗口运行下面的命令，如果iframe窗口不是同源，就会报错。12document.getElementById(&quot;myIFrame&quot;).contentWindow.document// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame. 上面命令中，父窗口想获取子窗口的DOM，因为跨源导致报错。反之亦然，子窗口获取主窗口的DOM也会报错。12window.parent.document.body// 报错 如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的document.domain属性，就可以规避同源政策，拿到DOM。 对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。 片段识别符（fragment identifier） window.name 跨文档通信API（Cross-document messaging） 3.1 片段识别符片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。父窗口可以把信息，写入子窗口的片段标识符。 12var src = originURL + &apos;#&apos; + data;document.getElementById(&apos;myIFrame&apos;).src = src; 子窗口通过监听hashchange事件得到通知。123456window.onhashchange = checkMessage;function checkMessage() &#123; var message = window.location.hash; // ...&#125; 同样的，子窗口也可以改变父窗口的片段标识符。parent.location.href= target + &quot;#&quot; + hash; 3.2 window.name浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入window.name属性。1window.name = data; 接着，子窗口跳回一个与主窗口同域的网址。1location = &apos;http://parent.url.com/xxx.html&apos;; 然后，主窗口就可以读取子窗口的window.name了。1var data = document.getElementById(&apos;myFrame&apos;).contentWindow.name; 这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。 3.3 window.postMessage上面两种方法都属于破解，HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。举例来说，父窗口http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法就可以了。12var popup = window.open(&apos;http://bbb.com&apos;, &apos;title&apos;);popup.postMessage(&apos;Hello World!&apos;, &apos;http://bbb.com&apos;); postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即”协议 + 域名 + 端口”。也可以设为*，表示不限制域名，向所有窗口发送。子窗口向父窗口发送消息的写法类似。 1window.opener.postMessage(&apos;Nice to see you&apos;, &apos;http://aaa.com&apos;); 父窗口和子窗口都可以通过message事件，监听对方的消息。123window.addEventListener(&apos;message&apos;, function(e) &#123; console.log(e.data);&#125;,false); message事件的事件对象event，提供以下三个属性。 event.source：发送消息的窗口 event.origin: 消息发向的网址 event.data: 消息内容 下面的例子是，子窗口通过event.source属性引用父窗口，然后发送消息。1234window.addEventListener(&apos;message&apos;, receiveMessage);function receiveMessage(event) &#123; event.source.postMessage(&apos;Nice to see you!&apos;, &apos;*&apos;);&#125; event.origin属性可以过滤不是发给本窗口的消息。123456789window.addEventListener(&apos;message&apos;, receiveMessage);function receiveMessage(event) &#123; if (event.origin !== &apos;http://aaa.com&apos;) return; if (event.data === &apos;Hello World&apos;) &#123; event.source.postMessage(&apos;Hello&apos;, event.origin); &#125; else &#123; console.log(event.data); &#125;&#125; 3.4 LocalStorage通过window.postMessage，读写其他窗口的 LocalStorage也成为了可能。下面是一个例子，主窗口写入iframe子窗口的localStorage。1234567window.onmessage = function(e) &#123; if (e.origin !== &apos;http://bbb.com&apos;) &#123; return; &#125; var payload = JSON.parse(e.data); localStorage.setItem(payload.key, JSON.stringify(payload.data));&#125;; 上面代码中，子窗口将父窗口发来的消息，写入自己的LocalStorage。父窗口发送消息的代码如下。123var win = document.getElementsByTagName(&apos;iframe&apos;)[0].contentWindow;var obj = &#123; name: &apos;Jack&apos; &#125;;win.postMessage(JSON.stringify(&#123;key: &apos;storage&apos;, data: obj&#125;), &apos;http://bbb.com&apos;); 加强版的子窗口接收消息的代码如下。1234567891011121314151617window.onmessage = function(e) &#123; if (e.origin !== &apos;http://bbb.com&apos;) return; var payload = JSON.parse(e.data); switch (payload.method) &#123; case &apos;set&apos;: localStorage.setItem(payload.key, JSON.stringify(payload.data)); break; case &apos;get&apos;: var parent = window.parent; var data = localStorage.getItem(payload.key); parent.postMessage(data, &apos;http://aaa.com&apos;); break; case &apos;remove&apos;: localStorage.removeItem(payload.key); break; &#125;&#125;; 加强版的父窗口发送消息代码如下。1234567891011var win = document.getElementsByTagName(&apos;iframe&apos;)[0].contentWindow;var obj = &#123; name: &apos;Jack&apos; &#125;;// 存入对象win.postMessage(JSON.stringify(&#123;key: &apos;storage&apos;, method: &apos;set&apos;, data: obj&#125;), &apos;http://bbb.com&apos;);// 读取对象win.postMessage(JSON.stringify(&#123;key: &apos;storage&apos;, method: &quot;get&quot;&#125;), &quot;*&quot;);window.onmessage = function(e) &#123; if (e.origin != &apos;http://aaa.com&apos;) return; // &quot;Jack&quot; console.log(JSON.parse(e.data).name);&#125;; 四、AJAX同源政策规定，AJAX请求只能发给同源的网址，否则就报错。除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。 JSONP WebSocket CORS 4.1 JSONPJSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。它的基本思想是，网页通过添加一个&lt;script&gt;元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。 首先，网页动态插入&lt;script&gt;元素，由它向跨源网址发出请求。1234567891011121314function addScriptTag(src) &#123; var script = document.createElement(&apos;script&apos;); script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;); script.src = src; document.body.appendChild(script);&#125;window.onload = function () &#123; addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);&#125;function foo(data) &#123; console.log(&apos;Your public IP address is: &apos; + data.ip);&#125;; 上面代码通过动态添加&lt;script&gt;元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。 123foo(&#123; &quot;ip&quot;: &quot;8.8.8.8&quot;&#125;); 由于&lt;script&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 4.2 WebSocketWebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自维基百科）。12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat 4.3 CORSCORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。 详细CORS介绍的文章:如何通过CORS完成跨源AJAX请求 来源：阮一峰 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/24/same-origin-poolicy/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>浏览器</tag>
        <tag>Jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域资源共享 CORS 详解]]></title>
    <url>%2F2017%2F06%2F24%2Fajax-1%2F</url>
    <content type="text"><![CDATA[Ajax是浏览器专门用来和服务器进行交互的异步通讯技术，其核心对象是XMLHttpRequest,通过该对象可以创建一个Ajax请求。 为了防止XSS攻击，浏览器对Ajax做了限制，不允许Ajax跨域请求服务器,就是只能访问当前域名下的url。 当然，如果确信你的站点不存在跨域的风险，可以在服务端主动开启跨域请求。 也可以直接通过CORS或JSONP来实现。 JSONP是利用脚本(script)跨域能力来模拟Ajax请求。 CORS是一个W3C标准，全称是”跨域资源共享“（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 本文详细介绍CORS的内部机制。一、简介CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 二、两种请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求。（1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。浏览器对这两种请求的处理，是不一样的。 三、简单请求3.1 基本流程对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。123456GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。 （1）Access-Control-Allow-Origin该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 （2）Access-Control-Allow-Credentials该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 （3）Access-Control-Expose-Headers该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。 3.2 withCredentials 属性上面说到，CORS请求默认不发送Cookie和HTTP认证信息。 如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。Access-Control-Allow-Credentials: true 另一方面，开发者必须在AJAX请求中打开withCredentials属性。12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。 xhr.withCredentials = false; 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 四、非简单请求4.1 预检请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。下面是一段浏览器的JavaScript脚本。12345var url = &apos;http://api.alice.com/cors&apos;;var xhr = new XMLHttpRequest();xhr.open(&apos;PUT&apos;, url, true);xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;);xhr.send(); 上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检“请求的HTTP头信息。12345678OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，”预检”请求的头信息包括两个特殊字段。 （1）Access-Control-Request-Method该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。（2）Access-Control-Request-Headers该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。 4.2 预检请求的回应服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 Access-Control-Allow-Origin: *如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。12XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他CORS相关字段如下。1234Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 （2）Access-Control-Allow-Headers如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 （3）Access-Control-Allow-Credentials该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 4.3 浏览器的正常请求和回应一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。下面是”预检”请求之后，浏览器的正常CORS请求。1234567PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面头信息的Origin字段是浏览器自动添加的。 下面是服务器正常的回应。12Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8 上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。 五、与JSONP的比较 CORS与JSONP的使用目的相同，但是比JSONP更强大。 JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 来源：阮一峰 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/24/ajax-1/]]></content>
      <categories>
        <category>JS</category>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
        <tag>JS</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域资源共享 CORS 详解]]></title>
    <url>%2F2017%2F06%2F24%2Fajax-1(1)%2F</url>
    <content type="text"><![CDATA[Ajax是浏览器专门用来和服务器进行交互的异步通讯技术，其核心对象是XMLHttpRequest,通过该对象可以创建一个Ajax请求。 为了防止XSS攻击，浏览器对Ajax做了限制，不允许Ajax跨域请求服务器,就是只能访问当前域名下的url。 当然，如果确信你的站点不存在跨域的风险，可以在服务端主动开启跨域请求。 也可以直接通过CORS或JSONP来实现。 JSONP是利用脚本(script)跨域能力来模拟Ajax请求。 CORS是一个W3C标准，全称是”跨域资源共享“（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 本文详细介绍CORS的内部机制。一、简介CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 二、两种请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求。（1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。浏览器对这两种请求的处理，是不一样的。 三、简单请求3.1 基本流程对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。123456GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。 （1）Access-Control-Allow-Origin该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 （2）Access-Control-Allow-Credentials该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 （3）Access-Control-Expose-Headers该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。 3.2 withCredentials 属性上面说到，CORS请求默认不发送Cookie和HTTP认证信息。 如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。Access-Control-Allow-Credentials: true 另一方面，开发者必须在AJAX请求中打开withCredentials属性。12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。 xhr.withCredentials = false; 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 四、非简单请求4.1 预检请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。下面是一段浏览器的JavaScript脚本。12345var url = &apos;http://api.alice.com/cors&apos;;var xhr = new XMLHttpRequest();xhr.open(&apos;PUT&apos;, url, true);xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;);xhr.send(); 上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检“请求的HTTP头信息。12345678OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，”预检”请求的头信息包括两个特殊字段。 （1）Access-Control-Request-Method该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。（2）Access-Control-Request-Headers该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。 4.2 预检请求的回应服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 Access-Control-Allow-Origin: *如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。12XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他CORS相关字段如下。1234Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 （2）Access-Control-Allow-Headers如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 （3）Access-Control-Allow-Credentials该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 4.3 浏览器的正常请求和回应一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。下面是”预检”请求之后，浏览器的正常CORS请求。1234567PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面头信息的Origin字段是浏览器自动添加的。 下面是服务器正常的回应。12Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8 上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。 五、与JSONP的比较 CORS与JSONP的使用目的相同，但是比JSONP更强大。 JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 来源：阮一峰 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/24/ajax-1(1)/]]></content>
      <categories>
        <category>JS</category>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
        <tag>JS</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2017%2F06%2F24%2FClosure%2F</url>
    <content type="text"><![CDATA[闭包其实是一个主动执行的代码块，这个代码块的特殊之处是可以永久保存局部变量，但又不污染全局变量，可以形成一个独立的执行过程，因此我们经常用闭包来定义组件。 让你分分钟学会JS闭包 闭包，是 Javascript 比较重要的一个概念，对于初学者来讲，闭包是一个特别抽象的概念，特别是ECMA规范给的定义，如果没有实战经验，很难从定义去理解它。因此，本文不会对闭包的概念进行大篇幅描述，直接上干货，让你分分钟学会闭包！ 1、闭包，一睹为快在接触一个新技术的时候，我首先会做的一件事就是找它的 demo。对于我们来说，看代码比自然语言更能理解一个事物的本质。其实，闭包无处不在，比如：jQuery、zepto的核心代码都包含在一个大的闭包中，所以下面我先写一个最简单最原始的闭包，以便让你在大脑里产生闭包的画面： 12345678function A()&#123; function B()&#123; console.log(&quot;Hello Closure!&quot;); &#125; return B;&#125;var C = A();C();//Hello Closure! 这是最简单的闭包。 有了初步认识后，我们简单分析一下它和普通函数有什么不同，上面代码翻译成自然语言如下： （1）定义普通函数 A （2）在 A 中定义普通函数 B （3）在 A 中返回 B （4）执行 A, 并把 A 的返回结果赋值给变量 C （5）执行 C 把这5步操作总结成一句话就是： 函数A的内部函数B被函数A外的一个变量 c 引用。 把这句话再加工一下就变成了闭包的定义：当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。 因此，当你执行上述5步操作时，就已经定义了一个闭包！ 这就是闭包。 2、 闭包的用途在了解闭包的作用之前，我们先了解一下 Javascript 中的GC机制: 在 Javascript 中，如果一个对象不再被引用，那么这个对象就会被 GC 回收，否则这个对象一直会保存在内存中。 在上述例子中，B 定义在 A 中，因此 B 依赖于 A ,而外部变量 C 又引用了 B , 所以A间接的被 C 引用。 也就是说，A 不会被 GC 回收，会一直保存在内存中。为了证明我们的推理，上面的例子稍作改进：123456789101112function A()&#123; var count = 0; function B()&#123; count ++; console.log(count); &#125; return B;&#125;var C = A();C();// 1C();// 2C();// 3 count 是函数A 中的一个变量，它的值在函数B 中被改变，函数B 每执行一次，count 的值就在原来的基础上累加 1 。因此，函数A中的 count 变量会一直保存在内存中。 当我们需要在模块中定义一些变量，并希望这些变量一直保存在内存中但又不会“污染”全局的变量时，就可以用闭包来定义这个模块。 3、 闭包的高级写法上面的写法其实是最原始的写法，而在实际应用中，会将闭包和匿名函数联系在一起使用。下面就是一个闭包常用的写法：123456789101112131415(function(document)&#123; var viewport; var obj = &#123; init:function(id)&#123; viewport = document.querySelector(&quot;#&quot;+id); &#125;, addChild:function(child)&#123; viewport.appendChild(child); &#125;, removeChild:function(child)&#123; viewport.removeChild(child); &#125; &#125; window.jView = obj;&#125;)(document); 这个组件的作用是：初始化一个容器，然后可以给这个容器添加子容器，也可以移除一个容器。 功能很简单，但这里涉及到了另外一个概念：立即执行函数。 简单了解一下就行，需要重点理解的是这种写法是如何实现闭包功能的。 可以将上面的代码拆分成两部分：(function(){}) 和() , 第1个() 是一个表达式，而这个表达式本身是一个匿名函数，所以在这个表达式后面加 () 就表示执行这个匿名函数。 因此这段代码执行执行过程可以分解如下：12345678910111213141516var f = function(document)&#123; var viewport; var obj = &#123; init:function(id)&#123; viewport = document.querySelector(&quot;#&quot;+id); &#125;, addChild:function(child)&#123; viewport.appendChild(child); &#125;, removeChild:function(child)&#123; viewport.removeChild(child); &#125; &#125; window.jView = obj;&#125;;f(document); 在这段代码中似乎看到了闭包的影子，但 f 中没有任何返回值，似乎不具备闭包的条件，注意这句代码：window.jView = obj; obj 是在函数 f 中定义的一个对象，这个对象中定义了一系列方法， 执行window.jView = obj 就是在 window 全局对象定义了一个变量 jView，并将这个变量指向 obj 对象，即全局变量 jView 引用了 obj . 而 obj 对象中的函数又引用了函数 f 中的变量 viewport ,因此函数 f 中的 viewport 不会被 GC 回收，viewport 会一直保存到内存中，所以这种写法满足了闭包的条件。 4、 总结语这是对闭包最简单的理解，当然闭包还有其更深层次的理解，这个就涉及的多了，你需要了解JS的执行环境(execution context)、活动对象(activation object)以及作用域(scope)和作用域链(scope chain)的运行机制。但作为初学者，暂时不必了解这些，有了简单的理解之后，一定要在实际项目中用起来，等你用的多了，对于闭包，你自然会有更深层次的理解！ 来源：一像素 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/24/Closure/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2017%2F06%2F24%2FClosure(1)%2F</url>
    <content type="text"><![CDATA[闭包其实是一个主动执行的代码块，这个代码块的特殊之处是可以永久保存局部变量，但又不污染全局变量，可以形成一个独立的执行过程，因此我们经常用闭包来定义组件。 让你分分钟学会JS闭包 闭包，是 Javascript 比较重要的一个概念，对于初学者来讲，闭包是一个特别抽象的概念，特别是ECMA规范给的定义，如果没有实战经验，很难从定义去理解它。因此，本文不会对闭包的概念进行大篇幅描述，直接上干货，让你分分钟学会闭包！ 1、闭包，一睹为快在接触一个新技术的时候，我首先会做的一件事就是找它的 demo。对于我们来说，看代码比自然语言更能理解一个事物的本质。其实，闭包无处不在，比如：jQuery、zepto的核心代码都包含在一个大的闭包中，所以下面我先写一个最简单最原始的闭包，以便让你在大脑里产生闭包的画面： 12345678function A()&#123; function B()&#123; console.log(&quot;Hello Closure!&quot;); &#125; return B;&#125;var C = A();C();//Hello Closure! 这是最简单的闭包。 有了初步认识后，我们简单分析一下它和普通函数有什么不同，上面代码翻译成自然语言如下： （1）定义普通函数 A （2）在 A 中定义普通函数 B （3）在 A 中返回 B （4）执行 A, 并把 A 的返回结果赋值给变量 C （5）执行 C 把这5步操作总结成一句话就是： 函数A的内部函数B被函数A外的一个变量 c 引用。 把这句话再加工一下就变成了闭包的定义：当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。 因此，当你执行上述5步操作时，就已经定义了一个闭包！ 这就是闭包。 2、 闭包的用途在了解闭包的作用之前，我们先了解一下 Javascript 中的GC机制: 在 Javascript 中，如果一个对象不再被引用，那么这个对象就会被 GC 回收，否则这个对象一直会保存在内存中。 在上述例子中，B 定义在 A 中，因此 B 依赖于 A ,而外部变量 C 又引用了 B , 所以A间接的被 C 引用。 也就是说，A 不会被 GC 回收，会一直保存在内存中。为了证明我们的推理，上面的例子稍作改进：123456789101112function A()&#123; var count = 0; function B()&#123; count ++; console.log(count); &#125; return B;&#125;var C = A();C();// 1C();// 2C();// 3 count 是函数A 中的一个变量，它的值在函数B 中被改变，函数B 每执行一次，count 的值就在原来的基础上累加 1 。因此，函数A中的 count 变量会一直保存在内存中。 当我们需要在模块中定义一些变量，并希望这些变量一直保存在内存中但又不会“污染”全局的变量时，就可以用闭包来定义这个模块。 3、 闭包的高级写法上面的写法其实是最原始的写法，而在实际应用中，会将闭包和匿名函数联系在一起使用。下面就是一个闭包常用的写法：123456789101112131415(function(document)&#123; var viewport; var obj = &#123; init:function(id)&#123; viewport = document.querySelector(&quot;#&quot;+id); &#125;, addChild:function(child)&#123; viewport.appendChild(child); &#125;, removeChild:function(child)&#123; viewport.removeChild(child); &#125; &#125; window.jView = obj;&#125;)(document); 这个组件的作用是：初始化一个容器，然后可以给这个容器添加子容器，也可以移除一个容器。 功能很简单，但这里涉及到了另外一个概念：立即执行函数。 简单了解一下就行，需要重点理解的是这种写法是如何实现闭包功能的。 可以将上面的代码拆分成两部分：(function(){}) 和() , 第1个() 是一个表达式，而这个表达式本身是一个匿名函数，所以在这个表达式后面加 () 就表示执行这个匿名函数。 因此这段代码执行执行过程可以分解如下：12345678910111213141516var f = function(document)&#123; var viewport; var obj = &#123; init:function(id)&#123; viewport = document.querySelector(&quot;#&quot;+id); &#125;, addChild:function(child)&#123; viewport.appendChild(child); &#125;, removeChild:function(child)&#123; viewport.removeChild(child); &#125; &#125; window.jView = obj;&#125;;f(document); 在这段代码中似乎看到了闭包的影子，但 f 中没有任何返回值，似乎不具备闭包的条件，注意这句代码：window.jView = obj; obj 是在函数 f 中定义的一个对象，这个对象中定义了一系列方法， 执行window.jView = obj 就是在 window 全局对象定义了一个变量 jView，并将这个变量指向 obj 对象，即全局变量 jView 引用了 obj . 而 obj 对象中的函数又引用了函数 f 中的变量 viewport ,因此函数 f 中的 viewport 不会被 GC 回收，viewport 会一直保存到内存中，所以这种写法满足了闭包的条件。 4、 总结语这是对闭包最简单的理解，当然闭包还有其更深层次的理解，这个就涉及的多了，你需要了解JS的执行环境(execution context)、活动对象(activation object)以及作用域(scope)和作用域链(scope chain)的运行机制。但作为初学者，暂时不必了解这些，有了简单的理解之后，一定要在实际项目中用起来，等你用的多了，对于闭包，你自然会有更深层次的理解！ 来源：一像素 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/24/Closure(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解JS的call,apply和bind]]></title>
    <url>%2F2017%2F06%2F20%2F%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88-this(1)%2F</url>
    <content type="text"><![CDATA[Function对象还提供了call、apply和bind等方法来改变函数的this指向，其中call和apply主动执行函数，bind一般在事件回调中使用，而call和apply的区别只是参数的传递方式不同 深入理解call,apply和bind在JavaScript 中，call、apply 和 bind 是 Function 对象自带的三个方法，这三个方法的主要作用是改变函数中的 this 指向，从而可以达到接花移木的效果。本文将对这三个方法进行详细的讲解，并列出几个经典应用场景。 1、call(thisArgs [,args…])该方法可以传递一个thisArgs参数和一个参数列表，thisArgs 指定了函数在运行期的调用者，也就是函数中的 this 对象，而参数列表会被传入调用函数中。thisArgs 的取值有以下4种情况：（1） 不传，或者传null,undefined， 函数中的 this 指向 window 对象 （2） 传递另一个函数的函数名，函数中的 this 指向这个函数的引用 （3） 传递字符串、数值或布尔类型等基础类型，函数中的 this 指向其对应的包装对象，如 String、Number、Boolean （4） 传递一个对象，函数中的 this 指向这个对象 function a(){ console.log(this); //输出函数a中的this对象 } function b(){} //定义函数b var obj = {name:&apos;onepixel&apos;}; //定义对象obj a.call(); //window a.call(null); //window a.call(undefined);//window a.call(1); //Number a.call(&apos;&apos;); //String a.call(true); //Boolean a.call(b);// function b(){} a.call(obj); //Object 这是call 的核心功能，它允许你在一个对象上调用该对象没有定义的方法，并且这个方法可以访问该对象中的属性，至于这样做有什么好处，我待会再讲，我们先看一个简单的例子： var a = { name:&apos;onepixel&apos;, //定义a的属性 say:function(){ //定义a的方法 console.log(&quot;Hi,I&apos;m function a!&quot;); } }; function b(name){ console.log(&quot;Post params: &quot;+ name); console.log(&quot;I&apos;m &quot;+ this.name); this.say(); } b.call(a,&apos;test&apos;); &gt;&gt; Post params: test I&apos;m onepixel I&apos;m function a! 当执行b.call 时，字符串test作为参数传递给了函数b,由于call的作用，函数b中的this指向了对象a, 因此相当于调用了对象a上的函数b,而实际上a中没有定义b 。 2、apply(thisArgs[,args[]])apply 和 call 的唯一区别是第二个参数的传递方式不同，apply 的第二个参数必须是一个数组，而 call 允许传递一个参数列表。值得你注意的是，虽然 apply 接收的是一个参数数组，但在传递给调用函数时，却是以参数列表的形式传递，我们看个简单的例子： function b(x,y,z){ console.log(x,y,z); } b.apply(null,[1,2,3]); // 1 2 3 apply 的这个特性很重要，我们会在下面的应用场景中提到这个特性。 3、bind(thisArgs [,args…])bind是ES5 新增的一个方法，它的传参和call类似，但又和 call/apply 有着显著的不同，即调用 call 或 apply 都会自动执行对应的函数，而 bind 不会执行对应的函数，只是返回了对函数的引用。粗略一看，bind 似乎比call/apply 要落后一些，那ES5为什么还要引入bind 呢？ 其实，ES5引入 bind 的真正目的是为了弥补 call/apply 的不足，由于 call/apply 会对目标函数自动执行，从而导致它无法在事件绑定函数中使用，因为事件绑定函数不需要我们手动执行，它是在事件被触发时由JS 内部自动执行的。而 bind 在实现改变函数 this 的同时又不会自动执行目标函数，因此可以完美的解决上述问题，看一个例子就能明白： var obj = {name:&apos;onepixel&apos;}; /** * 给document添加click事件监听，并绑定onClick函数 * 通过bind方法设置onClick的this为obj，并传递参数p1,p2 */ document.addEventListener(&apos;click&apos;,onClick.bind(obj,&apos;p1&apos;,&apos;p2&apos;),false); //当点击网页时触发并执行 function onClick(a,b){ console.log( this.name, //onepixel a, //p1 b //p2 ) } 当点击网页时，onClick 被触发执行，输出onepixel p1 p2, 说明 onClick 中的 this 被 bind 改变成了obj 对象，为了对 bind 进行深入的理解，我们来看一下 bind 的polyfill 实现： if (!Function.prototype.bind) { Function.prototype.bind = function (oThis) { var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, //this在这里指向的是目标函数 fBound = function () { return fToBind.apply( //如果外部执行var obj = new fBound(),则将obj作为最终的this，放弃使用oThis this instanceof fToBind ? this //此时的this就是new出的obj : oThis || this, //如果传递的oThis无效，就将fBound的调用者作为this //将通过bind传递的参数和调用时传递的参数进行合并，并作为最终的参数传递 aArgs.concat(Array.prototype.slice.call(arguments))); }; //将目标函数的原型对象拷贝到新函数中，因为目标函数有可能被当作构造函数使用 fBound.prototype = this.prototype; //返回fBond的引用，由外部按需调用 return fBound; }; } 一旦函数通过bind传递了有效的this对象，则该函数在运行期的this将指向这个对象，即使通过call或apply来试图改变this的指向也是徒劳的。 //实现数组的去重功能 Array.prototype.unique = function(fn) { var rst = []; var tmp = {}; this.forEach(function(val) { //使用call来改变fn的this指向，这里传window var key = &apos;uniq&apos; + (typeof fn === &apos;function&apos; ? fn.call(window, val) : val); if (!tmp.hasOwnProperty(key)) { rst.push(val); tmp[key] = null; } }, this); return rst; } //对象数组去重 var arr = [ { id: 2 }, { id: 4 }, { id: 3 }, { id: 3 }, { id: 4 }, { id: 6 } ] arr.unique(function(v) { console.log(this) //使用bind传递了Array,则this一定是Array,而不会是window return v.id }.bind(Array)); 4、应用场景一：继承大家知道，JavaScript中没有诸如Java、C# 等高级语言中的extend 关键字，因此JS 中没有继承的概念，如果一定要继承的话，call 和 apply 可以实现这个功能： function Animal(name,weight){ this.name = name; this.weight = weight; } function Cat(){ Animal.call(this,&apos;cat&apos;,&apos;50&apos;); //Animal.apply(this,[&apos;cat&apos;,&apos;50&apos;]); this.say = function(){ console.log(&quot;I am &quot; + this.name+&quot;,my weight is &quot; + this.weight); } } var cat = new Cat(); cat.say();//I am cat,my weight is 50 当通过new 运算符产生了cat 时，Cat中的 this 就指向了cat对象(关于new运算符的讲解，请参考JS构造函数和new运算符，而继承的关键是在于Cat中执行了Animal.call(this,’cat’,’50’) 这句话，在call中将this作为thisArgs参数传递，于是Animal 方法中的 this 就指向了Cat中的 this，而 cat 中的 this 指向的是 cat 对象，所以Animal 中的 this 指向的就是 cat 对象，在 Animal 中定义了name 和 weight 属性，就相当于在 cat 中定义了这些属性，因此 cat 对象便拥有了Animal 中定义的属性，从而达到了继承的目的。 5、应用场景二：移花接木在讲下面的内容之前，我们首先来认识一下JavaScript 中的一个非标准专业术语：ArrayLike (类数组/伪数组) ArrayLike 对象即拥有数组的一部分行为，在DOM 中早已表现出来，而jQuery 的崛起让ArrayLike 在JavaScript 中大放异彩。ArrayLike 对象的精妙在于它和JS 原生的 Array 类似，但是它是自由构建的，它来自开发者对JavaScript 对象的扩展，也就是说：对于它的原型(prototype)我们可以自由定义，而不会污染到JS原生的Array。 ArrayLike 对象在JS中被广泛使用，比如DOM 中的NodeList, 函数中的arguments 都是类数组对象，这些对象像数组一样存储着每一个元素，但它没有操作数组的方法，而我们可以通过call 将数组的某些方法移接到ArrayLike 对象，从而达到操作其元素的目的。比如我们可以这样遍历函数中的arguments: function test(){ //检测arguments是否为Array的实例 console.log( arguments instanceof Array, //false Array.isArray(arguments) //false ); //判断arguments是否有forEach方法 console.log(arguments.forEach); //undefined // 将数组中的forEach应用到arguments上 Array.prototype.forEach.call(arguments,function(item){ console.log(item); // 1 2 3 4 }); } test(1,2,3,4); 除此之外，对于apply 而言，我们上面提到了它独有的一个特性，即apply 接收的是数组，在传递给调用函数的时候是以参数列表传递的。 这个特性让apply 看起来比call 略胜一筹，比如有这样一个场景：给定一个数组[1,3,4,7]，然后求数组中的最大元素，而我们知道，数组中并没有获取最大值的方法，一般情况下，你需要通过编写代码来实现。而我们知道，Math 对象中有一个获取最大值的方法，即Math.max()， max方法需要传递一个参数列表，然后返回这些参数中的最大值。而apply 不仅可以将Math 对象的max 方法应用到其他对象上，还可以将一个数组转化为参数列表传递给max,看代码就能一目了然： var arr = [2,3,1,5,4]; Math.max.apply(null,arr); // 5 以上便是call 和apply 比较经典的几个应用场景，熟练掌握这些技巧，并把这些特性应用到你的实际项目中，会使你的代码看起来更加耐人寻味！ 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/20/函数指针-this(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>函数</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解JS的call,apply和bind]]></title>
    <url>%2F2017%2F06%2F20%2F%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88-this%2F</url>
    <content type="text"><![CDATA[Function对象还提供了call、apply和bind等方法来改变函数的this指向，其中call和apply主动执行函数，bind一般在事件回调中使用，而call和apply的区别只是参数的传递方式不同 深入理解call,apply和bind在JavaScript 中，call、apply 和 bind 是 Function 对象自带的三个方法，这三个方法的主要作用是改变函数中的 this 指向，从而可以达到接花移木的效果。本文将对这三个方法进行详细的讲解，并列出几个经典应用场景。 1、call(thisArgs [,args…])该方法可以传递一个thisArgs参数和一个参数列表，thisArgs 指定了函数在运行期的调用者，也就是函数中的 this 对象，而参数列表会被传入调用函数中。thisArgs 的取值有以下4种情况：（1） 不传，或者传null,undefined， 函数中的 this 指向 window 对象 （2） 传递另一个函数的函数名，函数中的 this 指向这个函数的引用 （3） 传递字符串、数值或布尔类型等基础类型，函数中的 this 指向其对应的包装对象，如 String、Number、Boolean （4） 传递一个对象，函数中的 this 指向这个对象 function a(){ console.log(this); //输出函数a中的this对象 } function b(){} //定义函数b var obj = {name:&apos;onepixel&apos;}; //定义对象obj a.call(); //window a.call(null); //window a.call(undefined);//window a.call(1); //Number a.call(&apos;&apos;); //String a.call(true); //Boolean a.call(b);// function b(){} a.call(obj); //Object 这是call 的核心功能，它允许你在一个对象上调用该对象没有定义的方法，并且这个方法可以访问该对象中的属性，至于这样做有什么好处，我待会再讲，我们先看一个简单的例子： var a = { name:&apos;onepixel&apos;, //定义a的属性 say:function(){ //定义a的方法 console.log(&quot;Hi,I&apos;m function a!&quot;); } }; function b(name){ console.log(&quot;Post params: &quot;+ name); console.log(&quot;I&apos;m &quot;+ this.name); this.say(); } b.call(a,&apos;test&apos;); &gt;&gt; Post params: test I&apos;m onepixel I&apos;m function a! 当执行b.call 时，字符串test作为参数传递给了函数b,由于call的作用，函数b中的this指向了对象a, 因此相当于调用了对象a上的函数b,而实际上a中没有定义b 。 2、apply(thisArgs[,args[]])apply 和 call 的唯一区别是第二个参数的传递方式不同，apply 的第二个参数必须是一个数组，而 call 允许传递一个参数列表。值得你注意的是，虽然 apply 接收的是一个参数数组，但在传递给调用函数时，却是以参数列表的形式传递，我们看个简单的例子： function b(x,y,z){ console.log(x,y,z); } b.apply(null,[1,2,3]); // 1 2 3 apply 的这个特性很重要，我们会在下面的应用场景中提到这个特性。 3、bind(thisArgs [,args…])bind是ES5 新增的一个方法，它的传参和call类似，但又和 call/apply 有着显著的不同，即调用 call 或 apply 都会自动执行对应的函数，而 bind 不会执行对应的函数，只是返回了对函数的引用。粗略一看，bind 似乎比call/apply 要落后一些，那ES5为什么还要引入bind 呢？ 其实，ES5引入 bind 的真正目的是为了弥补 call/apply 的不足，由于 call/apply 会对目标函数自动执行，从而导致它无法在事件绑定函数中使用，因为事件绑定函数不需要我们手动执行，它是在事件被触发时由JS 内部自动执行的。而 bind 在实现改变函数 this 的同时又不会自动执行目标函数，因此可以完美的解决上述问题，看一个例子就能明白： var obj = {name:&apos;onepixel&apos;}; /** * 给document添加click事件监听，并绑定onClick函数 * 通过bind方法设置onClick的this为obj，并传递参数p1,p2 */ document.addEventListener(&apos;click&apos;,onClick.bind(obj,&apos;p1&apos;,&apos;p2&apos;),false); //当点击网页时触发并执行 function onClick(a,b){ console.log( this.name, //onepixel a, //p1 b //p2 ) } 当点击网页时，onClick 被触发执行，输出onepixel p1 p2, 说明 onClick 中的 this 被 bind 改变成了obj 对象，为了对 bind 进行深入的理解，我们来看一下 bind 的polyfill 实现： if (!Function.prototype.bind) { Function.prototype.bind = function (oThis) { var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, //this在这里指向的是目标函数 fBound = function () { return fToBind.apply( //如果外部执行var obj = new fBound(),则将obj作为最终的this，放弃使用oThis this instanceof fToBind ? this //此时的this就是new出的obj : oThis || this, //如果传递的oThis无效，就将fBound的调用者作为this //将通过bind传递的参数和调用时传递的参数进行合并，并作为最终的参数传递 aArgs.concat(Array.prototype.slice.call(arguments))); }; //将目标函数的原型对象拷贝到新函数中，因为目标函数有可能被当作构造函数使用 fBound.prototype = this.prototype; //返回fBond的引用，由外部按需调用 return fBound; }; } 一旦函数通过bind传递了有效的this对象，则该函数在运行期的this将指向这个对象，即使通过call或apply来试图改变this的指向也是徒劳的。 //实现数组的去重功能 Array.prototype.unique = function(fn) { var rst = []; var tmp = {}; this.forEach(function(val) { //使用call来改变fn的this指向，这里传window var key = &apos;uniq&apos; + (typeof fn === &apos;function&apos; ? fn.call(window, val) : val); if (!tmp.hasOwnProperty(key)) { rst.push(val); tmp[key] = null; } }, this); return rst; } //对象数组去重 var arr = [ { id: 2 }, { id: 4 }, { id: 3 }, { id: 3 }, { id: 4 }, { id: 6 } ] arr.unique(function(v) { console.log(this) //使用bind传递了Array,则this一定是Array,而不会是window return v.id }.bind(Array)); 4、应用场景一：继承大家知道，JavaScript中没有诸如Java、C# 等高级语言中的extend 关键字，因此JS 中没有继承的概念，如果一定要继承的话，call 和 apply 可以实现这个功能： function Animal(name,weight){ this.name = name; this.weight = weight; } function Cat(){ Animal.call(this,&apos;cat&apos;,&apos;50&apos;); //Animal.apply(this,[&apos;cat&apos;,&apos;50&apos;]); this.say = function(){ console.log(&quot;I am &quot; + this.name+&quot;,my weight is &quot; + this.weight); } } var cat = new Cat(); cat.say();//I am cat,my weight is 50 当通过new 运算符产生了cat 时，Cat中的 this 就指向了cat对象(关于new运算符的讲解，请参考JS构造函数和new运算符，而继承的关键是在于Cat中执行了Animal.call(this,’cat’,’50’) 这句话，在call中将this作为thisArgs参数传递，于是Animal 方法中的 this 就指向了Cat中的 this，而 cat 中的 this 指向的是 cat 对象，所以Animal 中的 this 指向的就是 cat 对象，在 Animal 中定义了name 和 weight 属性，就相当于在 cat 中定义了这些属性，因此 cat 对象便拥有了Animal 中定义的属性，从而达到了继承的目的。 5、应用场景二：移花接木在讲下面的内容之前，我们首先来认识一下JavaScript 中的一个非标准专业术语：ArrayLike (类数组/伪数组) ArrayLike 对象即拥有数组的一部分行为，在DOM 中早已表现出来，而jQuery 的崛起让ArrayLike 在JavaScript 中大放异彩。ArrayLike 对象的精妙在于它和JS 原生的 Array 类似，但是它是自由构建的，它来自开发者对JavaScript 对象的扩展，也就是说：对于它的原型(prototype)我们可以自由定义，而不会污染到JS原生的Array。 ArrayLike 对象在JS中被广泛使用，比如DOM 中的NodeList, 函数中的arguments 都是类数组对象，这些对象像数组一样存储着每一个元素，但它没有操作数组的方法，而我们可以通过call 将数组的某些方法移接到ArrayLike 对象，从而达到操作其元素的目的。比如我们可以这样遍历函数中的arguments: function test(){ //检测arguments是否为Array的实例 console.log( arguments instanceof Array, //false Array.isArray(arguments) //false ); //判断arguments是否有forEach方法 console.log(arguments.forEach); //undefined // 将数组中的forEach应用到arguments上 Array.prototype.forEach.call(arguments,function(item){ console.log(item); // 1 2 3 4 }); } test(1,2,3,4); 除此之外，对于apply 而言，我们上面提到了它独有的一个特性，即apply 接收的是数组，在传递给调用函数的时候是以参数列表传递的。 这个特性让apply 看起来比call 略胜一筹，比如有这样一个场景：给定一个数组[1,3,4,7]，然后求数组中的最大元素，而我们知道，数组中并没有获取最大值的方法，一般情况下，你需要通过编写代码来实现。而我们知道，Math 对象中有一个获取最大值的方法，即Math.max()， max方法需要传递一个参数列表，然后返回这些参数中的最大值。而apply 不仅可以将Math 对象的max 方法应用到其他对象上，还可以将一个数组转化为参数列表传递给max,看代码就能一目了然： var arr = [2,3,1,5,4]; Math.max.apply(null,arr); // 5 以上便是call 和apply 比较经典的几个应用场景，熟练掌握这些技巧，并把这些特性应用到你的实际项目中，会使你的代码看起来更加耐人寻味！ 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/20/函数指针-this/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>函数</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R入门]]></title>
    <url>%2F2017%2F06%2F20%2FR%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[一门可视化语言安装包（例如在RStudio中国安装caret包） install.packages(&quot;caret&quot;) 使用引入包 library(caret) 数据对象的5种基本类型：字符（character）、数值（numeric：real numbers）、整数（integer）、复数（complex）、逻辑（logical：True/False) x&lt;-1数值x&lt;-1L 整数（后面加L）逻辑（TRUE和FALSE要用大写） 数据结构：向量（Vector）：只能包含同一类型的对象矩阵（Matrix）：向量+维度属性数组（array）：相当于维度大于2的矩阵（矩阵的维度等于2）列表（list）：可以包含不同类型的对象因子(factor):分类数据/有序vs无序 整数向量+标签（label）（优于整数向量）缺失值（missing value):数据框（data frame）（表格）：数据框是R里面最重要的数据对象，日期与时间： par()——数据可视化的起点 (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/20/R入门/]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>初级</tag>
        <tag>可视化</tag>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 之函数原型链]]></title>
    <url>%2F2017%2F06%2F20%2FJS-%E4%B9%8B%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[在Javascript中，万物皆对象，但对象也有区别，大致可以分为两类，即：普通对象Object 和 函数对象Function。一般而言，通过new Function产生的对象是函数对象，其他对象都是普通对象。 JS原型对象和原型链 一般而言，通过new Function产生的对象是函数对象，其他对象都是普通对象。栗子： function f1(){ //todo } var f2 = function(){ //todo }; var f3 = new Function(&apos;x&apos;,&apos;console.log(x)&apos;); var o1 = {}; var o2 = new Object(); var o3 = new f1(); console.log( typeof f1,//function typeof f2,//function typeof f3,//function typeof o1,//object typeof o2,//object typeof o3 //object ); &gt;&gt; function function function object object object f1属于函数的声明，最常见的函数定义方式，f2实际上是一个匿名函数，把这个匿名函数赋值给了f2,属于函数表达式，f3不常见，但也是一种函数对象。f1属于函数的声明，最常见的函数定义方式，f2实际上是一个匿名函数，把这个匿名函数赋值给了f2,属于函数表达式，f3不常见，但也是一种函数对象。 Function是JS自带的对象，f1,f2在创建的时候，JS会自动通过new Function()的方式来构建这些对象，因此，这三个对象都是通过new Function()创建的。 在Javascript中创建对象有两种方式：对象字面量和使用new表达式，o1和o2的创建恰好对应了这两种方式，重点讲一下o3, 如果用Java和C#的思路来理解的话，o3是f1的实例对象，o3和f1是同一类型，至少我以前这么认为，其实不然… 那么怎么理解呢? 很简单，看o3是不是通过new Function产生的, 显然不是，既然不是函数对象，那就是普通对象 。 通过对函数对象和普通对象的简单理解之后，我们再来了解一下Javascript中的原型和原型链： 在JS中，每当创建一个函数对象f1 时，该对象中都会内置一些属性，其中包括prototype和__proto__, prototype即原型对象，它记录着f1的一些属性和方法。 需要注意的是，prototype 对f1是不可见的，也就是说，f1不会查找prototype中的属性和方法。 function f(){} f.prototype.foo = &quot;abc&quot;; console.log(f.foo); //undefined 那么，prototype有什么用呢？ 其实prototype的主要作用就是继承。 通俗一点讲，prototype中定义的属性和方法都是留给自己的“后代”用的，因此，子类完全可以访问prototype中的属性和方法。 想要知道f1是如何把prototype留给“后代”，我们需要了解一下JS中的原型链，此时，JS中的__proto__ 入场了，这哥们长的很奇特，隐藏的也很深，以致于你经常见不到它，但它在普通对象和函数对象中都存在， 它的作用就是保存父类的prototype对象，JS在通过new 表达式创建一个对象的时候，通常会把父类的prototype赋值给新对象的proto属性，这样，就形成了一代代传承… function f(){} f.prototype.foo = &quot;abc&quot;; var obj = new f(); console.log(obj.foo); //abc 现在我们知道，obj中proto保存的是f的prototype,那么f的prototype中的proto中保存的是什么呢? 看下图： 如图所示，f.prototype的proto中保存的是Object.prototype，Object.prototype对象中也有proto，而从输出结果看，Object.prototype.proto 是null，表示obj对象原型链的终结。如下图所示： obj对象拥有这样一个原型链以后，当obj.foo执行时，obj会先查找自身是否有该属性，但不会查找自己的prototype,当找不到foo时，obj就沿着原型链依次去查找… 在上面的例子中，我们在f的prototype上定义了foo属性，这时obj就会在原型链上找到这个属性并执行。 最后，用几句话总结一下本文中涉及到的重点： 原型链的形成真正是靠__proto__ 而非prototype 当JS引擎执行对象的方法时，先查找对象本身是否存在该方法，如果不存在，会在原型链上查找，但不会查找自身的prototype。一个对象的proto记录着自己的原型链，决定了自身的数据类型，改变proto就等于改变对象的数据类型。 函数的prototype不属于自身的原型链，它是子类创建的核心，决定了子类的数据类型，是连接子类原型链的桥梁。 在原型对象上定义方法和属性的目的是为了被子类继承和使用。 来源：@一像素 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/20/JS-之函数原型链/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 之函数原型链]]></title>
    <url>%2F2017%2F06%2F20%2FJS-%E4%B9%8B%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E9%93%BE(1)%2F</url>
    <content type="text"><![CDATA[在Javascript中，万物皆对象，但对象也有区别，大致可以分为两类，即：普通对象Object 和 函数对象Function。一般而言，通过new Function产生的对象是函数对象，其他对象都是普通对象。 JS原型对象和原型链 一般而言，通过new Function产生的对象是函数对象，其他对象都是普通对象。栗子： function f1(){ //todo } var f2 = function(){ //todo }; var f3 = new Function(&apos;x&apos;,&apos;console.log(x)&apos;); var o1 = {}; var o2 = new Object(); var o3 = new f1(); console.log( typeof f1,//function typeof f2,//function typeof f3,//function typeof o1,//object typeof o2,//object typeof o3 //object ); &gt;&gt; function function function object object object f1属于函数的声明，最常见的函数定义方式，f2实际上是一个匿名函数，把这个匿名函数赋值给了f2,属于函数表达式，f3不常见，但也是一种函数对象。f1属于函数的声明，最常见的函数定义方式，f2实际上是一个匿名函数，把这个匿名函数赋值给了f2,属于函数表达式，f3不常见，但也是一种函数对象。 Function是JS自带的对象，f1,f2在创建的时候，JS会自动通过new Function()的方式来构建这些对象，因此，这三个对象都是通过new Function()创建的。 在Javascript中创建对象有两种方式：对象字面量和使用new表达式，o1和o2的创建恰好对应了这两种方式，重点讲一下o3, 如果用Java和C#的思路来理解的话，o3是f1的实例对象，o3和f1是同一类型，至少我以前这么认为，其实不然… 那么怎么理解呢? 很简单，看o3是不是通过new Function产生的, 显然不是，既然不是函数对象，那就是普通对象 。 通过对函数对象和普通对象的简单理解之后，我们再来了解一下Javascript中的原型和原型链： 在JS中，每当创建一个函数对象f1 时，该对象中都会内置一些属性，其中包括prototype和__proto__, prototype即原型对象，它记录着f1的一些属性和方法。 需要注意的是，prototype 对f1是不可见的，也就是说，f1不会查找prototype中的属性和方法。 function f(){} f.prototype.foo = &quot;abc&quot;; console.log(f.foo); //undefined 那么，prototype有什么用呢？ 其实prototype的主要作用就是继承。 通俗一点讲，prototype中定义的属性和方法都是留给自己的“后代”用的，因此，子类完全可以访问prototype中的属性和方法。 想要知道f1是如何把prototype留给“后代”，我们需要了解一下JS中的原型链，此时，JS中的__proto__ 入场了，这哥们长的很奇特，隐藏的也很深，以致于你经常见不到它，但它在普通对象和函数对象中都存在， 它的作用就是保存父类的prototype对象，JS在通过new 表达式创建一个对象的时候，通常会把父类的prototype赋值给新对象的proto属性，这样，就形成了一代代传承… function f(){} f.prototype.foo = &quot;abc&quot;; var obj = new f(); console.log(obj.foo); //abc 现在我们知道，obj中proto保存的是f的prototype,那么f的prototype中的proto中保存的是什么呢? 看下图： 如图所示，f.prototype的proto中保存的是Object.prototype，Object.prototype对象中也有proto，而从输出结果看，Object.prototype.proto 是null，表示obj对象原型链的终结。如下图所示： obj对象拥有这样一个原型链以后，当obj.foo执行时，obj会先查找自身是否有该属性，但不会查找自己的prototype,当找不到foo时，obj就沿着原型链依次去查找… 在上面的例子中，我们在f的prototype上定义了foo属性，这时obj就会在原型链上找到这个属性并执行。 最后，用几句话总结一下本文中涉及到的重点： 原型链的形成真正是靠__proto__ 而非prototype 当JS引擎执行对象的方法时，先查找对象本身是否存在该方法，如果不存在，会在原型链上查找，但不会查找自身的prototype。一个对象的proto记录着自己的原型链，决定了自身的数据类型，改变proto就等于改变对象的数据类型。 函数的prototype不属于自身的原型链，它是子类创建的核心，决定了子类的数据类型，是连接子类原型链的桥梁。 在原型对象上定义方法和属性的目的是为了被子类继承和使用。 来源：@一像素 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/20/JS-之函数原型链(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R入门]]></title>
    <url>%2F2017%2F06%2F20%2FR%E5%85%A5%E9%97%A8(1)%2F</url>
    <content type="text"><![CDATA[一门可视化语言安装包（例如在RStudio中国安装caret包） install.packages(&quot;caret&quot;) 使用引入包 library(caret) 数据对象的5种基本类型：字符（character）、数值（numeric：real numbers）、整数（integer）、复数（complex）、逻辑（logical：True/False) x&lt;-1数值x&lt;-1L 整数（后面加L）逻辑（TRUE和FALSE要用大写） 数据结构：向量（Vector）：只能包含同一类型的对象矩阵（Matrix）：向量+维度属性数组（array）：相当于维度大于2的矩阵（矩阵的维度等于2）列表（list）：可以包含不同类型的对象因子(factor):分类数据/有序vs无序 整数向量+标签（label）（优于整数向量）缺失值（missing value):数据框（data frame）（表格）：数据框是R里面最重要的数据对象，日期与时间： par()——数据可视化的起点 (function(){var appid = ‘cysmzRdbl’;var conf = ‘prod_7c789e58c2fd9306e64aff79a862b4df’;var width = window.innerWidth || document.documentElement.clientWidth;if (width &lt; 960) {window.document.write(‘&lt;\/script&gt;’); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(“head”)[0]||document.head||document.documentElement;var b=document.createElement(“script”);b.setAttribute(“type”,”text/javascript”);b.setAttribute(“charset”,”UTF-8”);b.setAttribute(“src”,d);if(typeof a===”function”){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===”loaded”||e===”complete”){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(“https://changyan.sohu.com/upload/changyan.js&quot;,function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/20/R入门(1)/]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>初级</tag>
        <tag>可视化</tag>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之函数作用域]]></title>
    <url>%2F2017%2F06%2F20%2FJS%E4%B9%8B%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F(1)%2F</url>
    <content type="text"><![CDATA[所谓作用域就是：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。 函数作用域和作用域链 1、作用域所谓作用域就是：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。 function scope(){ var foo = &quot;global&quot;; if(window.getComputedStyle){ var a = &quot;I&apos;m if&quot;; console.log(&quot;if:&quot;+foo); //if:global } while(1){ var b = &quot;I&apos;m while&quot;; console.log(&quot;while:&quot;+foo);//while:global break; } !function (){ var c = &quot;I&apos;m function&quot;; console.log(&quot;function:&quot;+foo);//function:global }(); console.log( foo,//global a, // I&apos;m if b, // I&apos;m while c // c is not defined ); } scope(); （1）scope函数中定义的foo变量，除过自身可以访问以外，还可以在if语句、while语句和内嵌的匿名函数中访问。 因此，foo的作用域就是scope函数体。 （2）在javascript中，if、while、for 等代码块不能形成独立的作用域。因此，javascript中没有块级作用域，只有函数作用域。 但是，在JS中有一种特殊情况： 如果一个变量没有使用var声明，window便拥有了该属性，因此这个变量的作用域不属于某一个函数体,而是window对象。 function varscope(){ foo = &quot;I&apos;m in function&quot;; console.log(foo);//I&apos;m in function } varscope(); console.log(window.foo); //I&apos;m in function 2、作用域链所谓作用域链就是：一个函数体中嵌套了多层函数体，并在不同的函数体中定义了同一变量， 当其中一个函数访问这个变量时，便会形成一条作用域链。 foo = &quot;window&quot;; function first(){ var foo = &quot;first&quot;; function second(){ var foo = &quot;second&quot;; console.log(foo); } function third(){ console.log(foo); } second(); //second third(); //first } first(); 当执行second时，JS引擎会将second的作用域放置链表的头部，其次是first的作用域，最后是window对象，于是会形成如下作用域链： second-&gt;first-&gt;window, 此时，JS引擎沿着该作用域链查找变量foo, 查到的是 second 当执行third时，third形成的作用域链：third-&gt;first-&gt;window, 因此查到的是：frist 3、作用域的延长：with 和 catchwith和catch语句主要用来临时扩展作用域链， 将语句中传递的变量对象添加到作用域的头部。语句结束后，原作用域链恢复正常。 //with语句 foo = &quot;window&quot;; function first(){ var foo = &quot;first&quot;; function second(){ var foo = &quot;second&quot;; console.log(foo); } function third(obj){ console.log(foo); //first with (obj){ console.log(foo); //obj } console.log(foo); //first } var obj = {foo:&apos;obj&apos;}; third(obj); } first(); //catch语句 var e = new Error(&apos;a&apos;); try { throw new Error(&apos;b&apos;); } catch (e) { console.log(e.message); //b } 在执行third()时，传递了一个obj对象，obj 中有属性foo, 在执行with语句时，JS引擎将obj放置在了原链表的头部，于是形成的作用域链如下： obj-&gt;third-&gt;first-&gt;window, 此时查找到的foo就是obj中的foo,因此输出的是 obj 而在with之前和之后，都是沿着原来的链表进行查找，从而说明在with语句结束后，作用域链已恢复正常。 4、this 关键字 在一个函数中，this总是指向当前函数的所有者对象，this总是在运行时才能确定其具体的指向, 也才能知道它的调用对象。 window.name = &quot;window&quot;; function f(){ console.log(this.name); } f();//window var obj = {name:&apos;obj&apos;}; f.call(obj); //obj 在执行f()时，此时f()的调用者是window对象，因此输出 window f.call(obj) 是把f()放在obj对象上执行，相当于obj.f(),此时f 中的this就是obj,所以输出的是 obj 5、实战应用//demo1 var foo = &quot;window&quot;; var obj = { foo : &quot;obj&quot;, getFoo : function(){ return function(){ return this.foo; }; } }; var f = obj.getFoo(); f(); //window //demo2 var foo = &quot;window&quot;; var obj = { foo : &quot;obj&quot;, getFoo : function(){ var that = this; return function(){ return that.foo; }; } }; var f = obj.getFoo(); f(); //obj 6、demo解析//demo1: //执行var f = obj.getFoo()返回的是一个匿名函数，相当于: var f = function(){ return this.foo; } //f() 相当于window.f(), 因此f中的this指向的是window对象，this.foo相当于window.foo, 所以f()返回&quot;window&quot; //demo2: //执行var f = obj.getFoo() 同样返回匿名函数，即： var f = function(){ return that.foo; } //唯一不同的是f中的this变成了that, 要知道that是哪个对象之前，先确定f的作用域链：f-&gt;getFoo-&gt;window 并在该链条上查找that, //此时可以发现that指代的是getFoo中的this, getFoo中的this指向其运行时的调用者， //从var f = obj.getFoo() 可知此时this指向的是obj对象，因此that.foo 就相当于obj.foo,所以f()返回&quot;obj&quot; 所以： this是指向window, that就是执行obj.getFoo()时的this, 调用getFoo()的对象是obj,因此这里的this就指的是obj 来源：一像素 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/20/JS之函数作用域(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>作用域</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之函数作用域]]></title>
    <url>%2F2017%2F06%2F20%2FJS%E4%B9%8B%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[所谓作用域就是：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。 函数作用域和作用域链 1、作用域所谓作用域就是：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。 function scope(){ var foo = &quot;global&quot;; if(window.getComputedStyle){ var a = &quot;I&apos;m if&quot;; console.log(&quot;if:&quot;+foo); //if:global } while(1){ var b = &quot;I&apos;m while&quot;; console.log(&quot;while:&quot;+foo);//while:global break; } !function (){ var c = &quot;I&apos;m function&quot;; console.log(&quot;function:&quot;+foo);//function:global }(); console.log( foo,//global a, // I&apos;m if b, // I&apos;m while c // c is not defined ); } scope(); （1）scope函数中定义的foo变量，除过自身可以访问以外，还可以在if语句、while语句和内嵌的匿名函数中访问。 因此，foo的作用域就是scope函数体。 （2）在javascript中，if、while、for 等代码块不能形成独立的作用域。因此，javascript中没有块级作用域，只有函数作用域。 但是，在JS中有一种特殊情况： 如果一个变量没有使用var声明，window便拥有了该属性，因此这个变量的作用域不属于某一个函数体,而是window对象。 function varscope(){ foo = &quot;I&apos;m in function&quot;; console.log(foo);//I&apos;m in function } varscope(); console.log(window.foo); //I&apos;m in function 2、作用域链所谓作用域链就是：一个函数体中嵌套了多层函数体，并在不同的函数体中定义了同一变量， 当其中一个函数访问这个变量时，便会形成一条作用域链。 foo = &quot;window&quot;; function first(){ var foo = &quot;first&quot;; function second(){ var foo = &quot;second&quot;; console.log(foo); } function third(){ console.log(foo); } second(); //second third(); //first } first(); 当执行second时，JS引擎会将second的作用域放置链表的头部，其次是first的作用域，最后是window对象，于是会形成如下作用域链： second-&gt;first-&gt;window, 此时，JS引擎沿着该作用域链查找变量foo, 查到的是 second 当执行third时，third形成的作用域链：third-&gt;first-&gt;window, 因此查到的是：frist 3、作用域的延长：with 和 catchwith和catch语句主要用来临时扩展作用域链， 将语句中传递的变量对象添加到作用域的头部。语句结束后，原作用域链恢复正常。 //with语句 foo = &quot;window&quot;; function first(){ var foo = &quot;first&quot;; function second(){ var foo = &quot;second&quot;; console.log(foo); } function third(obj){ console.log(foo); //first with (obj){ console.log(foo); //obj } console.log(foo); //first } var obj = {foo:&apos;obj&apos;}; third(obj); } first(); //catch语句 var e = new Error(&apos;a&apos;); try { throw new Error(&apos;b&apos;); } catch (e) { console.log(e.message); //b } 在执行third()时，传递了一个obj对象，obj 中有属性foo, 在执行with语句时，JS引擎将obj放置在了原链表的头部，于是形成的作用域链如下： obj-&gt;third-&gt;first-&gt;window, 此时查找到的foo就是obj中的foo,因此输出的是 obj 而在with之前和之后，都是沿着原来的链表进行查找，从而说明在with语句结束后，作用域链已恢复正常。 4、this 关键字 在一个函数中，this总是指向当前函数的所有者对象，this总是在运行时才能确定其具体的指向, 也才能知道它的调用对象。 window.name = &quot;window&quot;; function f(){ console.log(this.name); } f();//window var obj = {name:&apos;obj&apos;}; f.call(obj); //obj 在执行f()时，此时f()的调用者是window对象，因此输出 window f.call(obj) 是把f()放在obj对象上执行，相当于obj.f(),此时f 中的this就是obj,所以输出的是 obj 5、实战应用//demo1 var foo = &quot;window&quot;; var obj = { foo : &quot;obj&quot;, getFoo : function(){ return function(){ return this.foo; }; } }; var f = obj.getFoo(); f(); //window //demo2 var foo = &quot;window&quot;; var obj = { foo : &quot;obj&quot;, getFoo : function(){ var that = this; return function(){ return that.foo; }; } }; var f = obj.getFoo(); f(); //obj 6、demo解析//demo1: //执行var f = obj.getFoo()返回的是一个匿名函数，相当于: var f = function(){ return this.foo; } //f() 相当于window.f(), 因此f中的this指向的是window对象，this.foo相当于window.foo, 所以f()返回&quot;window&quot; //demo2: //执行var f = obj.getFoo() 同样返回匿名函数，即： var f = function(){ return that.foo; } //唯一不同的是f中的this变成了that, 要知道that是哪个对象之前，先确定f的作用域链：f-&gt;getFoo-&gt;window 并在该链条上查找that, //此时可以发现that指代的是getFoo中的this, getFoo中的this指向其运行时的调用者， //从var f = obj.getFoo() 可知此时this指向的是obj对象，因此that.foo 就相当于obj.foo,所以f()返回&quot;obj&quot; 所以： this是指向window, that就是执行obj.getFoo()时的this, 调用getFoo()的对象是obj,因此这里的this就指的是obj 来源：一像素 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/20/JS之函数作用域/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>作用域</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断JS数据类型的四种方法]]></title>
    <url>%2F2017%2F06%2F20%2F%E5%88%A4%E6%96%ADJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95(1)%2F</url>
    <content type="text"><![CDATA[Javascript可以通过typeof来判断基础数据类型，但不能够准确判断引用类型, 因此需要用到另外一个方法，那就是Object的toString 说到数据类型，我们先说一下JavaScript 中常见的几种数据类型： 基本类型：string,number,boolean 特殊类型：undefined,null 引用类型：Object,Function,Function,Array,RegExp,Date,… 很多时候我们都需要通过判断变量的数据类型来进行下一步操作，下面我们介绍常用的4种方法： 1、typeoftypeof 返回一个表示数据类型的字符串，返回结果包括：number、boolean、string、object、undefined、function等6种数据类型。 typeof &apos;&apos;; // string 有效 typeof 1; // number 有效 typeof true; //boolean 有效 typeof undefined; //undefined 有效 typeof null; //object 无效 typeof [] ; //object 无效 typeof new Function(); // function 有效 typeof new Date(); //object 无效 typeof new RegExp(); //object 无效 typeof 可以对JS基础数据类型做出准确的判断，而对于引用类型返回的基本上都是object,其实返回object也没有错，因为所有对象的原型链最终都指向了Object,Object是所有对象的祖宗。但当我们需要知道某个对象的具体类型时，typeof 就显得有些力不从心了 2、instanceofnstanceof 是用来判断 A 是否为 B 的实例对，表达式为：A instanceof B，如果A是B的实例，则返回true,否则返回false。 在这里需要特别注意的是：instanceof检测的是原型，我们用一段伪代码来模拟其内部执行过程： instanceof (A,B) = { var L = A.__proto__; var R = B.prototype; if(L === R) { //A的内部属性__proto__指向B的原型对象 return true; } return false; } 上述过程可以看出，当 A 的 proto 指向 B 的 prototype 时，就认为A就是B的实例，我们再来看几个例子： [] instanceof Array; //true {} instanceof Object;//true new Date() instanceof Date;//true function Person(){}; new Person() instanceof Person; [] instanceof Object; //true new Date() instanceof Object;//true new Person instanceof Object;//true 我们发现，虽然 instanceof 能够判断出 [] 是Array的实例，但它认为 [] 也是Object的实例，为什么呢？ 我们来分析一下[]、Array、Object 三者之间的关系: 从instanceof 能够判断出 [].proto 指向 Array.prototype， 而 Array.prototype.proto 又指向了Object.prototype，Object.prototype.proto 指向了null,标志着原型链的结束。因此，[]、Array、Object就形成了如下图所示的一条原型链：从原型链可以看出，[] 的 proto 直接指向Array.prototype, 间接指向Object.prototype, 所以按照 instanceof 的判断规则，[] 就是Object的实例。当然，类似的new Date()、new Person() 也会形成这样一条原型链，因此，instanceof 只能用来判断两个对象是否属于原型链的关系， 而不能获取对象的具体类型。 3、constructor当一个函数F被定义时，JS引擎会为F添加prototype原型，然后再在prototype上添加一个constructor属性，并让其指向F的引用。如下所示：当执行 var f = new F() 时，F被当成了构造函数，f是F的实例对象，此时F原型上的constructor传递到了f上，因此f.constructor == F可以看出，JS在函数F的原型上定义了constructor，当F被当作构造函数用来创建对象时，创建的新对象就被标记为了“F” 类型，使得新对象有名有姓，可以追溯。 同理,JS中的数据类型也遵守这个规则：注意： null和undefined是无效的对象，因此是不会有constructor存在的，这两种类型的数据需要通过typeof来判断。 JS对象的constructor是不稳定的，这个主要体现在自定义对象上，当开发者重写prototype后，原有的constructor会丢失，constructor会默认为Object 4、Object.prototype.toStringObject.prototype.toString.call(&apos;&apos;) ; // [object String] Object.prototype.toString.call(1) ; // [object Number] Object.prototype.toString.call(true) ; // [object Boolean] Object.prototype.toString.call(undefined) ; // [object Undefined] Object.prototype.toString.call(null) ; // [object Null] Object.prototype.toString.call(new Function()) ; // [object Function] Object.prototype.toString.call(new Date()) ; // [object Date] Object.prototype.toString.call([]) ; // [object Array] Object.prototype.toString.call(new RegExp()) ; // [object RegExp] Object.prototype.toString.call(new Error()) ; // [object Error] Object.prototype.toString.call(document) ; // [object HTMLDocument] Object.prototype.toString.call(window) ; //[object global] window是全局对象global的引用 需要注意的是，必须通过Object.prototype.toString.call来获取，而不能直接 newDate().toString(), 从原型链的角度讲，所有对象的原型链最终都指向了Object,按照JS变量查找规则，其他对象应该也可以直接访问到Object的toString方法，而事实上，大部分的对象都实现了自身的toString方法，这样就可能会导致Object的toString被终止查找，因此要用call来强制执行Object的toString方法。 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/20/判断JS数据类型的四种方法(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>原型</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断JS数据类型的四种方法]]></title>
    <url>%2F2017%2F06%2F20%2F%E5%88%A4%E6%96%ADJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Javascript可以通过typeof来判断基础数据类型，但不能够准确判断引用类型, 因此需要用到另外一个方法，那就是Object的toString 说到数据类型，我们先说一下JavaScript 中常见的几种数据类型： 基本类型：string,number,boolean 特殊类型：undefined,null 引用类型：Object,Function,Function,Array,RegExp,Date,… 很多时候我们都需要通过判断变量的数据类型来进行下一步操作，下面我们介绍常用的4种方法： 1、typeoftypeof 返回一个表示数据类型的字符串，返回结果包括：number、boolean、string、object、undefined、function等6种数据类型。 typeof &apos;&apos;; // string 有效 typeof 1; // number 有效 typeof true; //boolean 有效 typeof undefined; //undefined 有效 typeof null; //object 无效 typeof [] ; //object 无效 typeof new Function(); // function 有效 typeof new Date(); //object 无效 typeof new RegExp(); //object 无效 typeof 可以对JS基础数据类型做出准确的判断，而对于引用类型返回的基本上都是object,其实返回object也没有错，因为所有对象的原型链最终都指向了Object,Object是所有对象的祖宗。但当我们需要知道某个对象的具体类型时，typeof 就显得有些力不从心了 2、instanceofnstanceof 是用来判断 A 是否为 B 的实例对，表达式为：A instanceof B，如果A是B的实例，则返回true,否则返回false。 在这里需要特别注意的是：instanceof检测的是原型，我们用一段伪代码来模拟其内部执行过程： instanceof (A,B) = { var L = A.__proto__; var R = B.prototype; if(L === R) { //A的内部属性__proto__指向B的原型对象 return true; } return false; } 上述过程可以看出，当 A 的 proto 指向 B 的 prototype 时，就认为A就是B的实例，我们再来看几个例子： [] instanceof Array; //true {} instanceof Object;//true new Date() instanceof Date;//true function Person(){}; new Person() instanceof Person; [] instanceof Object; //true new Date() instanceof Object;//true new Person instanceof Object;//true 我们发现，虽然 instanceof 能够判断出 [] 是Array的实例，但它认为 [] 也是Object的实例，为什么呢？ 我们来分析一下[]、Array、Object 三者之间的关系: 从instanceof 能够判断出 [].proto 指向 Array.prototype， 而 Array.prototype.proto 又指向了Object.prototype，Object.prototype.proto 指向了null,标志着原型链的结束。因此，[]、Array、Object就形成了如下图所示的一条原型链：从原型链可以看出，[] 的 proto 直接指向Array.prototype, 间接指向Object.prototype, 所以按照 instanceof 的判断规则，[] 就是Object的实例。当然，类似的new Date()、new Person() 也会形成这样一条原型链，因此，instanceof 只能用来判断两个对象是否属于原型链的关系， 而不能获取对象的具体类型。 3、constructor当一个函数F被定义时，JS引擎会为F添加prototype原型，然后再在prototype上添加一个constructor属性，并让其指向F的引用。如下所示：当执行 var f = new F() 时，F被当成了构造函数，f是F的实例对象，此时F原型上的constructor传递到了f上，因此f.constructor == F可以看出，JS在函数F的原型上定义了constructor，当F被当作构造函数用来创建对象时，创建的新对象就被标记为了“F” 类型，使得新对象有名有姓，可以追溯。 同理,JS中的数据类型也遵守这个规则：注意： null和undefined是无效的对象，因此是不会有constructor存在的，这两种类型的数据需要通过typeof来判断。 JS对象的constructor是不稳定的，这个主要体现在自定义对象上，当开发者重写prototype后，原有的constructor会丢失，constructor会默认为Object 4、Object.prototype.toStringObject.prototype.toString.call(&apos;&apos;) ; // [object String] Object.prototype.toString.call(1) ; // [object Number] Object.prototype.toString.call(true) ; // [object Boolean] Object.prototype.toString.call(undefined) ; // [object Undefined] Object.prototype.toString.call(null) ; // [object Null] Object.prototype.toString.call(new Function()) ; // [object Function] Object.prototype.toString.call(new Date()) ; // [object Date] Object.prototype.toString.call([]) ; // [object Array] Object.prototype.toString.call(new RegExp()) ; // [object RegExp] Object.prototype.toString.call(new Error()) ; // [object Error] Object.prototype.toString.call(document) ; // [object HTMLDocument] Object.prototype.toString.call(window) ; //[object global] window是全局对象global的引用 需要注意的是，必须通过Object.prototype.toString.call来获取，而不能直接 newDate().toString(), 从原型链的角度讲，所有对象的原型链最终都指向了Object,按照JS变量查找规则，其他对象应该也可以直接访问到Object的toString方法，而事实上，大部分的对象都实现了自身的toString方法，这样就可能会导致Object的toString被终止查找，因此要用call来强制执行Object的toString方法。 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/20/判断JS数据类型的四种方法/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>原型</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之数据类型详解]]></title>
    <url>%2F2017%2F06%2F20%2FJS%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Javascript中的数据类型有以下几种情况：基本类型：string,number,boolean特殊类型：undefined,null引用类型：Object,Function,Date,Array,RegExp, … Javascript中的数据类型有以下几种情况： 基本类型：string,number,boolean 特殊类型：undefined,null 引用类型：Object,Function,Date,Array,RegExp, … 1、stringstring类型的数据是由16位Unicode字符组成的字符串，用typeof检测其数据类型如下： var str = &quot;Hi, Javascript&quot;; console.log(typeof str); // string 在Javascript中，除过undefined和null之外的其他的数据类型都有toString()方法，因此这些数据类型都可以通过toString方法转化为对应的string类型 123..toString(); // &quot;123&quot;,注意有两个.. true.toString(); // &quot;true&quot; new Object().toString(); // [object Object] &quot;Hello&quot;.toString(); // &quot;Hello&quot; undefined.toString(); // Error null.toString(); // Error 一般情况下，toString不需要传递参数，而将数值转化为字符串时，通过传递一个radix参数，可以将数值转化为对应的二进制、八进制和十六进制的字符串表示。 2、number在Javascript中，没有int和float数据类型，而是用number来表示整数和浮点数值，除此之外，number还有一个特殊的数值，即NaN (Not a Number)，NaN表示一个承诺返回数值类型数据但实际没有返回的情况. NaN有两个特点：一是任何涉及NaN的操作都会返回NaN，二是NaN不与任何数值相等，包括自己，但可以通过isNaN()方法来判断一个数值是否为NaN typeof 123; // &quot;number&quot; typeof 123.45 // &quot;number&quot; typeof NaN; // &quot;number&quot; NaN+1; // NaN NaN == false; // false NaN == NaN; //false isNaN(NaN+1); //true 3、booleanboolean类型只有两个字面值：true和false 。 但在Javascript中，所有类型的值都可以转化为与boolean等价的值，转化规则如下：（1）所有对象都被当作 true（2）当字符串为空时，该字符串被当作false（3）null 和 undefined 被当作 false（4）当数字为0时，该数字被当作 false typeof true; // &quot;boolean&quot; typeof false; // &quot;boolean&quot; Boolean(new Object()); //true Boolean(undefined); //false Boolean(null); //false Boolean(&apos;&apos;); //false Boolean(0); //false Boolean(100); // true 4、undefined该类型只有一个值，即 undefined。 undefined意为未定义，即当使用var声明了变量但未进行赋值时，这个变量的值就是undefined。undefined产生的原因有两种：（1）访问对象不存在的属性或方法 （2）声明了变量但从未赋值 var v1,obj = {}; console.log(v1); //undefined console.log(obj.get); //undefined typeof v1; // &quot;undefined&quot; typeof v2; // &quot;undefined&quot; typeof obj.get; // &quot;undefined&quot; 5、nullnull类型也只有一个值：null , 表示一个变量中没有包含有效数据。null在这里意为空值、空对象的意思，更确切的说，一个被赋值为null的变量没有保存有效的数值、字符串、布尔、数组或对象等，可以通过给一个变量赋值为null来清空变量中的内容。产生null的原因只有一个：即对一个变量显式的赋值为null 。 var p = null; console.log(p); //null typeof p ; // &quot;object&quot; typeof null; // &quot;object&quot; 另外，需要注意的是，typeof null 应该返回null，但实际上返回的是object，这是一个历史遗留问题，并没有其他原因。 6、Object,Function,Array,Date,RegExp这些对象在JS中都属于引用类型, 除Function之外，通过typeof检测其数据类型返回的都是object, 如果要判断对应的具体类型，则可以通过Object.prototype.toString来获取。 var a = {}; var b = new Function(); var c = []; var d = new Date(); var e = new RegExp(); typeof a; //object 有效 Object.prototype.toString.call(a); //[object Object] typeof b; //function 有效 Object.prototype.toString.call(b); //[object Object] typeof c; //object 无效 Object.prototype.toString.call(c);//[object Array] typeof d; //object 无效 Object.prototype.toString.call(d);//[object Date] typeof e; //object 无效 Object.prototype.toString.call(e);//[object RegExp] 另外，ES6中新增了symbol这个类型: typeof Symbol() 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/20/JS之数据类型详解/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之数据类型详解]]></title>
    <url>%2F2017%2F06%2F20%2FJS%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3(1)%2F</url>
    <content type="text"><![CDATA[Javascript中的数据类型有以下几种情况：基本类型：string,number,boolean特殊类型：undefined,null引用类型：Object,Function,Date,Array,RegExp, … Javascript中的数据类型有以下几种情况： 基本类型：string,number,boolean 特殊类型：undefined,null 引用类型：Object,Function,Date,Array,RegExp, … 1、stringstring类型的数据是由16位Unicode字符组成的字符串，用typeof检测其数据类型如下： var str = &quot;Hi, Javascript&quot;; console.log(typeof str); // string 在Javascript中，除过undefined和null之外的其他的数据类型都有toString()方法，因此这些数据类型都可以通过toString方法转化为对应的string类型 123..toString(); // &quot;123&quot;,注意有两个.. true.toString(); // &quot;true&quot; new Object().toString(); // [object Object] &quot;Hello&quot;.toString(); // &quot;Hello&quot; undefined.toString(); // Error null.toString(); // Error 一般情况下，toString不需要传递参数，而将数值转化为字符串时，通过传递一个radix参数，可以将数值转化为对应的二进制、八进制和十六进制的字符串表示。 2、number在Javascript中，没有int和float数据类型，而是用number来表示整数和浮点数值，除此之外，number还有一个特殊的数值，即NaN (Not a Number)，NaN表示一个承诺返回数值类型数据但实际没有返回的情况. NaN有两个特点：一是任何涉及NaN的操作都会返回NaN，二是NaN不与任何数值相等，包括自己，但可以通过isNaN()方法来判断一个数值是否为NaN typeof 123; // &quot;number&quot; typeof 123.45 // &quot;number&quot; typeof NaN; // &quot;number&quot; NaN+1; // NaN NaN == false; // false NaN == NaN; //false isNaN(NaN+1); //true 3、booleanboolean类型只有两个字面值：true和false 。 但在Javascript中，所有类型的值都可以转化为与boolean等价的值，转化规则如下：（1）所有对象都被当作 true（2）当字符串为空时，该字符串被当作false（3）null 和 undefined 被当作 false（4）当数字为0时，该数字被当作 false typeof true; // &quot;boolean&quot; typeof false; // &quot;boolean&quot; Boolean(new Object()); //true Boolean(undefined); //false Boolean(null); //false Boolean(&apos;&apos;); //false Boolean(0); //false Boolean(100); // true 4、undefined该类型只有一个值，即 undefined。 undefined意为未定义，即当使用var声明了变量但未进行赋值时，这个变量的值就是undefined。undefined产生的原因有两种：（1）访问对象不存在的属性或方法 （2）声明了变量但从未赋值 var v1,obj = {}; console.log(v1); //undefined console.log(obj.get); //undefined typeof v1; // &quot;undefined&quot; typeof v2; // &quot;undefined&quot; typeof obj.get; // &quot;undefined&quot; 5、nullnull类型也只有一个值：null , 表示一个变量中没有包含有效数据。null在这里意为空值、空对象的意思，更确切的说，一个被赋值为null的变量没有保存有效的数值、字符串、布尔、数组或对象等，可以通过给一个变量赋值为null来清空变量中的内容。产生null的原因只有一个：即对一个变量显式的赋值为null 。 var p = null; console.log(p); //null typeof p ; // &quot;object&quot; typeof null; // &quot;object&quot; 另外，需要注意的是，typeof null 应该返回null，但实际上返回的是object，这是一个历史遗留问题，并没有其他原因。 6、Object,Function,Array,Date,RegExp这些对象在JS中都属于引用类型, 除Function之外，通过typeof检测其数据类型返回的都是object, 如果要判断对应的具体类型，则可以通过Object.prototype.toString来获取。 var a = {}; var b = new Function(); var c = []; var d = new Date(); var e = new RegExp(); typeof a; //object 有效 Object.prototype.toString.call(a); //[object Object] typeof b; //function 有效 Object.prototype.toString.call(b); //[object Object] typeof c; //object 无效 Object.prototype.toString.call(c);//[object Array] typeof d; //object 无效 Object.prototype.toString.call(d);//[object Date] typeof e; //object 无效 Object.prototype.toString.call(e);//[object RegExp] 另外，ES6中新增了symbol这个类型: typeof Symbol() 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/20/JS之数据类型详解(1)/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery 效果 - 动画]]></title>
    <url>%2F2017%2F06%2F19%2FjQuery-%E6%95%88%E6%9E%9C-%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[基础要扎实。对于我来说，虽然学了好多好泛，但却没有学扎实，所以，这是一个复习JQuery动画的一篇文章，很基础。 jQuery 效果 - 隐藏和显示包括隐藏、显示、切换，滑动，淡入淡出，以及动画，哇哦 jQuery hide() $(“#hide”).click(function(){ $(&quot;p&quot;).hide(); }); 演示地址 show()与hide()类似$(“#show”).click(function(){$(“p”).show();}); 演示地址 语法： $(selector).hide(speed,callback); $(selector).show(speed,callback); 可选的 speed 参数规定隐藏/显示的速度，可以取以下值：”slow”、”fast” 或毫秒。 可选的 callback 参数是隐藏或显示完成后所执行的函数名称 jQuery toggle() 使用 toggle() 方法来切换 hide() 和 show() $(&quot;button&quot;).click(function(){ $(&quot;p&quot;).toggle(); }); 演示地址 jQuery 效果 - 淡入淡出 jQuery fadeIn() jQuery fadeOut() jQuery fadeToggle() jQuery fadeTo() jQuery fadeTo() 方法允许渐变为给定的不透明度（值介于 0 与 1 之间）语法： $(selector).fadeTo(speed,opacity,callback); jQuery 效果 - 滑动 slideDown() slideUp() slideToggle() slideToggle() 方法演示 jQuery animate()动画 Query animate() 方法用于创建自定义动画。 语法： $(selector).animate({params},speed,callback); 必需的 params 参数定义形成动画的 CSS 属性 下面的例子演示 animate() 方法的简单应用；它把 元素移动到左边，直到 left 属性等于 250 像素为止： $(&quot;button&quot;).click(function(){ $(&quot;div&quot;).animate({left:&apos;250px&apos;}); }); 演示地址ps：生成动画的过程中可同时使用多个属性 $(&quot;button&quot;).click(function(){ $(&quot;div&quot;).animate({ left:&apos;250px&apos;, opacity:&apos;0.5&apos;, height:&apos;150px&apos;, width:&apos;150px&apos; }); }); 可以用 animate() 方法来操作所有 CSS 属性吗？ 是的，几乎可以！不过，需要记住一件重要的事情：当使用 animate() 时，必须使用 Camel 标记法书写所有的属性名，比如，必须使用 paddingLeft 而不是 padding-left，使用 marginRight 而不是 margin-right，等等。 同时，色彩动画并不包含在核心 jQuery 库中。 如果需要生成颜色动画，您需要从 jQuery.com 下载 Color Animations 插件。 jQuery animate() - 使用预定义的值您甚至可以把属性的动画值设置为 “show”、”hide” 或 “toggle”： $(&quot;button&quot;).click(function(){ $(&quot;div&quot;).animate({ height:&apos;toggle&apos; }); }); jQuery animate() - 使用队列功能如果您希望在彼此之后执行不同的动画，那么我们要利用队列功能： $(&quot;button&quot;).click(function(){ var div=$(&quot;div&quot;); div.animate({height:&apos;300px&apos;,opacity:&apos;0.4&apos;},&quot;slow&quot;); div.animate({width:&apos;300px&apos;,opacity:&apos;0.8&apos;},&quot;slow&quot;); div.animate({height:&apos;100px&apos;,opacity:&apos;0.4&apos;},&quot;slow&quot;); div.animate({width:&apos;100px&apos;,opacity:&apos;0.8&apos;},&quot;slow&quot;); }); jQuery 停止动画jQuery stop() 方法用于在动画或效果完成前对它们进行停止。jQuery stop() 滑动语法： $(selector).stop(stopAll,goToEnd); 可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行。 可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。 因此，默认地，stop() 会清除在被选元素上指定的当前动画。 jQuery Callback 函数 Callback 函数在当前动画 100% 完成之后执行。 由于 JavaScript 语句（指令）是逐一执行的 - 按照次序，动画之后的语句可能会产生错误或页面冲突，因为动画还没有完成。 为了避免这个情况，您可以以参数的形式添加 Callback 函数。 典型的语法： $(selector).hide(speed,callback) 错误（没有 callback）: $(&quot;p&quot;).hide(1000); alert(&quot;The paragraph is now hidden&quot;); jQuery - Chaining 通过 jQuery，您可以把动作/方法链接起来。Chaining 允许我们在一条语句中允许多个 jQuery 方法（在相同的元素上）。 例子 1下面的例子把 css(), slideUp(), and slideDown() 链接在一起。”p1” 元素首先会变为红色，然后向上滑动，然后向下滑动： $(&quot;#p1&quot;).css(&quot;color&quot;,&quot;red&quot;).slideUp(2000).slideDown(2000); 这些是jquery的基础动画，jquery真的是一个经典的库！！！ 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/19/jQuery-效果-动画/]]></content>
      <tags>
        <tag>js</tag>
        <tag>jquery</tag>
        <tag>动画</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery 效果 - 动画]]></title>
    <url>%2F2017%2F06%2F19%2FjQuery-%E6%95%88%E6%9E%9C-%E5%8A%A8%E7%94%BB(1)%2F</url>
    <content type="text"><![CDATA[基础要扎实。对于我来说，虽然学了好多好泛，但却没有学扎实，所以，这是一个复习JQuery动画的一篇文章，很基础。 jQuery 效果 - 隐藏和显示包括隐藏、显示、切换，滑动，淡入淡出，以及动画，哇哦 jQuery hide() $(“#hide”).click(function(){ $(&quot;p&quot;).hide(); }); 演示地址 show()与hide()类似$(“#show”).click(function(){$(“p”).show();}); 演示地址 语法： $(selector).hide(speed,callback); $(selector).show(speed,callback); 可选的 speed 参数规定隐藏/显示的速度，可以取以下值：”slow”、”fast” 或毫秒。 可选的 callback 参数是隐藏或显示完成后所执行的函数名称 jQuery toggle() 使用 toggle() 方法来切换 hide() 和 show() $(&quot;button&quot;).click(function(){ $(&quot;p&quot;).toggle(); }); 演示地址 jQuery 效果 - 淡入淡出 jQuery fadeIn() jQuery fadeOut() jQuery fadeToggle() jQuery fadeTo() jQuery fadeTo() 方法允许渐变为给定的不透明度（值介于 0 与 1 之间）语法： $(selector).fadeTo(speed,opacity,callback); jQuery 效果 - 滑动 slideDown() slideUp() slideToggle() slideToggle() 方法演示 jQuery animate()动画 Query animate() 方法用于创建自定义动画。 语法： $(selector).animate({params},speed,callback); 必需的 params 参数定义形成动画的 CSS 属性 下面的例子演示 animate() 方法的简单应用；它把 元素移动到左边，直到 left 属性等于 250 像素为止： $(&quot;button&quot;).click(function(){ $(&quot;div&quot;).animate({left:&apos;250px&apos;}); }); 演示地址ps：生成动画的过程中可同时使用多个属性 $(&quot;button&quot;).click(function(){ $(&quot;div&quot;).animate({ left:&apos;250px&apos;, opacity:&apos;0.5&apos;, height:&apos;150px&apos;, width:&apos;150px&apos; }); }); 可以用 animate() 方法来操作所有 CSS 属性吗？ 是的，几乎可以！不过，需要记住一件重要的事情：当使用 animate() 时，必须使用 Camel 标记法书写所有的属性名，比如，必须使用 paddingLeft 而不是 padding-left，使用 marginRight 而不是 margin-right，等等。 同时，色彩动画并不包含在核心 jQuery 库中。 如果需要生成颜色动画，您需要从 jQuery.com 下载 Color Animations 插件。 jQuery animate() - 使用预定义的值您甚至可以把属性的动画值设置为 “show”、”hide” 或 “toggle”： $(&quot;button&quot;).click(function(){ $(&quot;div&quot;).animate({ height:&apos;toggle&apos; }); }); jQuery animate() - 使用队列功能如果您希望在彼此之后执行不同的动画，那么我们要利用队列功能： $(&quot;button&quot;).click(function(){ var div=$(&quot;div&quot;); div.animate({height:&apos;300px&apos;,opacity:&apos;0.4&apos;},&quot;slow&quot;); div.animate({width:&apos;300px&apos;,opacity:&apos;0.8&apos;},&quot;slow&quot;); div.animate({height:&apos;100px&apos;,opacity:&apos;0.4&apos;},&quot;slow&quot;); div.animate({width:&apos;100px&apos;,opacity:&apos;0.8&apos;},&quot;slow&quot;); }); jQuery 停止动画jQuery stop() 方法用于在动画或效果完成前对它们进行停止。jQuery stop() 滑动语法： $(selector).stop(stopAll,goToEnd); 可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行。 可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。 因此，默认地，stop() 会清除在被选元素上指定的当前动画。 jQuery Callback 函数 Callback 函数在当前动画 100% 完成之后执行。 由于 JavaScript 语句（指令）是逐一执行的 - 按照次序，动画之后的语句可能会产生错误或页面冲突，因为动画还没有完成。 为了避免这个情况，您可以以参数的形式添加 Callback 函数。 典型的语法： $(selector).hide(speed,callback) 错误（没有 callback）: $(&quot;p&quot;).hide(1000); alert(&quot;The paragraph is now hidden&quot;); jQuery - Chaining 通过 jQuery，您可以把动作/方法链接起来。Chaining 允许我们在一条语句中允许多个 jQuery 方法（在相同的元素上）。 例子 1下面的例子把 css(), slideUp(), and slideDown() 链接在一起。”p1” 元素首先会变为红色，然后向上滑动，然后向下滑动： $(&quot;#p1&quot;).css(&quot;color&quot;,&quot;red&quot;).slideUp(2000).slideDown(2000); 这些是jquery的基础动画，jquery真的是一个经典的库！！！ 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/19/jQuery-效果-动画(1)/]]></content>
      <tags>
        <tag>js</tag>
        <tag>jquery</tag>
        <tag>动画</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步coding教程]]></title>
    <url>%2F2017%2F06%2F19%2F%E5%90%8C%E6%AD%A5%E5%88%B0coding%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[coding是国内版的github，这篇文章默认是已经在github上布置好了，写的是现在在coding在布置教程 参考网址： hexo干货系列：（四）将hexo博客同时托管到github和coding Hexo搭建独立博客，托管到Github和Coding上教程 YAML 语言教程 - 阮一峰的网络日志步骤： 注册coding帐号访问官网注册并登录 创建仓库,点+创建项目,这里我创建为jaymo （仓库名称和用户名一样，推荐；ps：如果你的项目名称跟你coding的用户名一样，jaymo,博客项目名也叫jaymo那直接访问jaymo.coding.me就能访问博客，否则就要带上项目名:jaymo.coding.me/项目名 才能访问推荐项目名跟用户名一样，这样就可以省略项目名了） 配置SHH，配置shh key是让本地git项目与远程的github建立联系 ： 1cd ~/.ssh 输入cat命令，打开id_rsa.pub文件 1cat id_rsa.pub 复制ssh到Coding的SSH中（这里直接使用之前部署github时已经生成的公钥）4.打开Git Bash，然后输入 1ssh -T git@git.coding.net 输入密码后，如果显示以下内容，则说明coding中的ssh配置成功。 12Hi username! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 4.创建Coding Pages 服务 官网点击代码再点击Coding Pages 服务开启。分支和github分支写一样，填写master 打开根目录中的_config.yml文件，找到如下位置，填写 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:yourname/yourname.github.io.git,master coding: git@git.coding.net:yourname/yourname.git,master 5.在根目录中空白处右击打开Git Bash输入 123hexo s #启动服务，调试用hexo g #生成静态网页hexo d #开始部署 设置自动部署 找到项目设置那边的WebHook,然后点击新建 Hook 第一个输入框中是填你的博客域名，然后在后面加上 /_，比如我的http://jaymo.coding.me/_ 第二个输入框是输入一个token，我们直接填写就可以了。 未完！！！下一篇将结束自动部署。 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/19/同步到coding教程/]]></content>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步coding教程]]></title>
    <url>%2F2017%2F06%2F19%2F%E5%90%8C%E6%AD%A5%E5%88%B0coding%E6%95%99%E7%A8%8B(1)%2F</url>
    <content type="text"><![CDATA[coding是国内版的github，这篇文章默认是已经在github上布置好了，写的是现在在coding在布置教程 参考网址： hexo干货系列：（四）将hexo博客同时托管到github和coding Hexo搭建独立博客，托管到Github和Coding上教程 YAML 语言教程 - 阮一峰的网络日志步骤： 注册coding帐号访问官网注册并登录 创建仓库,点+创建项目,这里我创建为jaymo （仓库名称和用户名一样，推荐；ps：如果你的项目名称跟你coding的用户名一样，jaymo,博客项目名也叫jaymo那直接访问jaymo.coding.me就能访问博客，否则就要带上项目名:jaymo.coding.me/项目名 才能访问推荐项目名跟用户名一样，这样就可以省略项目名了） 配置SHH，配置shh key是让本地git项目与远程的github建立联系 ： 1cd ~/.ssh 输入cat命令，打开id_rsa.pub文件 1cat id_rsa.pub 复制ssh到Coding的SSH中（这里直接使用之前部署github时已经生成的公钥）4.打开Git Bash，然后输入 1ssh -T git@git.coding.net 输入密码后，如果显示以下内容，则说明coding中的ssh配置成功。 12Hi username! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 4.创建Coding Pages 服务 官网点击代码再点击Coding Pages 服务开启。分支和github分支写一样，填写master 打开根目录中的_config.yml文件，找到如下位置，填写 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:yourname/yourname.github.io.git,master coding: git@git.coding.net:yourname/yourname.git,master 5.在根目录中空白处右击打开Git Bash输入 123hexo s #启动服务，调试用hexo g #生成静态网页hexo d #开始部署 设置自动部署 找到项目设置那边的WebHook,然后点击新建 Hook 第一个输入框中是填你的博客域名，然后在后面加上 /_，比如我的http://jaymo.coding.me/_ 第二个输入框是输入一个token，我们直接填写就可以了。 未完！！！下一篇将结束自动部署。 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/19/同步到coding教程(1)/]]></content>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主题页面设置]]></title>
    <url>%2F2017%2F06%2F19%2F%E4%B8%BB%E9%A2%98%E9%A1%B5%E9%9D%A2%E8%AE%BE%E7%BD%AE(1)%2F</url>
    <content type="text"><![CDATA[主题页面的简单设置 参考网站 NexT主题 下载主题 12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题：启用了Pisces - 双栏 Scheme，小家碧玉似的清新在\themes\next文件夹中找到站点配置文件_config.yml文件，选择 Scheme，去掉scheme前面注释#，如： 123#scheme: Muse#scheme: Mistscheme: Pisces 设置 语言编辑_config.yml，配置：1language: zh-Hans 设置 菜单1234567menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html 设置菜单项的显示文本在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的languages/{language}.yml （{language} 为你所使用的语言）。以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml，在menu 字段下添加一项： 123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 something: 有料 设定菜单项的图标对应的字段是 menu_icons。 此设定格式是item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。 123456789menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat 设置 头像放置在了 source/images/ 目录下 ,如下： 集成常用的第三方服务百度统计 登录 百度统计， 定位到站点的代码获取页面 复制 hm.js? 后面那串统计脚本 id 编辑 主题配置文件， 修改字段 baidu_analytics 字段，值设置成你的百度统计脚本 id。所以，页面已经设置了百度统计阅读次数统计以按照 为NexT主题添加文章阅读量统计功能，注册了https://leancloud.cn如图：创建了JayMo个人博客应用，创建了名称为Counter的Class,复制AppID以及AppKey并在NexT主题的_config.yml文件中我们相应的位置填入即可，正确配置之后文件内容像这个样子: 1234leancloud_visitors: enable: true app_id: joaeuuc4hsqudUUwx4gIvGF6-gzGzoHsz app_key: E9UJsJpw1omCHuS22PdSpKoh Web安全以设置只能通过：jaymo666.github.io/或jaymo.cf/来访问,确保数据调用的安全。 数据统计与分析配置了百度分享搜索服务Local Search添加百度/谷歌/本地 自定义站点内容搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 2.编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 评论服务注册了Disqus，配置了评论 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/19/主题页面设置(1)/]]></content>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主题页面设置]]></title>
    <url>%2F2017%2F06%2F19%2F%E4%B8%BB%E9%A2%98%E9%A1%B5%E9%9D%A2%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[主题页面的简单设置 参考网站 NexT主题 下载主题 12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题：启用了Pisces - 双栏 Scheme，小家碧玉似的清新在\themes\next文件夹中找到站点配置文件_config.yml文件，选择 Scheme，去掉scheme前面注释#，如： 123#scheme: Muse#scheme: Mistscheme: Pisces 设置 语言编辑_config.yml，配置：1language: zh-Hans 设置 菜单1234567menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html 设置菜单项的显示文本在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的languages/{language}.yml （{language} 为你所使用的语言）。以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml，在menu 字段下添加一项： 123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 something: 有料 设定菜单项的图标对应的字段是 menu_icons。 此设定格式是item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。 123456789menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat 设置 头像放置在了 source/images/ 目录下 ,如下： 集成常用的第三方服务百度统计 登录 百度统计， 定位到站点的代码获取页面 复制 hm.js? 后面那串统计脚本 id 编辑 主题配置文件， 修改字段 baidu_analytics 字段，值设置成你的百度统计脚本 id。所以，页面已经设置了百度统计阅读次数统计以按照 为NexT主题添加文章阅读量统计功能，注册了https://leancloud.cn如图：创建了JayMo个人博客应用，创建了名称为Counter的Class,复制AppID以及AppKey并在NexT主题的_config.yml文件中我们相应的位置填入即可，正确配置之后文件内容像这个样子: 1234leancloud_visitors: enable: true app_id: joaeuuc4hsqudUUwx4gIvGF6-gzGzoHsz app_key: E9UJsJpw1omCHuS22PdSpKoh Web安全以设置只能通过：jaymo666.github.io/或jaymo.cf/来访问,确保数据调用的安全。 数据统计与分析配置了百度分享搜索服务Local Search添加百度/谷歌/本地 自定义站点内容搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 2.编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 评论服务注册了Disqus，配置了评论 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/19/主题页面设置/]]></content>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建及使用]]></title>
    <url>%2F2017%2F06%2F19%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8(1)%2F</url>
    <content type="text"><![CDATA[博客搭建及使用 参考网站 基于hexo+github搭建一个独立博客 主题：Anisina 中文使用教程 手把手教你用Hexo+Github 搭建属于自己的博客 用Hexo创建个人博客 用Hexo创建个人博客步骤 搭建环境准备（包括node.js和git环境，gitHub账户的配置） 安装Hexo 配置Hexo 怎样将Hexo与github page 联系起来 怎样发布文章 主题 推荐 主题Net的简单配置 添加sitemap和feed插件 添加404 公益页面 在搭建中我使用的不是推荐的Net主题，而是Anisina 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 比如我的电脑下的 F:\JayMo666 目录下的成为 站点配置文件，F:\JayMo66\themes\Anisina 目录下的成为主题配置文件。具体如何配置详细看上面的网站：主题：Anisina 中文使用教程 创建博客步骤：在1.Run server 1$ hexo server F:\JayMo666启动命令行执行下面命令：3.1hexo new post &quot;文章标题&quot; 这时候在我的 电脑的目录下 F:\JayMo666\source\ _posts 将会看到文章标题.md 文件 4.用MarDown编辑器打开就可以编辑文章了。文章编辑好之后，运行生成、部署命令： 1hexo d -g #在部署前先生成 其中g代表 generate（md文件生成html文件） d 代表deploy(配置) 这样个人博客基本就ok了，剩下的就是完善了 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/19/博客搭建及使用(1)/]]></content>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建及使用]]></title>
    <url>%2F2017%2F06%2F19%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[博客搭建及使用 参考网站 基于hexo+github搭建一个独立博客 主题：Anisina 中文使用教程 手把手教你用Hexo+Github 搭建属于自己的博客 用Hexo创建个人博客 用Hexo创建个人博客步骤 搭建环境准备（包括node.js和git环境，gitHub账户的配置） 安装Hexo 配置Hexo 怎样将Hexo与github page 联系起来 怎样发布文章 主题 推荐 主题Net的简单配置 添加sitemap和feed插件 添加404 公益页面 在搭建中我使用的不是推荐的Net主题，而是Anisina 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 比如我的电脑下的 F:\JayMo666 目录下的成为 站点配置文件，F:\JayMo66\themes\Anisina 目录下的成为主题配置文件。具体如何配置详细看上面的网站：主题：Anisina 中文使用教程 创建博客步骤：在1.Run server 1$ hexo server F:\JayMo666启动命令行执行下面命令：3.1hexo new post &quot;文章标题&quot; 这时候在我的 电脑的目录下 F:\JayMo666\source\ _posts 将会看到文章标题.md 文件 4.用MarDown编辑器打开就可以编辑文章了。文章编辑好之后，运行生成、部署命令： 1hexo d -g #在部署前先生成 其中g代表 generate（md文件生成html文件） d 代表deploy(配置) 这样个人博客基本就ok了，剩下的就是完善了 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/19/博客搭建及使用/]]></content>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next-主题配置教程]]></title>
    <url>%2F2017%2F06%2F19%2Fnext-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B(1)%2F</url>
    <content type="text"><![CDATA[next-主题页面设置。使用了next，next在众多主题中评分最高，使用了几个主题后，发现它确实好用，PS：hexo很方便更换主题，赞 参考网站 NexT主题 下载主题 12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题：启用了Pisces - 双栏 Scheme，小家碧玉似的清新在\themes\next文件夹中找到站点配置文件_config.yml文件，选择 Scheme，去掉scheme前面注释#，如： 123#scheme: Muse#scheme: Mistscheme: Pisces 设置 语言编辑_config.yml，配置：1language: zh-Hans 设置 菜单1234567menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html 设置菜单项的显示文本在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的languages/{language}.yml （{language} 为你所使用的语言）。以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml，在menu 字段下添加一项： 123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 something: 有料 设定菜单项的图标对应的字段是 menu_icons。 此设定格式是item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。 123456789menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat 设置 头像放置在了 source/images/ 目录下 ,如下： 集成常用的第三方服务百度统计 登录 百度统计， 定位到站点的代码获取页面 复制 hm.js? 后面那串统计脚本 id 编辑 主题配置文件， 修改字段 baidu_analytics 字段，值设置成你的百度统计脚本 id。所以，页面已经设置了百度统计阅读次数统计以按照 为NexT主题添加文章阅读量统计功能，注册了https://leancloud.cn如图：创建了JayMo个人博客应用，创建了名称为Counter的Class,复制AppID以及AppKey并在NexT主题的_config.yml文件中我们相应的位置填入即可，正确配置之后文件内容像这个样子: 1234leancloud_visitors: enable: true app_id: joaeuuc4hsqudUUwx4gIvGF6-gzGzoHsz app_key: E9UJsJpw1omCHuS22PdSpKoh Web安全以设置只能通过：jaymo666.github.io/或jaymo.cf/来访问,确保数据调用的安全。 数据统计与分析配置了百度分享搜索服务Local Search添加百度/谷歌/本地 自定义站点内容搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 2.编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 评论服务注册了Disqus，配置了评论 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/19/next-主题配置教程(1)/]]></content>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next-主题配置教程]]></title>
    <url>%2F2017%2F06%2F19%2Fnext-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[next-主题页面设置。使用了next，next在众多主题中评分最高，使用了几个主题后，发现它确实好用，PS：hexo很方便更换主题，赞 参考网站 NexT主题 下载主题 12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题：启用了Pisces - 双栏 Scheme，小家碧玉似的清新在\themes\next文件夹中找到站点配置文件_config.yml文件，选择 Scheme，去掉scheme前面注释#，如： 123#scheme: Muse#scheme: Mistscheme: Pisces 设置 语言编辑_config.yml，配置：1language: zh-Hans 设置 菜单1234567menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html 设置菜单项的显示文本在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的languages/{language}.yml （{language} 为你所使用的语言）。以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml，在menu 字段下添加一项： 123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 something: 有料 设定菜单项的图标对应的字段是 menu_icons。 此设定格式是item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。 123456789menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat 设置 头像放置在了 source/images/ 目录下 ,如下： 集成常用的第三方服务百度统计 登录 百度统计， 定位到站点的代码获取页面 复制 hm.js? 后面那串统计脚本 id 编辑 主题配置文件， 修改字段 baidu_analytics 字段，值设置成你的百度统计脚本 id。所以，页面已经设置了百度统计阅读次数统计以按照 为NexT主题添加文章阅读量统计功能，注册了https://leancloud.cn如图：创建了JayMo个人博客应用，创建了名称为Counter的Class,复制AppID以及AppKey并在NexT主题的_config.yml文件中我们相应的位置填入即可，正确配置之后文件内容像这个样子: 1234leancloud_visitors: enable: true app_id: joaeuuc4hsqudUUwx4gIvGF6-gzGzoHsz app_key: E9UJsJpw1omCHuS22PdSpKoh Web安全以设置只能通过：jaymo666.github.io/或jaymo.cf/来访问,确保数据调用的安全。 数据统计与分析配置了百度分享搜索服务Local Search添加百度/谷歌/本地 自定义站点内容搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 2.编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 评论服务注册了Disqus，配置了评论 本作品采用 知识共享署名 2.5 中国大陆许可协议 进行许可，欢迎转载，但转载请注明来自JayMo，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文永久链接：http://jaymo666.github.io/2017/06/19/next-主题配置教程/]]></content>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
